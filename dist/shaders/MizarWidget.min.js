(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD.
    define(['jquery'], factory);
  } else {
    // Browser globals.
    root.mylib = factory(root.$);
  }
}(this, function($) {
/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {string} name the relative name
     * @param {string} baseName a real name that the name arg is relative
     * to.
     * @returns {string} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map["*"]) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === ".." || name[0] === "..")) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf("./") === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split("/");

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join("/")];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join("/");
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error("No " + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf("!") : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + "!" + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== "undefined") {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: "",
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === "function") {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ["require", "exports", "module"] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + " missing " + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === "function") {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
define("../build/almond", function(){});

/*! jQuery v2.2.4 | (c) jQuery Foundation | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=a.document,e=c.slice,f=c.concat,g=c.push,h=c.indexOf,i={},j=i.toString,k=i.hasOwnProperty,l={},m="2.2.4",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return e.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:e.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a){return n.each(this,a)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(e.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:g,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=a&&a.toString();return!n.isArray(a)&&b-parseFloat(b)+1>=0},isPlainObject:function(a){var b;if("object"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;if(a.constructor&&!k.call(a,"constructor")&&!k.call(a.constructor.prototype||{},"isPrototypeOf"))return!1;for(b in a);return void 0===b||k.call(a,b)},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?i[j.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=d.createElement("script"),b.text=a,d.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(s(a)){for(c=a.length;c>d;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):g.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:h.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,g=0,h=[];if(s(a))for(d=a.length;d>g;g++)e=b(a[g],g,c),null!=e&&h.push(e);else for(g in a)e=b(a[g],g,c),null!=e&&h.push(e);return f.apply([],h)},guid:1,proxy:function(a,b){var c,d,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(d=e.call(arguments,2),f=function(){return a.apply(b||this,d.concat(e.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:l}),"function"==typeof Symbol&&(n.fn[Symbol.iterator]=c[Symbol.iterator]),n.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){i["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=!!a&&"length"in a&&a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ga(),z=ga(),A=ga(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+M+"))|)"+L+"*\\]",O=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+N+")*)|.*)\\)|)",P=new RegExp(L+"+","g"),Q=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),R=new RegExp("^"+L+"*,"+L+"*"),S=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),T=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),U=new RegExp(O),V=new RegExp("^"+M+"$"),W={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M+"|[*])"),ATTR:new RegExp("^"+N),PSEUDO:new RegExp("^"+O),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},X=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Z=/^[^{]+\{\s*\[native \w/,$=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,_=/[+~]/,aa=/'|\\/g,ba=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),ca=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},da=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(ea){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function fa(a,b,d,e){var f,h,j,k,l,o,r,s,w=b&&b.ownerDocument,x=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==x&&9!==x&&11!==x)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==x&&(o=$.exec(a)))if(f=o[1]){if(9===x){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(w&&(j=w.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(o[2])return H.apply(d,b.getElementsByTagName(a)),d;if((f=o[3])&&c.getElementsByClassName&&b.getElementsByClassName)return H.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==x)w=b,s=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(aa,"\\$&"):b.setAttribute("id",k=u),r=g(a),h=r.length,l=V.test(k)?"#"+k:"[id='"+k+"']";while(h--)r[h]=l+" "+qa(r[h]);s=r.join(","),w=_.test(a)&&oa(b.parentNode)||b}if(s)try{return H.apply(d,w.querySelectorAll(s)),d}catch(y){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(Q,"$1"),b,d,e)}function ga(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ha(a){return a[u]=!0,a}function ia(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ja(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function ka(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function la(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function na(a){return ha(function(b){return b=+b,ha(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function oa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=fa.support={},f=fa.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=fa.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ia(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ia(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Z.test(n.getElementsByClassName),c.getById=ia(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ba,ca);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ba,ca);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return"undefined"!=typeof b.getElementsByClassName&&p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=Z.test(n.querySelectorAll))&&(ia(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ia(function(a){var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Z.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ia(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",O)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Z.test(o.compareDocumentPosition),t=b||Z.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return ka(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?ka(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},fa.matches=function(a,b){return fa(a,null,null,b)},fa.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(T,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return fa(b,n,null,[a]).length>0},fa.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},fa.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},fa.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},fa.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=fa.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=fa.selectors={cacheLength:50,createPseudo:ha,match:W,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ba,ca),a[3]=(a[3]||a[4]||a[5]||"").replace(ba,ca),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||fa.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&fa.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return W.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&U.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ba,ca).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=fa.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(P," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||fa.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ha(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ha(function(a){var b=[],c=[],d=h(a.replace(Q,"$1"));return d[u]?ha(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ha(function(a){return function(b){return fa(a,b).length>0}}),contains:ha(function(a){return a=a.replace(ba,ca),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ha(function(a){return V.test(a||"")||fa.error("unsupported lang: "+a),a=a.replace(ba,ca).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Y.test(a.nodeName)},input:function(a){return X.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:na(function(){return[0]}),last:na(function(a,b){return[b-1]}),eq:na(function(a,b,c){return[0>c?c+b:c]}),even:na(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:na(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:na(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:na(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=la(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=ma(b);function pa(){}pa.prototype=d.filters=d.pseudos,d.setFilters=new pa,g=fa.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=R.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=S.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(Q," ")}),h=h.slice(c.length));for(g in d.filter)!(e=W[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?fa.error(a):z(a,i).slice(0)};function qa(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function ra(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j,k=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(j=b[u]||(b[u]={}),i=j[b.uniqueID]||(j[b.uniqueID]={}),(h=i[d])&&h[0]===w&&h[1]===f)return k[2]=h[2];if(i[d]=k,k[2]=a(b,c,g))return!0}}}function sa(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ta(a,b,c){for(var d=0,e=b.length;e>d;d++)fa(a,b[d],c);return c}function ua(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function va(a,b,c,d,e,f){return d&&!d[u]&&(d=va(d)),e&&!e[u]&&(e=va(e,f)),ha(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ta(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:ua(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=ua(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=ua(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function wa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ra(function(a){return a===b},h,!0),l=ra(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[ra(sa(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return va(i>1&&sa(m),i>1&&qa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(Q,"$1"),c,e>i&&wa(a.slice(i,e)),f>e&&wa(a=a.slice(e)),f>e&&qa(a))}m.push(c)}return sa(m)}function xa(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=F.call(i));u=ua(u)}H.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&fa.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ha(f):f}return h=fa.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=wa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,xa(e,d)),f.selector=a}return f},i=fa.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ba,ca),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=W.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ba,ca),_.test(j[0].type)&&oa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&qa(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,!b||_.test(a)&&oa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ia(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ia(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ja("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ia(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ja("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ia(function(a){return null==a.getAttribute("disabled")})||ja(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),fa}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.uniqueSort=n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},v=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},w=n.expr.match.needsContext,x=/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,y=/^.[^:#\[\.,]*$/;function z(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(y.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return h.call(b,a)>-1!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(z(this,a||[],!1))},not:function(a){return this.pushStack(z(this,a||[],!0))},is:function(a){return!!z(this,"string"==typeof a&&w.test(a)?n(a):a||[],!1).length}});var A,B=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=n.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||A,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:B.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),x.test(e[1])&&n.isPlainObject(b))for(e in b)n.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&f.parentNode&&(this.length=1,this[0]=f),this.context=d,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?void 0!==c.ready?c.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};C.prototype=n.fn,A=n(d);var D=/^(?:parents|prev(?:Until|All))/,E={children:!0,contents:!0,next:!0,prev:!0};n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=w.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?h.call(n(a),this[0]):h.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.uniqueSort(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function F(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return u(a,"parentNode")},parentsUntil:function(a,b,c){return u(a,"parentNode",c)},next:function(a){return F(a,"nextSibling")},prev:function(a){return F(a,"previousSibling")},nextAll:function(a){return u(a,"nextSibling")},prevAll:function(a){return u(a,"previousSibling")},nextUntil:function(a,b,c){return u(a,"nextSibling",c)},prevUntil:function(a,b,c){return u(a,"previousSibling",c)},siblings:function(a){return v((a.parentNode||{}).firstChild,a)},children:function(a){return v(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(E[a]||n.uniqueSort(e),D.test(a)&&e.reverse()),this.pushStack(e)}});var G=/\S+/g;function H(a){var b={};return n.each(a.match(G)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?H(a):n.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){n.each(b,function(b,c){n.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==n.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return n.each(arguments,function(a,b){var c;while((c=n.inArray(b,f,c))>-1)f.splice(c,1),h>=c&&h--}),this},has:function(a){return a?n.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().progress(c.notify).done(c.resolve).fail(c.reject):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=e.call(arguments),d=c.length,f=1!==d||a&&n.isFunction(a.promise)?d:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(d){b[a]=this,c[a]=arguments.length>1?e.call(arguments):d,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(d>1)for(i=new Array(d),j=new Array(d),k=new Array(d);d>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().progress(h(b,j,i)).done(h(b,k,c)).fail(g.reject):--f;return f||g.resolveWith(k,c),g.promise()}});var I;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(I.resolveWith(d,[n]),n.fn.triggerHandler&&(n(d).triggerHandler("ready"),n(d).off("ready"))))}});function J(){d.removeEventListener("DOMContentLoaded",J),a.removeEventListener("load",J),n.ready()}n.ready.promise=function(b){return I||(I=n.Deferred(),"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(n.ready):(d.addEventListener("DOMContentLoaded",J),a.addEventListener("load",J))),I.promise(b)},n.ready.promise();var K=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)K(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},L=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function M(){this.expando=n.expando+M.uid++}M.uid=1,M.prototype={register:function(a,b){var c=b||{};return a.nodeType?a[this.expando]=c:Object.defineProperty(a,this.expando,{value:c,writable:!0,configurable:!0}),a[this.expando]},cache:function(a){if(!L(a))return{};var b=a[this.expando];return b||(b={},L(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[b]=c;else for(d in b)e[d]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=a[this.expando];if(void 0!==f){if(void 0===b)this.register(a);else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in f?d=[b,e]:(d=e,d=d in f?[d]:d.match(G)||[])),c=d.length;while(c--)delete f[d[c]]}(void 0===b||n.isEmptyObject(f))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!n.isEmptyObject(b)}};var N=new M,O=new M,P=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Q=/[A-Z]/g;function R(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Q,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:P.test(c)?n.parseJSON(c):c;
}catch(e){}O.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return O.hasData(a)||N.hasData(a)},data:function(a,b,c){return O.access(a,b,c)},removeData:function(a,b){O.remove(a,b)},_data:function(a,b,c){return N.access(a,b,c)},_removeData:function(a,b){N.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=O.get(f),1===f.nodeType&&!N.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),R(f,d,e[d])));N.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){O.set(this,a)}):K(this,function(b){var c,d;if(f&&void 0===b){if(c=O.get(f,a)||O.get(f,a.replace(Q,"-$&").toLowerCase()),void 0!==c)return c;if(d=n.camelCase(a),c=O.get(f,d),void 0!==c)return c;if(c=R(f,d,void 0),void 0!==c)return c}else d=n.camelCase(a),this.each(function(){var c=O.get(this,d);O.set(this,d,b),a.indexOf("-")>-1&&void 0!==c&&O.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){O.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=N.get(a,b),c&&(!d||n.isArray(c)?d=N.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return N.get(a,c)||N.access(a,c,{empty:n.Callbacks("once memory").add(function(){N.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=N.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var S=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=new RegExp("^(?:([+-])=|)("+S+")([a-z%]*)$","i"),U=["Top","Right","Bottom","Left"],V=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)};function W(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return n.css(a,b,"")},i=h(),j=c&&c[3]||(n.cssNumber[b]?"":"px"),k=(n.cssNumber[b]||"px"!==j&&+i)&&T.exec(n.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,n.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var X=/^(?:checkbox|radio)$/i,Y=/<([\w:-]+)/,Z=/^$|\/(?:java|ecma)script/i,$={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};$.optgroup=$.option,$.tbody=$.tfoot=$.colgroup=$.caption=$.thead,$.th=$.td;function _(a,b){var c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function aa(a,b){for(var c=0,d=a.length;d>c;c++)N.set(a[c],"globalEval",!b||N.get(b[c],"globalEval"))}var ba=/<|&#?\w+;/;function ca(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],o=0,p=a.length;p>o;o++)if(f=a[o],f||0===f)if("object"===n.type(f))n.merge(m,f.nodeType?[f]:f);else if(ba.test(f)){g=g||l.appendChild(b.createElement("div")),h=(Y.exec(f)||["",""])[1].toLowerCase(),i=$[h]||$._default,g.innerHTML=i[1]+n.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;n.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",o=0;while(f=m[o++])if(d&&n.inArray(f,d)>-1)e&&e.push(f);else if(j=n.contains(f.ownerDocument,f),g=_(l.appendChild(f),"script"),j&&aa(g),c){k=0;while(f=g[k++])Z.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),l.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",l.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var da=/^key/,ea=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,fa=/^([^.]*)(?:\.(.+)|)/;function ga(){return!0}function ha(){return!1}function ia(){try{return d.activeElement}catch(a){}}function ja(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)ja(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=ha;else if(!e)return a;return 1===f&&(g=e,e=function(a){return n().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=n.guid++)),a.each(function(){n.event.add(this,b,e,d,c)})}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=N.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return"undefined"!=typeof n&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(G)||[""],j=b.length;while(j--)h=fa.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=N.hasData(a)&&N.get(a);if(r&&(i=r.events)){b=(b||"").match(G)||[""],j=b.length;while(j--)if(h=fa.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&N.remove(a,"handle events")}},dispatch:function(a){a=n.event.fix(a);var b,c,d,f,g,h=[],i=e.call(arguments),j=(N.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())a.rnamespace&&!a.rnamespace.test(g.namespace)||(a.handleObj=g,a.data=g.data,d=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==d&&(a.result=d)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&("click"!==a.type||isNaN(a.button)||a.button<1))for(;i!==this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>-1:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,e,f,g=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||d,e=c.documentElement,f=c.body,a.pageX=b.clientX+(e&&e.scrollLeft||f&&f.scrollLeft||0)-(e&&e.clientLeft||f&&f.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||f&&f.scrollTop||0)-(e&&e.clientTop||f&&f.clientTop||0)),a.which||void 0===g||(a.which=1&g?1:2&g?3:4&g?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,e,f=a.type,g=a,h=this.fixHooks[f];h||(this.fixHooks[f]=h=ea.test(f)?this.mouseHooks:da.test(f)?this.keyHooks:{}),e=h.props?this.props.concat(h.props):this.props,a=new n.Event(g),b=e.length;while(b--)c=e[b],a[c]=g[c];return a.target||(a.target=d),3===a.target.nodeType&&(a.target=a.target.parentNode),h.filter?h.filter(a,g):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==ia()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===ia()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?ga:ha):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={constructor:n.Event,isDefaultPrevented:ha,isPropagationStopped:ha,isImmediatePropagationStopped:ha,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=ga,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=ga,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=ga,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||n.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),n.fn.extend({on:function(a,b,c,d){return ja(this,a,b,c,d)},one:function(a,b,c,d){return ja(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=ha),this.each(function(){n.event.remove(this,a,c,b)})}});var ka=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,la=/<script|<style|<link/i,ma=/checked\s*(?:[^=]|=\s*.checked.)/i,na=/^true\/(.*)/,oa=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function pa(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function qa(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function ra(a){var b=na.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function sa(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(N.hasData(a)&&(f=N.access(a),g=N.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}O.hasData(a)&&(h=O.access(a),i=n.extend({},h),O.set(b,i))}}function ta(a,b){var c=b.nodeName.toLowerCase();"input"===c&&X.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function ua(a,b,c,d){b=f.apply([],b);var e,g,h,i,j,k,m=0,o=a.length,p=o-1,q=b[0],r=n.isFunction(q);if(r||o>1&&"string"==typeof q&&!l.checkClone&&ma.test(q))return a.each(function(e){var f=a.eq(e);r&&(b[0]=q.call(this,e,f.html())),ua(f,b,c,d)});if(o&&(e=ca(b,a[0].ownerDocument,!1,a,d),g=e.firstChild,1===e.childNodes.length&&(e=g),g||d)){for(h=n.map(_(e,"script"),qa),i=h.length;o>m;m++)j=e,m!==p&&(j=n.clone(j,!0,!0),i&&n.merge(h,_(j,"script"))),c.call(a[m],j,m);if(i)for(k=h[h.length-1].ownerDocument,n.map(h,ra),m=0;i>m;m++)j=h[m],Z.test(j.type||"")&&!N.access(j,"globalEval")&&n.contains(k,j)&&(j.src?n._evalUrl&&n._evalUrl(j.src):n.globalEval(j.textContent.replace(oa,"")))}return a}function va(a,b,c){for(var d,e=b?n.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||n.cleanData(_(d)),d.parentNode&&(c&&n.contains(d.ownerDocument,d)&&aa(_(d,"script")),d.parentNode.removeChild(d));return a}n.extend({htmlPrefilter:function(a){return a.replace(ka,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(l.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=_(h),f=_(a),d=0,e=f.length;e>d;d++)ta(f[d],g[d]);if(b)if(c)for(f=f||_(a),g=g||_(h),d=0,e=f.length;e>d;d++)sa(f[d],g[d]);else sa(a,h);return g=_(h,"script"),g.length>0&&aa(g,!i&&_(a,"script")),h},cleanData:function(a){for(var b,c,d,e=n.event.special,f=0;void 0!==(c=a[f]);f++)if(L(c)){if(b=c[N.expando]){if(b.events)for(d in b.events)e[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);c[N.expando]=void 0}c[O.expando]&&(c[O.expando]=void 0)}}}),n.fn.extend({domManip:ua,detach:function(a){return va(this,a,!0)},remove:function(a){return va(this,a)},text:function(a){return K(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return ua(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=pa(this,a);b.appendChild(a)}})},prepend:function(){return ua(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=pa(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return ua(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return ua(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(_(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return K(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!la.test(a)&&!$[(Y.exec(a)||["",""])[1].toLowerCase()]){a=n.htmlPrefilter(a);try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(_(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return ua(this,arguments,function(b){var c=this.parentNode;n.inArray(this,a)<0&&(n.cleanData(_(this)),c&&c.replaceChild(b,this))},a)}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),f=e.length-1,h=0;f>=h;h++)c=h===f?this:this.clone(!0),n(e[h])[b](c),g.apply(d,c.get());return this.pushStack(d)}});var wa,xa={HTML:"block",BODY:"block"};function ya(a,b){var c=n(b.createElement(a)).appendTo(b.body),d=n.css(c[0],"display");return c.detach(),d}function za(a){var b=d,c=xa[a];return c||(c=ya(a,b),"none"!==c&&c||(wa=(wa||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=wa[0].contentDocument,b.write(),b.close(),c=ya(a,b),wa.detach()),xa[a]=c),c}var Aa=/^margin/,Ba=new RegExp("^("+S+")(?!px)[a-z%]+$","i"),Ca=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)},Da=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e},Ea=d.documentElement;!function(){var b,c,e,f,g=d.createElement("div"),h=d.createElement("div");if(h.style){h.style.backgroundClip="content-box",h.cloneNode(!0).style.backgroundClip="",l.clearCloneStyle="content-box"===h.style.backgroundClip,g.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",g.appendChild(h);function i(){h.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",h.innerHTML="",Ea.appendChild(g);var d=a.getComputedStyle(h);b="1%"!==d.top,f="2px"===d.marginLeft,c="4px"===d.width,h.style.marginRight="50%",e="4px"===d.marginRight,Ea.removeChild(g)}n.extend(l,{pixelPosition:function(){return i(),b},boxSizingReliable:function(){return null==c&&i(),c},pixelMarginRight:function(){return null==c&&i(),e},reliableMarginLeft:function(){return null==c&&i(),f},reliableMarginRight:function(){var b,c=h.appendChild(d.createElement("div"));return c.style.cssText=h.style.cssText="-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",h.style.width="1px",Ea.appendChild(g),b=!parseFloat(a.getComputedStyle(c).marginRight),Ea.removeChild(g),h.removeChild(c),b}})}}();function Fa(a,b,c){var d,e,f,g,h=a.style;return c=c||Ca(a),g=c?c.getPropertyValue(b)||c[b]:void 0,""!==g&&void 0!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),c&&!l.pixelMarginRight()&&Ba.test(g)&&Aa.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f),void 0!==g?g+"":g}function Ga(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Ha=/^(none|table(?!-c[ea]).+)/,Ia={position:"absolute",visibility:"hidden",display:"block"},Ja={letterSpacing:"0",fontWeight:"400"},Ka=["Webkit","O","Moz","ms"],La=d.createElement("div").style;function Ma(a){if(a in La)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ka.length;while(c--)if(a=Ka[c]+b,a in La)return a}function Na(a,b,c){var d=T.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Oa(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+U[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+U[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+U[f]+"Width",!0,e))):(g+=n.css(a,"padding"+U[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+U[f]+"Width",!0,e)));return g}function Pa(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Ca(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Fa(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ba.test(e))return e;d=g&&(l.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Oa(a,b,c||(g?"border":"content"),d,f)+"px"}function Qa(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=N.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&V(d)&&(f[g]=N.access(d,"olddisplay",za(d.nodeName)))):(e=V(d),"none"===c&&e||N.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Fa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Ma(h)||h),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=T.exec(c))&&e[1]&&(c=W(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(n.cssNumber[h]?"":"px")),l.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Ma(h)||h),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Fa(a,b,d)),"normal"===e&&b in Ja&&(e=Ja[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?Ha.test(n.css(a,"display"))&&0===a.offsetWidth?Da(a,Ia,function(){return Pa(a,b,d)}):Pa(a,b,d):void 0},set:function(a,c,d){var e,f=d&&Ca(a),g=d&&Oa(a,b,d,"border-box"===n.css(a,"boxSizing",!1,f),f);return g&&(e=T.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=n.css(a,b)),Na(a,c,g)}}}),n.cssHooks.marginLeft=Ga(l.reliableMarginLeft,function(a,b){return b?(parseFloat(Fa(a,"marginLeft"))||a.getBoundingClientRect().left-Da(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px":void 0}),n.cssHooks.marginRight=Ga(l.reliableMarginRight,function(a,b){return b?Da(a,{display:"inline-block"},Fa,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+U[d]+b]=f[d]||f[d-2]||f[0];return e}},Aa.test(a)||(n.cssHooks[a+b].set=Na)}),n.fn.extend({css:function(a,b){return K(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=Ca(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Qa(this,!0)},hide:function(){return Qa(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){V(this)?n(this).show():n(this).hide()})}});function Ra(a,b,c,d,e){return new Ra.prototype.init(a,b,c,d,e)}n.Tween=Ra,Ra.prototype={constructor:Ra,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||n.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Ra.propHooks[this.prop];return a&&a.get?a.get(this):Ra.propHooks._default.get(this)},run:function(a){var b,c=Ra.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ra.propHooks._default.set(this),this}},Ra.prototype.init.prototype=Ra.prototype,Ra.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[n.cssProps[a.prop]]&&!n.cssHooks[a.prop]?a.elem[a.prop]=a.now:n.style(a.elem,a.prop,a.now+a.unit)}}},Ra.propHooks.scrollTop=Ra.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},n.fx=Ra.prototype.init,n.fx.step={};var Sa,Ta,Ua=/^(?:toggle|show|hide)$/,Va=/queueHooks$/;function Wa(){return a.setTimeout(function(){Sa=void 0}),Sa=n.now()}function Xa(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=U[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ya(a,b,c){for(var d,e=(_a.tweeners[b]||[]).concat(_a.tweeners["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Za(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&V(a),q=N.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?N.get(a,"olddisplay")||za(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Ua.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?za(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=N.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;N.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ya(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function $a(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function _a(a,b,c){var d,e,f=0,g=_a.prefilters.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Sa||Wa(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{},easing:n.easing._default},c),originalProperties:b,originalOptions:c,startTime:Sa||Wa(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for($a(k,j.opts.specialEasing);g>f;f++)if(d=_a.prefilters[f].call(j,a,k,j.opts))return n.isFunction(d.stop)&&(n._queueHooks(j.elem,j.opts.queue).stop=n.proxy(d.stop,d)),d;return n.map(k,Ya,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(_a,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return W(c.elem,a,T.exec(b),c),c}]},tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.match(G);for(var c,d=0,e=a.length;e>d;d++)c=a[d],_a.tweeners[c]=_a.tweeners[c]||[],_a.tweeners[c].unshift(b)},prefilters:[Za],prefilter:function(a,b){b?_a.prefilters.unshift(a):_a.prefilters.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(V).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=_a(this,n.extend({},a),f);(e||N.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=N.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Va.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=N.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Xa(b,!0),a,d,e)}}),n.each({slideDown:Xa("show"),slideUp:Xa("hide"),slideToggle:Xa("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(Sa=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),Sa=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Ta||(Ta=a.setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){a.clearInterval(Ta),Ta=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(b,c){return b=n.fx?n.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",l.checkOn=""!==a.value,l.optSelected=c.selected,b.disabled=!0,l.optDisabled=!c.disabled,a=d.createElement("input"),a.value="t",a.type="radio",l.radioValue="t"===a.value}();var ab,bb=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return K(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),e=n.attrHooks[b]||(n.expr.match.bool.test(b)?ab:void 0)),void 0!==c?null===c?void n.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=n.find.attr(a,b),null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!l.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(G);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)}}),ab={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=bb[b]||n.find.attr;bb[b]=function(a,b,d){var e,f;return d||(f=bb[b],bb[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,bb[b]=f),e}});var cb=/^(?:input|select|textarea|button)$/i,db=/^(?:a|area)$/i;n.fn.extend({prop:function(a,b){return K(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&n.isXMLDoc(a)||(b=n.propFix[b]||b,e=n.propHooks[b]),
void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=n.find.attr(a,"tabindex");return b?parseInt(b,10):cb.test(a.nodeName)||db.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),l.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var eb=/[\t\r\n\f]/g;function fb(a){return a.getAttribute&&a.getAttribute("class")||""}n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,fb(this)))});if("string"==typeof a&&a){b=a.match(G)||[];while(c=this[i++])if(e=fb(c),d=1===c.nodeType&&(" "+e+" ").replace(eb," ")){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=n.trim(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,fb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(G)||[];while(c=this[i++])if(e=fb(c),d=1===c.nodeType&&(" "+e+" ").replace(eb," ")){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=n.trim(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):n.isFunction(a)?this.each(function(c){n(this).toggleClass(a.call(this,c,fb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=n(this),f=a.match(G)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=fb(this),b&&N.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":N.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+fb(c)+" ").replace(eb," ").indexOf(b)>-1)return!0;return!1}});var gb=/\r/g,hb=/[\x20\t\r\n\f]+/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(gb,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a)).replace(hb," ")}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],(c.selected||i===e)&&(l.optDisabled?!c.disabled:null===c.getAttribute("disabled"))&&(!c.parentNode.disabled||!n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(n.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>-1:void 0}},l.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var ib=/^(?:focusinfocus|focusoutblur)$/;n.extend(n.event,{trigger:function(b,c,e,f){var g,h,i,j,l,m,o,p=[e||d],q=k.call(b,"type")?b.type:b,r=k.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!ib.test(q+n.event.triggered)&&(q.indexOf(".")>-1&&(r=q.split("."),q=r.shift(),r.sort()),l=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=r.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},f||!o.trigger||o.trigger.apply(e,c)!==!1)){if(!f&&!o.noBubble&&!n.isWindow(e)){for(j=o.delegateType||q,ib.test(j+q)||(h=h.parentNode);h;h=h.parentNode)p.push(h),i=h;i===(e.ownerDocument||d)&&p.push(i.defaultView||i.parentWindow||a)}g=0;while((h=p[g++])&&!b.isPropagationStopped())b.type=g>1?j:o.bindType||q,m=(N.get(h,"events")||{})[b.type]&&N.get(h,"handle"),m&&m.apply(h,c),m=l&&h[l],m&&m.apply&&L(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=q,f||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!L(e)||l&&n.isFunction(e[q])&&!n.isWindow(e)&&(i=e[l],i&&(e[l]=null),n.event.triggered=q,e[q](),n.event.triggered=void 0,i&&(e[l]=i)),b.result}},simulate:function(a,b,c){var d=n.extend(new n.Event,c,{type:a,isSimulated:!0});n.event.trigger(d,null,b)}}),n.fn.extend({trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),l.focusin="onfocusin"in a,l.focusin||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a))};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=N.access(d,b);e||d.addEventListener(a,c,!0),N.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=N.access(d,b)-1;e?N.access(d,b,e):(d.removeEventListener(a,c,!0),N.remove(d,b))}}});var jb=a.location,kb=n.now(),lb=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||n.error("Invalid XML: "+b),c};var mb=/#.*$/,nb=/([?&])_=[^&]*/,ob=/^(.*?):[ \t]*([^\r\n]*)$/gm,pb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,qb=/^(?:GET|HEAD)$/,rb=/^\/\//,sb={},tb={},ub="*/".concat("*"),vb=d.createElement("a");vb.href=jb.href;function wb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(G)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function xb(a,b,c,d){var e={},f=a===tb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function yb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function zb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Ab(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:jb.href,type:"GET",isLocal:pb.test(jb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":ub,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?yb(yb(a,n.ajaxSettings),b):yb(n.ajaxSettings,a)},ajaxPrefilter:wb(sb),ajaxTransport:wb(tb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m=n.ajaxSetup({},c),o=m.context||m,p=m.context&&(o.nodeType||o.jquery)?n(o):n.event,q=n.Deferred(),r=n.Callbacks("once memory"),s=m.statusCode||{},t={},u={},v=0,w="canceled",x={readyState:0,getResponseHeader:function(a){var b;if(2===v){if(!h){h={};while(b=ob.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===v?g:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return v||(a=u[c]=u[c]||a,t[a]=b),this},overrideMimeType:function(a){return v||(m.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>v)for(b in a)s[b]=[s[b],a[b]];else x.always(a[x.status]);return this},abort:function(a){var b=a||w;return e&&e.abort(b),z(0,b),this}};if(q.promise(x).complete=r.add,x.success=x.done,x.error=x.fail,m.url=((b||m.url||jb.href)+"").replace(mb,"").replace(rb,jb.protocol+"//"),m.type=c.method||c.type||m.method||m.type,m.dataTypes=n.trim(m.dataType||"*").toLowerCase().match(G)||[""],null==m.crossDomain){j=d.createElement("a");try{j.href=m.url,j.href=j.href,m.crossDomain=vb.protocol+"//"+vb.host!=j.protocol+"//"+j.host}catch(y){m.crossDomain=!0}}if(m.data&&m.processData&&"string"!=typeof m.data&&(m.data=n.param(m.data,m.traditional)),xb(sb,m,c,x),2===v)return x;k=n.event&&m.global,k&&0===n.active++&&n.event.trigger("ajaxStart"),m.type=m.type.toUpperCase(),m.hasContent=!qb.test(m.type),f=m.url,m.hasContent||(m.data&&(f=m.url+=(lb.test(f)?"&":"?")+m.data,delete m.data),m.cache===!1&&(m.url=nb.test(f)?f.replace(nb,"$1_="+kb++):f+(lb.test(f)?"&":"?")+"_="+kb++)),m.ifModified&&(n.lastModified[f]&&x.setRequestHeader("If-Modified-Since",n.lastModified[f]),n.etag[f]&&x.setRequestHeader("If-None-Match",n.etag[f])),(m.data&&m.hasContent&&m.contentType!==!1||c.contentType)&&x.setRequestHeader("Content-Type",m.contentType),x.setRequestHeader("Accept",m.dataTypes[0]&&m.accepts[m.dataTypes[0]]?m.accepts[m.dataTypes[0]]+("*"!==m.dataTypes[0]?", "+ub+"; q=0.01":""):m.accepts["*"]);for(l in m.headers)x.setRequestHeader(l,m.headers[l]);if(m.beforeSend&&(m.beforeSend.call(o,x,m)===!1||2===v))return x.abort();w="abort";for(l in{success:1,error:1,complete:1})x[l](m[l]);if(e=xb(tb,m,c,x)){if(x.readyState=1,k&&p.trigger("ajaxSend",[x,m]),2===v)return x;m.async&&m.timeout>0&&(i=a.setTimeout(function(){x.abort("timeout")},m.timeout));try{v=1,e.send(t,z)}catch(y){if(!(2>v))throw y;z(-1,y)}}else z(-1,"No Transport");function z(b,c,d,h){var j,l,t,u,w,y=c;2!==v&&(v=2,i&&a.clearTimeout(i),e=void 0,g=h||"",x.readyState=b>0?4:0,j=b>=200&&300>b||304===b,d&&(u=zb(m,x,d)),u=Ab(m,u,x,j),j?(m.ifModified&&(w=x.getResponseHeader("Last-Modified"),w&&(n.lastModified[f]=w),w=x.getResponseHeader("etag"),w&&(n.etag[f]=w)),204===b||"HEAD"===m.type?y="nocontent":304===b?y="notmodified":(y=u.state,l=u.data,t=u.error,j=!t)):(t=y,!b&&y||(y="error",0>b&&(b=0))),x.status=b,x.statusText=(c||y)+"",j?q.resolveWith(o,[l,y,x]):q.rejectWith(o,[x,y,t]),x.statusCode(s),s=void 0,k&&p.trigger(j?"ajaxSuccess":"ajaxError",[x,m,j?l:t]),r.fireWith(o,[x,y]),k&&(p.trigger("ajaxComplete",[x,m]),--n.active||n.event.trigger("ajaxStop")))}return x},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax(n.extend({url:a,type:b,dataType:e,data:c,success:d},n.isPlainObject(a)&&a))}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return n.isFunction(a)?this.each(function(b){n(this).wrapInner(a.call(this,b))}):this.each(function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return!n.expr.filters.visible(a)},n.expr.filters.visible=function(a){return a.offsetWidth>0||a.offsetHeight>0||a.getClientRects().length>0};var Bb=/%20/g,Cb=/\[\]$/,Db=/\r?\n/g,Eb=/^(?:submit|button|image|reset|file)$/i,Fb=/^(?:input|select|textarea|keygen)/i;function Gb(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||Cb.test(a)?d(a,e):Gb(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Gb(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Gb(c,a[c],b,e);return d.join("&").replace(Bb,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&Fb.test(this.nodeName)&&!Eb.test(a)&&(this.checked||!X.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(Db,"\r\n")}}):{name:b.name,value:c.replace(Db,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Hb={0:200,1223:204},Ib=n.ajaxSettings.xhr();l.cors=!!Ib&&"withCredentials"in Ib,l.ajax=Ib=!!Ib,n.ajaxTransport(function(b){var c,d;return l.cors||Ib&&!b.crossDomain?{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Hb[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=n("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Jb=[],Kb=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Jb.pop()||n.expando+"_"+kb++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Kb.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Kb.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Kb,"$1"+e):b.jsonp!==!1&&(b.url+=(lb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?n(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Jb.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||d;var e=x.exec(a),f=!c&&[];return e?[b.createElement(e[1])]:(e=ca([a],b,f),f&&f.length&&n(f).remove(),n.merge([],e.childNodes))};var Lb=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Lb)return Lb.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};function Mb(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,n.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(e=d.getBoundingClientRect(),c=Mb(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Ea})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;n.fn[a]=function(d){return K(this,function(a,d,e){var f=Mb(a);return void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=Ga(l.pixelPosition,function(a,c){return c?(c=Fa(a,b),Ba.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return K(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)},size:function(){return this.length}}),n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Nb=a.jQuery,Ob=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Ob),b&&a.jQuery===n&&(a.jQuery=Nb),n},b||(a.jQuery=a.$=n),n});

//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
!function(){var n="object"==typeof self&&self.self===self&&self||"object"==typeof global&&global.global===global&&global||this||{},r=n._,e=Array.prototype,o=Object.prototype,s="undefined"!=typeof Symbol?Symbol.prototype:null,u=e.push,c=e.slice,p=o.toString,i=o.hasOwnProperty,t=Array.isArray,a=Object.keys,l=Object.create,f=function(){},h=function(n){return n instanceof h?n:this instanceof h?void(this._wrapped=n):new h(n)};"undefined"==typeof exports||exports.nodeType?n._=h:("undefined"!=typeof module&&!module.nodeType&&module.exports&&(exports=module.exports=h),exports._=h),h.VERSION="1.9.1";var v,y=function(u,i,n){if(void 0===i)return u;switch(null==n?3:n){case 1:return function(n){return u.call(i,n)};case 3:return function(n,r,t){return u.call(i,n,r,t)};case 4:return function(n,r,t,e){return u.call(i,n,r,t,e)}}return function(){return u.apply(i,arguments)}},d=function(n,r,t){return h.iteratee!==v?h.iteratee(n,r):null==n?h.identity:h.isFunction(n)?y(n,r,t):h.isObject(n)&&!h.isArray(n)?h.matcher(n):h.property(n)};h.iteratee=v=function(n,r){return d(n,r,1/0)};var g=function(u,i){return i=null==i?u.length-1:+i,function(){for(var n=Math.max(arguments.length-i,0),r=Array(n),t=0;t<n;t++)r[t]=arguments[t+i];switch(i){case 0:return u.call(this,r);case 1:return u.call(this,arguments[0],r);case 2:return u.call(this,arguments[0],arguments[1],r)}var e=Array(i+1);for(t=0;t<i;t++)e[t]=arguments[t];return e[i]=r,u.apply(this,e)}},m=function(n){if(!h.isObject(n))return{};if(l)return l(n);f.prototype=n;var r=new f;return f.prototype=null,r},b=function(r){return function(n){return null==n?void 0:n[r]}},j=function(n,r){return null!=n&&i.call(n,r)},x=function(n,r){for(var t=r.length,e=0;e<t;e++){if(null==n)return;n=n[r[e]]}return t?n:void 0},_=Math.pow(2,53)-1,A=b("length"),w=function(n){var r=A(n);return"number"==typeof r&&0<=r&&r<=_};h.each=h.forEach=function(n,r,t){var e,u;if(r=y(r,t),w(n))for(e=0,u=n.length;e<u;e++)r(n[e],e,n);else{var i=h.keys(n);for(e=0,u=i.length;e<u;e++)r(n[i[e]],i[e],n)}return n},h.map=h.collect=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=Array(u),o=0;o<u;o++){var a=e?e[o]:o;i[o]=r(n[a],a,n)}return i};var O=function(c){return function(n,r,t,e){var u=3<=arguments.length;return function(n,r,t,e){var u=!w(n)&&h.keys(n),i=(u||n).length,o=0<c?0:i-1;for(e||(t=n[u?u[o]:o],o+=c);0<=o&&o<i;o+=c){var a=u?u[o]:o;t=r(t,n[a],a,n)}return t}(n,y(r,e,4),t,u)}};h.reduce=h.foldl=h.inject=O(1),h.reduceRight=h.foldr=O(-1),h.find=h.detect=function(n,r,t){var e=(w(n)?h.findIndex:h.findKey)(n,r,t);if(void 0!==e&&-1!==e)return n[e]},h.filter=h.select=function(n,e,r){var u=[];return e=d(e,r),h.each(n,function(n,r,t){e(n,r,t)&&u.push(n)}),u},h.reject=function(n,r,t){return h.filter(n,h.negate(d(r)),t)},h.every=h.all=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=0;i<u;i++){var o=e?e[i]:i;if(!r(n[o],o,n))return!1}return!0},h.some=h.any=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=0;i<u;i++){var o=e?e[i]:i;if(r(n[o],o,n))return!0}return!1},h.contains=h.includes=h.include=function(n,r,t,e){return w(n)||(n=h.values(n)),("number"!=typeof t||e)&&(t=0),0<=h.indexOf(n,r,t)},h.invoke=g(function(n,t,e){var u,i;return h.isFunction(t)?i=t:h.isArray(t)&&(u=t.slice(0,-1),t=t[t.length-1]),h.map(n,function(n){var r=i;if(!r){if(u&&u.length&&(n=x(n,u)),null==n)return;r=n[t]}return null==r?r:r.apply(n,e)})}),h.pluck=function(n,r){return h.map(n,h.property(r))},h.where=function(n,r){return h.filter(n,h.matcher(r))},h.findWhere=function(n,r){return h.find(n,h.matcher(r))},h.max=function(n,e,r){var t,u,i=-1/0,o=-1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var a=0,c=(n=w(n)?n:h.values(n)).length;a<c;a++)null!=(t=n[a])&&i<t&&(i=t);else e=d(e,r),h.each(n,function(n,r,t){u=e(n,r,t),(o<u||u===-1/0&&i===-1/0)&&(i=n,o=u)});return i},h.min=function(n,e,r){var t,u,i=1/0,o=1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var a=0,c=(n=w(n)?n:h.values(n)).length;a<c;a++)null!=(t=n[a])&&t<i&&(i=t);else e=d(e,r),h.each(n,function(n,r,t){((u=e(n,r,t))<o||u===1/0&&i===1/0)&&(i=n,o=u)});return i},h.shuffle=function(n){return h.sample(n,1/0)},h.sample=function(n,r,t){if(null==r||t)return w(n)||(n=h.values(n)),n[h.random(n.length-1)];var e=w(n)?h.clone(n):h.values(n),u=A(e);r=Math.max(Math.min(r,u),0);for(var i=u-1,o=0;o<r;o++){var a=h.random(o,i),c=e[o];e[o]=e[a],e[a]=c}return e.slice(0,r)},h.sortBy=function(n,e,r){var u=0;return e=d(e,r),h.pluck(h.map(n,function(n,r,t){return{value:n,index:u++,criteria:e(n,r,t)}}).sort(function(n,r){var t=n.criteria,e=r.criteria;if(t!==e){if(e<t||void 0===t)return 1;if(t<e||void 0===e)return-1}return n.index-r.index}),"value")};var k=function(o,r){return function(e,u,n){var i=r?[[],[]]:{};return u=d(u,n),h.each(e,function(n,r){var t=u(n,r,e);o(i,n,t)}),i}};h.groupBy=k(function(n,r,t){j(n,t)?n[t].push(r):n[t]=[r]}),h.indexBy=k(function(n,r,t){n[t]=r}),h.countBy=k(function(n,r,t){j(n,t)?n[t]++:n[t]=1});var S=/[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;h.toArray=function(n){return n?h.isArray(n)?c.call(n):h.isString(n)?n.match(S):w(n)?h.map(n,h.identity):h.values(n):[]},h.size=function(n){return null==n?0:w(n)?n.length:h.keys(n).length},h.partition=k(function(n,r,t){n[t?0:1].push(r)},!0),h.first=h.head=h.take=function(n,r,t){return null==n||n.length<1?null==r?void 0:[]:null==r||t?n[0]:h.initial(n,n.length-r)},h.initial=function(n,r,t){return c.call(n,0,Math.max(0,n.length-(null==r||t?1:r)))},h.last=function(n,r,t){return null==n||n.length<1?null==r?void 0:[]:null==r||t?n[n.length-1]:h.rest(n,Math.max(0,n.length-r))},h.rest=h.tail=h.drop=function(n,r,t){return c.call(n,null==r||t?1:r)},h.compact=function(n){return h.filter(n,Boolean)};var M=function(n,r,t,e){for(var u=(e=e||[]).length,i=0,o=A(n);i<o;i++){var a=n[i];if(w(a)&&(h.isArray(a)||h.isArguments(a)))if(r)for(var c=0,l=a.length;c<l;)e[u++]=a[c++];else M(a,r,t,e),u=e.length;else t||(e[u++]=a)}return e};h.flatten=function(n,r){return M(n,r,!1)},h.without=g(function(n,r){return h.difference(n,r)}),h.uniq=h.unique=function(n,r,t,e){h.isBoolean(r)||(e=t,t=r,r=!1),null!=t&&(t=d(t,e));for(var u=[],i=[],o=0,a=A(n);o<a;o++){var c=n[o],l=t?t(c,o,n):c;r&&!t?(o&&i===l||u.push(c),i=l):t?h.contains(i,l)||(i.push(l),u.push(c)):h.contains(u,c)||u.push(c)}return u},h.union=g(function(n){return h.uniq(M(n,!0,!0))}),h.intersection=function(n){for(var r=[],t=arguments.length,e=0,u=A(n);e<u;e++){var i=n[e];if(!h.contains(r,i)){var o;for(o=1;o<t&&h.contains(arguments[o],i);o++);o===t&&r.push(i)}}return r},h.difference=g(function(n,r){return r=M(r,!0,!0),h.filter(n,function(n){return!h.contains(r,n)})}),h.unzip=function(n){for(var r=n&&h.max(n,A).length||0,t=Array(r),e=0;e<r;e++)t[e]=h.pluck(n,e);return t},h.zip=g(h.unzip),h.object=function(n,r){for(var t={},e=0,u=A(n);e<u;e++)r?t[n[e]]=r[e]:t[n[e][0]]=n[e][1];return t};var F=function(i){return function(n,r,t){r=d(r,t);for(var e=A(n),u=0<i?0:e-1;0<=u&&u<e;u+=i)if(r(n[u],u,n))return u;return-1}};h.findIndex=F(1),h.findLastIndex=F(-1),h.sortedIndex=function(n,r,t,e){for(var u=(t=d(t,e,1))(r),i=0,o=A(n);i<o;){var a=Math.floor((i+o)/2);t(n[a])<u?i=a+1:o=a}return i};var E=function(i,o,a){return function(n,r,t){var e=0,u=A(n);if("number"==typeof t)0<i?e=0<=t?t:Math.max(t+u,e):u=0<=t?Math.min(t+1,u):t+u+1;else if(a&&t&&u)return n[t=a(n,r)]===r?t:-1;if(r!=r)return 0<=(t=o(c.call(n,e,u),h.isNaN))?t+e:-1;for(t=0<i?e:u-1;0<=t&&t<u;t+=i)if(n[t]===r)return t;return-1}};h.indexOf=E(1,h.findIndex,h.sortedIndex),h.lastIndexOf=E(-1,h.findLastIndex),h.range=function(n,r,t){null==r&&(r=n||0,n=0),t||(t=r<n?-1:1);for(var e=Math.max(Math.ceil((r-n)/t),0),u=Array(e),i=0;i<e;i++,n+=t)u[i]=n;return u},h.chunk=function(n,r){if(null==r||r<1)return[];for(var t=[],e=0,u=n.length;e<u;)t.push(c.call(n,e,e+=r));return t};var N=function(n,r,t,e,u){if(!(e instanceof r))return n.apply(t,u);var i=m(n.prototype),o=n.apply(i,u);return h.isObject(o)?o:i};h.bind=g(function(r,t,e){if(!h.isFunction(r))throw new TypeError("Bind must be called on a function");var u=g(function(n){return N(r,u,t,this,e.concat(n))});return u}),h.partial=g(function(u,i){var o=h.partial.placeholder,a=function(){for(var n=0,r=i.length,t=Array(r),e=0;e<r;e++)t[e]=i[e]===o?arguments[n++]:i[e];for(;n<arguments.length;)t.push(arguments[n++]);return N(u,a,this,this,t)};return a}),(h.partial.placeholder=h).bindAll=g(function(n,r){var t=(r=M(r,!1,!1)).length;if(t<1)throw new Error("bindAll must be passed function names");for(;t--;){var e=r[t];n[e]=h.bind(n[e],n)}}),h.memoize=function(e,u){var i=function(n){var r=i.cache,t=""+(u?u.apply(this,arguments):n);return j(r,t)||(r[t]=e.apply(this,arguments)),r[t]};return i.cache={},i},h.delay=g(function(n,r,t){return setTimeout(function(){return n.apply(null,t)},r)}),h.defer=h.partial(h.delay,h,1),h.throttle=function(t,e,u){var i,o,a,c,l=0;u||(u={});var f=function(){l=!1===u.leading?0:h.now(),i=null,c=t.apply(o,a),i||(o=a=null)},n=function(){var n=h.now();l||!1!==u.leading||(l=n);var r=e-(n-l);return o=this,a=arguments,r<=0||e<r?(i&&(clearTimeout(i),i=null),l=n,c=t.apply(o,a),i||(o=a=null)):i||!1===u.trailing||(i=setTimeout(f,r)),c};return n.cancel=function(){clearTimeout(i),l=0,i=o=a=null},n},h.debounce=function(t,e,u){var i,o,a=function(n,r){i=null,r&&(o=t.apply(n,r))},n=g(function(n){if(i&&clearTimeout(i),u){var r=!i;i=setTimeout(a,e),r&&(o=t.apply(this,n))}else i=h.delay(a,e,this,n);return o});return n.cancel=function(){clearTimeout(i),i=null},n},h.wrap=function(n,r){return h.partial(r,n)},h.negate=function(n){return function(){return!n.apply(this,arguments)}},h.compose=function(){var t=arguments,e=t.length-1;return function(){for(var n=e,r=t[e].apply(this,arguments);n--;)r=t[n].call(this,r);return r}},h.after=function(n,r){return function(){if(--n<1)return r.apply(this,arguments)}},h.before=function(n,r){var t;return function(){return 0<--n&&(t=r.apply(this,arguments)),n<=1&&(r=null),t}},h.once=h.partial(h.before,2),h.restArguments=g;var I=!{toString:null}.propertyIsEnumerable("toString"),T=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"],B=function(n,r){var t=T.length,e=n.constructor,u=h.isFunction(e)&&e.prototype||o,i="constructor";for(j(n,i)&&!h.contains(r,i)&&r.push(i);t--;)(i=T[t])in n&&n[i]!==u[i]&&!h.contains(r,i)&&r.push(i)};h.keys=function(n){if(!h.isObject(n))return[];if(a)return a(n);var r=[];for(var t in n)j(n,t)&&r.push(t);return I&&B(n,r),r},h.allKeys=function(n){if(!h.isObject(n))return[];var r=[];for(var t in n)r.push(t);return I&&B(n,r),r},h.values=function(n){for(var r=h.keys(n),t=r.length,e=Array(t),u=0;u<t;u++)e[u]=n[r[u]];return e},h.mapObject=function(n,r,t){r=d(r,t);for(var e=h.keys(n),u=e.length,i={},o=0;o<u;o++){var a=e[o];i[a]=r(n[a],a,n)}return i},h.pairs=function(n){for(var r=h.keys(n),t=r.length,e=Array(t),u=0;u<t;u++)e[u]=[r[u],n[r[u]]];return e},h.invert=function(n){for(var r={},t=h.keys(n),e=0,u=t.length;e<u;e++)r[n[t[e]]]=t[e];return r},h.functions=h.methods=function(n){var r=[];for(var t in n)h.isFunction(n[t])&&r.push(t);return r.sort()};var R=function(c,l){return function(n){var r=arguments.length;if(l&&(n=Object(n)),r<2||null==n)return n;for(var t=1;t<r;t++)for(var e=arguments[t],u=c(e),i=u.length,o=0;o<i;o++){var a=u[o];l&&void 0!==n[a]||(n[a]=e[a])}return n}};h.extend=R(h.allKeys),h.extendOwn=h.assign=R(h.keys),h.findKey=function(n,r,t){r=d(r,t);for(var e,u=h.keys(n),i=0,o=u.length;i<o;i++)if(r(n[e=u[i]],e,n))return e};var q,K,z=function(n,r,t){return r in t};h.pick=g(function(n,r){var t={},e=r[0];if(null==n)return t;h.isFunction(e)?(1<r.length&&(e=y(e,r[1])),r=h.allKeys(n)):(e=z,r=M(r,!1,!1),n=Object(n));for(var u=0,i=r.length;u<i;u++){var o=r[u],a=n[o];e(a,o,n)&&(t[o]=a)}return t}),h.omit=g(function(n,t){var r,e=t[0];return h.isFunction(e)?(e=h.negate(e),1<t.length&&(r=t[1])):(t=h.map(M(t,!1,!1),String),e=function(n,r){return!h.contains(t,r)}),h.pick(n,e,r)}),h.defaults=R(h.allKeys,!0),h.create=function(n,r){var t=m(n);return r&&h.extendOwn(t,r),t},h.clone=function(n){return h.isObject(n)?h.isArray(n)?n.slice():h.extend({},n):n},h.tap=function(n,r){return r(n),n},h.isMatch=function(n,r){var t=h.keys(r),e=t.length;if(null==n)return!e;for(var u=Object(n),i=0;i<e;i++){var o=t[i];if(r[o]!==u[o]||!(o in u))return!1}return!0},q=function(n,r,t,e){if(n===r)return 0!==n||1/n==1/r;if(null==n||null==r)return!1;if(n!=n)return r!=r;var u=typeof n;return("function"===u||"object"===u||"object"==typeof r)&&K(n,r,t,e)},K=function(n,r,t,e){n instanceof h&&(n=n._wrapped),r instanceof h&&(r=r._wrapped);var u=p.call(n);if(u!==p.call(r))return!1;switch(u){case"[object RegExp]":case"[object String]":return""+n==""+r;case"[object Number]":return+n!=+n?+r!=+r:0==+n?1/+n==1/r:+n==+r;case"[object Date]":case"[object Boolean]":return+n==+r;case"[object Symbol]":return s.valueOf.call(n)===s.valueOf.call(r)}var i="[object Array]"===u;if(!i){if("object"!=typeof n||"object"!=typeof r)return!1;var o=n.constructor,a=r.constructor;if(o!==a&&!(h.isFunction(o)&&o instanceof o&&h.isFunction(a)&&a instanceof a)&&"constructor"in n&&"constructor"in r)return!1}e=e||[];for(var c=(t=t||[]).length;c--;)if(t[c]===n)return e[c]===r;if(t.push(n),e.push(r),i){if((c=n.length)!==r.length)return!1;for(;c--;)if(!q(n[c],r[c],t,e))return!1}else{var l,f=h.keys(n);if(c=f.length,h.keys(r).length!==c)return!1;for(;c--;)if(l=f[c],!j(r,l)||!q(n[l],r[l],t,e))return!1}return t.pop(),e.pop(),!0},h.isEqual=function(n,r){return q(n,r)},h.isEmpty=function(n){return null==n||(w(n)&&(h.isArray(n)||h.isString(n)||h.isArguments(n))?0===n.length:0===h.keys(n).length)},h.isElement=function(n){return!(!n||1!==n.nodeType)},h.isArray=t||function(n){return"[object Array]"===p.call(n)},h.isObject=function(n){var r=typeof n;return"function"===r||"object"===r&&!!n},h.each(["Arguments","Function","String","Number","Date","RegExp","Error","Symbol","Map","WeakMap","Set","WeakSet"],function(r){h["is"+r]=function(n){return p.call(n)==="[object "+r+"]"}}),h.isArguments(arguments)||(h.isArguments=function(n){return j(n,"callee")});var D=n.document&&n.document.childNodes;"function"!=typeof/./&&"object"!=typeof Int8Array&&"function"!=typeof D&&(h.isFunction=function(n){return"function"==typeof n||!1}),h.isFinite=function(n){return!h.isSymbol(n)&&isFinite(n)&&!isNaN(parseFloat(n))},h.isNaN=function(n){return h.isNumber(n)&&isNaN(n)},h.isBoolean=function(n){return!0===n||!1===n||"[object Boolean]"===p.call(n)},h.isNull=function(n){return null===n},h.isUndefined=function(n){return void 0===n},h.has=function(n,r){if(!h.isArray(r))return j(n,r);for(var t=r.length,e=0;e<t;e++){var u=r[e];if(null==n||!i.call(n,u))return!1;n=n[u]}return!!t},h.noConflict=function(){return n._=r,this},h.identity=function(n){return n},h.constant=function(n){return function(){return n}},h.noop=function(){},h.property=function(r){return h.isArray(r)?function(n){return x(n,r)}:b(r)},h.propertyOf=function(r){return null==r?function(){}:function(n){return h.isArray(n)?x(r,n):r[n]}},h.matcher=h.matches=function(r){return r=h.extendOwn({},r),function(n){return h.isMatch(n,r)}},h.times=function(n,r,t){var e=Array(Math.max(0,n));r=y(r,t,1);for(var u=0;u<n;u++)e[u]=r(u);return e},h.random=function(n,r){return null==r&&(r=n,n=0),n+Math.floor(Math.random()*(r-n+1))},h.now=Date.now||function(){return(new Date).getTime()};var L={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},P=h.invert(L),W=function(r){var t=function(n){return r[n]},n="(?:"+h.keys(r).join("|")+")",e=RegExp(n),u=RegExp(n,"g");return function(n){return n=null==n?"":""+n,e.test(n)?n.replace(u,t):n}};h.escape=W(L),h.unescape=W(P),h.result=function(n,r,t){h.isArray(r)||(r=[r]);var e=r.length;if(!e)return h.isFunction(t)?t.call(n):t;for(var u=0;u<e;u++){var i=null==n?void 0:n[r[u]];void 0===i&&(i=t,u=e),n=h.isFunction(i)?i.call(n):i}return n};var C=0;h.uniqueId=function(n){var r=++C+"";return n?n+r:r},h.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var J=/(.)^/,U={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},V=/\\|'|\r|\n|\u2028|\u2029/g,$=function(n){return"\\"+U[n]};h.template=function(i,n,r){!n&&r&&(n=r),n=h.defaults({},n,h.templateSettings);var t,e=RegExp([(n.escape||J).source,(n.interpolate||J).source,(n.evaluate||J).source].join("|")+"|$","g"),o=0,a="__p+='";i.replace(e,function(n,r,t,e,u){return a+=i.slice(o,u).replace(V,$),o=u+n.length,r?a+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'":t?a+="'+\n((__t=("+t+"))==null?'':__t)+\n'":e&&(a+="';\n"+e+"\n__p+='"),n}),a+="';\n",n.variable||(a="with(obj||{}){\n"+a+"}\n"),a="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+a+"return __p;\n";try{t=new Function(n.variable||"obj","_",a)}catch(n){throw n.source=a,n}var u=function(n){return t.call(this,n,h)},c=n.variable||"obj";return u.source="function("+c+"){\n"+a+"}",u},h.chain=function(n){var r=h(n);return r._chain=!0,r};var G=function(n,r){return n._chain?h(r).chain():r};h.mixin=function(t){return h.each(h.functions(t),function(n){var r=h[n]=t[n];h.prototype[n]=function(){var n=[this._wrapped];return u.apply(n,arguments),G(this,r.apply(h,n))}}),h},h.mixin(h),h.each(["pop","push","reverse","shift","sort","splice","unshift"],function(r){var t=e[r];h.prototype[r]=function(){var n=this._wrapped;return t.apply(n,arguments),"shift"!==r&&"splice"!==r||0!==n.length||delete n[0],G(this,n)}}),h.each(["concat","join","slice"],function(n){var r=e[n];h.prototype[n]=function(){return G(this,r.apply(this._wrapped,arguments))}}),h.prototype.value=function(){return this._wrapped},h.prototype.valueOf=h.prototype.toJSON=h.prototype.value,h.prototype.toString=function(){return String(this._wrapped)},"function"==typeof define&&define.amd&&define("underscore",[],function(){return h})}();
define("underscore-min", ["jquery"], (function (global) {
    return function () {
        var ret, fn;
       fn = function () {
                return _.noConflict();
            };
        ret = fn.apply(global, arguments);
        return ret || global._;
    };
}(this)));

// Generated by CoffeeScript 1.3.3
(function() {
  var WCS,
    __bind = function(fn, me){
      return function(){
        return fn.apply(me, arguments);
      };
    },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  WCS = (typeof exports !== "undefined" && exports !== null) && this || (this.WCS = {});

  WCS.Math = {};

  WCS.Math.R2D = 180 / Math.PI;

  WCS.Math.D2R = Math.PI / 180;

  WCS.Math.WCSTRIG_TOL = 1e-10;

  WCS.Math.cosd = function(angle) {
    var i;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 + 0.5)) % 4;
      switch (i) {
        case 0:
          return 1;
        case 1:
          return 0;
        case 2:
          return -1;
        case 3:
          return 0;
      }
    }
    return Math.cos(angle * WCS.Math.D2R);
  };

  WCS.Math.sind = function(angle) {
    var i;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 - 0.5)) % 4;
      switch (i) {
        case 0:
          return 1;
        case 1:
          return 0;
        case 2:
          return -1;
        case 3:
          return 0;
      }
    }
    return Math.sin(angle * WCS.Math.D2R);
  };

  WCS.Math.sincosd = function(angle) {
    var c, i, s, _ref, _ref1;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 + 0.5)) % 4;
      switch (i) {
        case 0:
          s = 0;
          c = 1;
          break;
        case 1:
          s = (_ref = angle > 0) != null ? _ref : {
            1: -1
          };
          c = 0;
          break;
        case 2:
          s = 0;
          c = -1;
          break;
        case 3:
          s = (_ref1 = angle > 0) != null ? _ref1 : -{
            1: 1
          };
          c = 0;
      }
      return s * c;
    }
    s = Math.sin(angle * WCS.Math.D2R);
    c = Math.cos(angle * WCS.Math.D2R);
    return s * c;
  };

  WCS.Math.tand = function(angle) {
    var resid;
    resid = angle & 360;
    if (resid === 0 || Math.abs(resid) === 180) {
      return 0;
    } else if (resid === 45 || resid === 225) {
      return 1;
    } else if (resid === -135 || resid === -315) {
      return -1;
    }
    return Math.tan(angle * WCS.Math.D2R);
  };

  WCS.Math.acosd = function(v) {
    if (v >= 1) {
      if (v - 1 < WCS.Math.WCSTRIG_TOL) {
        return 0;
      }
    } else if (v === 0) {
      return 90;
    } else if (v <= -1) {
      if (v + 1 > -WCS.Math.WCSTRIG_TOL) {
        return 180;
      }
    }
    return Math.acos(v) * WCS.Math.R2D;
  };

  WCS.Math.asind = function(v) {
    if (v <= -1) {
      if (v + 1 > -WCS.Math.WCSTRIG_TOL) {
        return -90;
      } else if (v === 0) {
        return 0;
      } else if (v >= 1) {
        if (v - 1 < WCS.Math.WCSTRIG_TOL) {
          return 90;
        }
      }
    }
    return Math.asin(v) * WCS.Math.R2D;
  };

  WCS.Math.atand = function(v) {
    if (v === -1) {
      return -45;
    } else if (v === 0) {
      return 0;
    } else if (v === 1) {
      return 45;
    }
    return Math.atan(v) * WCS.Math.R2D;
  };

  WCS.Math.atan2d = function(y, x) {
    if (y === 0) {
      if (x >= 0) {
        return 0;
      } else if (x < 0) {
        return 180;
      }
    } else if (x === 0) {
      if (y > 0) {
        return 90;
      } else if (y < 0) {
        return -90;
      }
    }
    return Math.atan2(y, x) * WCS.Math.R2D;
  };

  WCS.Math.toRightTriangular = function(mat) {
    var els, i, j, k, kp, multiplier, n, np, p;
    n = mat.length;
    k = n;
    kp = mat[0].length;
    while (true) {
      i = k - n;
      if (mat[i][i] === 0) {
        j = i + 1;
        while (j < k) {
          if (mat[j][i] !== 0) {
            els = [];
            np = kp;
            while (true) {
              p = kp - np;
              els.push(mat[i][p] + mat[j][p]);
              if (!--np) {
                break;
              }
            }
            mat[i] = els;
            break;
          }
          j += 1;
        }
      }
      if (mat[i][i] !== 0) {
        j = i + 1;
        while (j < k) {
          multiplier = mat[j][i] / mat[i][i];
          els = [];
          np = kp;
          while (true) {
            p = kp - np;
            els.push((p <= i ? 0 : mat[j][p] - mat[i][p] * multiplier));
            if (!--np) {
              break;
            }
          }
          mat[j] = els;
          j += 1;
        }
      }
      if (!--n) {
        break;
      }
    }
    return mat;
  };

  WCS.Math.determinant = function(mat) {
    var det, i, k, m, n;
    m = WCS.Math.toRightTriangular(mat);
    det = m[0][0];
    n = m.length - 1;
    k = n;
    while (true) {
      i = k - n + 1;
      det = det * m[i][i];
      if (!--n) {
        break;
      }
    }
    return det;
  };

  WCS.Math.matrixInverse = function(m) {
    var I, h, i, inv, j, mat, temp, w;
    w = m[0].length;
    h = m.length;
    I = new Array(h);
    inv = new Array(h);
    temp = [];
    mat = [];
    j = 0;
    while (j < h) {
      mat[j] = [];
      i = 0;
      while (i < w) {
        mat[j][i] = m[j][i];
        i += 1;
      }
      j += 1;
    }
    j = 0;
    while (j < h) {
      I[j] = new Array(w);
      inv[j] = new Array(w);
      i = 0;
      while (i < w) {
        I[j][i] = (i === j ? 1 : 0);
        i += 1;
      }
      temp[j] = mat[j].concat(I[j]);
      j += 1;
    }
    WCS.Math.gaussJordan(temp);
    j = 0;
    while (j < h) {
      inv[j] = temp[j].slice(w, 2 * w);
      j += 1;
    }
    return inv;
  };

  WCS.Math.gaussJordan = function (m, eps) {
  if (!eps) eps = 1e-10;
  var h, w, y, y2, x, maxrow, tmp, c;
  h = m.length;
  w = m[0].length;
  y = -1;

  while (++y < h) {
    maxrow = y;

    // Find max pivot.
    y2 = y;
    while (++y2 < h) {
      if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
        maxrow = y2;
    }

    // Swap.
    tmp = m[y];
    m[y] = m[maxrow];
    m[maxrow] = tmp;

    // Singular?
    if (Math.abs(m[y][y]) <= eps)
      return false;

    // Eliminate column y.
    y2 = y;
    while (++y2 < h) {
      c = m[y2][y] / m[y][y];
      x = y - 1;
      while (++x < w) {
        m[y2][x] -= m[y][x] * c;
      }
    }
  }

  // Backsubstitute.
  y = h;
  while (--y >= 0) {
    c = m[y][y];
    y2 = -1;
    while (++y2 < y) {
      x = w;
      while (--x >= y) {
        m[y2][x] -=  m[y][x] * m[y2][y] / c;
      }
    }
    m[y][y] /= c;
    // Normalize row y.
    x = h - 1;
    while (++x < w) {
      m[y][x] /= c;
    }
  }
  return true;
};;

  WCS.Mapper = (function() {

    function Mapper(header) {
      this.coordinateToPixel = __bind(this.coordinateToPixel, this);

      this.pixelToCoordinate = __bind(this.pixelToCoordinate, this);

      this.fromCelestial = __bind(this.fromCelestial, this);

      this.toCelestial = __bind(this.toCelestial, this);

      this.fromIntermediate = __bind(this.fromIntermediate, this);

      this.toIntermediate = __bind(this.toIntermediate, this);

      this.computeCelestialParameters = __bind(this.computeCelestialParameters, this);

      this.getSipCoefficients = __bind(this.getSipCoefficients, this);

      this.setProjection = __bind(this.setProjection, this);

      this.derivePC = __bind(this.derivePC, this);

      this.checkCard = __bind(this.checkCard, this);

      this.verifyHeader = __bind(this.verifyHeader, this);
      this.wcsobj = {};
      this.projection = void 0;
      this.longitudeAxis = void 0;
      this.latitudeAxis = void 0;
      this.sip = void 0;
      this.verifyHeader(header);
      this.setProjection(header);
    }

    Mapper.prototype.verifyHeader = function(header) {
      var arrayName, axis, date, j, key, naxis, requiredCards, _i, _j, _k, _ref;
      this.wcsobj.naxis = naxis = header['NAXIS'] || header['WCSAXES'] || 2;
      this.wcsobj.radesys = header['RADESYS'] || 'ICRS';
      requiredCards = ['CRPIX', 'CRVAL', 'CTYPE'];
      this.wcsobj.crpix = [];
      this.wcsobj.crval = [];
      this.wcsobj.ctype = [];
      for (axis = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; axis = 1 <= naxis ? ++_i : --_i) {
        for (j = _j = 0, _ref = requiredCards.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; j = 0 <= _ref ? ++_j : --_j) {
          key = requiredCards[j] + axis;
          if (!header.hasOwnProperty(key)) {
            throw "Not enough information to compute WCS, missing required keyword " + key;
          }
          arrayName = requiredCards[j].toLowerCase();
          this.wcsobj[arrayName].push(header[key]);
        }
      }
      this.wcsobj.cunit = [];
      this.wcsobj.cdelt = [];
      for (axis = _k = 1; 1 <= naxis ? _k <= naxis : _k >= naxis; axis = 1 <= naxis ? ++_k : --_k) {
        key = 'CUNIT' + axis;
        this.wcsobj.cunit.push(header[key] || 'deg');
        key = 'CDELT' + axis;
        this.wcsobj.cdelt.push(header[key] || 1);
      }
      this.wcsobj.lonpole = header['LONPOLE'] || 0;
      this.wcsobj.latpole = header['LATPOLE'] || 0;
      this.wcsobj.equinox = header['EQUINOX'] || 2000;
      date = new Date();
      this.wcsobj.dateObs = header['DATE_OBS'] || (date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate());
      this.wcsobj.dateObs = header['DATE_OBS'] || ("" + (date.getFullYear()) + "-" + (date.getMonth() + 1) + "-" + (date.getDate()));
      this.wcsobj.pc = this.checkCard(header, 'PC', naxis) || this.derivePC(header);
      this.wcsobj.pcInv = WCS.Math.matrixInverse(this.wcsobj.pc);
      this.wcsobj.cd = this.checkCard(header, 'CD', naxis);
      if (this.wcsobj.cd != null) {
        return this.wcsobj.cdInv = WCS.Math.matrixInverse(this.wcsobj.cd);
      }
    };

    Mapper.prototype.checkCard = function(header, key, dimensions) {
      var fullKey, i, j, obj, _i, _j;
      obj = [];
      for (i = _i = 1; 1 <= dimensions ? _i <= dimensions : _i >= dimensions; i = 1 <= dimensions ? ++_i : --_i) {
        obj[i - 1] = [];
        for (j = _j = 1; 1 <= dimensions ? _j <= dimensions : _j >= dimensions; j = 1 <= dimensions ? ++_j : --_j) {
          fullKey = "" + key + i + "_" + j;
          if (!header.hasOwnProperty(fullKey)) {
            return;
          }
          obj[i - 1].push(header[fullKey]);
        }
      }
      return obj;
    };

    Mapper.prototype.derivePC = function(header) {
      var cd, cd11, cd12, cd21, cd22, cos_rho, crota, lambda, rho_a, rho_b, _ref;
      if (header.hasOwnProperty('CROTA2')) {
        crota = header['CROTA2'];
        lambda = this.wcsobj.cdelt[1] / this.wcsobj.cdelt[0];
      } else {
        cd = this.checkCard(header, 'CD', this.wcsobj.naxis);
        if (cd == null) {
          _ref = [0, 1], crota = _ref[0], lambda = _ref[1];
        } else {
          cd11 = cd[0][0];
          cd12 = cd[0][1];
          cd21 = cd[1][0];
          cd22 = cd[1][1];
          if (cd21 > 0) {
            rho_a = Math.atan2(cd21, cd11);
          } else if (cd21 === 0) {
            rho_a = 0;
          } else {
            rho_a = Math.atan2(-cd21, -cd11);
          }
          if (cd12 > 0) {
            rho_b = Math.atan2(cd12, -cd22);
          } else if (cd12 === 0) {
            rho_b = 0;
          } else {
            rho_b = Math.atan2(-cd21, cd22);
          }
          crota = 0.5 * (rho_a + rho_b);
          cos_rho = Math.cos(crota);
          this.wcsobj.cdelt1 = cd11 / cos_rho;
          this.wcsobj.cdelt2 = cd22 / cos_rho;
          lambda = this.wcsobj.cdelt2 / this.wcsobj.cdelt1;
        }
      }
      return cd;
    };

    Mapper.prototype.setProjection = function(header) {
      var conic, cylindrical, key, key1, key2, key3, polyConic, quadCube, zenithal, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
        _this = this;
      zenithal = ['AIR', 'ARC', 'AZP', 'NCP', 'SIN', 'STG', 'SZP', 'TAN', 'TAN-SIP', 'ZEA', 'ZPN'];
      cylindrical = ['CYP', 'CEA', 'CAR', 'MER', 'SFL', 'PAR', 'MOL', 'AIT'];
      conic = ['COP', 'COE', 'COD', 'COO'];
      polyConic = ['BON', 'PCO'];
      quadCube = ['TSC', 'CSC', 'QSC'];
      this.projection = this.wcsobj.ctype[0].slice(5);
      this.longitudeAxis = this.wcsobj.ctype[0].match("RA|GLON|ELON|HLON|SLON") ? 1 : 2;
      this.latitudeAxis = this.wcsobj.ctype[1].match("DEC|GLAT|ELAT|HLAT|SLAT") ? 2 : 1;
      if (_ref = this.projection, __indexOf.call(zenithal, _ref) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 90;
        this.wcsobj.alphaP = this.wcsobj.crval[0];
        this.wcsobj.deltaP = this.wcsobj.crval[1];
        this.wcsobj.lonpole = this.wcsobj.crval[1] >= this.wcsobj.theta0 ? 0 : 180;
        switch (this.projection) {
          case 'AIR':
            key = "PV" + this.latitudeAxis + "_1";
            this.wcsobj.thetaB = header.hasOwnProperty(key) ? parseFloat(header[key]) : 90;
            this.wcsobj.etaB = (90 - this.wcsobj.thetaB) / 2;
            ({
              toSpherical: function(x, y) {
                throw 'Sorry, not yet implemented!';
              },
              fromSpherical: function(phi, theta) {
                throw 'Sorry, not yet implemented!';
              }
            });
            break;
          case 'ARC':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - r;
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 90 - theta;
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'AZP':
            _ref1 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2"], key1 = _ref1[0], key2 = _ref1[1];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.gamma = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
            break;
          case 'NCP':
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
            break;
          case 'SIN':
            _ref2 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2"], key1 = _ref2[0], key2 = _ref2[1];
            this.wcsobj.eta = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.nu = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.acosd(Math.PI * r / 180);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / Math.PI * WCS.Math.cosd(theta);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'STG':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - 2 * WCS.Math.atand(Math.PI * r / 360);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 360 / Math.PI * WCS.Math.tand((90 - theta) / 2);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'SZP':
            _ref3 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2", "PV" + this.latitudeAxis + "_3"], key1 = _ref3[0], key2 = _ref3[1], key3 = _ref3[2];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.phiC = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.wcsobj.thetaC = header.hasOwnProperty(key3) ? parseFloat(header[key3]) : 90;
            this.wcsobj.xp = -this.wcsobj.mu * WCS.Math.cosd(this.wcsobj.thetaC) * WCS.Math.sind(this.wcsobj.phiC);
            this.wcsobj.yp = this.wcsobj.mu * WCS.Math.cosd(this.wcsobj.thetaC) * WCS.Math.cosd(this.wcsobj.phiC);
            this.wcsobj.zp = this.wcsobj.mu * WCS.Math.sind(this.wcsobj.thetaC) + 1;
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented';
            };
            this.fromSpherical = function(phi, theta) {
              var divisor, x, y;
              throw 'Sorry, not yet implemented';
              divisor = _this.wcsobj.zp - 1 + WCS.Math.sind(theta);
              x = (180 / Math.PI) * (_this.wcsobj.zp * WCS.Math.cosd(theta) * WCS.Math.sind(phi) - _this.wcsobj.xp * (1 - WCS.Math.sind(theta))) / divisor;
              y = (-180 / Math.PI) * (_this.wcsobj.zp * WCS.Math.cosd(theta) * WCS.Math.cosd(phi) + _this.wcsobj.yp * (1 - WCS.Math.sind(theta))) / divisor;
              return [x, y];
            };
            break;
          case 'TAN':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.atand(180 / (Math.PI * r));
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / (Math.PI * WCS.Math.tand(theta));
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'TAN-SIP':
            this.getSipCoefficients(header);
            this.f = function(u, v, coeffs) {
              var order, p, q, value, _i, _j;
              value = 0;
              order = coeffs[0].length - 1;
              for (p = _i = 0; 0 <= order ? _i <= order : _i >= order; p = 0 <= order ? ++_i : --_i) {
                for (q = _j = 0; 0 <= order ? _j <= order : _j >= order; q = 0 <= order ? ++_j : --_j) {
                  value += coeffs[p][q] * Math.pow(u, p) * Math.pow(v, q);
                }
              }
              return value;
            };
            this.toIntermediate = function(points) {
              var dx, dy, i, j, proj, u, v, _i, _j, _ref4, _ref5;
              proj = [];
              u = points[0] - _this.wcsobj.crpix[0];
              v = points[1] - _this.wcsobj.crpix[1];
              dx = dy = 0;
              dx = _this.f(u, v, _this.sip.aCoeffs);
              dy = _this.f(u, v, _this.sip.bCoeffs);
              points[0] = points[0] + dx;
              points[1] = points[1] + dy;
              for (i = _i = 0, _ref4 = _this.wcsobj.naxis - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
                proj[i] = 0;
                points[i] -= _this.wcsobj.crpix[i];
                for (j = _j = 0, _ref5 = _this.wcsobj - 1; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; j = 0 <= _ref5 ? ++_j : --_j) {
                  proj[i] += _this.wcsobj.cd[i][j] * points[j];
                }
              }
              return proj;
            };
            this.fromIntermediate = function(proj) {
              var dx, dy, i, j, points, tmp, _i, _j, _ref4, _ref5;
              tmp = [];
              for (i = _i = 0, _ref4 = _this.wcsobj.naxis - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
                tmp[i] = 0;
                for (j = _j = 0, _ref5 = _this.wcsobj.naxis - 1; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; j = 0 <= _ref5 ? ++_j : --_j) {
                  tmp[i] += _this.wcsobj.cdInv[i][j] * proj[j];
                }
                tmp[i] += _this.wcsobj.crpix[i];
              }
              dx = dy = 0;
              dx = _this.f(tmp[0], tmp[1], _this.sip.apCoeffs);
              dy = _this.f(tmp[0], tmp[1], _this.sip.bpCoeffs);
              points = [];
              points[0] = tmp[0] + dx;
              points[1] = tmp[1] + dy;
              points[0] += _this.wcsobj.crpix[0];
              points[1] += _this.wcsobj.crpix[1];
              return points;
            };
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.atand(180 / (Math.PI * r));
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / (Math.PI * WCS.Math.tand(theta));
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'ZEA':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - 2 * WCS.Math.asind(Math.PI * r / 360);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 360 / Math.PI * WCS.Math.sind((90 - theta) / 2);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'ZPN':
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
        }
      }
      if (_ref4 = this.projection, __indexOf.call(cylindrical, _ref4) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        this.computeCelestialParameters(this.wcsobj.phi0, this.wcsobj.theta0);
        switch (this.projection) {
          case 'CYP':
            _ref5 = ["PV" + this.latitudeAxis + "_1,", "PV" + this.latitudeAxis + "_2"], key1 = _ref5[0], key2 = _ref5[1];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 1;
            this.wcsobj.lambda = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 1;
            if (this.wcsobj.mu + this.wcsobj.lambda === 0) {
              raise("Divide by zero error");
            }
            this.toSpherical = function(x, y) {
              var nu, phi, theta;
              nu = (Math.PI * y) / (180 * (_this.wcsobj.mu + _this.wcsobj.lambda));
              theta = WCS.Math.atan2d(nu, 1) + WCS.Math.asind(nu * _this.wcsobj.mu / Math.sqrt(nu * nu + 1));
              phi = x / _this.wcsobj.lambda;
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              x = _this.wcsobj.lambda * phi;
              y = (180 / Math.PI) * ((_this.wcsobj.mu + _this.wcsobj.lambda) / (_this.wcsobj.mu + WCS.Math.cosd(theta))) * WCS.Math.sind(theta);
              return [x, y];
            };
            break;
          case 'CEA':
            key = "PV" + this.latitudeAxis + "_1";
            this.wcsobj.lambda = header.hasOwnProperty(key) ? parseFloat(header[key]) : 1;
            this.toSpherical = function(x, y) {
              var theta;
              theta = WCS.Math.asind(Math.PI * _this.wcsobj.lambda * y / 180);
              return [x, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var y;
              y = 180 / Math.PI * WCS.Math.sind(theta) / _this.wcsobj.lambda;
              return [phi, y];
            };
            break;
          case 'CAR':
            this.toSpherical = function(x, y) {
              return [x, y];
            };
            this.fromSpherical = function(phi, theta) {
              return [phi, theta];
            };
            break;
          case 'MER':
            this.toSpherical = function(x, y) {
              var theta;
              theta = 2 * WCS.Math.atand(Math.exp(y * Math.PI / 180)) - 90;
              return [x, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var y;
              y = (180 / Math.PI) * Math.log(WCS.Math.tand((90 + theta) / 2));
              return [phi, y];
            };
            break;
          case 'SFL':
            this.toSpherical = function(x, y) {
              var phi;
              phi = x / WCS.Math.cosd(y);
              return [phi, y];
            };
            this.fromSpherical = function(phi, theta) {
              var x;
              x = phi * WCS.Math.cosd(theta);
              return [x, theta];
            };
            break;
          case 'PAR':
            this.toSpherical = function(x, y) {
              var phi, theta;
              theta = 3 * WCS.Math.asind(y / 180);
              phi = x / (1 - 4 * Math.pow(y / 180, 2));
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              x = phi * (2 * WCS.Math.cosd(2 * theta / 3) - 1);
              y = 180 * WCS.Math.sind(theta / 3);
              return [x, y];
            };
            break;
          case 'MOL':
            this.toSpherical = function(x, y) {
              var phi, theta;
              theta = WCS.Math.asind(WCS.Math.asind((Math.PI * y) / (180 * Math.sqrt(2))) / 90 + (y / 180) * Math.sqrt(2 - Math.pow(Math.PI * y / 180, 2)));
              phi = (Math.PI * x) / (2 * Math.sqrt(2 - Math.pow(Math.PI * y / 180, 2)));
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              throw 'Sorry, not yet implemented!';
              x = 2 * Math.sqrt(2) / Math.PI * phi * WCS.Math.cosd(gamma);
              y = Math.sqrt(2) * 180 / Math.PI * WCS.Math.sind(gamma);
              return [x, y];
            };
            break;
          case 'AIT':
            this.toSpherical = function(x, y) {
              var phi, theta, x_z, y_z, z;
              x_z = Math.pow((Math.PI * x) / (4 * 180), 2);
              y_z = Math.pow((Math.PI * y) / (2 * 180), 2);
              z = Math.sqrt(1 - x_z - y_z);
              theta = WCS.Math.asind(Math.PI * y * z / 180);
              phi = 2 * WCS.Math.atan2d(Math.PI * z * x / (2 * 180), 2 * z * z - 1);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var gamma, x, y;
              gamma = 180 / Math.PI * Math.sqrt(2 / (1 + WCS.Math.cosd(theta) * WCS.Math.cosd(phi / 2)));
              x = 2 * gamma * WCS.Math.cosd(theta) * WCS.Math.sind(phi / 2);
              y = gamma * WCS.Math.sind(theta);
              return [x, y];
            };
        }
      }
      if (_ref6 = this.projection, __indexOf.call(conic, _ref6) >= 0) {
        key = "PV" + this.latitudeAxis + "_1";
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = header.hasOwnProperty(key) ? header[key] : 0;
        throw 'Sorry, not yet implemented!';
      }
      if (_ref7 = this.projection, __indexOf.call(polyConic, _ref7) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        throw 'Sorry, not yet implemented!';
      }
      if (_ref8 = this.projection, __indexOf.call(quadCube, _ref8) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        throw 'Sorry, not yet implemented!';
      }
    };

    Mapper.prototype.getSipCoefficients = function(header) {
      var i, j, key, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if (!(header.hasOwnProperty('A_ORDER') || header.hasOwnProperty('B_ORDER'))) {
        throw "What's the polynomial order, man!";
      }
      this.sip = {};
      this.sip.aOrder = header.A_ORDER;
      this.sip.bOrder = header.B_ORDER;
      this.sip.apOrder = header.AP_ORDER || 0;
      this.sip.bpOrder = header.BP_ORDER || 0;
      this.sip.aCoeffs = [];
      this.sip.bCoeffs = [];
      this.sip.apCoeffs = [];
      this.sip.bpCoeffs = [];
      for (i = _i = 0, _ref = this.sip.aOrder; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.sip.aCoeffs[i] = [];
        for (j = _j = 0, _ref1 = this.sip.aOrder; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          key = "A_" + i + "_" + j;
          this.sip.aCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _k = 0, _ref2 = this.sip.bOrder; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        this.sip.bCoeffs[i] = [];
        for (j = _l = 0, _ref3 = this.sip.bOrder; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; j = 0 <= _ref3 ? ++_l : --_l) {
          key = "B_" + i + "_" + j;
          this.sip.bCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _m = 0, _ref4 = this.sip.apOrder; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
        this.sip.apCoeffs[i] = [];
        for (j = _n = 0, _ref5 = this.sip.apOrder; 0 <= _ref5 ? _n <= _ref5 : _n >= _ref5; j = 0 <= _ref5 ? ++_n : --_n) {
          key = "AP_" + i + "_" + j;
          this.sip.apCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _o = 0, _ref6 = this.sip.bpOrder; 0 <= _ref6 ? _o <= _ref6 : _o >= _ref6; i = 0 <= _ref6 ? ++_o : --_o) {
        this.sip.bpCoeffs[i] = [];
        for (j = _p = 0, _ref7 = this.sip.bpOrder; 0 <= _ref7 ? _p <= _ref7 : _p >= _ref7; j = 0 <= _ref7 ? ++_p : --_p) {
          key = "BP_" + i + "_" + j;
          this.sip.bpCoeffs[i][j] = header[key] || 0;
        }
      }
      if (!(this.sip.aCoeffs || this.sip.bCoeffs)) {
        throw "Where are the coefficients dude!";
      }
    };

    Mapper.prototype.computeCelestialParameters = function(phi0, theta0) {
      var alpha0, delta0, deltaP1, deltaP2, dist1, dist2, phiP, sol1, sol2, thetaP, _ref, _ref1;
      _ref = this.wcsobj.crval, alpha0 = _ref[0], delta0 = _ref[1];
      _ref1 = [this.wcsobj.lonpole, this.wcsobj.latpole], phiP = _ref1[0], thetaP = _ref1[1];
      deltaP1 = WCS.Math.atan2d(WCS.Math.sind(this.wcsobj.theta0), WCS.Math.cosd(this.wcsobj.theta0 * WCS.Math.cosd(phiP - this.wcsobj.phi0)));
      deltaP2 = WCS.Math.acosd(WCS.Math.sind(delta0) / Math.sqrt(1 - Math.pow(WCS.Math.cosd(this.wcsobj.theta0), 2) * Math.pow(WCS.Math.sind(phiP - this.wcsobj.phi0), 2)));
      sol1 = sol2 = false;
      if (deltaP1 + deltaP2 >= -90 && deltaP1 + deltaP2 <= 90) {
        sol1 = true;
      }
      if (deltaP1 - deltaP2 >= -90 && deltaP1 - deltaP2 <= 90) {
        sol2 = true;
      }
      if (sol1 && sol2) {
        dist1 = Math.abs(deltaP1 + deltaP2 - thetaP);
        dist2 = Math.abs(deltaP1 - deltaP2 - thetaP);
        this.wcsobj.deltaP = dist1 < dist2 ? deltaP1 + deltaP2 : deltaP1 - deltaP2;
      } else if (sol1) {
        this.wcsobj.deltaP = deltaP1 + deltaP2;
      } else if (sol2) {
        this.wcsobj.deltaP = deltaP1 - deltaP2;
      } else {
        this.wcsobj.deltaP = thetaP;
      }
      return this.wcsobj.alphaP = Math.abs(delta0) === 90 ? alpha0 : alpha0 - WCS.Math.asind(WCS.Math.sind(phiP - this.wcsobj.phi0) * WCS.Math.cosd(this.wcsobj.theta0) / WCS.Math.cosd(delta0));
    };

    Mapper.prototype.toIntermediate = function(points) {
      var i, j, proj, _i, _j, _ref, _ref1;
      proj = [];
      for (i = _i = 0, _ref = this.wcsobj.naxis - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        proj[i] = 0;
        points[i] -= this.wcsobj.crpix[i];
        for (j = _j = 0, _ref1 = this.wcsobj.naxis - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          proj[i] += this.wcsobj.cdelt[i] * this.wcsobj.pc[i][j] * points[j];
        }
      }
      return proj;
    };

    Mapper.prototype.fromIntermediate = function(proj) {
      var i, j, points, _i, _j, _ref, _ref1;
      points = [];
      for (i = _i = 0, _ref = this.wcsobj.naxis - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        points[i] = 0;
        for (j = _j = 0, _ref1 = this.wcsobj.naxis - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          points[i] += this.wcsobj.pcInv[i][j] * proj[j] / this.wcsobj.cdelt[i];
        }
        points[i] += this.wcsobj.crpix[i];
      }
      return points;
    };

    Mapper.prototype.toCelestial = function(phi, theta) {
      var cosDecP, cosDphi, cosTheta, dec, ra, sinDecP, sinDphi, sinTheta, xTemp, yTemp, zTemp;
      sinTheta = WCS.Math.sind(theta);
      cosTheta = WCS.Math.cosd(theta);
      sinDphi = WCS.Math.sind(phi - this.wcsobj.lonpole);
      cosDphi = WCS.Math.cosd(phi - this.wcsobj.lonpole);
      sinDecP = WCS.Math.sind(this.wcsobj.deltaP);
      cosDecP = WCS.Math.cosd(this.wcsobj.deltaP);
      xTemp = sinTheta * cosDecP - cosTheta * sinDecP * cosDphi;
      yTemp = -cosTheta * sinDphi;
      zTemp = sinTheta * sinDecP + cosTheta * cosDecP * cosDphi;
      ra = WCS.Math.atan2d(yTemp, xTemp) + this.wcsobj.alphaP;
      ra = (ra + 360) % 360;
      dec = WCS.Math.asind(zTemp);
      return [ra, dec];
    };

    Mapper.prototype.fromCelestial = function(ra, dec) {
      var cosDalpha, cosDelta, cosDp, phi, sinDalpha, sinDelta, sinDp, theta, xTemp, yTemp;
      sinDelta = WCS.Math.sind(dec);
      cosDelta = WCS.Math.cosd(dec);
      sinDp = WCS.Math.sind(this.wcsobj.deltaP);
      cosDp = WCS.Math.cosd(this.wcsobj.deltaP);
      sinDalpha = WCS.Math.sind(ra - this.wcsobj.alphaP);
      cosDalpha = WCS.Math.cosd(ra - this.wcsobj.alphaP);
      xTemp = sinDelta * cosDp - cosDelta * sinDp * cosDalpha;
      yTemp = -cosDelta * sinDalpha;
      phi = this.wcsobj.lonpole + WCS.Math.atan2d(yTemp, xTemp);
      theta = WCS.Math.asind(sinDelta * sinDp + cosDelta * cosDp * cosDalpha);
      return [phi, theta];
    };

    Mapper.prototype.pixelToCoordinate = function() {
      var coords;
      coords = this.toIntermediate(arguments[0], arguments[1]);
      coords = this.toSpherical(coords[0], coords[1]);
      coords = this.toCelestial(coords[0], coords[1]);
      return {
        ra: coords[this.longitudeAxis - 1],
        dec: coords[this.latitudeAxis - 1]
      };
    };

    Mapper.prototype.coordinateToPixel = function() {
      var coords;
      coords = this.fromCelestial(arguments[0], arguments[1]);
      coords = this.fromSpherical(coords[0], coords[1]);
      coords = this.fromIntermediate(coords);
      return {
        x: coords[0],
        y: coords[1]
      };
    };

    return Mapper;

  })();

}).call(this);

define("wcs", function(){});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Utils/Constants',[],function() {
    var Constants = function() {};

    /**
     * @namespace
     * API
     * @property {string} version - API version
     */
    Constants.API = {
        version: "[VERSION_API]"
    };

    /**
     * @namespace
     * LEVEL
     * @property {string} WARNING - Warning level
     * @property {string} ERROR - Error level
     * @property {string} DEBUG - Error level     
     */
    Constants.LEVEL = {
        WARNING: "warning",
        ERROR: "error",
        DEBUG: "debug"
    };

    /**
     * @namespace
     * ANIMATION
     * @property {string} Inertia - Inertia animation
     * @property {string} Interpolated - Interpolated animation
     * @property {string} Path - Path animation
     * @property {string} Segmented - Segmented animation
     */
    Constants.ANIMATION = {
        Inertia: "Inertia",
        Interpolated: "Interpolated",
        Path: "Path",
        Segmented: "Segmented"
    };

    /**
     * @namespace
     * CONTEXT
     * @property {string} Planet - Planet context
     * @property {string} Sky - Sky context
     * @property {string} Ground - Ground context
     */
    Constants.CONTEXT = {
        Planet: "Planet",
        Sky: "Sky",
        Ground: "Ground"
    };

    /**
     * @namespace
     * GLOBE
     * @property {string} Planet - Planet
     * @property {string} Sky - Sky
     */
    Constants.GLOBE = {
        Planet: "Planet",
        Sky: "Sky"
    };

    /**
     * @namespace
     * LAYER
     * @property {string} WMS - Web Map Service
     * @property {string} WMTS - Web Map Tile Service
     * @property {string} WMSElevation - Web Map Service for elevation
     * @property {string} WCSElevation - Web Map Coverage for elevation
     * @property {string} GeoJSON - GeoJSON
     * @property {string} Vector - Vector
     * @property {string} Atmosphere - Atmosphere
     * @property {string} Bing - Microsoft BING
     * @property {string} GroundOverlay - GroundOverlay
     * @property {string} OSM - Open Street Map
     * @property {string} TileWireframe - TileWireframe
     * @property {string} HipsGrid - HipsGrid
     * @property {string} CoordinateGrid - CoordinateGrid
     * @property {string} Hips - Hierarchical Progressive Survey for images
     * @property {string} HipsCat - Hierarchical Progressive Survey for catalogue
     * @property {string} HipsFits - Hierarchical Progressive Survey for FITS
     * @property {string} Moc - Multiple Order Coverage
     * @property {string} OpenSearch - Open Search
     */
    Constants.LAYER = {
        AsynchroneWMS: "AsynchroneWMS",
        WMS: "WMS",
        WMTS: "WMTS",
        WMSElevation: "WMSElevation",
        WCSElevation: "WCSElevation",
        GeoJSON: "GeoJSON",
        Vector: "Vector",
        Atmosphere: "Atmosphere",
        Bing: "Bing",
        GroundOverlay: "GroundOverlay",
        OSM: "OSM",
        TileWireframe: "TileWireframe",
        HipsGrid: "HipsGrid",
        CoordinateGrid: "CoordinateGrid",
        HipsFits: "HipsFits",
        Hips: "Hips",
        HipsCat: "HipsCat",
        Moc: "Moc",
        OpenSearch: "OpenSearch"
    };

    /**
     * @namespace
     * GEOMETRY
     * @property {string} Point - Point
     * @property {string} MultiPoint - MultiPoint
     * @property {string} LineString - LineString
     * @property {string} MultiLineString - MultiLineString
     * @property {string} Polygon - Polygon
     * @property {string} MultiPolygon - MultiPolygon
     * @property {string} GeometryCollection - GeometryCollection
     */
    Constants.GEOMETRY = {
        Point: "Point",
        MultiPoint: "MultiPoint",
        LineString: "LineString",
        MultiLineString: "MultiLineString",
        Polygon: "Polygon",
        MultiPolygon: "MultiPolygon",
        GeometryCollection: "GeometryCollection"
    };

    /**
     * @namespace
     * PROJECTION
     * @property {string} Aitoff - Aitoff projection
     * @property {string} August - August projection
     * @property {string} Mercator - Mercator projection
     * @property {string} Mollweide - Mollweide projection
     * @property {string} Plate - Plate Carre projection
     * @property {string} Azimuth - Azimuthal projection
     */
    Constants.PROJECTION = {
        Aitoff: "Aitoff",
        August: "August",
        Mercator: "Mercator",
        Mollweide: "Mollweide",
        Plate: "Plate Carre",
        Azimuth: "Azimuth"
    };

    /**
     * @namespace
     * CRS
     * @property {string} Equatorial - Equatorial coordinate reference system
     * @property {string} Galactic - Galactic coordinate reference system
     * @property {string} WGS84 - CRS:84 coordinate reference system
     * @property {string} Mars_2000 - IAU2000:49901 coordinate reference system
     * @property {string} Mars_2000_old - IAU2000:49900 coordinate reference system
     * @property {string} Moon_2000 - IAU2000:30101 coordinate reference system
     * @property {string} Moon_2000_old - IAU2000:30100 coordinate reference system
     * @property {string} HorizontalLocal - Local reference system based on horizontal coordinates
     * @property {string} Sun - Sun Coordinate reference system
     */
    Constants.CRS = {
        Equatorial: "Equatorial",
        Galactic: "Galactic",
        WGS84: "CRS:84",
        Mars_2000: "IAU2000:49901",
        Mars_2000_old: "IAU2000:49900",
        Moon_2000: "IAU2000:30101",
        Moon_2000_old: "IAU2000:30100",
        HorizontalLocal: "HorizontalLocal",
        Sun: "IAU:Sun"
    };

    /**
     * @namespace
     * CRS_TO_CONTEXT
     * @property {string} Equatorial - Sky context
     * @property {string} Galactic - Sky context
     * @property {string} WGS84 - Planet context
     * @property {string} Mars_2000 - Planet context
     * @property {string} Mars_2000_old - Planet context
     * @property {string} Moon_2000 - Planet context
     * @property {string} Moon_2000_old - Planet context
     * @property {string} HorizontalLocal - Ground context
     * @property {string} Sun - Sun Coordinate reference system
     */
    Constants.CRS_TO_CONTEXT = {
        Equatorial: "Sky",
        Galactic: "Sky",
        "CRS:84": "Planet",
        "IAU2000:49901": "Planet",
        "IAU2000:49900": "Planet",
        "IAU2000:30101": "Planet",
        "IAU2000:30100": "Planet",
        HorizontalLocal: "Ground",
        "IAU:Sun": "Planet"
    };

    /**
     * @namespace
     * NAVIGATION
     * @property {string} AstroNavigation - 3D Navigation for sky
     * @property {string} PlanetNavigation - 3D Navigation for planet
     * @property {string} FlatNavigation - 2D Navigation for planet
     * @property {string} GroundNavigation - 3D Navigation for ground visualization
     */
    Constants.NAVIGATION = {
        AstroNavigation: "AstroNavigation",
        PlanetNavigation: "PlanetNavigation",
        FlatNavigation: "FlatNavigation",
        GroundNavigation: "GroundNavigation"
    };

    /**
     * @namespace
     * SERVICE
     * @property {string} FitsVisu - FITS visualization
     * @property {string} Histogram - Histogram values from a FITS file
     * @property {string} ImageProcessing - Image processing
     * @property {string} MeasureToolSky - Tool to measure the distance between two points on the sky
     * @property {string} MeasureToolPlanet - Tool to measure the distance between two points on a planet
     * @property {string} MocBase - MOC service
     * @property {string} MollweideViewer - Mollweide Viewer
     * @property {string} PickingManager - Picking Manager
     * @property {string} Samp - Samp
     * @property {string} SelectionTool - Selection Tool
     * @property {string} NameResolver - NameResolver
     * @property {string} ReverseNameResolver - ReverseNameResolver
     * @property {string} ExportTool - ExportTool
     */
    Constants.SERVICE = {
        FitsHips: "FitsHips",
        FitsVisu: "FitsVisu",
        Histogram: "Histogram",
        ImageProcessing: "ImageProcessing",
        MeasureToolSky: "MeasureToolSky",
        MeasureToolPlanet: "MeasureToolPlanet",
        MocBase: "MocBase",
        MollweideViewer: "MollweideViewer",
        PickingManager: "PickingManager",
        Samp: "Samp",
        SelectionTool: "SelectionTool",
        NameResolver: "NameResolver",
        ReverseNameResolver: "ReverseNameResolver",
        ExportTool: "ExportTool",
        TimeTravel: "TimeTravel"
    };

    /**
     * @namespace
     * HANDLER
     * @property {string} Touch - Touch device
     * @property {string} Keyboard - Keyboard device
     * @property {string} Mouse - Mouse device
     * @property {string} GoogleMouse - GoogleMouse device
     */
    Constants.HANDLER = {
        Touch: "Touch",
        Keyboard: "Keyboard",
        Mouse: "Mouse",
        GoogleMouse: "GoogleMouse"
    };

    /**
     * @namespace
     * PROVIDER
     * @property {string} Constellation - Constellation
     * @property {string} Json - Json
     * @property {string} Planet - Planet
     * @property {string} Star - Star
     * @property {string} Trajectory - Trajectory
     */
    Constants.PROVIDER = {
        Constellation: "Constellation",
        Planet: "Planet",
        Star: "Star",
        Crater: "Crater",
        Trajectory: "Trajectory"
    };

    /**
     * @namespace
     * MappingCrsHips2Mizar
     * @property {string} equatorial - Equatorial
     * @property {string} galactic - Galactic
     * @property {string} ecliptic - Ecliptic
     * @property {string} horizontalLocal - Equatorial
     */
    Constants.MappingCrsHips2Mizar = {
        equatorial: "Equatorial",
        galactic: "Galactic",
        ecliptic: "Ecliptic",
        "mars-panstimson": "Equatorial",
        horizontalLocal: "Equatorial"
    };

    /**
     * @namespace
     * UTILITY
     * @property {string} Fits - Fits utility
     * @property {string} Intersection - Intersection utility
     * @property {string} CreateStyle - CreateStyle utility
     * @property {string} FeatureStyle - FeatureStyle utility
     */
    Constants.UTILITY = {
        Fits: "Fits",
        Intersection: "Intersection",
        Numeric: "Numeric",
        CreateStyle: "CreateStyle",
        FeatureStyle: "FeatureStyle"
    };

    /**
     * @namespace
     * ANIMATION_STATUS
     * @property {string} STOPPED - animation is stopped
     * @property {string} RUNNING - animation is running
     * @property {string} PAUSED - animation is paused
     */
    Constants.ANIMATION_STATUS = {
        STOPPED: "STOPPED",
        RUNNING: "RUNNING",
        PAUSED: "PAUSED"
    };

    /**
     * @namespace
     * EVENT_MSG
     * @property {string} PLUGIN_NOT_FOUND - Plugin not found
     * @property {string} MIZAR_MODE_TOGGLE - Mizar mode, one value among {Constants.CONTEXT}
     * @property {string} LAYER_BACKGROUND_ADDED - Background Layer added
     * @property {string} LAYER_BACKGROUND_CHANGED - Background Layer changed
     * @property {string} LAYER_ADDED - Layer added
     * @property {string} LAYER_REMOVED - Layer removed
     * @property {string} LAYER_VISIBILITY_CHANGED - Visibility Layer changed
     * @property {string} LAYER_OPACITY_CHANGED - Opacity Layer changed
     * @property {string} LAYER_START_LOAD - Overlay rasters or vectors start to load
     * @property {string} LAYER_END_LOAD - Overlay rasters  or vectors finish to load
     * @property {string} LAYER_START_BACKGROUND_LOAD - Background rasters start to load
     * @property {string} LAYER_END_BACKGROUND_LOAD - Background rasters finish to load
     * @property {string} BASE_LAYERS_ERROR - Error at the initialisation of layer to render
     * @property {string} BASE_LAYERS_READY - Initialisation of the rendering is fine
     * @property {string} CRS_MODIFIED - Coordinate reference system is modified
     * @property {string} NAVIGATION_STARTED - Navigation started
     * @property {string} NAVIGATION_ENDED - Navigation ended
     * @property {string} NAVIGATION_MODIFIED - Navigation modified
     * @property {string} NAVIGATION_CHANGED_DISTANCE - Distance of the camera from the planet has changed
     * @property {string} IMAGE_DOWNLOADED - Image downloaded
     * @property {string} IMAGE_REMOVED - Image removed
     * @property {string} IMAGE_ADDED - Image added
     * @property {string} FEATURED_ADDED - Feature added
     * @property {string} GLOBAL_TIME_REWIND - global time is rewinded
     * @property {string} GLOBAL_TIME_FORWARD - global time is forwarded
     * @property {string} GLOBAL_TIME_SET - global time is set
     * @property {string} GLOBAL_TIME_CHANGED - global time has changed

     */
    Constants.EVENT_MSG = {
        PLUGIN_NOT_FOUND: "plugin:not_found",
        MIZAR_MODE_TOGGLE: "mizarMode:toggle",
        LAYER_BACKGROUND_ERROR: "backgroundLayer:error",
        LAYER_BACKGROUND_ADDED: "backgroundLayer:added",
        LAYER_BACKGROUND_CHANGED: "backgroundLayer:changed",
        LAYER_ADDED: "layer:added",
        LAYER_REMOVED: "layer:removed",
        LAYER_VISIBILITY_CHANGED: "visibility:changed",
        LAYER_OPACITY_CHANGED: "opacity:changed",
        LAYER_START_LOAD: "startLoad",
        LAYER_END_LOAD: "endLoad",
        LAYER_START_BACKGROUND_LOAD: "startBackgroundLoad",
        LAYER_END_BACKGROUND_LOAD: "endBackgroundLoad",
        LAYER_UPDATE_STATS_ATTRIBUTES: "updateStatsAttribute",
        LAYER_TOGGLE_WMS: "toggleWMS",
        BASE_LAYERS_ERROR: "baseLayersError",
        BASE_LAYERS_READY: "baseLayersReady",
        CRS_MODIFIED: "modifiedCrs",
        NAVIGATION_STARTED: "startNavigation",
        NAVIGATION_ENDED: "endNavigation",
        NAVIGATION_MODIFIED: "modifiedNavigation",
        NAVIGATION_CHANGED_DISTANCE: "navigation:changedDistance",
        IMAGE_DOWNLOADED: "image:downloaded",
        IMAGE_REMOVED: "image:removed",
        IMAGE_ADDED: "image:added",
        FEATURED_ADDED: "features:added",
        GLOBAL_TIME_REWIND: "globalTime:rewind",
        GLOBAL_TIME_FORWARD: "globalTime:forward",
        GLOBAL_TIME_SET: "globalTime:set",
        GLOBAL_TIME_CHANGED: "globalTime:changed" // temporary, need to be link to LAYERS_TIME_CHANGED after dev
    };

    /**
     * @namespace
     * DISPLAY_ORDER
     * @property {string} RENDERING - Special rendering index
     * @property {string} DEFAULT_RASTER - Default layer index (specially images)
     * @property {string} SELECTED_RASTER - Selected layer index (specially images)
     * @property {string} DEFAULT_VECTOR - Default vector index
     * @property {string} SELECTED_VECTOR - Selected vector index
     * @property {string} HIGHLIGHTED_VECTOR - Highlighted vector index     
     * @property {string} SERVICE_VECTOR - Service index
     */
    Constants.DISPLAY = {
        RENDERING: -1,
        DEFAULT_RASTER: 0,
        SELECTED_RASTER: 10,
        DEFAULT_VECTOR: 20,
        SELECTED_VECTOR: 30,
        HIGHLIGHTED_VECTOR: 31,
        SERVICE_VECTOR: 40
    };

    /**
     * @namespace
     * INFORMATION_TYPE
     * @property {string} ATMOSPHERE - atmosphere data
     * @property {string} RASTER - raster data
     * @property {string} VECTOR - vector data
     */
    Constants.INFORMATION_TYPE = {
        ATMOSPHERE: "ATMOSPHERE",
        RASTER: "RASTER",
        VECTOR: "VECTOR"
    };

    /**
     * @namespace
     * TIME_STEP
     * @property {string} YEAR - years
     * @property {string} QUARTER - quarters
     * @property {string} MONTH - months
     * @property {string} WEEK - weeks
     * @property {string} DAY - days
     * @property {string} HOUR - hours
     * @property {string} MINUTE - minutes
     * @property {string} SECOND - seconds
     * @property {string} MILLISECOND - milliseconds
     * @property {string} ENUMERATED - null
     */
    Constants.TIME_STEP = {
        YEAR: "years",
        QUARTER: "quarters",
        MONTH: "months",
        WEEK: "weeks",
        DAY: "days",
        HOUR: "hours",
        MINUTE: "minutes",
        SECOND: "seconds",
        MILLISECOND: "milliseconds",
        ENUMERATED: null
    };

    /**
     * @namespace
     * TIME_MOMENT_STEP
     * @property {string} YEAR - year
     * @property {string} MONTH - month
     * @property {string} DAY - day
     * @property {string} HOUR - hour
     * @property {string} MINUTE - minute
     * @property {string} SECOND - second
     */

    Constants.TIME_MOMENT_STEP = {
        YEAR: "year",
        MONTH: "month",
        DAY: "day",
        HOUR: "hour",
        MINUTE: "minute",
        SECOND: "second"
    };

    /**
     * @namespace
     * UNIT_TIME_WMS
     * @property {string} YEAR - Y
     * @property {string} MONTH - M
     * @property {string} DAY - D
     * @property {string} HOUR - H
     * @property {string} MINUTE - M
     * @property {string} SECOND - S
     */

    Constants.UNIT_TIME_WMS = {
        YEAR: "Y",
        MONTH: "M",
        DAY: "D",
        HOUR: "H",
        MINUTE: "M",
        SECONDE: "S"
    };

    /**
     * @namespace
     * UNIT_RESOLUTION_WMS
     * @property {string} TIME - PT
     * @property {string} NOT_TIME - P
     */

    Constants.UNIT_RESOLUTION_WMS = {
        TIME: "PT",
        NOT_TIME: "P"
    };

    /**
     * @namespace
     * TIME
     * @property {string} DEFAULT_FORMAT - Do MMM Y HH:mm
     */

    Constants.TIME = {
        DEFAULT_FORMAT: "Do MMM Y HH:mm"
    };

    /**
     * @namespace
     * TILE
     * @property {string} GEO_TILE - GeoTile
     * @property {string} MERCATOR_TILE - MercatorTile
     * @property {string} HEALPIX_TILE - HealpixTile          
     */    
    Constants.TILE = {
        GEO_TILE: "GeoTile",
        MERCATOR_TILE: "MercatorTile",
        HEALPIX_TILE: "HealpixTile"
    };

    /**************************************************************************************************************/

    return Constants;
});

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define('moment',t):e.moment=t()}(this,function(){"use strict";var e,i;function c(){return e.apply(null,arguments)}function o(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function u(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function l(e){return void 0===e}function d(e){return"number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function h(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function f(e,t){var n,s=[];for(n=0;n<e.length;++n)s.push(t(e[n],n));return s}function m(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function _(e,t){for(var n in t)m(t,n)&&(e[n]=t[n]);return m(t,"toString")&&(e.toString=t.toString),m(t,"valueOf")&&(e.valueOf=t.valueOf),e}function y(e,t,n,s){return Ot(e,t,n,s,!0).utc()}function g(e){return null==e._pf&&(e._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),e._pf}function p(e){if(null==e._isValid){var t=g(e),n=i.call(t.parsedDateParts,function(e){return null!=e}),s=!isNaN(e._d.getTime())&&t.overflow<0&&!t.empty&&!t.invalidMonth&&!t.invalidWeekday&&!t.weekdayMismatch&&!t.nullInput&&!t.invalidFormat&&!t.userInvalidated&&(!t.meridiem||t.meridiem&&n);if(e._strict&&(s=s&&0===t.charsLeftOver&&0===t.unusedTokens.length&&void 0===t.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return s;e._isValid=s}return e._isValid}function v(e){var t=y(NaN);return null!=e?_(g(t),e):g(t).userInvalidated=!0,t}i=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,s=0;s<n;s++)if(s in t&&e.call(this,t[s],s,t))return!0;return!1};var r=c.momentProperties=[];function w(e,t){var n,s,i;if(l(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),l(t._i)||(e._i=t._i),l(t._f)||(e._f=t._f),l(t._l)||(e._l=t._l),l(t._strict)||(e._strict=t._strict),l(t._tzm)||(e._tzm=t._tzm),l(t._isUTC)||(e._isUTC=t._isUTC),l(t._offset)||(e._offset=t._offset),l(t._pf)||(e._pf=g(t)),l(t._locale)||(e._locale=t._locale),0<r.length)for(n=0;n<r.length;n++)l(i=t[s=r[n]])||(e[s]=i);return e}var t=!1;function M(e){w(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===t&&(t=!0,c.updateOffset(this),t=!1)}function S(e){return e instanceof M||null!=e&&null!=e._isAMomentObject}function D(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function k(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=D(t)),n}function a(e,t,n){var s,i=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),a=0;for(s=0;s<i;s++)(n&&e[s]!==t[s]||!n&&k(e[s])!==k(t[s]))&&a++;return a+r}function Y(e){!1===c.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e)}function n(i,r){var a=!0;return _(function(){if(null!=c.deprecationHandler&&c.deprecationHandler(null,i),a){for(var e,t=[],n=0;n<arguments.length;n++){if(e="","object"==typeof arguments[n]){for(var s in e+="\n["+n+"] ",arguments[0])e+=s+": "+arguments[0][s]+", ";e=e.slice(0,-2)}else e=arguments[n];t.push(e)}Y(i+"\nArguments: "+Array.prototype.slice.call(t).join("")+"\n"+(new Error).stack),a=!1}return r.apply(this,arguments)},r)}var s,O={};function T(e,t){null!=c.deprecationHandler&&c.deprecationHandler(e,t),O[e]||(Y(t),O[e]=!0)}function x(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function b(e,t){var n,s=_({},e);for(n in t)m(t,n)&&(u(e[n])&&u(t[n])?(s[n]={},_(s[n],e[n]),_(s[n],t[n])):null!=t[n]?s[n]=t[n]:delete s[n]);for(n in e)m(e,n)&&!m(t,n)&&u(e[n])&&(s[n]=_({},s[n]));return s}function P(e){null!=e&&this.set(e)}c.suppressDeprecationWarnings=!1,c.deprecationHandler=null,s=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)m(e,t)&&n.push(t);return n};var W={};function H(e,t){var n=e.toLowerCase();W[n]=W[n+"s"]=W[t]=e}function R(e){return"string"==typeof e?W[e]||W[e.toLowerCase()]:void 0}function C(e){var t,n,s={};for(n in e)m(e,n)&&(t=R(n))&&(s[t]=e[n]);return s}var F={};function L(e,t){F[e]=t}function U(e,t,n){var s=""+Math.abs(e),i=t-s.length;return(0<=e?n?"+":"":"-")+Math.pow(10,Math.max(0,i)).toString().substr(1)+s}var N=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,G=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,V={},E={};function I(e,t,n,s){var i=s;"string"==typeof s&&(i=function(){return this[s]()}),e&&(E[e]=i),t&&(E[t[0]]=function(){return U(i.apply(this,arguments),t[1],t[2])}),n&&(E[n]=function(){return this.localeData().ordinal(i.apply(this,arguments),e)})}function A(e,t){return e.isValid()?(t=j(t,e.localeData()),V[t]=V[t]||function(s){var e,i,t,r=s.match(N);for(e=0,i=r.length;e<i;e++)E[r[e]]?r[e]=E[r[e]]:r[e]=(t=r[e]).match(/\[[\s\S]/)?t.replace(/^\[|\]$/g,""):t.replace(/\\/g,"");return function(e){var t,n="";for(t=0;t<i;t++)n+=x(r[t])?r[t].call(e,s):r[t];return n}}(t),V[t](e)):e.localeData().invalidDate()}function j(e,t){var n=5;function s(e){return t.longDateFormat(e)||e}for(G.lastIndex=0;0<=n&&G.test(e);)e=e.replace(G,s),G.lastIndex=0,n-=1;return e}var Z=/\d/,z=/\d\d/,$=/\d{3}/,q=/\d{4}/,J=/[+-]?\d{6}/,B=/\d\d?/,Q=/\d\d\d\d?/,X=/\d\d\d\d\d\d?/,K=/\d{1,3}/,ee=/\d{1,4}/,te=/[+-]?\d{1,6}/,ne=/\d+/,se=/[+-]?\d+/,ie=/Z|[+-]\d\d:?\d\d/gi,re=/Z|[+-]\d\d(?::?\d\d)?/gi,ae=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,oe={};function ue(e,n,s){oe[e]=x(n)?n:function(e,t){return e&&s?s:n}}function le(e,t){return m(oe,e)?oe[e](t._strict,t._locale):new RegExp(de(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,s,i){return t||n||s||i})))}function de(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var he={};function ce(e,n){var t,s=n;for("string"==typeof e&&(e=[e]),d(n)&&(s=function(e,t){t[n]=k(e)}),t=0;t<e.length;t++)he[e[t]]=s}function fe(e,i){ce(e,function(e,t,n,s){n._w=n._w||{},i(e,n._w,n,s)})}var me=0,_e=1,ye=2,ge=3,pe=4,ve=5,we=6,Me=7,Se=8;function De(e){return ke(e)?366:365}function ke(e){return e%4==0&&e%100!=0||e%400==0}I("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),I(0,["YY",2],0,function(){return this.year()%100}),I(0,["YYYY",4],0,"year"),I(0,["YYYYY",5],0,"year"),I(0,["YYYYYY",6,!0],0,"year"),H("year","y"),L("year",1),ue("Y",se),ue("YY",B,z),ue("YYYY",ee,q),ue("YYYYY",te,J),ue("YYYYYY",te,J),ce(["YYYYY","YYYYYY"],me),ce("YYYY",function(e,t){t[me]=2===e.length?c.parseTwoDigitYear(e):k(e)}),ce("YY",function(e,t){t[me]=c.parseTwoDigitYear(e)}),ce("Y",function(e,t){t[me]=parseInt(e,10)}),c.parseTwoDigitYear=function(e){return k(e)+(68<k(e)?1900:2e3)};var Ye,Oe=Te("FullYear",!0);function Te(t,n){return function(e){return null!=e?(be(this,t,e),c.updateOffset(this,n),this):xe(this,t)}}function xe(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function be(e,t,n){e.isValid()&&!isNaN(n)&&("FullYear"===t&&ke(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+t](n,e.month(),Pe(n,e.month())):e._d["set"+(e._isUTC?"UTC":"")+t](n))}function Pe(e,t){if(isNaN(e)||isNaN(t))return NaN;var n,s=(t%(n=12)+n)%n;return e+=(t-s)/12,1===s?ke(e)?29:28:31-s%7%2}Ye=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;t<this.length;++t)if(this[t]===e)return t;return-1},I("M",["MM",2],"Mo",function(){return this.month()+1}),I("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),I("MMMM",0,0,function(e){return this.localeData().months(this,e)}),H("month","M"),L("month",8),ue("M",B),ue("MM",B,z),ue("MMM",function(e,t){return t.monthsShortRegex(e)}),ue("MMMM",function(e,t){return t.monthsRegex(e)}),ce(["M","MM"],function(e,t){t[_e]=k(e)-1}),ce(["MMM","MMMM"],function(e,t,n,s){var i=n._locale.monthsParse(e,s,n._strict);null!=i?t[_e]=i:g(n).invalidMonth=e});var We=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,He="January_February_March_April_May_June_July_August_September_October_November_December".split("_");var Re="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function Ce(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=k(t);else if(!d(t=e.localeData().monthsParse(t)))return e;return n=Math.min(e.date(),Pe(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function Fe(e){return null!=e?(Ce(this,e),c.updateOffset(this,!0),this):xe(this,"Month")}var Le=ae;var Ue=ae;function Ne(){function e(e,t){return t.length-e.length}var t,n,s=[],i=[],r=[];for(t=0;t<12;t++)n=y([2e3,t]),s.push(this.monthsShort(n,"")),i.push(this.months(n,"")),r.push(this.months(n,"")),r.push(this.monthsShort(n,""));for(s.sort(e),i.sort(e),r.sort(e),t=0;t<12;t++)s[t]=de(s[t]),i[t]=de(i[t]);for(t=0;t<24;t++)r[t]=de(r[t]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+s.join("|")+")","i")}function Ge(e){var t=new Date(Date.UTC.apply(null,arguments));return e<100&&0<=e&&isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e),t}function Ve(e,t,n){var s=7+t-n;return-((7+Ge(e,0,s).getUTCDay()-t)%7)+s-1}function Ee(e,t,n,s,i){var r,a,o=1+7*(t-1)+(7+n-s)%7+Ve(e,s,i);return o<=0?a=De(r=e-1)+o:o>De(e)?(r=e+1,a=o-De(e)):(r=e,a=o),{year:r,dayOfYear:a}}function Ie(e,t,n){var s,i,r=Ve(e.year(),t,n),a=Math.floor((e.dayOfYear()-r-1)/7)+1;return a<1?s=a+Ae(i=e.year()-1,t,n):a>Ae(e.year(),t,n)?(s=a-Ae(e.year(),t,n),i=e.year()+1):(i=e.year(),s=a),{week:s,year:i}}function Ae(e,t,n){var s=Ve(e,t,n),i=Ve(e+1,t,n);return(De(e)-s+i)/7}I("w",["ww",2],"wo","week"),I("W",["WW",2],"Wo","isoWeek"),H("week","w"),H("isoWeek","W"),L("week",5),L("isoWeek",5),ue("w",B),ue("ww",B,z),ue("W",B),ue("WW",B,z),fe(["w","ww","W","WW"],function(e,t,n,s){t[s.substr(0,1)]=k(e)});I("d",0,"do","day"),I("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),I("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),I("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),I("e",0,0,"weekday"),I("E",0,0,"isoWeekday"),H("day","d"),H("weekday","e"),H("isoWeekday","E"),L("day",11),L("weekday",11),L("isoWeekday",11),ue("d",B),ue("e",B),ue("E",B),ue("dd",function(e,t){return t.weekdaysMinRegex(e)}),ue("ddd",function(e,t){return t.weekdaysShortRegex(e)}),ue("dddd",function(e,t){return t.weekdaysRegex(e)}),fe(["dd","ddd","dddd"],function(e,t,n,s){var i=n._locale.weekdaysParse(e,s,n._strict);null!=i?t.d=i:g(n).invalidWeekday=e}),fe(["d","e","E"],function(e,t,n,s){t[s]=k(e)});var je="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");var Ze="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");var ze="Su_Mo_Tu_We_Th_Fr_Sa".split("_");var $e=ae;var qe=ae;var Je=ae;function Be(){function e(e,t){return t.length-e.length}var t,n,s,i,r,a=[],o=[],u=[],l=[];for(t=0;t<7;t++)n=y([2e3,1]).day(t),s=this.weekdaysMin(n,""),i=this.weekdaysShort(n,""),r=this.weekdays(n,""),a.push(s),o.push(i),u.push(r),l.push(s),l.push(i),l.push(r);for(a.sort(e),o.sort(e),u.sort(e),l.sort(e),t=0;t<7;t++)o[t]=de(o[t]),u[t]=de(u[t]),l[t]=de(l[t]);this._weekdaysRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+o.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+a.join("|")+")","i")}function Qe(){return this.hours()%12||12}function Xe(e,t){I(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)})}function Ke(e,t){return t._meridiemParse}I("H",["HH",2],0,"hour"),I("h",["hh",2],0,Qe),I("k",["kk",2],0,function(){return this.hours()||24}),I("hmm",0,0,function(){return""+Qe.apply(this)+U(this.minutes(),2)}),I("hmmss",0,0,function(){return""+Qe.apply(this)+U(this.minutes(),2)+U(this.seconds(),2)}),I("Hmm",0,0,function(){return""+this.hours()+U(this.minutes(),2)}),I("Hmmss",0,0,function(){return""+this.hours()+U(this.minutes(),2)+U(this.seconds(),2)}),Xe("a",!0),Xe("A",!1),H("hour","h"),L("hour",13),ue("a",Ke),ue("A",Ke),ue("H",B),ue("h",B),ue("k",B),ue("HH",B,z),ue("hh",B,z),ue("kk",B,z),ue("hmm",Q),ue("hmmss",X),ue("Hmm",Q),ue("Hmmss",X),ce(["H","HH"],ge),ce(["k","kk"],function(e,t,n){var s=k(e);t[ge]=24===s?0:s}),ce(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e}),ce(["h","hh"],function(e,t,n){t[ge]=k(e),g(n).bigHour=!0}),ce("hmm",function(e,t,n){var s=e.length-2;t[ge]=k(e.substr(0,s)),t[pe]=k(e.substr(s)),g(n).bigHour=!0}),ce("hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=k(e.substr(0,s)),t[pe]=k(e.substr(s,2)),t[ve]=k(e.substr(i)),g(n).bigHour=!0}),ce("Hmm",function(e,t,n){var s=e.length-2;t[ge]=k(e.substr(0,s)),t[pe]=k(e.substr(s))}),ce("Hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=k(e.substr(0,s)),t[pe]=k(e.substr(s,2)),t[ve]=k(e.substr(i))});var et,tt=Te("Hours",!0),nt={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:He,monthsShort:Re,week:{dow:0,doy:6},weekdays:je,weekdaysMin:ze,weekdaysShort:Ze,meridiemParse:/[ap]\.?m?\.?/i},st={},it={};function rt(e){return e?e.toLowerCase().replace("_","-"):e}function at(e){var t=null;if(!st[e]&&"undefined"!=typeof module&&module&&module.exports)try{t=et._abbr,require("./locale/"+e),ot(t)}catch(e){}return st[e]}function ot(e,t){var n;return e&&((n=l(t)?lt(e):ut(e,t))?et=n:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+e+" not found. Did you forget to load it?")),et._abbr}function ut(e,t){if(null!==t){var n,s=nt;if(t.abbr=e,null!=st[e])T("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),s=st[e]._config;else if(null!=t.parentLocale)if(null!=st[t.parentLocale])s=st[t.parentLocale]._config;else{if(null==(n=at(t.parentLocale)))return it[t.parentLocale]||(it[t.parentLocale]=[]),it[t.parentLocale].push({name:e,config:t}),null;s=n._config}return st[e]=new P(b(s,t)),it[e]&&it[e].forEach(function(e){ut(e.name,e.config)}),ot(e),st[e]}return delete st[e],null}function lt(e){var t;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return et;if(!o(e)){if(t=at(e))return t;e=[e]}return function(e){for(var t,n,s,i,r=0;r<e.length;){for(t=(i=rt(e[r]).split("-")).length,n=(n=rt(e[r+1]))?n.split("-"):null;0<t;){if(s=at(i.slice(0,t).join("-")))return s;if(n&&n.length>=t&&a(i,n,!0)>=t-1)break;t--}r++}return et}(e)}function dt(e){var t,n=e._a;return n&&-2===g(e).overflow&&(t=n[_e]<0||11<n[_e]?_e:n[ye]<1||n[ye]>Pe(n[me],n[_e])?ye:n[ge]<0||24<n[ge]||24===n[ge]&&(0!==n[pe]||0!==n[ve]||0!==n[we])?ge:n[pe]<0||59<n[pe]?pe:n[ve]<0||59<n[ve]?ve:n[we]<0||999<n[we]?we:-1,g(e)._overflowDayOfYear&&(t<me||ye<t)&&(t=ye),g(e)._overflowWeeks&&-1===t&&(t=Me),g(e)._overflowWeekday&&-1===t&&(t=Se),g(e).overflow=t),e}function ht(e,t,n){return null!=e?e:null!=t?t:n}function ct(e){var t,n,s,i,r,a=[];if(!e._d){var o,u;for(o=e,u=new Date(c.now()),s=o._useUTC?[u.getUTCFullYear(),u.getUTCMonth(),u.getUTCDate()]:[u.getFullYear(),u.getMonth(),u.getDate()],e._w&&null==e._a[ye]&&null==e._a[_e]&&function(e){var t,n,s,i,r,a,o,u;if(null!=(t=e._w).GG||null!=t.W||null!=t.E)r=1,a=4,n=ht(t.GG,e._a[me],Ie(Tt(),1,4).year),s=ht(t.W,1),((i=ht(t.E,1))<1||7<i)&&(u=!0);else{r=e._locale._week.dow,a=e._locale._week.doy;var l=Ie(Tt(),r,a);n=ht(t.gg,e._a[me],l.year),s=ht(t.w,l.week),null!=t.d?((i=t.d)<0||6<i)&&(u=!0):null!=t.e?(i=t.e+r,(t.e<0||6<t.e)&&(u=!0)):i=r}s<1||s>Ae(n,r,a)?g(e)._overflowWeeks=!0:null!=u?g(e)._overflowWeekday=!0:(o=Ee(n,s,i,r,a),e._a[me]=o.year,e._dayOfYear=o.dayOfYear)}(e),null!=e._dayOfYear&&(r=ht(e._a[me],s[me]),(e._dayOfYear>De(r)||0===e._dayOfYear)&&(g(e)._overflowDayOfYear=!0),n=Ge(r,0,e._dayOfYear),e._a[_e]=n.getUTCMonth(),e._a[ye]=n.getUTCDate()),t=0;t<3&&null==e._a[t];++t)e._a[t]=a[t]=s[t];for(;t<7;t++)e._a[t]=a[t]=null==e._a[t]?2===t?1:0:e._a[t];24===e._a[ge]&&0===e._a[pe]&&0===e._a[ve]&&0===e._a[we]&&(e._nextDay=!0,e._a[ge]=0),e._d=(e._useUTC?Ge:function(e,t,n,s,i,r,a){var o=new Date(e,t,n,s,i,r,a);return e<100&&0<=e&&isFinite(o.getFullYear())&&o.setFullYear(e),o}).apply(null,a),i=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[ge]=24),e._w&&void 0!==e._w.d&&e._w.d!==i&&(g(e).weekdayMismatch=!0)}}var ft=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,mt=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,_t=/Z|[+-]\d\d(?::?\d\d)?/,yt=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],gt=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],pt=/^\/?Date\((\-?\d+)/i;function vt(e){var t,n,s,i,r,a,o=e._i,u=ft.exec(o)||mt.exec(o);if(u){for(g(e).iso=!0,t=0,n=yt.length;t<n;t++)if(yt[t][1].exec(u[1])){i=yt[t][0],s=!1!==yt[t][2];break}if(null==i)return void(e._isValid=!1);if(u[3]){for(t=0,n=gt.length;t<n;t++)if(gt[t][1].exec(u[3])){r=(u[2]||" ")+gt[t][0];break}if(null==r)return void(e._isValid=!1)}if(!s&&null!=r)return void(e._isValid=!1);if(u[4]){if(!_t.exec(u[4]))return void(e._isValid=!1);a="Z"}e._f=i+(r||"")+(a||""),kt(e)}else e._isValid=!1}var wt=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function Mt(e,t,n,s,i,r){var a=[function(e){var t=parseInt(e,10);{if(t<=49)return 2e3+t;if(t<=999)return 1900+t}return t}(e),Re.indexOf(t),parseInt(n,10),parseInt(s,10),parseInt(i,10)];return r&&a.push(parseInt(r,10)),a}var St={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Dt(e){var t,n,s,i=wt.exec(e._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,""));if(i){var r=Mt(i[4],i[3],i[2],i[5],i[6],i[7]);if(t=i[1],n=r,s=e,t&&Ze.indexOf(t)!==new Date(n[0],n[1],n[2]).getDay()&&(g(s).weekdayMismatch=!0,!(s._isValid=!1)))return;e._a=r,e._tzm=function(e,t,n){if(e)return St[e];if(t)return 0;var s=parseInt(n,10),i=s%100;return(s-i)/100*60+i}(i[8],i[9],i[10]),e._d=Ge.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),g(e).rfc2822=!0}else e._isValid=!1}function kt(e){if(e._f!==c.ISO_8601)if(e._f!==c.RFC_2822){e._a=[],g(e).empty=!0;var t,n,s,i,r,a,o,u,l=""+e._i,d=l.length,h=0;for(s=j(e._f,e._locale).match(N)||[],t=0;t<s.length;t++)i=s[t],(n=(l.match(le(i,e))||[])[0])&&(0<(r=l.substr(0,l.indexOf(n))).length&&g(e).unusedInput.push(r),l=l.slice(l.indexOf(n)+n.length),h+=n.length),E[i]?(n?g(e).empty=!1:g(e).unusedTokens.push(i),a=i,u=e,null!=(o=n)&&m(he,a)&&he[a](o,u._a,u,a)):e._strict&&!n&&g(e).unusedTokens.push(i);g(e).charsLeftOver=d-h,0<l.length&&g(e).unusedInput.push(l),e._a[ge]<=12&&!0===g(e).bigHour&&0<e._a[ge]&&(g(e).bigHour=void 0),g(e).parsedDateParts=e._a.slice(0),g(e).meridiem=e._meridiem,e._a[ge]=function(e,t,n){var s;if(null==n)return t;return null!=e.meridiemHour?e.meridiemHour(t,n):(null!=e.isPM&&((s=e.isPM(n))&&t<12&&(t+=12),s||12!==t||(t=0)),t)}(e._locale,e._a[ge],e._meridiem),ct(e),dt(e)}else Dt(e);else vt(e)}function Yt(e){var t,n,s,i,r=e._i,a=e._f;return e._locale=e._locale||lt(e._l),null===r||void 0===a&&""===r?v({nullInput:!0}):("string"==typeof r&&(e._i=r=e._locale.preparse(r)),S(r)?new M(dt(r)):(h(r)?e._d=r:o(a)?function(e){var t,n,s,i,r;if(0===e._f.length)return g(e).invalidFormat=!0,e._d=new Date(NaN);for(i=0;i<e._f.length;i++)r=0,t=w({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[i],kt(t),p(t)&&(r+=g(t).charsLeftOver,r+=10*g(t).unusedTokens.length,g(t).score=r,(null==s||r<s)&&(s=r,n=t));_(e,n||t)}(e):a?kt(e):l(n=(t=e)._i)?t._d=new Date(c.now()):h(n)?t._d=new Date(n.valueOf()):"string"==typeof n?(s=t,null===(i=pt.exec(s._i))?(vt(s),!1===s._isValid&&(delete s._isValid,Dt(s),!1===s._isValid&&(delete s._isValid,c.createFromInputFallback(s)))):s._d=new Date(+i[1])):o(n)?(t._a=f(n.slice(0),function(e){return parseInt(e,10)}),ct(t)):u(n)?function(e){if(!e._d){var t=C(e._i);e._a=f([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),ct(e)}}(t):d(n)?t._d=new Date(n):c.createFromInputFallback(t),p(e)||(e._d=null),e))}function Ot(e,t,n,s,i){var r,a={};return!0!==n&&!1!==n||(s=n,n=void 0),(u(e)&&function(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var t;for(t in e)if(e.hasOwnProperty(t))return!1;return!0}(e)||o(e)&&0===e.length)&&(e=void 0),a._isAMomentObject=!0,a._useUTC=a._isUTC=i,a._l=n,a._i=e,a._f=t,a._strict=s,(r=new M(dt(Yt(a))))._nextDay&&(r.add(1,"d"),r._nextDay=void 0),r}function Tt(e,t,n,s){return Ot(e,t,n,s,!1)}c.createFromInputFallback=n("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""))}),c.ISO_8601=function(){},c.RFC_2822=function(){};var xt=n("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=Tt.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:v()}),bt=n("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=Tt.apply(null,arguments);return this.isValid()&&e.isValid()?this<e?this:e:v()});function Pt(e,t){var n,s;if(1===t.length&&o(t[0])&&(t=t[0]),!t.length)return Tt();for(n=t[0],s=1;s<t.length;++s)t[s].isValid()&&!t[s][e](n)||(n=t[s]);return n}var Wt=["year","quarter","month","week","day","hour","minute","second","millisecond"];function Ht(e){var t=C(e),n=t.year||0,s=t.quarter||0,i=t.month||0,r=t.week||0,a=t.day||0,o=t.hour||0,u=t.minute||0,l=t.second||0,d=t.millisecond||0;this._isValid=function(e){for(var t in e)if(-1===Ye.call(Wt,t)||null!=e[t]&&isNaN(e[t]))return!1;for(var n=!1,s=0;s<Wt.length;++s)if(e[Wt[s]]){if(n)return!1;parseFloat(e[Wt[s]])!==k(e[Wt[s]])&&(n=!0)}return!0}(t),this._milliseconds=+d+1e3*l+6e4*u+1e3*o*60*60,this._days=+a+7*r,this._months=+i+3*s+12*n,this._data={},this._locale=lt(),this._bubble()}function Rt(e){return e instanceof Ht}function Ct(e){return e<0?-1*Math.round(-1*e):Math.round(e)}function Ft(e,n){I(e,0,0,function(){var e=this.utcOffset(),t="+";return e<0&&(e=-e,t="-"),t+U(~~(e/60),2)+n+U(~~e%60,2)})}Ft("Z",":"),Ft("ZZ",""),ue("Z",re),ue("ZZ",re),ce(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=Ut(re,e)});var Lt=/([\+\-]|\d\d)/gi;function Ut(e,t){var n=(t||"").match(e);if(null===n)return null;var s=((n[n.length-1]||[])+"").match(Lt)||["-",0,0],i=60*s[1]+k(s[2]);return 0===i?0:"+"===s[0]?i:-i}function Nt(e,t){var n,s;return t._isUTC?(n=t.clone(),s=(S(e)||h(e)?e.valueOf():Tt(e).valueOf())-n.valueOf(),n._d.setTime(n._d.valueOf()+s),c.updateOffset(n,!1),n):Tt(e).local()}function Gt(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Vt(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}c.updateOffset=function(){};var Et=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,It=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function At(e,t){var n,s,i,r=e,a=null;return Rt(e)?r={ms:e._milliseconds,d:e._days,M:e._months}:d(e)?(r={},t?r[t]=e:r.milliseconds=e):(a=Et.exec(e))?(n="-"===a[1]?-1:1,r={y:0,d:k(a[ye])*n,h:k(a[ge])*n,m:k(a[pe])*n,s:k(a[ve])*n,ms:k(Ct(1e3*a[we]))*n}):(a=It.exec(e))?(n="-"===a[1]?-1:(a[1],1),r={y:jt(a[2],n),M:jt(a[3],n),w:jt(a[4],n),d:jt(a[5],n),h:jt(a[6],n),m:jt(a[7],n),s:jt(a[8],n)}):null==r?r={}:"object"==typeof r&&("from"in r||"to"in r)&&(i=function(e,t){var n;if(!e.isValid()||!t.isValid())return{milliseconds:0,months:0};t=Nt(t,e),e.isBefore(t)?n=Zt(e,t):((n=Zt(t,e)).milliseconds=-n.milliseconds,n.months=-n.months);return n}(Tt(r.from),Tt(r.to)),(r={}).ms=i.milliseconds,r.M=i.months),s=new Ht(r),Rt(e)&&m(e,"_locale")&&(s._locale=e._locale),s}function jt(e,t){var n=e&&parseFloat(e.replace(",","."));return(isNaN(n)?0:n)*t}function Zt(e,t){var n={milliseconds:0,months:0};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function zt(s,i){return function(e,t){var n;return null===t||isNaN(+t)||(T(i,"moment()."+i+"(period, number) is deprecated. Please use moment()."+i+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),n=e,e=t,t=n),$t(this,At(e="string"==typeof e?+e:e,t),s),this}}function $t(e,t,n,s){var i=t._milliseconds,r=Ct(t._days),a=Ct(t._months);e.isValid()&&(s=null==s||s,a&&Ce(e,xe(e,"Month")+a*n),r&&be(e,"Date",xe(e,"Date")+r*n),i&&e._d.setTime(e._d.valueOf()+i*n),s&&c.updateOffset(e,r||a))}At.fn=Ht.prototype,At.invalid=function(){return At(NaN)};var qt=zt(1,"add"),Jt=zt(-1,"subtract");function Bt(e,t){var n=12*(t.year()-e.year())+(t.month()-e.month()),s=e.clone().add(n,"months");return-(n+(t-s<0?(t-s)/(s-e.clone().add(n-1,"months")):(t-s)/(e.clone().add(n+1,"months")-s)))||0}function Qt(e){var t;return void 0===e?this._locale._abbr:(null!=(t=lt(e))&&(this._locale=t),this)}c.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",c.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Xt=n("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});function Kt(){return this._locale}function en(e,t){I(0,[e,e.length],0,t)}function tn(e,t,n,s,i){var r;return null==e?Ie(this,s,i).year:((r=Ae(e,s,i))<t&&(t=r),function(e,t,n,s,i){var r=Ee(e,t,n,s,i),a=Ge(r.year,0,r.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}.call(this,e,t,n,s,i))}I(0,["gg",2],0,function(){return this.weekYear()%100}),I(0,["GG",2],0,function(){return this.isoWeekYear()%100}),en("gggg","weekYear"),en("ggggg","weekYear"),en("GGGG","isoWeekYear"),en("GGGGG","isoWeekYear"),H("weekYear","gg"),H("isoWeekYear","GG"),L("weekYear",1),L("isoWeekYear",1),ue("G",se),ue("g",se),ue("GG",B,z),ue("gg",B,z),ue("GGGG",ee,q),ue("gggg",ee,q),ue("GGGGG",te,J),ue("ggggg",te,J),fe(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,s){t[s.substr(0,2)]=k(e)}),fe(["gg","GG"],function(e,t,n,s){t[s]=c.parseTwoDigitYear(e)}),I("Q",0,"Qo","quarter"),H("quarter","Q"),L("quarter",7),ue("Q",Z),ce("Q",function(e,t){t[_e]=3*(k(e)-1)}),I("D",["DD",2],"Do","date"),H("date","D"),L("date",9),ue("D",B),ue("DD",B,z),ue("Do",function(e,t){return e?t._dayOfMonthOrdinalParse||t._ordinalParse:t._dayOfMonthOrdinalParseLenient}),ce(["D","DD"],ye),ce("Do",function(e,t){t[ye]=k(e.match(B)[0])});var nn=Te("Date",!0);I("DDD",["DDDD",3],"DDDo","dayOfYear"),H("dayOfYear","DDD"),L("dayOfYear",4),ue("DDD",K),ue("DDDD",$),ce(["DDD","DDDD"],function(e,t,n){n._dayOfYear=k(e)}),I("m",["mm",2],0,"minute"),H("minute","m"),L("minute",14),ue("m",B),ue("mm",B,z),ce(["m","mm"],pe);var sn=Te("Minutes",!1);I("s",["ss",2],0,"second"),H("second","s"),L("second",15),ue("s",B),ue("ss",B,z),ce(["s","ss"],ve);var rn,an=Te("Seconds",!1);for(I("S",0,0,function(){return~~(this.millisecond()/100)}),I(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),I(0,["SSS",3],0,"millisecond"),I(0,["SSSS",4],0,function(){return 10*this.millisecond()}),I(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),I(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),I(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),I(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),I(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),H("millisecond","ms"),L("millisecond",16),ue("S",K,Z),ue("SS",K,z),ue("SSS",K,$),rn="SSSS";rn.length<=9;rn+="S")ue(rn,ne);function on(e,t){t[we]=k(1e3*("0."+e))}for(rn="S";rn.length<=9;rn+="S")ce(rn,on);var un=Te("Milliseconds",!1);I("z",0,0,"zoneAbbr"),I("zz",0,0,"zoneName");var ln=M.prototype;function dn(e){return e}ln.add=qt,ln.calendar=function(e,t){var n=e||Tt(),s=Nt(n,this).startOf("day"),i=c.calendarFormat(this,s)||"sameElse",r=t&&(x(t[i])?t[i].call(this,n):t[i]);return this.format(r||this.localeData().calendar(i,this,Tt(n)))},ln.clone=function(){return new M(this)},ln.diff=function(e,t,n){var s,i,r;if(!this.isValid())return NaN;if(!(s=Nt(e,this)).isValid())return NaN;switch(i=6e4*(s.utcOffset()-this.utcOffset()),t=R(t)){case"year":r=Bt(this,s)/12;break;case"month":r=Bt(this,s);break;case"quarter":r=Bt(this,s)/3;break;case"second":r=(this-s)/1e3;break;case"minute":r=(this-s)/6e4;break;case"hour":r=(this-s)/36e5;break;case"day":r=(this-s-i)/864e5;break;case"week":r=(this-s-i)/6048e5;break;default:r=this-s}return n?r:D(r)},ln.endOf=function(e){return void 0===(e=R(e))||"millisecond"===e?this:("date"===e&&(e="day"),this.startOf(e).add(1,"isoWeek"===e?"week":e).subtract(1,"ms"))},ln.format=function(e){e||(e=this.isUtc()?c.defaultFormatUtc:c.defaultFormat);var t=A(this,e);return this.localeData().postformat(t)},ln.from=function(e,t){return this.isValid()&&(S(e)&&e.isValid()||Tt(e).isValid())?At({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},ln.fromNow=function(e){return this.from(Tt(),e)},ln.to=function(e,t){return this.isValid()&&(S(e)&&e.isValid()||Tt(e).isValid())?At({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},ln.toNow=function(e){return this.to(Tt(),e)},ln.get=function(e){return x(this[e=R(e)])?this[e]():this},ln.invalidAt=function(){return g(this).overflow},ln.isAfter=function(e,t){var n=S(e)?e:Tt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=R(l(t)?"millisecond":t))?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())},ln.isBefore=function(e,t){var n=S(e)?e:Tt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=R(l(t)?"millisecond":t))?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())},ln.isBetween=function(e,t,n,s){return("("===(s=s||"()")[0]?this.isAfter(e,n):!this.isBefore(e,n))&&(")"===s[1]?this.isBefore(t,n):!this.isAfter(t,n))},ln.isSame=function(e,t){var n,s=S(e)?e:Tt(e);return!(!this.isValid()||!s.isValid())&&("millisecond"===(t=R(t||"millisecond"))?this.valueOf()===s.valueOf():(n=s.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))},ln.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)},ln.isSameOrBefore=function(e,t){return this.isSame(e,t)||this.isBefore(e,t)},ln.isValid=function(){return p(this)},ln.lang=Xt,ln.locale=Qt,ln.localeData=Kt,ln.max=bt,ln.min=xt,ln.parsingFlags=function(){return _({},g(this))},ln.set=function(e,t){if("object"==typeof e)for(var n=function(e){var t=[];for(var n in e)t.push({unit:n,priority:F[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}(e=C(e)),s=0;s<n.length;s++)this[n[s].unit](e[n[s].unit]);else if(x(this[e=R(e)]))return this[e](t);return this},ln.startOf=function(e){switch(e=R(e)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":case"date":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===e&&this.weekday(0),"isoWeek"===e&&this.isoWeekday(1),"quarter"===e&&this.month(3*Math.floor(this.month()/3)),this},ln.subtract=Jt,ln.toArray=function(){var e=this;return[e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]},ln.toObject=function(){var e=this;return{years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}},ln.toDate=function(){return new Date(this.valueOf())},ln.toISOString=function(e){if(!this.isValid())return null;var t=!0!==e,n=t?this.clone().utc():this;return n.year()<0||9999<n.year()?A(n,t?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):x(Date.prototype.toISOString)?t?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",A(n,"Z")):A(n,t?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},ln.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");var n="["+e+'("]',s=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",i=t+'[")]';return this.format(n+s+"-MM-DD[T]HH:mm:ss.SSS"+i)},ln.toJSON=function(){return this.isValid()?this.toISOString():null},ln.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},ln.unix=function(){return Math.floor(this.valueOf()/1e3)},ln.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},ln.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},ln.year=Oe,ln.isLeapYear=function(){return ke(this.year())},ln.weekYear=function(e){return tn.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},ln.isoWeekYear=function(e){return tn.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)},ln.quarter=ln.quarters=function(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)},ln.month=Fe,ln.daysInMonth=function(){return Pe(this.year(),this.month())},ln.week=ln.weeks=function(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")},ln.isoWeek=ln.isoWeeks=function(e){var t=Ie(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")},ln.weeksInYear=function(){var e=this.localeData()._week;return Ae(this.year(),e.dow,e.doy)},ln.isoWeeksInYear=function(){return Ae(this.year(),1,4)},ln.date=nn,ln.day=ln.days=function(e){if(!this.isValid())return null!=e?this:NaN;var t,n,s=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(t=e,n=this.localeData(),e="string"!=typeof t?t:isNaN(t)?"number"==typeof(t=n.weekdaysParse(t))?t:null:parseInt(t,10),this.add(e-s,"d")):s},ln.weekday=function(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")},ln.isoWeekday=function(e){if(!this.isValid())return null!=e?this:NaN;if(null!=e){var t=(n=e,s=this.localeData(),"string"==typeof n?s.weekdaysParse(n)%7||7:isNaN(n)?null:n);return this.day(this.day()%7?t:t-7)}return this.day()||7;var n,s},ln.dayOfYear=function(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")},ln.hour=ln.hours=tt,ln.minute=ln.minutes=sn,ln.second=ln.seconds=an,ln.millisecond=ln.milliseconds=un,ln.utcOffset=function(e,t,n){var s,i=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null!=e){if("string"==typeof e){if(null===(e=Ut(re,e)))return this}else Math.abs(e)<16&&!n&&(e*=60);return!this._isUTC&&t&&(s=Gt(this)),this._offset=e,this._isUTC=!0,null!=s&&this.add(s,"m"),i!==e&&(!t||this._changeInProgress?$t(this,At(e-i,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,c.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?i:Gt(this)},ln.utc=function(e){return this.utcOffset(0,e)},ln.local=function(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Gt(this),"m")),this},ln.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=Ut(ie,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0)}return this},ln.hasAlignedHourOffset=function(e){return!!this.isValid()&&(e=e?Tt(e).utcOffset():0,(this.utcOffset()-e)%60==0)},ln.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},ln.isLocal=function(){return!!this.isValid()&&!this._isUTC},ln.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},ln.isUtc=Vt,ln.isUTC=Vt,ln.zoneAbbr=function(){return this._isUTC?"UTC":""},ln.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},ln.dates=n("dates accessor is deprecated. Use date instead.",nn),ln.months=n("months accessor is deprecated. Use month instead",Fe),ln.years=n("years accessor is deprecated. Use year instead",Oe),ln.zone=n("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",function(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}),ln.isDSTShifted=n("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",function(){if(!l(this._isDSTShifted))return this._isDSTShifted;var e={};if(w(e,this),(e=Yt(e))._a){var t=e._isUTC?y(e._a):Tt(e._a);this._isDSTShifted=this.isValid()&&0<a(e._a,t.toArray())}else this._isDSTShifted=!1;return this._isDSTShifted});var hn=P.prototype;function cn(e,t,n,s){var i=lt(),r=y().set(s,t);return i[n](r,e)}function fn(e,t,n){if(d(e)&&(t=e,e=void 0),e=e||"",null!=t)return cn(e,t,n,"month");var s,i=[];for(s=0;s<12;s++)i[s]=cn(e,s,n,"month");return i}function mn(e,t,n,s){"boolean"==typeof e?d(t)&&(n=t,t=void 0):(t=e,e=!1,d(n=t)&&(n=t,t=void 0)),t=t||"";var i,r=lt(),a=e?r._week.dow:0;if(null!=n)return cn(t,(n+a)%7,s,"day");var o=[];for(i=0;i<7;i++)o[i]=cn(t,(i+a)%7,s,"day");return o}hn.calendar=function(e,t,n){var s=this._calendar[e]||this._calendar.sameElse;return x(s)?s.call(t,n):s},hn.longDateFormat=function(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:(this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])},hn.invalidDate=function(){return this._invalidDate},hn.ordinal=function(e){return this._ordinal.replace("%d",e)},hn.preparse=dn,hn.postformat=dn,hn.relativeTime=function(e,t,n,s){var i=this._relativeTime[n];return x(i)?i(e,t,n,s):i.replace(/%d/i,e)},hn.pastFuture=function(e,t){var n=this._relativeTime[0<e?"future":"past"];return x(n)?n(t):n.replace(/%s/i,t)},hn.set=function(e){var t,n;for(n in e)x(t=e[n])?this[n]=t:this["_"+n]=t;this._config=e,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},hn.months=function(e,t){return e?o(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||We).test(t)?"format":"standalone"][e.month()]:o(this._months)?this._months:this._months.standalone},hn.monthsShort=function(e,t){return e?o(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[We.test(t)?"format":"standalone"][e.month()]:o(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},hn.monthsParse=function(e,t,n){var s,i,r;if(this._monthsParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],s=0;s<12;++s)r=y([2e3,s]),this._shortMonthsParse[s]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[s]=this.months(r,"").toLocaleLowerCase();return n?"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null}.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),s=0;s<12;s++){if(i=y([2e3,s]),n&&!this._longMonthsParse[s]&&(this._longMonthsParse[s]=new RegExp("^"+this.months(i,"").replace(".","")+"$","i"),this._shortMonthsParse[s]=new RegExp("^"+this.monthsShort(i,"").replace(".","")+"$","i")),n||this._monthsParse[s]||(r="^"+this.months(i,"")+"|^"+this.monthsShort(i,""),this._monthsParse[s]=new RegExp(r.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[s].test(e))return s;if(n&&"MMM"===t&&this._shortMonthsParse[s].test(e))return s;if(!n&&this._monthsParse[s].test(e))return s}},hn.monthsRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsStrictRegex:this._monthsRegex):(m(this,"_monthsRegex")||(this._monthsRegex=Ue),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)},hn.monthsShortRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(m(this,"_monthsShortRegex")||(this._monthsShortRegex=Le),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)},hn.week=function(e){return Ie(e,this._week.dow,this._week.doy).week},hn.firstDayOfYear=function(){return this._week.doy},hn.firstDayOfWeek=function(){return this._week.dow},hn.weekdays=function(e,t){return e?o(this._weekdays)?this._weekdays[e.day()]:this._weekdays[this._weekdays.isFormat.test(t)?"format":"standalone"][e.day()]:o(this._weekdays)?this._weekdays:this._weekdays.standalone},hn.weekdaysMin=function(e){return e?this._weekdaysMin[e.day()]:this._weekdaysMin},hn.weekdaysShort=function(e){return e?this._weekdaysShort[e.day()]:this._weekdaysShort},hn.weekdaysParse=function(e,t,n){var s,i,r;if(this._weekdaysParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],s=0;s<7;++s)r=y([2e3,1]).day(s),this._minWeekdaysParse[s]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[s]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[s]=this.weekdays(r,"").toLocaleLowerCase();return n?"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null}.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),s=0;s<7;s++){if(i=y([2e3,1]).day(s),n&&!this._fullWeekdaysParse[s]&&(this._fullWeekdaysParse[s]=new RegExp("^"+this.weekdays(i,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[s]=new RegExp("^"+this.weekdaysShort(i,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[s]=new RegExp("^"+this.weekdaysMin(i,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[s]||(r="^"+this.weekdays(i,"")+"|^"+this.weekdaysShort(i,"")+"|^"+this.weekdaysMin(i,""),this._weekdaysParse[s]=new RegExp(r.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[s].test(e))return s;if(n&&"ddd"===t&&this._shortWeekdaysParse[s].test(e))return s;if(n&&"dd"===t&&this._minWeekdaysParse[s].test(e))return s;if(!n&&this._weekdaysParse[s].test(e))return s}},hn.weekdaysRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Be.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(m(this,"_weekdaysRegex")||(this._weekdaysRegex=$e),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)},hn.weekdaysShortRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Be.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(m(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=qe),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},hn.weekdaysMinRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Be.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(m(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Je),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},hn.isPM=function(e){return"p"===(e+"").toLowerCase().charAt(0)},hn.meridiem=function(e,t,n){return 11<e?n?"pm":"PM":n?"am":"AM"},ot("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10;return e+(1===k(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")}}),c.lang=n("moment.lang is deprecated. Use moment.locale instead.",ot),c.langData=n("moment.langData is deprecated. Use moment.localeData instead.",lt);var _n=Math.abs;function yn(e,t,n,s){var i=At(t,n);return e._milliseconds+=s*i._milliseconds,e._days+=s*i._days,e._months+=s*i._months,e._bubble()}function gn(e){return e<0?Math.floor(e):Math.ceil(e)}function pn(e){return 4800*e/146097}function vn(e){return 146097*e/4800}function wn(e){return function(){return this.as(e)}}var Mn=wn("ms"),Sn=wn("s"),Dn=wn("m"),kn=wn("h"),Yn=wn("d"),On=wn("w"),Tn=wn("M"),xn=wn("y");function bn(e){return function(){return this.isValid()?this._data[e]:NaN}}var Pn=bn("milliseconds"),Wn=bn("seconds"),Hn=bn("minutes"),Rn=bn("hours"),Cn=bn("days"),Fn=bn("months"),Ln=bn("years");var Un=Math.round,Nn={ss:44,s:45,m:45,h:22,d:26,M:11};var Gn=Math.abs;function Vn(e){return(0<e)-(e<0)||+e}function En(){if(!this.isValid())return this.localeData().invalidDate();var e,t,n=Gn(this._milliseconds)/1e3,s=Gn(this._days),i=Gn(this._months);t=D((e=D(n/60))/60),n%=60,e%=60;var r=D(i/12),a=i%=12,o=s,u=t,l=e,d=n?n.toFixed(3).replace(/\.?0+$/,""):"",h=this.asSeconds();if(!h)return"P0D";var c=h<0?"-":"",f=Vn(this._months)!==Vn(h)?"-":"",m=Vn(this._days)!==Vn(h)?"-":"",_=Vn(this._milliseconds)!==Vn(h)?"-":"";return c+"P"+(r?f+r+"Y":"")+(a?f+a+"M":"")+(o?m+o+"D":"")+(u||l||d?"T":"")+(u?_+u+"H":"")+(l?_+l+"M":"")+(d?_+d+"S":"")}var In=Ht.prototype;return In.isValid=function(){return this._isValid},In.abs=function(){var e=this._data;return this._milliseconds=_n(this._milliseconds),this._days=_n(this._days),this._months=_n(this._months),e.milliseconds=_n(e.milliseconds),e.seconds=_n(e.seconds),e.minutes=_n(e.minutes),e.hours=_n(e.hours),e.months=_n(e.months),e.years=_n(e.years),this},In.add=function(e,t){return yn(this,e,t,1)},In.subtract=function(e,t){return yn(this,e,t,-1)},In.as=function(e){if(!this.isValid())return NaN;var t,n,s=this._milliseconds;if("month"===(e=R(e))||"year"===e)return t=this._days+s/864e5,n=this._months+pn(t),"month"===e?n:n/12;switch(t=this._days+Math.round(vn(this._months)),e){case"week":return t/7+s/6048e5;case"day":return t+s/864e5;case"hour":return 24*t+s/36e5;case"minute":return 1440*t+s/6e4;case"second":return 86400*t+s/1e3;case"millisecond":return Math.floor(864e5*t)+s;default:throw new Error("Unknown unit "+e)}},In.asMilliseconds=Mn,In.asSeconds=Sn,In.asMinutes=Dn,In.asHours=kn,In.asDays=Yn,In.asWeeks=On,In.asMonths=Tn,In.asYears=xn,In.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*k(this._months/12):NaN},In._bubble=function(){var e,t,n,s,i,r=this._milliseconds,a=this._days,o=this._months,u=this._data;return 0<=r&&0<=a&&0<=o||r<=0&&a<=0&&o<=0||(r+=864e5*gn(vn(o)+a),o=a=0),u.milliseconds=r%1e3,e=D(r/1e3),u.seconds=e%60,t=D(e/60),u.minutes=t%60,n=D(t/60),u.hours=n%24,o+=i=D(pn(a+=D(n/24))),a-=gn(vn(i)),s=D(o/12),o%=12,u.days=a,u.months=o,u.years=s,this},In.clone=function(){return At(this)},In.get=function(e){return e=R(e),this.isValid()?this[e+"s"]():NaN},In.milliseconds=Pn,In.seconds=Wn,In.minutes=Hn,In.hours=Rn,In.days=Cn,In.weeks=function(){return D(this.days()/7)},In.months=Fn,In.years=Ln,In.humanize=function(e){if(!this.isValid())return this.localeData().invalidDate();var t,n,s,i,r,a,o,u,l,d,h,c=this.localeData(),f=(n=!e,s=c,i=At(t=this).abs(),r=Un(i.as("s")),a=Un(i.as("m")),o=Un(i.as("h")),u=Un(i.as("d")),l=Un(i.as("M")),d=Un(i.as("y")),(h=r<=Nn.ss&&["s",r]||r<Nn.s&&["ss",r]||a<=1&&["m"]||a<Nn.m&&["mm",a]||o<=1&&["h"]||o<Nn.h&&["hh",o]||u<=1&&["d"]||u<Nn.d&&["dd",u]||l<=1&&["M"]||l<Nn.M&&["MM",l]||d<=1&&["y"]||["yy",d])[2]=n,h[3]=0<+t,h[4]=s,function(e,t,n,s,i){return i.relativeTime(t||1,!!n,e,s)}.apply(null,h));return e&&(f=c.pastFuture(+this,f)),c.postformat(f)},In.toISOString=En,In.toString=En,In.toJSON=En,In.locale=Qt,In.localeData=Kt,In.toIsoString=n("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",En),In.lang=Xt,I("X",0,0,"unix"),I("x",0,0,"valueOf"),ue("x",se),ue("X",/[+-]?\d+(\.\d{1,3})?/),ce("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10))}),ce("x",function(e,t,n){n._d=new Date(k(e))}),c.version="2.22.2",e=Tt,c.fn=ln,c.min=function(){return Pt("isBefore",[].slice.call(arguments,0))},c.max=function(){return Pt("isAfter",[].slice.call(arguments,0))},c.now=function(){return Date.now?Date.now():+new Date},c.utc=y,c.unix=function(e){return Tt(1e3*e)},c.months=function(e,t){return fn(e,t,"months")},c.isDate=h,c.locale=ot,c.invalid=v,c.duration=At,c.isMoment=S,c.weekdays=function(e,t,n){return mn(e,t,n,"weekdays")},c.parseZone=function(){return Tt.apply(null,arguments).parseZone()},c.localeData=lt,c.isDuration=Rt,c.monthsShort=function(e,t){return fn(e,t,"monthsShort")},c.weekdaysMin=function(e,t,n){return mn(e,t,n,"weekdaysMin")},c.defineLocale=ut,c.updateLocale=function(e,t){if(null!=t){var n,s,i=nt;null!=(s=at(e))&&(i=s._config),(n=new P(t=b(i,t))).parentLocale=st[e],st[e]=n,ot(e)}else null!=st[e]&&(null!=st[e].parentLocale?st[e]=st[e].parentLocale:null!=st[e]&&delete st[e]);return st[e]},c.locales=function(){return s(st)},c.weekdaysShort=function(e,t,n){return mn(e,t,n,"weekdaysShort")},c.normalizeUnits=R,c.relativeTimeRounding=function(e){return void 0===e?Un:"function"==typeof e&&(Un=e,!0)},c.relativeTimeThreshold=function(e,t){return void 0!==Nn[e]&&(void 0===t?Nn[e]:(Nn[e]=t,"s"===e&&(Nn.ss=t-1),!0))},c.calendarFormat=function(e,t){var n=e.diff(t,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"},c.prototype=ln,c.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"YYYY-[W]WW",MONTH:"YYYY-MM"},c});
/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Utils/Numeric',[],function() {
    /**************************************************************************************************************/

    /**
     Declare namespace for Numeric functions.
     TODO : Should be put into GlobWeb
     */
    var Numeric = {};

    /**************************************************************************************************************/

    /**
     Linear interpolation between [a, b], t must be [0, 1]
     */
    Numeric.lerp = function(t, a, b) {
        return a + (b - a) * t;
    };

    /**************************************************************************************************************/

    /**
     Cosine interpolation between [a, b], t must be [0, 1]
     */
    Numeric.coserp = function(t, a, b) {
        var t2 = (1 - Math.cos(t * Math.PI)) / 2;
        return a + (b - a) * t2;
    };

    /**************************************************************************************************************/

    /**
     Cubic interpolation between [a, b], t must be [0, 1]
     */
    Numeric.cubicInterpolation = function(
        t,
        startPos,
        startVel,
        endPos,
        endVel
    ) {
        var t2 = t * t;
        var t3 = t2 * t;

        // Evaluate the position

        var M00 = 2 * startPos[0] - 2 * endPos[0] + startVel[0] + endVel[0];
        var M10 = 2 * startPos[1] - 2 * endPos[1] + startVel[1] + endVel[1];
        var M20 = 2 * startPos[2] - 2 * endPos[2] + startVel[2] + endVel[2];

        var M01 =
            -3 * startPos[0] + 3 * endPos[0] - 2 * startVel[0] - endVel[0];
        var M11 =
            -3 * startPos[1] + 3 * endPos[1] - 2 * startVel[1] - endVel[1];
        var M21 =
            -3 * startPos[2] + 3 * endPos[2] - 2 * startVel[2] - endVel[2];

        var position = vec3.create();
        position[0] = M00 * t3 + M01 * t2 + startVel[0] * t + startPos[0];
        position[1] = M10 * t3 + M11 * t2 + startVel[1] * t + startPos[1];
        position[2] = M20 * t3 + M21 * t2 + startVel[2] * t + startPos[2];

        return position;
    };

    /**************************************************************************************************************/

    /**
     Cubic interpolation between [a, b], t must be [0, 1]
     */
    Numeric.cubicInterpolationDerivative = function(
        t,
        startPos,
        startVel,
        endPos,
        endVel
    ) {
        var t2 = t * t;

        // Evaluates the direction

        var M01 =
            6 * startPos[0] - 6 * endPos[0] + 3 * startVel[0] + 3 * endVel[0];
        var M11 =
            6 * startPos[1] - 6 * endPos[1] + 3 * startVel[1] + 3 * endVel[1];
        var M21 =
            6 * startPos[2] - 6 * endPos[2] + 3 * startVel[2] + 3 * endVel[2];

        var M02 =
            -6 * startPos[0] + 6 * endPos[0] - 4 * startVel[0] - 2 * endVel[0];
        var M12 =
            -6 * startPos[1] + 6 * endPos[1] - 4 * startVel[1] - 2 * endVel[1];
        var M22 =
            -6 * startPos[2] + 6 * endPos[2] - 4 * startVel[2] - 2 * endVel[2];

        var direction = vec3.create();
        direction[0] = M01 * t2 + M02 * t + startVel[0];
        direction[1] = M11 * t2 + M12 * t + startVel[1];
        direction[2] = M21 * t2 + M22 * t + startVel[2];

        return direction;
    };

    /**************************************************************************************************************/

    /**
     Map x between [xMin, xMax] to [0, 1]
     */
    Numeric.map01 = function(x, xMin, xMax) {
        return xMin !== xMax ? (x - xMin) / (xMax - xMin) : 0;
    };

    /**************************************************************************************************************/

    /*
     Map x between [xMin, xMax] to [outMin, outMax]
     */
    Numeric.mapLinear = function(x, xMin, xMax, outMin, outMax) {
        return Numeric.lerp(Numeric.map01(x, xMin, xMax), outMin, outMax);
    };

    /**************************************************************************************************************/

    Numeric.easeInQuad = function(t) {
        return t * t;
    };

    /**************************************************************************************************************/

    Numeric.easeOutQuad = function(t) {
        // use 1-(t^2) with input [-1, 0]
        var v = t - 1; // map [0 1] to [-1 0]
        return 1.0 - v * v;
    };

    /**************************************************************************************************************/

    /**
     Remap input t ([0, 1]) to a curve starting slowly
     and accelerating till 0.5 an decelerating till 1
     */
    Numeric.easeInOutQuad = function(t) {
        var out = t;
        if (out < 0.5) {
            // use (0.5*t^2) with input [0, 1]
            out = out + out; // map [0 0.5] outo [0 1]
            out = 0.5 * (out * out);
        } else {
            // use (0.5*(1-t)^2) with input [-1, 0]
            out = out + out - 2.0; // map [0.5 1] to [-1 0]
            out = 0.5 * (1.0 - out * out);
            out = 0.5 + out;
        }
        return out;
    };

    /**************************************************************************************************************/

    /*
     */
    Numeric.easeOutInQuad = function(t) {
        var out = t;
        if (out < 0.5) {
            // use (0.5*(1-t)^2) with input [-1, 0]
            out = out + out - 1.0; // map [0 0.5] to [-1 0]
            out = 0.5 * (1.0 - out * out);
        } else {
            // use (0.5*t^2) with input [0, 1]
            out = out + out - 1.0; // map [0.5 1] outo [0 1]
            out = 0.5 * (out * out);
            out = 0.5 + out;
        }
        return out;
    };

    /**************************************************************************************************************/

    /**
     Convert the given degree value in radian
     */
    Numeric.toRadian = function(degree) {
        return (degree * Math.PI) / 180.0;
    };

    /**************************************************************************************************************/

    /**
     Convert the given radian value in degree
     */
    Numeric.toDegree = function(radian) {
        return (radian * 180.0) / Math.PI;
    };

    /**************************************************************************************************************/

    /**
     Line-line intersection
     rayDirection must be normalized.
     Returns t at which intersection occurs or -1 if no intersection.
     */

    Numeric.lineIntersection = function(x1, y1, x2, y2, x3, y3, x4, y4) {
        var det = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        if (det === 0) {
            return [-1, -1];
        }

        var ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
        var ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);

        ua /= det;
        ub /= det;

        return [ua, ub];
        //return ua > 0.0 && ua < 1.0 && ub > 0.0 && ub < 1.0;
    };

    /**************************************************************************************************************/

    /**
     *    Round the given number
     *
     *    @param num Number to round
     *    @param dec Number of decimals
     */
    Numeric.roundNumber = function(num, dec) {
        return Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
    };

    /**
     * Return the sign of a value
     */
    Numeric.sign = function(v) {
        if (v < 0) return -1;
        else {
            if (v > 0) return 1;
            else return 0;
        }
    };

    Numeric.equals = function(a, b) {
        return Math.abs(a - b) < Number.EPSILON;
    };

    Numeric.shortestPath360 = function(startLongitude, endLongitude) {
        var startLongValue, endLongValue;
        if (Math.abs(endLongitude - startLongitude) < 180.0) {
            startLongValue = startLongitude;
            endLongValue = endLongitude;
        } else {
            if (startLongitude < endLongitude) {
                startLongValue = startLongitude + 360;
                endLongValue = endLongitude;
            } else {
                startLongValue = startLongitude;
                endLongValue = endLongitude + 360;
            }
        }
        return [startLongValue, endLongValue];
    };

    Numeric.shortestPath180 = function(startLongitude, endLongitude) {
        var startLongValue, endLongValue;
        if (
            Math.sign(startLongitude) * Math.sign(endLongitude) > 0 ||
            Numeric.equals(startLongitude, 0) ||
            Numeric.equals(endLongitude, 0)
        ) {
            // 1st case:
            // Nothing to do because :
            // - the two values have the same sign
            // - and max(angle) <= 180 (longitude included in [-180,180]
            // so we have the shortest path
            startLongValue = startLongitude;
            endLongValue = endLongitude;
        } else {
            // we convert everything from [0 to 360]
            var longGeoCenter = (startLongitude + 360) % 360;
            var longGeoPos = (endLongitude + 360) % 360;
            var path = Numeric.shortestPath360(longGeoCenter, longGeoPos);
            startLongValue = path[0];
            endLongValue = path[1];
        }
        return [startLongValue, endLongValue];
    };

    /**************************************************************************************************************/

    return Numeric;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 *    Module with constants
 */
define('gw/Tiling/HEALPixTables',[],function() {
    /**************************************************************************************************************/

    var HealPixTables = {
        ctab: [
            0,
            1,
            256,
            257,
            2,
            3,
            258,
            259,
            512,
            513,
            768,
            769,
            514,
            515,
            770,
            771,
            4,
            5,
            260,
            261,
            6,
            7,
            262,
            263,
            516,
            517,
            772,
            773,
            518,
            519,
            774,
            775,
            1024,
            1025,
            1280,
            1281,
            1026,
            1027,
            1282,
            1283,
            1536,
            1537,
            1792,
            1793,
            1538,
            1539,
            1794,
            1795,
            1028,
            1029,
            1284,
            1285,
            1030,
            1031,
            1286,
            1287,
            1540,
            1541,
            1796,
            1797,
            1542,
            1543,
            1798,
            1799,
            8,
            9,
            264,
            265,
            10,
            11,
            266,
            267,
            520,
            521,
            776,
            777,
            522,
            523,
            778,
            779,
            12,
            13,
            268,
            269,
            14,
            15,
            270,
            271,
            524,
            525,
            780,
            781,
            526,
            527,
            782,
            783,
            1032,
            1033,
            1288,
            1289,
            1034,
            1035,
            1290,
            1291,
            1544,
            1545,
            1800,
            1801,
            1546,
            1547,
            1802,
            1803,
            1036,
            1037,
            1292,
            1293,
            1038,
            1039,
            1294,
            1295,
            1548,
            1549,
            1804,
            1805,
            1550,
            1551,
            1806,
            1807,
            2048,
            2049,
            2304,
            2305,
            2050,
            2051,
            2306,
            2307,
            2560,
            2561,
            2816,
            2817,
            2562,
            2563,
            2818,
            2819,
            2052,
            2053,
            2308,
            2309,
            2054,
            2055,
            2310,
            2311,
            2564,
            2565,
            2820,
            2821,
            2566,
            2567,
            2822,
            2823,
            3072,
            3073,
            3328,
            3329,
            3074,
            3075,
            3330,
            3331,
            3584,
            3585,
            3840,
            3841,
            3586,
            3587,
            3842,
            3843,
            3076,
            3077,
            3332,
            3333,
            3078,
            3079,
            3334,
            3335,
            3588,
            3589,
            3844,
            3845,
            3590,
            3591,
            3846,
            3847,
            2056,
            2057,
            2312,
            2313,
            2058,
            2059,
            2314,
            2315,
            2568,
            2569,
            2824,
            2825,
            2570,
            2571,
            2826,
            2827,
            2060,
            2061,
            2316,
            2317,
            2062,
            2063,
            2318,
            2319,
            2572,
            2573,
            2828,
            2829,
            2574,
            2575,
            2830,
            2831,
            3080,
            3081,
            3336,
            3337,
            3082,
            3083,
            3338,
            3339,
            3592,
            3593,
            3848,
            3849,
            3594,
            3595,
            3850,
            3851,
            3084,
            3085,
            3340,
            3341,
            3086,
            3087,
            3342,
            3343,
            3596,
            3597,
            3852,
            3853,
            3598,
            3599,
            3854,
            3855
        ],
        utab: [
            0,
            1,
            4,
            5,
            16,
            17,
            20,
            21,
            64,
            65,
            68,
            69,
            80,
            81,
            84,
            85,
            256,
            257,
            260,
            261,
            272,
            273,
            276,
            277,
            320,
            321,
            324,
            325,
            336,
            337,
            340,
            341,
            1024,
            1025,
            1028,
            1029,
            1040,
            1041,
            1044,
            1045,
            1088,
            1089,
            1092,
            1093,
            1104,
            1105,
            1108,
            1109,
            1280,
            1281,
            1284,
            1285,
            1296,
            1297,
            1300,
            1301,
            1344,
            1345,
            1348,
            1349,
            1360,
            1361,
            1364,
            1365,
            4096,
            4097,
            4100,
            4101,
            4112,
            4113,
            4116,
            4117,
            4160,
            4161,
            4164,
            4165,
            4176,
            4177,
            4180,
            4181,
            4352,
            4353,
            4356,
            4357,
            4368,
            4369,
            4372,
            4373,
            4416,
            4417,
            4420,
            4421,
            4432,
            4433,
            4436,
            4437,
            5120,
            5121,
            5124,
            5125,
            5136,
            5137,
            5140,
            5141,
            5184,
            5185,
            5188,
            5189,
            5200,
            5201,
            5204,
            5205,
            5376,
            5377,
            5380,
            5381,
            5392,
            5393,
            5396,
            5397,
            5440,
            5441,
            5444,
            5445,
            5456,
            5457,
            5460,
            5461,
            16384,
            16385,
            16388,
            16389,
            16400,
            16401,
            16404,
            16405,
            16448,
            16449,
            16452,
            16453,
            16464,
            16465,
            16468,
            16469,
            16640,
            16641,
            16644,
            16645,
            16656,
            16657,
            16660,
            16661,
            16704,
            16705,
            16708,
            16709,
            16720,
            16721,
            16724,
            16725,
            17408,
            17409,
            17412,
            17413,
            17424,
            17425,
            17428,
            17429,
            17472,
            17473,
            17476,
            17477,
            17488,
            17489,
            17492,
            17493,
            17664,
            17665,
            17668,
            17669,
            17680,
            17681,
            17684,
            17685,
            17728,
            17729,
            17732,
            17733,
            17744,
            17745,
            17748,
            17749,
            20480,
            20481,
            20484,
            20485,
            20496,
            20497,
            20500,
            20501,
            20544,
            20545,
            20548,
            20549,
            20560,
            20561,
            20564,
            20565,
            20736,
            20737,
            20740,
            20741,
            20752,
            20753,
            20756,
            20757,
            20800,
            20801,
            20804,
            20805,
            20816,
            20817,
            20820,
            20821,
            21504,
            21505,
            21508,
            21509,
            21520,
            21521,
            21524,
            21525,
            21568,
            21569,
            21572,
            21573,
            21584,
            21585,
            21588,
            21589,
            21760,
            21761,
            21764,
            21765,
            21776,
            21777,
            21780,
            21781,
            21824,
            21825,
            21828,
            21829,
            21840,
            21841,
            21844,
            21845
        ],

        // coordinate of the lowest corner of each face
        jrll: [2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4],
        jpll: [1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7],

        xoffset: [-1, -1, 0, 1, 1, 1, 0, -1],
        yoffset: [0, 1, 1, 1, 0, -1, -1, -1],
        facearray: [
            [8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9], // S
            [5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8], // SE
            [-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1], // E
            [4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10], // SW
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], // center
            [1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4], // NE
            [-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1], // W
            [3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7], // NW
            [2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]
        ], // N
        swaparray: [
            [0, 0, 3], // S
            [0, 0, 6], // SE
            [0, 0, 0], // E
            [0, 0, 5], // SW
            [0, 0, 0], // center
            [5, 0, 0], // NE
            [0, 0, 0], // W
            [6, 0, 0], // NW
            [3, 0, 0]
        ], // N

        swap_cycle: [
            [],
            [0, 1, 8, 12, 16, 21, 40],
            [0, 1, 2, 40, 114],
            [0, 4, 160, 263],
            [0, 4, 30, 49, 51, 87, 526, 1027, 1105, 1387, 1807, 2637],
            [0, 8, 10, 18, 39, 74, 146, 307, 452, 4737],
            [0, 1, 2, 7, 9, 17, 80, 410, 1526, 1921, 32859, 33566, 38931],
            [
                0,
                5,
                6,
                10,
                12,
                24,
                27,
                95,
                372,
                494,
                924,
                1409,
                3492,
                4248,
                9137,
                66043,
                103369,
                156899
            ],
            [
                0,
                1,
                2,
                3,
                4,
                45,
                125,
                351,
                697,
                24337,
                102940,
                266194,
                341855,
                419857
            ],
            [
                0,
                1,
                2,
                3,
                9,
                16,
                1705,
                2082,
                2126,
                8177,
                12753,
                15410,
                52642,
                80493,
                83235,
                88387,
                99444,
                1675361,
                2495125
            ],
            [
                0,
                2,
                6,
                8,
                9,
                11,
                20,
                50,
                93,
                152,
                183,
                2137,
                13671,
                44794,
                486954,
                741908,
                4803258,
                5692573
            ],
            [
                0,
                1,
                5,
                6,
                44,
                53,
                470,
                2847,
                3433,
                4906,
                13654,
                14710,
                400447,
                1797382,
                2744492,
                18775974,
                23541521
            ],
            [
                0,
                4,
                9,
                10,
                16,
                33,
                83,
                117,
                318,
                451,
                5759,
                10015,
                128975,
                171834,
                211256,
                347608,
                1278690,
                2154097,
                2590798,
                3427694,
                5581717,
                21012301,
                27023976,
                72522811,
                95032729,
                139166747,
                171822389
            ],
            [
                0,
                5,
                10,
                267,
                344,
                363,
                2968,
                3159,
                9083,
                18437,
                76602,
                147614,
                1246902,
                1593138,
                2035574,
                6529391,
                9511830,
                11340287,
                29565945,
                281666026,
                677946848
            ]
        ]
    };

    return HealPixTables;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Utils/Long',[],function() {
    /**
     * @name Long
     * @class
     *   Long class for only unsigned integers
     *  Constructs a 64-bit two's-complement integer, given its low and high 32-bit
     *  values as *signed* integers.  See the from* functions below for more
     *  convenient ways of constructing Longs.
     *
     *  The internal representation of a long is the two given signed, 32-bit values.
     *  We use 32-bit pieces because these are the size of integers on which
     *  Javascript performs bit-operations.  For operations like addition and
     *  multiplication, we split each number into 16-bit pieces, which can easily be
     *  multiplied within Javascript's floating-point representation without overflow
     *  or change in sign.
     *
     *  In the algorithms below, we frequently reduce the negative case to the
     *  positive case by negating the input(s) and then post-processing the result.
     *  Note that we must ALWAYS check specially whether those values are MIN_VALUE
     *  (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
     *  a positive number, it overflows back into a negative).  Not handling this
     * case would often result in infinite recursion.
     * @constructor
     * @param {number} low  The low (signed) 32 bits of the long.
     * @param {number} high  The high (signed) 32 bits of the long.
     */
    var Long = function(low, high) {
        /**
         * @type {number}
         * @private
         */
        this.low_ = low | 0; // force into 32 signed bits.

        /**
         * @type {number}
         * @private
         */
        this.high_ = high | 0; // force into 32 signed bits.
    };

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @private
     */
    Long.IntCache_ = {};

    /**
     * Returns a Long representing the given (32-bit) integer value.
     * @function fromInt
     * @memberof Long
     * @param {number} value The 32-bit integer in question.
     * @return {!Long} The corresponding Long value.
     */
    Long.fromInt = function(value) {
        if (-128 <= value && value < 128) {
            var cachedObj = Long.IntCache_[value];
            if (cachedObj) {
                return cachedObj;
            }
        }

        var obj = new Long(value | 0, value < 0 ? -1 : 0);
        if (-128 <= value && value < 128) {
            Long.IntCache_[value] = obj;
        }
        return obj;
    };

    /**
     * Returns a Long representing the given value, provided that it is a finite
     * number.  Otherwise, zero is returned.
     * @function fromNumber
     * @memberof Long
     * @param {number} value The number in question.
     * @return {!Long} The corresponding Long value.
     */
    Long.fromNumber = function(value) {
        if (isNaN(value) || !isFinite(value)) {
            return Long.ZERO;
        } else if (value <= -Long.TWO_PWR_63_DBL_) {
            return Long.MIN_VALUE;
        } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
            return Long.MAX_VALUE;
        } else if (value < 0) {
            return Long.fromNumber(-value).negate();
        } else {
            return new Long(
                value % Long.TWO_PWR_32_DBL_ | 0,
                (value / Long.TWO_PWR_32_DBL_) | 0
            );
        }
    };

    /**
     * Returns a Long representing the 64-bit integer that comes by concatenating
     * the given high and low bits.  Each is assumed to use 32 bits.
     * @function fromBits
     * @memberof Long
     * @param {number} lowBits The low 32-bits.
     * @param {number} highBits The high 32-bits.
     * @return {!Long} The corresponding Long value.
     */
    Long.fromBits = function(lowBits, highBits) {
        return new Long(lowBits, highBits);
    };

    /**
     * Number used repeated below in calculations.  This must appear before the
     * first call to any from* function below.
     * @type {number}
     * @private
     */
    Long.TWO_PWR_16_DBL_ = 1 << 16;

    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_24_DBL_ = 1 << 24;

    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;

    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;

    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;

    /** @type {!Long} */
    Long.ZERO = Long.fromInt(0);

    /** @type {!Long} */
    Long.ONE = Long.fromInt(1);

    /** @type {!Long} */
    Long.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0);

    /** @type {!Long} */
    Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);

    /**
     * @type {!Long}
     * @private
     */
    Long.TWO_PWR_24_ = Long.fromInt(1 << 24);

    /** @return {number} The value, assuming it is a 32-bit integer. */
    Long.prototype.toInt = function() {
        return this.low_;
    };

    /** @return {number} The closest floating-point representation to this value. */
    Long.prototype.toNumber = function() {
        return this.high_ * Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };

    /** @return {number} The low 32-bits as an unsigned value. */
    Long.prototype.getLowBitsUnsigned = function() {
        return this.low_ >= 0 ? this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
    };

    /** @return {boolean} Whether this value is zero. */
    Long.prototype.isZero = function() {
        return this.high_ === 0 && this.low_ === 0;
    };

    /** @return {boolean} Whether this value is negative. */
    Long.prototype.isNegative = function() {
        return this.high_ < 0;
    };

    /** @return {boolean} Whether this value is odd. */
    Long.prototype.isOdd = function() {
        return (this.low_ & 1) === 1;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long equals the other.
     */
    Long.prototype.equals = function(other) {
        return this.high_ === other.high_ && this.low_ === other.low_;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is less than the other.
     */
    Long.prototype.lessThan = function(other) {
        return this.compare(other) < 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is greater than or equal to the other.
     */
    Long.prototype.greaterThanOrEqual = function(other) {
        return this.compare(other) >= 0;
    };

    /**
     * Compares this Long with the given one.
     * @function compare
     * @memberof Long.prototype
     * @return {number} 0 if they are the same, 1 if the this is greater, and -1
     *     if the given one is greater.
     */
    Long.prototype.compare = function(other) {
        if (this.equals(other)) {
            return 0;
        }

        var thisNeg = this.isNegative();
        var otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) {
            return -1;
        }
        if (!thisNeg && otherNeg) {
            return 1;
        }

        // at this point, the signs are the same, so subtraction will not overflow
        if (this.subtract(other).isNegative()) {
            return -1;
        } else {
            return 1;
        }
    };

    /**
     * Return the negation
     * @function negate
     * @memberof Long.prototype
     * @return {!Long} The negation of this value.
     */
    Long.prototype.negate = function() {
        if (this.equals(Long.MIN_VALUE)) {
            return Long.MIN_VALUE;
        } else {
            return this.not().add(Long.ONE);
        }
    };

    /**
     * Returns the sum of this and the given Long.
     * @function add
     * @memberof Long.prototype
     * @param {Long} other Long to add to this one.
     * @return {!Long} The sum of this and the given Long.
     */
    Long.prototype.add = function(other) {
        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high_ >>> 16;
        var a32 = this.high_ & 0xffff;
        var a16 = this.low_ >>> 16;
        var a00 = this.low_ & 0xffff;

        var b48 = other.high_ >>> 16;
        var b32 = other.high_ & 0xffff;
        var b16 = other.low_ >>> 16;
        var b00 = other.low_ & 0xffff;

        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xffff;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c48 += a48 + b48;
        c48 &= 0xffff;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
    };

    /**
     * Returns the difference of this and the given Long.
     * @function subtract
     * @memberof Long.prototype
     * @param {Long} other Long to subtract from this.
     * @return {!Long} The difference of this and the given Long.
     */
    Long.prototype.subtract = function(other) {
        return this.add(other.negate());
    };

    /**
     * Returns the product of this and the given long.
     * @function multiply
     * @memberof Long.prototype
     * @param {Long} other Long to multiply with this.
     * @return {!Long} The product of this and the other.
     */
    Long.prototype.multiply = function(other) {
        if (this.isZero()) {
            return Long.ZERO;
        } else if (other.isZero()) {
            return Long.ZERO;
        }

        if (this.equals(Long.MIN_VALUE)) {
            return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        } else if (other.equals(Long.MIN_VALUE)) {
            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        }

        if (this.isNegative()) {
            if (other.isNegative()) {
                return this.negate().multiply(other.negate());
            } else {
                return this.negate()
                    .multiply(other)
                    .negate();
            }
        } else if (other.isNegative()) {
            return this.multiply(other.negate()).negate();
        }

        // If both longs are small, use float multiplication
        if (
            this.lessThan(Long.TWO_PWR_24_) &&
            other.lessThan(Long.TWO_PWR_24_)
        ) {
            return Long.fromNumber(this.toNumber() * other.toNumber());
        }

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high_ >>> 16;
        var a32 = this.high_ & 0xffff;
        var a16 = this.low_ >>> 16;
        var a00 = this.low_ & 0xffff;

        var b48 = other.high_ >>> 16;
        var b32 = other.high_ & 0xffff;
        var b16 = other.low_ >>> 16;
        var b00 = other.low_ & 0xffff;

        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xffff;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xffff;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
    };

    /** @return {!Long} The bitwise-NOT of this value. */
    Long.prototype.not = function() {
        return Long.fromBits(~this.low_, ~this.high_);
    };

    /**
     * Returns the bitwise-AND of this Long and the given one.
     * @function and
     * @memberof Long.prototype
     * @param {Long} other The Long with which to AND.
     * @return {!Long} The bitwise-AND of this and the other.
     */
    Long.prototype.and = function(other) {
        return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };

    /**
     * Returns the bitwise-OR of this Long and the given one.
     * @function or
     * @memberof Long.prototype
     * @param {Long} other The Long with which to OR.
     * @return {!Long} The bitwise-OR of this and the other.
     */
    Long.prototype.or = function(other) {
        return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };

    /**
     * Returns this Long with bits shifted to the right by the given amount, with
     * the new top bits matching the current sign bit.
     * @function shiftRightUnsigned
     * @memberof Long.prototype
     * @param {number} numBits The number of bits by which to shift.
     * @return {!Long} This shifted to the right by the given amount, with
     *     zeros placed into the new leading bits.
     */
    Long.prototype.shiftRightUnsigned = function(numBits) {
        numBits &= 63;
        if (numBits === 0) {
            return this;
        } else {
            var high = this.high_;
            if (numBits < 32) {
                var low = this.low_;
                return Long.fromBits(
                    (low >>> numBits) | (high << (32 - numBits)),
                    high >>> numBits
                );
            } else if (numBits === 32) {
                return Long.fromBits(high, 0);
            } else {
                return Long.fromBits(high >>> (numBits - 32), 0);
            }
        }
    };

    /**************************************************************************************************************/

    return Long;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Utils/CircleFinder',[], function() {
    /**************************************************************************************************************/

    var center, cosrad;

    var CircleFinder = function(point) {
        //CircleFinder.prototype.constructor.call(this, point);

        var np = point.length;
        //HealpixUtils.check(np >= 3, "too few points");

        center = vec3.add2(point[0], point[1]);
        center = vec3.normalize2(center);
        cosrad = vec3.dot2(point[0], center);
        for (var i = 2; i < np; ++i) {
            if (vec3.dot2(point[i], center) < cosrad) {
                // point outside the current circle
                this.getCircle(point, i);
            }
        }
    };

    /**************************************************************************************************************/

    CircleFinder.prototype.getCircle = function(point, q1, q2) {
        center = vec3.add2(point[q1], point[q2]);
        center = vec3.normalize2(center);
        cosrad = vec3.dot2(point[q1], center);
        for (var i = 0; i < q1; ++i) {
            if (vec3.dot2(point[i], center) < cosrad) {
                // point outside the current circle
                var subPoint = vec3.subtract2(point[q1], point[i]);
                var subPoint2 = vec3.subtract2(point[q2], point[i]);
                center = vec3.cross2(subPoint, subPoint2);
                center = vec3.normalize2(center);
                cosrad = vec3.dot2(point[q1], center);
                if (cosrad < 0) {
                    center = vec3.flip(center);
                    cosrad = -cosrad;
                }
            }
        }
    };

    /**************************************************************************************************************/

    CircleFinder.prototype.getCircle = function(point, q) {
        center = vec3.add2(point[0], point[q]);
        center = vec3.normalize2(center);
        cosrad = vec3.dot2(point[0], center);
        for (var i = 1; i < q; ++i) {
            if (vec3.dot2(point[i], center) < cosrad) {
                // point outside the current circle
                this.getCircle(point, i, q);
            }
        }
    };

    /**************************************************************************************************************/

    CircleFinder.prototype.getCenter = function() {
        return center;
    };

    CircleFinder.prototype.getCosRad = function() {
        return cosrad;
    };

    return CircleFinder;
});

/*! jQuery UI - v1.11.4 - 2015-03-11
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js
* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */

(function(e){"function"==typeof define&&define.amd?define('jquery.ui',["jquery"],e):e(jQuery)})(function(e){function t(t,s){var n,a,o,r=t.nodeName.toLowerCase();return"area"===r?(n=t.parentNode,a=n.name,t.href&&a&&"map"===n.nodeName.toLowerCase()?(o=e("img[usemap='#"+a+"']")[0],!!o&&i(o)):!1):(/^(input|select|textarea|button|object)$/.test(r)?!t.disabled:"a"===r?t.href||s:s)&&i(t)}function i(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}function s(e){for(var t,i;e.length&&e[0]!==document;){if(t=e.css("position"),("absolute"===t||"relative"===t||"fixed"===t)&&(i=parseInt(e.css("zIndex"),10),!isNaN(i)&&0!==i))return i;e=e.parent()}return 0}function n(){this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},e.extend(this._defaults,this.regional[""]),this.regional.en=e.extend(!0,{},this.regional[""]),this.regional["en-US"]=e.extend(!0,{},this.regional.en),this.dpDiv=a(e("<div id='"+this._mainDivId+"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))}function a(t){var i="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return t.delegate(i,"mouseout",function(){e(this).removeClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&e(this).removeClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&e(this).removeClass("ui-datepicker-next-hover")}).delegate(i,"mouseover",o)}function o(){e.datepicker._isDisabledDatepicker(v.inline?v.dpDiv.parent()[0]:v.input[0])||(e(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),e(this).addClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&e(this).addClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&e(this).addClass("ui-datepicker-next-hover"))}function r(t,i){e.extend(t,i);for(var s in i)null==i[s]&&(t[s]=i[s]);return t}function h(e){return function(){var t=this.element.val();e.apply(this,arguments),this._refresh(),t!==this.element.val()&&this._trigger("change")}}e.ui=e.ui||{},e.extend(e.ui,{version:"1.11.4",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({scrollParent:function(t){var i=this.css("position"),s="absolute"===i,n=t?/(auto|scroll|hidden)/:/(auto|scroll)/,a=this.parents().filter(function(){var t=e(this);return s&&"static"===t.css("position")?!1:n.test(t.css("overflow")+t.css("overflow-y")+t.css("overflow-x"))}).eq(0);return"fixed"!==i&&a.length?a:e(this[0].ownerDocument||document)},uniqueId:function(){var e=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++e)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(i){return t(i,!isNaN(e.attr(i,"tabindex")))},tabbable:function(i){var s=e.attr(i,"tabindex"),n=isNaN(s);return(n||s>=0)&&t(i,!n)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(t,i){function s(t,i,s,a){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),a&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],a=i.toLowerCase(),o={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+i]=function(t){return void 0===t?o["inner"+i].call(this):this.each(function(){e(this).css(a,s(this,t)+"px")})},e.fn["outer"+i]=function(t,n){return"number"!=typeof t?o["outer"+i].call(this,t):this.each(function(){e(this).css(a,s(this,t,!0,n)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.fn.extend({focus:function(t){return function(i,s){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),s&&s.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),disableSelection:function(){var e="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.bind(e+".ui-disableSelection",function(e){e.preventDefault()})}}(),enableSelection:function(){return this.unbind(".ui-disableSelection")},zIndex:function(t){if(void 0!==t)return this.css("zIndex",t);if(this.length)for(var i,s,n=e(this[0]);n.length&&n[0]!==document;){if(i=n.css("position"),("absolute"===i||"relative"===i||"fixed"===i)&&(s=parseInt(n.css("zIndex"),10),!isNaN(s)&&0!==s))return s;n=n.parent()}return 0}}),e.ui.plugin={add:function(t,i,s){var n,a=e.ui[t].prototype;for(n in s)a.plugins[n]=a.plugins[n]||[],a.plugins[n].push([i,s[n]])},call:function(e,t,i,s){var n,a=e.plugins[t];if(a&&(s||e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType))for(n=0;a.length>n;n++)e.options[a[n][0]]&&a[n][1].apply(e.element,i)}};var l=0,u=Array.prototype.slice;e.cleanData=function(t){return function(i){var s,n,a;for(a=0;null!=(n=i[a]);a++)try{s=e._data(n,"events"),s&&s.remove&&e(n).triggerHandler("remove")}catch(o){}t(i)}}(e.cleanData),e.widget=function(t,i,s){var n,a,o,r,h={},l=t.split(".")[0];return t=t.split(".")[1],n=l+"-"+t,s||(s=i,i=e.Widget),e.expr[":"][n.toLowerCase()]=function(t){return!!e.data(t,n)},e[l]=e[l]||{},a=e[l][t],o=e[l][t]=function(e,t){return this._createWidget?(arguments.length&&this._createWidget(e,t),void 0):new o(e,t)},e.extend(o,a,{version:s.version,_proto:e.extend({},s),_childConstructors:[]}),r=new i,r.options=e.widget.extend({},r.options),e.each(s,function(t,s){return e.isFunction(s)?(h[t]=function(){var e=function(){return i.prototype[t].apply(this,arguments)},n=function(e){return i.prototype[t].apply(this,e)};return function(){var t,i=this._super,a=this._superApply;return this._super=e,this._superApply=n,t=s.apply(this,arguments),this._super=i,this._superApply=a,t}}(),void 0):(h[t]=s,void 0)}),o.prototype=e.widget.extend(r,{widgetEventPrefix:a?r.widgetEventPrefix||t:t},h,{constructor:o,namespace:l,widgetName:t,widgetFullName:n}),a?(e.each(a._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete a._childConstructors):i._childConstructors.push(o),e.widget.bridge(t,o),o},e.widget.extend=function(t){for(var i,s,n=u.call(arguments,1),a=0,o=n.length;o>a;a++)for(i in n[a])s=n[a][i],n[a].hasOwnProperty(i)&&void 0!==s&&(t[i]=e.isPlainObject(s)?e.isPlainObject(t[i])?e.widget.extend({},t[i],s):e.widget.extend({},s):s);return t},e.widget.bridge=function(t,i){var s=i.prototype.widgetFullName||t;e.fn[t]=function(n){var a="string"==typeof n,o=u.call(arguments,1),r=this;return a?this.each(function(){var i,a=e.data(this,s);return"instance"===n?(r=a,!1):a?e.isFunction(a[n])&&"_"!==n.charAt(0)?(i=a[n].apply(a,o),i!==a&&void 0!==i?(r=i&&i.jquery?r.pushStack(i.get()):i,!1):void 0):e.error("no such method '"+n+"' for "+t+" widget instance"):e.error("cannot call methods on "+t+" prior to initialization; "+"attempted to call method '"+n+"'")}):(o.length&&(n=e.widget.extend.apply(null,[n].concat(o))),this.each(function(){var t=e.data(this,s);t?(t.option(n||{}),t._init&&t._init()):e.data(this,s,new i(n,this))})),r}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,i){i=e(i||this.defaultElement||this)[0],this.element=e(i),this.uuid=l++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=e(),this.hoverable=e(),this.focusable=e(),i!==this&&(e.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===i&&this.destroy()}}),this.document=e(i.style?i.ownerDocument:i.document||i),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(t,i){var s,n,a,o=t;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof t)if(o={},s=t.split("."),t=s.shift(),s.length){for(n=o[t]=e.widget.extend({},this.options[t]),a=0;s.length-1>a;a++)n[s[a]]=n[s[a]]||{},n=n[s[a]];if(t=s.pop(),1===arguments.length)return void 0===n[t]?null:n[t];n[t]=i}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=i}return this._setOptions(o),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled",!!t),t&&(this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus"))),this},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_on:function(t,i,s){var n,a=this;"boolean"!=typeof t&&(s=i,i=t,t=!1),s?(i=n=e(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),e.each(s,function(s,o){function r(){return t||a.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof o?a[o]:o).apply(a,arguments):void 0}"string"!=typeof o&&(r.guid=o.guid=o.guid||r.guid||e.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+a.eventNamespace,u=h[2];u?n.delegate(u,l,r):i.bind(l,r)})},_off:function(t,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,t.unbind(i).undelegate(i),this.bindings=e(this.bindings.not(t).get()),this.focusable=e(this.focusable.not(t).get()),this.hoverable=e(this.hoverable.not(t).get())},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var n,a,o=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],a=i.originalEvent)for(n in a)n in i||(i[n]=a[n]);return this.element.trigger(i,s),!(e.isFunction(o)&&o.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,n,a){"string"==typeof n&&(n={effect:n});var o,r=n?n===!0||"number"==typeof n?i:n.effect||i:t;n=n||{},"number"==typeof n&&(n={duration:n}),o=!e.isEmptyObject(n),n.complete=a,n.delay&&s.delay(n.delay),o&&e.effects&&e.effects.effect[r]?s[t](n):r!==t&&s[r]?s[r](n.duration,n.easing,a):s.queue(function(i){e(this)[t](),a&&a.call(s[0]),i()})}}),e.widget;var d=!1;e(document).mouseup(function(){d=!1}),e.widget("ui.mouse",{version:"1.11.4",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(t){if(!d){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(t),this._mouseDownEvent=t;var i=this,s=1===t.which,n="string"==typeof this.options.cancel&&t.target.nodeName?e(t.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(t)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(t)!==!1,!this._mouseStarted)?(t.preventDefault(),!0):(!0===e.data(t.target,this.widgetName+".preventClickEvent")&&e.removeData(t.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return i._mouseMove(e)},this._mouseUpDelegate=function(e){return i._mouseUp(e)},this.document.bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),t.preventDefault(),d=!0,!0)):!0}},_mouseMove:function(t){if(this._mouseMoved){if(e.ui.ie&&(!document.documentMode||9>document.documentMode)&&!t.button)return this._mouseUp(t);if(!t.which)return this._mouseUp(t)}return(t.which||t.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted)},_mouseUp:function(t){return this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),d=!1,!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),function(){function t(e,t,i){return[parseFloat(e[0])*(p.test(e[0])?t/100:1),parseFloat(e[1])*(p.test(e[1])?i/100:1)]}function i(t,i){return parseInt(e.css(t,i),10)||0}function s(t){var i=t[0];return 9===i.nodeType?{width:t.width(),height:t.height(),offset:{top:0,left:0}}:e.isWindow(i)?{width:t.width(),height:t.height(),offset:{top:t.scrollTop(),left:t.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:t.outerWidth(),height:t.outerHeight(),offset:t.offset()}}e.ui=e.ui||{};var n,a,o=Math.max,r=Math.abs,h=Math.round,l=/left|center|right/,u=/top|center|bottom/,d=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,p=/%$/,f=e.fn.position;e.position={scrollbarWidth:function(){if(void 0!==n)return n;var t,i,s=e("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),a=s.children()[0];return e("body").append(s),t=a.offsetWidth,s.css("overflow","scroll"),i=a.offsetWidth,t===i&&(i=s[0].clientWidth),s.remove(),n=t-i},getScrollInfo:function(t){var i=t.isWindow||t.isDocument?"":t.element.css("overflow-x"),s=t.isWindow||t.isDocument?"":t.element.css("overflow-y"),n="scroll"===i||"auto"===i&&t.width<t.element[0].scrollWidth,a="scroll"===s||"auto"===s&&t.height<t.element[0].scrollHeight;return{width:a?e.position.scrollbarWidth():0,height:n?e.position.scrollbarWidth():0}},getWithinInfo:function(t){var i=e(t||window),s=e.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType;return{element:i,isWindow:s,isDocument:n,offset:i.offset()||{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:s||n?i.width():i.outerWidth(),height:s||n?i.height():i.outerHeight()}}},e.fn.position=function(n){if(!n||!n.of)return f.apply(this,arguments);n=e.extend({},n);var p,m,g,v,y,b,_=e(n.of),x=e.position.getWithinInfo(n.within),w=e.position.getScrollInfo(x),k=(n.collision||"flip").split(" "),T={};return b=s(_),_[0].preventDefault&&(n.at="left top"),m=b.width,g=b.height,v=b.offset,y=e.extend({},v),e.each(["my","at"],function(){var e,t,i=(n[this]||"").split(" ");1===i.length&&(i=l.test(i[0])?i.concat(["center"]):u.test(i[0])?["center"].concat(i):["center","center"]),i[0]=l.test(i[0])?i[0]:"center",i[1]=u.test(i[1])?i[1]:"center",e=d.exec(i[0]),t=d.exec(i[1]),T[this]=[e?e[0]:0,t?t[0]:0],n[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===k.length&&(k[1]=k[0]),"right"===n.at[0]?y.left+=m:"center"===n.at[0]&&(y.left+=m/2),"bottom"===n.at[1]?y.top+=g:"center"===n.at[1]&&(y.top+=g/2),p=t(T.at,m,g),y.left+=p[0],y.top+=p[1],this.each(function(){var s,l,u=e(this),d=u.outerWidth(),c=u.outerHeight(),f=i(this,"marginLeft"),b=i(this,"marginTop"),D=d+f+i(this,"marginRight")+w.width,S=c+b+i(this,"marginBottom")+w.height,M=e.extend({},y),C=t(T.my,u.outerWidth(),u.outerHeight());"right"===n.my[0]?M.left-=d:"center"===n.my[0]&&(M.left-=d/2),"bottom"===n.my[1]?M.top-=c:"center"===n.my[1]&&(M.top-=c/2),M.left+=C[0],M.top+=C[1],a||(M.left=h(M.left),M.top=h(M.top)),s={marginLeft:f,marginTop:b},e.each(["left","top"],function(t,i){e.ui.position[k[t]]&&e.ui.position[k[t]][i](M,{targetWidth:m,targetHeight:g,elemWidth:d,elemHeight:c,collisionPosition:s,collisionWidth:D,collisionHeight:S,offset:[p[0]+C[0],p[1]+C[1]],my:n.my,at:n.at,within:x,elem:u})}),n.using&&(l=function(e){var t=v.left-M.left,i=t+m-d,s=v.top-M.top,a=s+g-c,h={target:{element:_,left:v.left,top:v.top,width:m,height:g},element:{element:u,left:M.left,top:M.top,width:d,height:c},horizontal:0>i?"left":t>0?"right":"center",vertical:0>a?"top":s>0?"bottom":"middle"};d>m&&m>r(t+i)&&(h.horizontal="center"),c>g&&g>r(s+a)&&(h.vertical="middle"),h.important=o(r(t),r(i))>o(r(s),r(a))?"horizontal":"vertical",n.using.call(this,e,h)}),u.offset(e.extend(M,{using:l}))})},e.ui.position={fit:{left:function(e,t){var i,s=t.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=e.left-t.collisionPosition.marginLeft,h=n-r,l=r+t.collisionWidth-a-n;t.collisionWidth>a?h>0&&0>=l?(i=e.left+h+t.collisionWidth-a-n,e.left+=h-i):e.left=l>0&&0>=h?n:h>l?n+a-t.collisionWidth:n:h>0?e.left+=h:l>0?e.left-=l:e.left=o(e.left-r,e.left)},top:function(e,t){var i,s=t.within,n=s.isWindow?s.scrollTop:s.offset.top,a=t.within.height,r=e.top-t.collisionPosition.marginTop,h=n-r,l=r+t.collisionHeight-a-n;t.collisionHeight>a?h>0&&0>=l?(i=e.top+h+t.collisionHeight-a-n,e.top+=h-i):e.top=l>0&&0>=h?n:h>l?n+a-t.collisionHeight:n:h>0?e.top+=h:l>0?e.top-=l:e.top=o(e.top-r,e.top)}},flip:{left:function(e,t){var i,s,n=t.within,a=n.offset.left+n.scrollLeft,o=n.width,h=n.isWindow?n.scrollLeft:n.offset.left,l=e.left-t.collisionPosition.marginLeft,u=l-h,d=l+t.collisionWidth-o-h,c="left"===t.my[0]?-t.elemWidth:"right"===t.my[0]?t.elemWidth:0,p="left"===t.at[0]?t.targetWidth:"right"===t.at[0]?-t.targetWidth:0,f=-2*t.offset[0];0>u?(i=e.left+c+p+f+t.collisionWidth-o-a,(0>i||r(u)>i)&&(e.left+=c+p+f)):d>0&&(s=e.left-t.collisionPosition.marginLeft+c+p+f-h,(s>0||d>r(s))&&(e.left+=c+p+f))},top:function(e,t){var i,s,n=t.within,a=n.offset.top+n.scrollTop,o=n.height,h=n.isWindow?n.scrollTop:n.offset.top,l=e.top-t.collisionPosition.marginTop,u=l-h,d=l+t.collisionHeight-o-h,c="top"===t.my[1],p=c?-t.elemHeight:"bottom"===t.my[1]?t.elemHeight:0,f="top"===t.at[1]?t.targetHeight:"bottom"===t.at[1]?-t.targetHeight:0,m=-2*t.offset[1];0>u?(s=e.top+p+f+m+t.collisionHeight-o-a,(0>s||r(u)>s)&&(e.top+=p+f+m)):d>0&&(i=e.top-t.collisionPosition.marginTop+p+f+m-h,(i>0||d>r(i))&&(e.top+=p+f+m))}},flipfit:{left:function(){e.ui.position.flip.left.apply(this,arguments),e.ui.position.fit.left.apply(this,arguments)},top:function(){e.ui.position.flip.top.apply(this,arguments),e.ui.position.fit.top.apply(this,arguments)}}},function(){var t,i,s,n,o,r=document.getElementsByTagName("body")[0],h=document.createElement("div");t=document.createElement(r?"div":"body"),s={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},r&&e.extend(s,{position:"absolute",left:"-1000px",top:"-1000px"});for(o in s)t.style[o]=s[o];t.appendChild(h),i=r||document.documentElement,i.insertBefore(t,i.firstChild),h.style.cssText="position: absolute; left: 10.7432222px;",n=e(h).offset().left,a=n>10&&11>n,t.innerHTML="",i.removeChild(t)}()}(),e.ui.position,e.widget("ui.accordion",{version:"1.11.4",options:{active:0,animate:{},collapsible:!1,event:"click",header:"> li > :first-child,> :not(li):even",heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},hideProps:{borderTopWidth:"hide",borderBottomWidth:"hide",paddingTop:"hide",paddingBottom:"hide",height:"hide"},showProps:{borderTopWidth:"show",borderBottomWidth:"show",paddingTop:"show",paddingBottom:"show",height:"show"},_create:function(){var t=this.options;this.prevShow=this.prevHide=e(),this.element.addClass("ui-accordion ui-widget ui-helper-reset").attr("role","tablist"),t.collapsible||t.active!==!1&&null!=t.active||(t.active=0),this._processPanels(),0>t.active&&(t.active+=this.headers.length),this._refresh()},_getCreateEventData:function(){return{header:this.active,panel:this.active.length?this.active.next():e()}},_createIcons:function(){var t=this.options.icons;t&&(e("<span>").addClass("ui-accordion-header-icon ui-icon "+t.header).prependTo(this.headers),this.active.children(".ui-accordion-header-icon").removeClass(t.header).addClass(t.activeHeader),this.headers.addClass("ui-accordion-icons"))},_destroyIcons:function(){this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove()},_destroy:function(){var e;this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role"),this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").removeUniqueId(),this._destroyIcons(),e=this.headers.next().removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled").css("display","").removeAttr("role").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeUniqueId(),"content"!==this.options.heightStyle&&e.css("height","")},_setOption:function(e,t){return"active"===e?(this._activate(t),void 0):("event"===e&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(t)),this._super(e,t),"collapsible"!==e||t||this.options.active!==!1||this._activate(0),"icons"===e&&(this._destroyIcons(),t&&this._createIcons()),"disabled"===e&&(this.element.toggleClass("ui-state-disabled",!!t).attr("aria-disabled",t),this.headers.add(this.headers.next()).toggleClass("ui-state-disabled",!!t)),void 0)},_keydown:function(t){if(!t.altKey&&!t.ctrlKey){var i=e.ui.keyCode,s=this.headers.length,n=this.headers.index(t.target),a=!1;switch(t.keyCode){case i.RIGHT:case i.DOWN:a=this.headers[(n+1)%s];break;case i.LEFT:case i.UP:a=this.headers[(n-1+s)%s];break;case i.SPACE:case i.ENTER:this._eventHandler(t);break;case i.HOME:a=this.headers[0];break;case i.END:a=this.headers[s-1]}a&&(e(t.target).attr("tabIndex",-1),e(a).attr("tabIndex",0),a.focus(),t.preventDefault())}},_panelKeyDown:function(t){t.keyCode===e.ui.keyCode.UP&&t.ctrlKey&&e(t.currentTarget).prev().focus()},refresh:function(){var t=this.options;this._processPanels(),t.active===!1&&t.collapsible===!0||!this.headers.length?(t.active=!1,this.active=e()):t.active===!1?this._activate(0):this.active.length&&!e.contains(this.element[0],this.active[0])?this.headers.length===this.headers.find(".ui-state-disabled").length?(t.active=!1,this.active=e()):this._activate(Math.max(0,t.active-1)):t.active=this.headers.index(this.active),this._destroyIcons(),this._refresh()},_processPanels:function(){var e=this.headers,t=this.panels;this.headers=this.element.find(this.options.header).addClass("ui-accordion-header ui-state-default ui-corner-all"),this.panels=this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").filter(":not(.ui-accordion-content-active)").hide(),t&&(this._off(e.not(this.headers)),this._off(t.not(this.panels)))},_refresh:function(){var t,i=this.options,s=i.heightStyle,n=this.element.parent();this.active=this._findActive(i.active).addClass("ui-accordion-header-active ui-state-active ui-corner-top").removeClass("ui-corner-all"),this.active.next().addClass("ui-accordion-content-active").show(),this.headers.attr("role","tab").each(function(){var t=e(this),i=t.uniqueId().attr("id"),s=t.next(),n=s.uniqueId().attr("id");t.attr("aria-controls",n),s.attr("aria-labelledby",i)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}).next().attr({"aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}).next().attr({"aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._createIcons(),this._setupEvents(i.event),"fill"===s?(t=n.height(),this.element.siblings(":visible").each(function(){var i=e(this),s=i.css("position");"absolute"!==s&&"fixed"!==s&&(t-=i.outerHeight(!0))}),this.headers.each(function(){t-=e(this).outerHeight(!0)}),this.headers.next().each(function(){e(this).height(Math.max(0,t-e(this).innerHeight()+e(this).height()))}).css("overflow","auto")):"auto"===s&&(t=0,this.headers.next().each(function(){t=Math.max(t,e(this).css("height","").height())}).height(t))},_activate:function(t){var i=this._findActive(t)[0];i!==this.active[0]&&(i=i||this.active[0],this._eventHandler({target:i,currentTarget:i,preventDefault:e.noop}))},_findActive:function(t){return"number"==typeof t?this.headers.eq(t):e()},_setupEvents:function(t){var i={keydown:"_keydown"};t&&e.each(t.split(" "),function(e,t){i[t]="_eventHandler"}),this._off(this.headers.add(this.headers.next())),this._on(this.headers,i),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._hoverable(this.headers),this._focusable(this.headers)},_eventHandler:function(t){var i=this.options,s=this.active,n=e(t.currentTarget),a=n[0]===s[0],o=a&&i.collapsible,r=o?e():n.next(),h=s.next(),l={oldHeader:s,oldPanel:h,newHeader:o?e():n,newPanel:r};t.preventDefault(),a&&!i.collapsible||this._trigger("beforeActivate",t,l)===!1||(i.active=o?!1:this.headers.index(n),this.active=a?e():n,this._toggle(l),s.removeClass("ui-accordion-header-active ui-state-active"),i.icons&&s.children(".ui-accordion-header-icon").removeClass(i.icons.activeHeader).addClass(i.icons.header),a||(n.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top"),i.icons&&n.children(".ui-accordion-header-icon").removeClass(i.icons.header).addClass(i.icons.activeHeader),n.next().addClass("ui-accordion-content-active")))},_toggle:function(t){var i=t.newPanel,s=this.prevShow.length?this.prevShow:t.oldPanel;this.prevShow.add(this.prevHide).stop(!0,!0),this.prevShow=i,this.prevHide=s,this.options.animate?this._animate(i,s,t):(s.hide(),i.show(),this._toggleComplete(t)),s.attr({"aria-hidden":"true"}),s.prev().attr({"aria-selected":"false","aria-expanded":"false"}),i.length&&s.length?s.prev().attr({tabIndex:-1,"aria-expanded":"false"}):i.length&&this.headers.filter(function(){return 0===parseInt(e(this).attr("tabIndex"),10)}).attr("tabIndex",-1),i.attr("aria-hidden","false").prev().attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_animate:function(e,t,i){var s,n,a,o=this,r=0,h=e.css("box-sizing"),l=e.length&&(!t.length||e.index()<t.index()),u=this.options.animate||{},d=l&&u.down||u,c=function(){o._toggleComplete(i)};return"number"==typeof d&&(a=d),"string"==typeof d&&(n=d),n=n||d.easing||u.easing,a=a||d.duration||u.duration,t.length?e.length?(s=e.show().outerHeight(),t.animate(this.hideProps,{duration:a,easing:n,step:function(e,t){t.now=Math.round(e)}}),e.hide().animate(this.showProps,{duration:a,easing:n,complete:c,step:function(e,i){i.now=Math.round(e),"height"!==i.prop?"content-box"===h&&(r+=i.now):"content"!==o.options.heightStyle&&(i.now=Math.round(s-t.outerHeight()-r),r=0)}}),void 0):t.animate(this.hideProps,a,n,c):e.animate(this.showProps,a,n,c)},_toggleComplete:function(e){var t=e.oldPanel;t.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all"),t.length&&(t.parent()[0].className=t.parent()[0].className),this._trigger("activate",null,e)}}),e.widget("ui.menu",{version:"1.11.4",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-carat-1-e"},items:"> *",menus:"ul",position:{my:"left-1 top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content").toggleClass("ui-menu-icons",!!this.element.find(".ui-icon").length).attr({role:this.options.role,tabIndex:0}),this.options.disabled&&this.element.addClass("ui-state-disabled").attr("aria-disabled","true"),this._on({"mousedown .ui-menu-item":function(e){e.preventDefault()},"click .ui-menu-item":function(t){var i=e(t.target);!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(t),t.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(t):!this.element.is(":focus")&&e(this.document[0].activeElement).closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(t){if(!this.previousFilter){var i=e(t.currentTarget);
i.siblings(".ui-state-active").removeClass("ui-state-active"),this.focus(t,i)}},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(e,t){var i=this.active||this.element.find(this.options.items).eq(0);t||this.focus(e,i)},blur:function(t){this._delay(function(){e.contains(this.element[0],this.document[0].activeElement)||this.collapseAll(t)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(e){this._closeOnDocumentClick(e)&&this.collapseAll(e),this.mouseHandled=!1}})},_destroy:function(){this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-menu-icons ui-front").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show(),this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").removeUniqueId().removeClass("ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function(){var t=e(this);t.data("ui-menu-submenu-carat")&&t.remove()}),this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content")},_keydown:function(t){var i,s,n,a,o=!0;switch(t.keyCode){case e.ui.keyCode.PAGE_UP:this.previousPage(t);break;case e.ui.keyCode.PAGE_DOWN:this.nextPage(t);break;case e.ui.keyCode.HOME:this._move("first","first",t);break;case e.ui.keyCode.END:this._move("last","last",t);break;case e.ui.keyCode.UP:this.previous(t);break;case e.ui.keyCode.DOWN:this.next(t);break;case e.ui.keyCode.LEFT:this.collapse(t);break;case e.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(t);break;case e.ui.keyCode.ENTER:case e.ui.keyCode.SPACE:this._activate(t);break;case e.ui.keyCode.ESCAPE:this.collapse(t);break;default:o=!1,s=this.previousFilter||"",n=String.fromCharCode(t.keyCode),a=!1,clearTimeout(this.filterTimer),n===s?a=!0:n=s+n,i=this._filterMenuItems(n),i=a&&-1!==i.index(this.active.next())?this.active.nextAll(".ui-menu-item"):i,i.length||(n=String.fromCharCode(t.keyCode),i=this._filterMenuItems(n)),i.length?(this.focus(t,i),this.previousFilter=n,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}o&&t.preventDefault()},_activate:function(e){this.active.is(".ui-state-disabled")||(this.active.is("[aria-haspopup='true']")?this.expand(e):this.select(e))},refresh:function(){var t,i,s=this,n=this.options.icons.submenu,a=this.element.find(this.options.menus);this.element.toggleClass("ui-menu-icons",!!this.element.find(".ui-icon").length),a.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-front").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var t=e(this),i=t.parent(),s=e("<span>").addClass("ui-menu-icon ui-icon "+n).data("ui-menu-submenu-carat",!0);i.attr("aria-haspopup","true").prepend(s),t.attr("aria-labelledby",i.attr("id"))}),t=a.add(this.element),i=t.find(this.options.items),i.not(".ui-menu-item").each(function(){var t=e(this);s._isDivider(t)&&t.addClass("ui-widget-content ui-menu-divider")}),i.not(".ui-menu-item, .ui-menu-divider").addClass("ui-menu-item").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),i.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!e.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(e,t){"icons"===e&&this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(t.submenu),"disabled"===e&&this.element.toggleClass("ui-state-disabled",!!t).attr("aria-disabled",t),this._super(e,t)},focus:function(e,t){var i,s;this.blur(e,e&&"focus"===e.type),this._scrollIntoView(t),this.active=t.first(),s=this.active.addClass("ui-state-focus").removeClass("ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),this.active.parent().closest(".ui-menu-item").addClass("ui-state-active"),e&&"keydown"===e.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=t.children(".ui-menu"),i.length&&e&&/^mouse/.test(e.type)&&this._startOpening(i),this.activeMenu=t.parent(),this._trigger("focus",e,{item:t})},_scrollIntoView:function(t){var i,s,n,a,o,r;this._hasScroll()&&(i=parseFloat(e.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(e.css(this.activeMenu[0],"paddingTop"))||0,n=t.offset().top-this.activeMenu.offset().top-i-s,a=this.activeMenu.scrollTop(),o=this.activeMenu.height(),r=t.outerHeight(),0>n?this.activeMenu.scrollTop(a+n):n+r>o&&this.activeMenu.scrollTop(a+n-o+r))},blur:function(e,t){t||clearTimeout(this.timer),this.active&&(this.active.removeClass("ui-state-focus"),this.active=null,this._trigger("blur",e,{item:this.active}))},_startOpening:function(e){clearTimeout(this.timer),"true"===e.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(e)},this.delay))},_open:function(t){var i=e.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden","true"),t.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(t,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:e(t&&t.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(t),this.activeMenu=s},this.delay)},_close:function(e){e||(e=this.active?this.active.parent():this.element),e.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false").end().find(".ui-state-active").not(".ui-state-focus").removeClass("ui-state-active")},_closeOnDocumentClick:function(t){return!e(t.target).closest(".ui-menu").length},_isDivider:function(e){return!/[^\-\u2014\u2013\s]/.test(e.text())},collapse:function(e){var t=this.active&&this.active.parent().closest(".ui-menu-item",this.element);t&&t.length&&(this._close(),this.focus(e,t))},expand:function(e){var t=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();t&&t.length&&(this._open(t.parent()),this._delay(function(){this.focus(e,t)}))},next:function(e){this._move("next","first",e)},previous:function(e){this._move("prev","last",e)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(e,t,i){var s;this.active&&(s="first"===e||"last"===e?this.active["first"===e?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[e+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.find(this.options.items)[t]()),this.focus(i,s)},nextPage:function(t){var i,s,n;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=e(this),0>i.offset().top-s-n}),this.focus(t,i)):this.focus(t,this.activeMenu.find(this.options.items)[this.active?"last":"first"]())),void 0):(this.next(t),void 0)},previousPage:function(t){var i,s,n;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=e(this),i.offset().top-s+n>0}),this.focus(t,i)):this.focus(t,this.activeMenu.find(this.options.items).first())),void 0):(this.next(t),void 0)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(t){this.active=this.active||e(t.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(t,!0),this._trigger("select",t,i)},_filterMenuItems:function(t){var i=t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),s=RegExp("^"+i,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return s.test(e.trim(e(this).text()))})}}),e.widget("ui.autocomplete",{version:"1.11.4",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var t,i,s,n=this.element[0].nodeName.toLowerCase(),a="textarea"===n,o="input"===n;this.isMultiLine=a?!0:o?!1:this.element.prop("isContentEditable"),this.valueMethod=this.element[a||o?"val":"text"],this.isNewMenu=!0,this.element.addClass("ui-autocomplete-input").attr("autocomplete","off"),this._on(this.element,{keydown:function(n){if(this.element.prop("readOnly"))return t=!0,s=!0,i=!0,void 0;t=!1,s=!1,i=!1;var a=e.ui.keyCode;switch(n.keyCode){case a.PAGE_UP:t=!0,this._move("previousPage",n);break;case a.PAGE_DOWN:t=!0,this._move("nextPage",n);break;case a.UP:t=!0,this._keyEvent("previous",n);break;case a.DOWN:t=!0,this._keyEvent("next",n);break;case a.ENTER:this.menu.active&&(t=!0,n.preventDefault(),this.menu.select(n));break;case a.TAB:this.menu.active&&this.menu.select(n);break;case a.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(n),n.preventDefault());break;default:i=!0,this._searchTimeout(n)}},keypress:function(s){if(t)return t=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),void 0;if(!i){var n=e.ui.keyCode;switch(s.keyCode){case n.PAGE_UP:this._move("previousPage",s);break;case n.PAGE_DOWN:this._move("nextPage",s);break;case n.UP:this._keyEvent("previous",s);break;case n.DOWN:this._keyEvent("next",s)}}},input:function(e){return s?(s=!1,e.preventDefault(),void 0):(this._searchTimeout(e),void 0)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(e){return this.cancelBlur?(delete this.cancelBlur,void 0):(clearTimeout(this.searching),this.close(e),this._change(e),void 0)}}),this._initSource(),this.menu=e("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur});var i=this.menu.element[0];e(t.target).closest(".ui-menu-item").length||this._delay(function(){var t=this;this.document.one("mousedown",function(s){s.target===t.element[0]||s.target===i||e.contains(i,s.target)||t.close()})})},menufocus:function(t,i){var s,n;return this.isNewMenu&&(this.isNewMenu=!1,t.originalEvent&&/^mouse/.test(t.originalEvent.type))?(this.menu.blur(),this.document.one("mousemove",function(){e(t.target).trigger(t.originalEvent)}),void 0):(n=i.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",t,{item:n})&&t.originalEvent&&/^key/.test(t.originalEvent.type)&&this._value(n.value),s=i.item.attr("aria-label")||n.value,s&&e.trim(s).length&&(this.liveRegion.children().hide(),e("<div>").text(s).appendTo(this.liveRegion)),void 0)},menuselect:function(e,t){var i=t.item.data("ui-autocomplete-item"),s=this.previous;this.element[0]!==this.document[0].activeElement&&(this.element.focus(),this.previous=s,this._delay(function(){this.previous=s,this.selectedItem=i})),!1!==this._trigger("select",e,{item:i})&&this._value(i.value),this.term=this._value(),this.close(e),this.selectedItem=i}}),this.liveRegion=e("<span>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(e,t){this._super(e,t),"source"===e&&this._initSource(),"appendTo"===e&&this.menu.element.appendTo(this._appendTo()),"disabled"===e&&t&&this.xhr&&this.xhr.abort()},_appendTo:function(){var t=this.options.appendTo;return t&&(t=t.jquery||t.nodeType?e(t):this.document.find(t).eq(0)),t&&t[0]||(t=this.element.closest(".ui-front")),t.length||(t=this.document[0].body),t},_initSource:function(){var t,i,s=this;e.isArray(this.options.source)?(t=this.options.source,this.source=function(i,s){s(e.ui.autocomplete.filter(t,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(t,n){s.xhr&&s.xhr.abort(),s.xhr=e.ajax({url:i,data:t,dataType:"json",success:function(e){n(e)},error:function(){n([])}})}):this.source=this.options.source},_searchTimeout:function(e){clearTimeout(this.searching),this.searching=this._delay(function(){var t=this.term===this._value(),i=this.menu.element.is(":visible"),s=e.altKey||e.ctrlKey||e.metaKey||e.shiftKey;(!t||t&&!i&&!s)&&(this.selectedItem=null,this.search(null,e))},this.options.delay)},search:function(e,t){return e=null!=e?e:this._value(),this.term=this._value(),e.length<this.options.minLength?this.close(t):this._trigger("search",t)!==!1?this._search(e):void 0},_search:function(e){this.pending++,this.element.addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:e},this._response())},_response:function(){var t=++this.requestIndex;return e.proxy(function(e){t===this.requestIndex&&this.__response(e),this.pending--,this.pending||this.element.removeClass("ui-autocomplete-loading")},this)},__response:function(e){e&&(e=this._normalize(e)),this._trigger("response",null,{content:e}),!this.options.disabled&&e&&e.length&&!this.cancelSearch?(this._suggest(e),this._trigger("open")):this._close()},close:function(e){this.cancelSearch=!0,this._close(e)},_close:function(e){this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",e))},_change:function(e){this.previous!==this._value()&&this._trigger("change",e,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:e.map(t,function(t){return"string"==typeof t?{label:t,value:t}:e.extend({},t,{label:t.label||t.value,value:t.value||t.label})})},_suggest:function(t){var i=this.menu.element.empty();this._renderMenu(i,t),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(e.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next()},_resizeMenu:function(){var e=this.menu.element;e.outerWidth(Math.max(e.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(t,i){var s=this;e.each(i,function(e,i){s._renderItemData(t,i)})},_renderItemData:function(e,t){return this._renderItem(e,t).data("ui-autocomplete-item",t)},_renderItem:function(t,i){return e("<li>").text(i.label).appendTo(t)},_move:function(e,t){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(e)||this.menu.isLastItem()&&/^next/.test(e)?(this.isMultiLine||this._value(this.term),this.menu.blur(),void 0):(this.menu[e](t),void 0):(this.search(null,t),void 0)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(e,t){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(e,t),t.preventDefault())}}),e.extend(e.ui.autocomplete,{escapeRegex:function(e){return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(t,i){var s=RegExp(e.ui.autocomplete.escapeRegex(i),"i");return e.grep(t,function(e){return s.test(e.label||e.value||e)})}}),e.widget("ui.autocomplete",e.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(e){return e+(e>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(t){var i;this._superApply(arguments),this.options.disabled||this.cancelSearch||(i=t&&t.length?this.options.messages.results(t.length):this.options.messages.noResults,this.liveRegion.children().hide(),e("<div>").text(i).appendTo(this.liveRegion))}}),e.ui.autocomplete;var c,p="ui-button ui-widget ui-state-default ui-corner-all",f="ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",m=function(){var t=e(this);setTimeout(function(){t.find(":ui-button").button("refresh")},1)},g=function(t){var i=t.name,s=t.form,n=e([]);return i&&(i=i.replace(/'/g,"\\'"),n=s?e(s).find("[name='"+i+"'][type=radio]"):e("[name='"+i+"'][type=radio]",t.ownerDocument).filter(function(){return!this.form})),n};e.widget("ui.button",{version:"1.11.4",defaultElement:"<button>",options:{disabled:null,text:!0,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset"+this.eventNamespace).bind("reset"+this.eventNamespace,m),"boolean"!=typeof this.options.disabled?this.options.disabled=!!this.element.prop("disabled"):this.element.prop("disabled",this.options.disabled),this._determineButtonType(),this.hasTitle=!!this.buttonElement.attr("title");var t=this,i=this.options,s="checkbox"===this.type||"radio"===this.type,n=s?"":"ui-state-active";null===i.label&&(i.label="input"===this.type?this.buttonElement.val():this.buttonElement.html()),this._hoverable(this.buttonElement),this.buttonElement.addClass(p).attr("role","button").bind("mouseenter"+this.eventNamespace,function(){i.disabled||this===c&&e(this).addClass("ui-state-active")}).bind("mouseleave"+this.eventNamespace,function(){i.disabled||e(this).removeClass(n)}).bind("click"+this.eventNamespace,function(e){i.disabled&&(e.preventDefault(),e.stopImmediatePropagation())}),this._on({focus:function(){this.buttonElement.addClass("ui-state-focus")},blur:function(){this.buttonElement.removeClass("ui-state-focus")}}),s&&this.element.bind("change"+this.eventNamespace,function(){t.refresh()}),"checkbox"===this.type?this.buttonElement.bind("click"+this.eventNamespace,function(){return i.disabled?!1:void 0}):"radio"===this.type?this.buttonElement.bind("click"+this.eventNamespace,function(){if(i.disabled)return!1;e(this).addClass("ui-state-active"),t.buttonElement.attr("aria-pressed","true");var s=t.element[0];g(s).not(s).map(function(){return e(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed","false")}):(this.buttonElement.bind("mousedown"+this.eventNamespace,function(){return i.disabled?!1:(e(this).addClass("ui-state-active"),c=this,t.document.one("mouseup",function(){c=null}),void 0)}).bind("mouseup"+this.eventNamespace,function(){return i.disabled?!1:(e(this).removeClass("ui-state-active"),void 0)}).bind("keydown"+this.eventNamespace,function(t){return i.disabled?!1:((t.keyCode===e.ui.keyCode.SPACE||t.keyCode===e.ui.keyCode.ENTER)&&e(this).addClass("ui-state-active"),void 0)}).bind("keyup"+this.eventNamespace+" blur"+this.eventNamespace,function(){e(this).removeClass("ui-state-active")}),this.buttonElement.is("a")&&this.buttonElement.keyup(function(t){t.keyCode===e.ui.keyCode.SPACE&&e(this).click()})),this._setOption("disabled",i.disabled),this._resetButton()},_determineButtonType:function(){var e,t,i;this.type=this.element.is("[type=checkbox]")?"checkbox":this.element.is("[type=radio]")?"radio":this.element.is("input")?"input":"button","checkbox"===this.type||"radio"===this.type?(e=this.element.parents().last(),t="label[for='"+this.element.attr("id")+"']",this.buttonElement=e.find(t),this.buttonElement.length||(e=e.length?e.siblings():this.element.siblings(),this.buttonElement=e.filter(t),this.buttonElement.length||(this.buttonElement=e.find(t))),this.element.addClass("ui-helper-hidden-accessible"),i=this.element.is(":checked"),i&&this.buttonElement.addClass("ui-state-active"),this.buttonElement.prop("aria-pressed",i)):this.buttonElement=this.element},widget:function(){return this.buttonElement},_destroy:function(){this.element.removeClass("ui-helper-hidden-accessible"),this.buttonElement.removeClass(p+" ui-state-active "+f).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()),this.hasTitle||this.buttonElement.removeAttr("title")},_setOption:function(e,t){return this._super(e,t),"disabled"===e?(this.widget().toggleClass("ui-state-disabled",!!t),this.element.prop("disabled",!!t),t&&("checkbox"===this.type||"radio"===this.type?this.buttonElement.removeClass("ui-state-focus"):this.buttonElement.removeClass("ui-state-focus ui-state-active")),void 0):(this._resetButton(),void 0)},refresh:function(){var t=this.element.is("input, button")?this.element.is(":disabled"):this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOption("disabled",t),"radio"===this.type?g(this.element[0]).each(function(){e(this).is(":checked")?e(this).button("widget").addClass("ui-state-active").attr("aria-pressed","true"):e(this).button("widget").removeClass("ui-state-active").attr("aria-pressed","false")}):"checkbox"===this.type&&(this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed","true"):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed","false"))},_resetButton:function(){if("input"===this.type)return this.options.label&&this.element.val(this.options.label),void 0;var t=this.buttonElement.removeClass(f),i=e("<span></span>",this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(t.empty()).text(),s=this.options.icons,n=s.primary&&s.secondary,a=[];s.primary||s.secondary?(this.options.text&&a.push("ui-button-text-icon"+(n?"s":s.primary?"-primary":"-secondary")),s.primary&&t.prepend("<span class='ui-button-icon-primary ui-icon "+s.primary+"'></span>"),s.secondary&&t.append("<span class='ui-button-icon-secondary ui-icon "+s.secondary+"'></span>"),this.options.text||(a.push(n?"ui-button-icons-only":"ui-button-icon-only"),this.hasTitle||t.attr("title",e.trim(i)))):a.push("ui-button-text-only"),t.addClass(a.join(" "))}}),e.widget("ui.buttonset",{version:"1.11.4",options:{items:"button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(e,t){"disabled"===e&&this.buttons.button("option",e,t),this._super(e,t)},refresh:function(){var t="rtl"===this.element.css("direction"),i=this.element.find(this.options.items),s=i.filter(":ui-button");i.not(":ui-button").button(),s.button("refresh"),this.buttons=i.map(function(){return e(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(t?"ui-corner-right":"ui-corner-left").end().filter(":last").addClass(t?"ui-corner-left":"ui-corner-right").end().end()},_destroy:function(){this.element.removeClass("ui-buttonset"),this.buttons.map(function(){return e(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy")}}),e.ui.button,e.extend(e.ui,{datepicker:{version:"1.11.4"}});var v;e.extend(n.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(e){return r(this._defaults,e||{}),this},_attachDatepicker:function(t,i){var s,n,a;s=t.nodeName.toLowerCase(),n="div"===s||"span"===s,t.id||(this.uuid+=1,t.id="dp"+this.uuid),a=this._newInst(e(t),n),a.settings=e.extend({},i||{}),"input"===s?this._connectDatepicker(t,a):n&&this._inlineDatepicker(t,a)},_newInst:function(t,i){var s=t[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1");return{id:s,input:t,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:i,dpDiv:i?a(e("<div class='"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")):this.dpDiv}},_connectDatepicker:function(t,i){var s=e(t);i.append=e([]),i.trigger=e([]),s.hasClass(this.markerClassName)||(this._attachments(s,i),s.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp),this._autoSize(i),e.data(t,"datepicker",i),i.settings.disabled&&this._disableDatepicker(t))},_attachments:function(t,i){var s,n,a,o=this._get(i,"appendText"),r=this._get(i,"isRTL");i.append&&i.append.remove(),o&&(i.append=e("<span class='"+this._appendClass+"'>"+o+"</span>"),t[r?"before":"after"](i.append)),t.unbind("focus",this._showDatepicker),i.trigger&&i.trigger.remove(),s=this._get(i,"showOn"),("focus"===s||"both"===s)&&t.focus(this._showDatepicker),("button"===s||"both"===s)&&(n=this._get(i,"buttonText"),a=this._get(i,"buttonImage"),i.trigger=e(this._get(i,"buttonImageOnly")?e("<img/>").addClass(this._triggerClass).attr({src:a,alt:n,title:n}):e("<button type='button'></button>").addClass(this._triggerClass).html(a?e("<img/>").attr({src:a,alt:n,title:n}):n)),t[r?"before":"after"](i.trigger),i.trigger.click(function(){return e.datepicker._datepickerShowing&&e.datepicker._lastInput===t[0]?e.datepicker._hideDatepicker():e.datepicker._datepickerShowing&&e.datepicker._lastInput!==t[0]?(e.datepicker._hideDatepicker(),e.datepicker._showDatepicker(t[0])):e.datepicker._showDatepicker(t[0]),!1}))},_autoSize:function(e){if(this._get(e,"autoSize")&&!e.inline){var t,i,s,n,a=new Date(2009,11,20),o=this._get(e,"dateFormat");o.match(/[DM]/)&&(t=function(e){for(i=0,s=0,n=0;e.length>n;n++)e[n].length>i&&(i=e[n].length,s=n);return s},a.setMonth(t(this._get(e,o.match(/MM/)?"monthNames":"monthNamesShort"))),a.setDate(t(this._get(e,o.match(/DD/)?"dayNames":"dayNamesShort"))+20-a.getDay())),e.input.attr("size",this._formatDate(e,a).length)}},_inlineDatepicker:function(t,i){var s=e(t);s.hasClass(this.markerClassName)||(s.addClass(this.markerClassName).append(i.dpDiv),e.data(t,"datepicker",i),this._setDate(i,this._getDefaultDate(i),!0),this._updateDatepicker(i),this._updateAlternate(i),i.settings.disabled&&this._disableDatepicker(t),i.dpDiv.css("display","block"))},_dialogDatepicker:function(t,i,s,n,a){var o,h,l,u,d,c=this._dialogInst;return c||(this.uuid+=1,o="dp"+this.uuid,this._dialogInput=e("<input type='text' id='"+o+"' style='position: absolute; top: -100px; width: 0px;'/>"),this._dialogInput.keydown(this._doKeyDown),e("body").append(this._dialogInput),c=this._dialogInst=this._newInst(this._dialogInput,!1),c.settings={},e.data(this._dialogInput[0],"datepicker",c)),r(c.settings,n||{}),i=i&&i.constructor===Date?this._formatDate(c,i):i,this._dialogInput.val(i),this._pos=a?a.length?a:[a.pageX,a.pageY]:null,this._pos||(h=document.documentElement.clientWidth,l=document.documentElement.clientHeight,u=document.documentElement.scrollLeft||document.body.scrollLeft,d=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[h/2-100+u,l/2-150+d]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),c.settings.onSelect=s,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),e.blockUI&&e.blockUI(this.dpDiv),e.data(this._dialogInput[0],"datepicker",c),this},_destroyDatepicker:function(t){var i,s=e(t),n=e.data(t,"datepicker");s.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),e.removeData(t,"datepicker"),"input"===i?(n.append.remove(),n.trigger.remove(),s.removeClass(this.markerClassName).unbind("focus",this._showDatepicker).unbind("keydown",this._doKeyDown).unbind("keypress",this._doKeyPress).unbind("keyup",this._doKeyUp)):("div"===i||"span"===i)&&s.removeClass(this.markerClassName).empty(),v===n&&(v=null))},_enableDatepicker:function(t){var i,s,n=e(t),a=e.data(t,"datepicker");n.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),"input"===i?(t.disabled=!1,a.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().removeClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)),this._disabledInputs=e.map(this._disabledInputs,function(e){return e===t?null:e}))},_disableDatepicker:function(t){var i,s,n=e(t),a=e.data(t,"datepicker");n.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),"input"===i?(t.disabled=!0,a.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().addClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)),this._disabledInputs=e.map(this._disabledInputs,function(e){return e===t?null:e}),this._disabledInputs[this._disabledInputs.length]=t)},_isDisabledDatepicker:function(e){if(!e)return!1;for(var t=0;this._disabledInputs.length>t;t++)if(this._disabledInputs[t]===e)return!0;return!1},_getInst:function(t){try{return e.data(t,"datepicker")}catch(i){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(t,i,s){var n,a,o,h,l=this._getInst(t);return 2===arguments.length&&"string"==typeof i?"defaults"===i?e.extend({},e.datepicker._defaults):l?"all"===i?e.extend({},l.settings):this._get(l,i):null:(n=i||{},"string"==typeof i&&(n={},n[i]=s),l&&(this._curInst===l&&this._hideDatepicker(),a=this._getDateDatepicker(t,!0),o=this._getMinMaxDate(l,"min"),h=this._getMinMaxDate(l,"max"),r(l.settings,n),null!==o&&void 0!==n.dateFormat&&void 0===n.minDate&&(l.settings.minDate=this._formatDate(l,o)),null!==h&&void 0!==n.dateFormat&&void 0===n.maxDate&&(l.settings.maxDate=this._formatDate(l,h)),"disabled"in n&&(n.disabled?this._disableDatepicker(t):this._enableDatepicker(t)),this._attachments(e(t),l),this._autoSize(l),this._setDate(l,a),this._updateAlternate(l),this._updateDatepicker(l)),void 0)},_changeDatepicker:function(e,t,i){this._optionDatepicker(e,t,i)},_refreshDatepicker:function(e){var t=this._getInst(e);t&&this._updateDatepicker(t)},_setDateDatepicker:function(e,t){var i=this._getInst(e);i&&(this._setDate(i,t),this._updateDatepicker(i),this._updateAlternate(i))},_getDateDatepicker:function(e,t){var i=this._getInst(e);return i&&!i.inline&&this._setDateFromField(i,t),i?this._getDate(i):null},_doKeyDown:function(t){var i,s,n,a=e.datepicker._getInst(t.target),o=!0,r=a.dpDiv.is(".ui-datepicker-rtl");if(a._keyEvent=!0,e.datepicker._datepickerShowing)switch(t.keyCode){case 9:e.datepicker._hideDatepicker(),o=!1;break;case 13:return n=e("td."+e.datepicker._dayOverClass+":not(."+e.datepicker._currentClass+")",a.dpDiv),n[0]&&e.datepicker._selectDay(t.target,a.selectedMonth,a.selectedYear,n[0]),i=e.datepicker._get(a,"onSelect"),i?(s=e.datepicker._formatDate(a),i.apply(a.input?a.input[0]:null,[s,a])):e.datepicker._hideDatepicker(),!1;case 27:e.datepicker._hideDatepicker();break;case 33:e.datepicker._adjustDate(t.target,t.ctrlKey?-e.datepicker._get(a,"stepBigMonths"):-e.datepicker._get(a,"stepMonths"),"M");break;case 34:e.datepicker._adjustDate(t.target,t.ctrlKey?+e.datepicker._get(a,"stepBigMonths"):+e.datepicker._get(a,"stepMonths"),"M");break;case 35:(t.ctrlKey||t.metaKey)&&e.datepicker._clearDate(t.target),o=t.ctrlKey||t.metaKey;break;case 36:(t.ctrlKey||t.metaKey)&&e.datepicker._gotoToday(t.target),o=t.ctrlKey||t.metaKey;break;case 37:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,r?1:-1,"D"),o=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&e.datepicker._adjustDate(t.target,t.ctrlKey?-e.datepicker._get(a,"stepBigMonths"):-e.datepicker._get(a,"stepMonths"),"M");break;case 38:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,-7,"D"),o=t.ctrlKey||t.metaKey;break;case 39:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,r?-1:1,"D"),o=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&e.datepicker._adjustDate(t.target,t.ctrlKey?+e.datepicker._get(a,"stepBigMonths"):+e.datepicker._get(a,"stepMonths"),"M");break;case 40:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,7,"D"),o=t.ctrlKey||t.metaKey;break;default:o=!1}else 36===t.keyCode&&t.ctrlKey?e.datepicker._showDatepicker(this):o=!1;o&&(t.preventDefault(),t.stopPropagation())},_doKeyPress:function(t){var i,s,n=e.datepicker._getInst(t.target);
return e.datepicker._get(n,"constrainInput")?(i=e.datepicker._possibleChars(e.datepicker._get(n,"dateFormat")),s=String.fromCharCode(null==t.charCode?t.keyCode:t.charCode),t.ctrlKey||t.metaKey||" ">s||!i||i.indexOf(s)>-1):void 0},_doKeyUp:function(t){var i,s=e.datepicker._getInst(t.target);if(s.input.val()!==s.lastVal)try{i=e.datepicker.parseDate(e.datepicker._get(s,"dateFormat"),s.input?s.input.val():null,e.datepicker._getFormatConfig(s)),i&&(e.datepicker._setDateFromField(s),e.datepicker._updateAlternate(s),e.datepicker._updateDatepicker(s))}catch(n){}return!0},_showDatepicker:function(t){if(t=t.target||t,"input"!==t.nodeName.toLowerCase()&&(t=e("input",t.parentNode)[0]),!e.datepicker._isDisabledDatepicker(t)&&e.datepicker._lastInput!==t){var i,n,a,o,h,l,u;i=e.datepicker._getInst(t),e.datepicker._curInst&&e.datepicker._curInst!==i&&(e.datepicker._curInst.dpDiv.stop(!0,!0),i&&e.datepicker._datepickerShowing&&e.datepicker._hideDatepicker(e.datepicker._curInst.input[0])),n=e.datepicker._get(i,"beforeShow"),a=n?n.apply(t,[t,i]):{},a!==!1&&(r(i.settings,a),i.lastVal=null,e.datepicker._lastInput=t,e.datepicker._setDateFromField(i),e.datepicker._inDialog&&(t.value=""),e.datepicker._pos||(e.datepicker._pos=e.datepicker._findPos(t),e.datepicker._pos[1]+=t.offsetHeight),o=!1,e(t).parents().each(function(){return o|="fixed"===e(this).css("position"),!o}),h={left:e.datepicker._pos[0],top:e.datepicker._pos[1]},e.datepicker._pos=null,i.dpDiv.empty(),i.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),e.datepicker._updateDatepicker(i),h=e.datepicker._checkOffset(i,h,o),i.dpDiv.css({position:e.datepicker._inDialog&&e.blockUI?"static":o?"fixed":"absolute",display:"none",left:h.left+"px",top:h.top+"px"}),i.inline||(l=e.datepicker._get(i,"showAnim"),u=e.datepicker._get(i,"duration"),i.dpDiv.css("z-index",s(e(t))+1),e.datepicker._datepickerShowing=!0,e.effects&&e.effects.effect[l]?i.dpDiv.show(l,e.datepicker._get(i,"showOptions"),u):i.dpDiv[l||"show"](l?u:null),e.datepicker._shouldFocusInput(i)&&i.input.focus(),e.datepicker._curInst=i))}},_updateDatepicker:function(t){this.maxRows=4,v=t,t.dpDiv.empty().append(this._generateHTML(t)),this._attachHandlers(t);var i,s=this._getNumberOfMonths(t),n=s[1],a=17,r=t.dpDiv.find("."+this._dayOverClass+" a");r.length>0&&o.apply(r.get(0)),t.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),n>1&&t.dpDiv.addClass("ui-datepicker-multi-"+n).css("width",a*n+"em"),t.dpDiv[(1!==s[0]||1!==s[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),t.dpDiv[(this._get(t,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),t===e.datepicker._curInst&&e.datepicker._datepickerShowing&&e.datepicker._shouldFocusInput(t)&&t.input.focus(),t.yearshtml&&(i=t.yearshtml,setTimeout(function(){i===t.yearshtml&&t.yearshtml&&t.dpDiv.find("select.ui-datepicker-year:first").replaceWith(t.yearshtml),i=t.yearshtml=null},0))},_shouldFocusInput:function(e){return e.input&&e.input.is(":visible")&&!e.input.is(":disabled")&&!e.input.is(":focus")},_checkOffset:function(t,i,s){var n=t.dpDiv.outerWidth(),a=t.dpDiv.outerHeight(),o=t.input?t.input.outerWidth():0,r=t.input?t.input.outerHeight():0,h=document.documentElement.clientWidth+(s?0:e(document).scrollLeft()),l=document.documentElement.clientHeight+(s?0:e(document).scrollTop());return i.left-=this._get(t,"isRTL")?n-o:0,i.left-=s&&i.left===t.input.offset().left?e(document).scrollLeft():0,i.top-=s&&i.top===t.input.offset().top+r?e(document).scrollTop():0,i.left-=Math.min(i.left,i.left+n>h&&h>n?Math.abs(i.left+n-h):0),i.top-=Math.min(i.top,i.top+a>l&&l>a?Math.abs(a+r):0),i},_findPos:function(t){for(var i,s=this._getInst(t),n=this._get(s,"isRTL");t&&("hidden"===t.type||1!==t.nodeType||e.expr.filters.hidden(t));)t=t[n?"previousSibling":"nextSibling"];return i=e(t).offset(),[i.left,i.top]},_hideDatepicker:function(t){var i,s,n,a,o=this._curInst;!o||t&&o!==e.data(t,"datepicker")||this._datepickerShowing&&(i=this._get(o,"showAnim"),s=this._get(o,"duration"),n=function(){e.datepicker._tidyDialog(o)},e.effects&&(e.effects.effect[i]||e.effects[i])?o.dpDiv.hide(i,e.datepicker._get(o,"showOptions"),s,n):o.dpDiv["slideDown"===i?"slideUp":"fadeIn"===i?"fadeOut":"hide"](i?s:null,n),i||n(),this._datepickerShowing=!1,a=this._get(o,"onClose"),a&&a.apply(o.input?o.input[0]:null,[o.input?o.input.val():"",o]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),e.blockUI&&(e.unblockUI(),e("body").append(this.dpDiv))),this._inDialog=!1)},_tidyDialog:function(e){e.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")},_checkExternalClick:function(t){if(e.datepicker._curInst){var i=e(t.target),s=e.datepicker._getInst(i[0]);(i[0].id!==e.datepicker._mainDivId&&0===i.parents("#"+e.datepicker._mainDivId).length&&!i.hasClass(e.datepicker.markerClassName)&&!i.closest("."+e.datepicker._triggerClass).length&&e.datepicker._datepickerShowing&&(!e.datepicker._inDialog||!e.blockUI)||i.hasClass(e.datepicker.markerClassName)&&e.datepicker._curInst!==s)&&e.datepicker._hideDatepicker()}},_adjustDate:function(t,i,s){var n=e(t),a=this._getInst(n[0]);this._isDisabledDatepicker(n[0])||(this._adjustInstDate(a,i+("M"===s?this._get(a,"showCurrentAtPos"):0),s),this._updateDatepicker(a))},_gotoToday:function(t){var i,s=e(t),n=this._getInst(s[0]);this._get(n,"gotoCurrent")&&n.currentDay?(n.selectedDay=n.currentDay,n.drawMonth=n.selectedMonth=n.currentMonth,n.drawYear=n.selectedYear=n.currentYear):(i=new Date,n.selectedDay=i.getDate(),n.drawMonth=n.selectedMonth=i.getMonth(),n.drawYear=n.selectedYear=i.getFullYear()),this._notifyChange(n),this._adjustDate(s)},_selectMonthYear:function(t,i,s){var n=e(t),a=this._getInst(n[0]);a["selected"+("M"===s?"Month":"Year")]=a["draw"+("M"===s?"Month":"Year")]=parseInt(i.options[i.selectedIndex].value,10),this._notifyChange(a),this._adjustDate(n)},_selectDay:function(t,i,s,n){var a,o=e(t);e(n).hasClass(this._unselectableClass)||this._isDisabledDatepicker(o[0])||(a=this._getInst(o[0]),a.selectedDay=a.currentDay=e("a",n).html(),a.selectedMonth=a.currentMonth=i,a.selectedYear=a.currentYear=s,this._selectDate(t,this._formatDate(a,a.currentDay,a.currentMonth,a.currentYear)))},_clearDate:function(t){var i=e(t);this._selectDate(i,"")},_selectDate:function(t,i){var s,n=e(t),a=this._getInst(n[0]);i=null!=i?i:this._formatDate(a),a.input&&a.input.val(i),this._updateAlternate(a),s=this._get(a,"onSelect"),s?s.apply(a.input?a.input[0]:null,[i,a]):a.input&&a.input.trigger("change"),a.inline?this._updateDatepicker(a):(this._hideDatepicker(),this._lastInput=a.input[0],"object"!=typeof a.input[0]&&a.input.focus(),this._lastInput=null)},_updateAlternate:function(t){var i,s,n,a=this._get(t,"altField");a&&(i=this._get(t,"altFormat")||this._get(t,"dateFormat"),s=this._getDate(t),n=this.formatDate(i,s,this._getFormatConfig(t)),e(a).each(function(){e(this).val(n)}))},noWeekends:function(e){var t=e.getDay();return[t>0&&6>t,""]},iso8601Week:function(e){var t,i=new Date(e.getTime());return i.setDate(i.getDate()+4-(i.getDay()||7)),t=i.getTime(),i.setMonth(0),i.setDate(1),Math.floor(Math.round((t-i)/864e5)/7)+1},parseDate:function(t,i,s){if(null==t||null==i)throw"Invalid arguments";if(i="object"==typeof i?""+i:i+"",""===i)return null;var n,a,o,r,h=0,l=(s?s.shortYearCutoff:null)||this._defaults.shortYearCutoff,u="string"!=typeof l?l:(new Date).getFullYear()%100+parseInt(l,10),d=(s?s.dayNamesShort:null)||this._defaults.dayNamesShort,c=(s?s.dayNames:null)||this._defaults.dayNames,p=(s?s.monthNamesShort:null)||this._defaults.monthNamesShort,f=(s?s.monthNames:null)||this._defaults.monthNames,m=-1,g=-1,v=-1,y=-1,b=!1,_=function(e){var i=t.length>n+1&&t.charAt(n+1)===e;return i&&n++,i},x=function(e){var t=_(e),s="@"===e?14:"!"===e?20:"y"===e&&t?4:"o"===e?3:2,n="y"===e?s:1,a=RegExp("^\\d{"+n+","+s+"}"),o=i.substring(h).match(a);if(!o)throw"Missing number at position "+h;return h+=o[0].length,parseInt(o[0],10)},w=function(t,s,n){var a=-1,o=e.map(_(t)?n:s,function(e,t){return[[t,e]]}).sort(function(e,t){return-(e[1].length-t[1].length)});if(e.each(o,function(e,t){var s=t[1];return i.substr(h,s.length).toLowerCase()===s.toLowerCase()?(a=t[0],h+=s.length,!1):void 0}),-1!==a)return a+1;throw"Unknown name at position "+h},k=function(){if(i.charAt(h)!==t.charAt(n))throw"Unexpected literal at position "+h;h++};for(n=0;t.length>n;n++)if(b)"'"!==t.charAt(n)||_("'")?k():b=!1;else switch(t.charAt(n)){case"d":v=x("d");break;case"D":w("D",d,c);break;case"o":y=x("o");break;case"m":g=x("m");break;case"M":g=w("M",p,f);break;case"y":m=x("y");break;case"@":r=new Date(x("@")),m=r.getFullYear(),g=r.getMonth()+1,v=r.getDate();break;case"!":r=new Date((x("!")-this._ticksTo1970)/1e4),m=r.getFullYear(),g=r.getMonth()+1,v=r.getDate();break;case"'":_("'")?k():b=!0;break;default:k()}if(i.length>h&&(o=i.substr(h),!/^\s+/.test(o)))throw"Extra/unparsed characters found in date: "+o;if(-1===m?m=(new Date).getFullYear():100>m&&(m+=(new Date).getFullYear()-(new Date).getFullYear()%100+(u>=m?0:-100)),y>-1)for(g=1,v=y;;){if(a=this._getDaysInMonth(m,g-1),a>=v)break;g++,v-=a}if(r=this._daylightSavingAdjust(new Date(m,g-1,v)),r.getFullYear()!==m||r.getMonth()+1!==g||r.getDate()!==v)throw"Invalid date";return r},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:1e7*60*60*24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925)),formatDate:function(e,t,i){if(!t)return"";var s,n=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,a=(i?i.dayNames:null)||this._defaults.dayNames,o=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,r=(i?i.monthNames:null)||this._defaults.monthNames,h=function(t){var i=e.length>s+1&&e.charAt(s+1)===t;return i&&s++,i},l=function(e,t,i){var s=""+t;if(h(e))for(;i>s.length;)s="0"+s;return s},u=function(e,t,i,s){return h(e)?s[t]:i[t]},d="",c=!1;if(t)for(s=0;e.length>s;s++)if(c)"'"!==e.charAt(s)||h("'")?d+=e.charAt(s):c=!1;else switch(e.charAt(s)){case"d":d+=l("d",t.getDate(),2);break;case"D":d+=u("D",t.getDay(),n,a);break;case"o":d+=l("o",Math.round((new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()-new Date(t.getFullYear(),0,0).getTime())/864e5),3);break;case"m":d+=l("m",t.getMonth()+1,2);break;case"M":d+=u("M",t.getMonth(),o,r);break;case"y":d+=h("y")?t.getFullYear():(10>t.getYear()%100?"0":"")+t.getYear()%100;break;case"@":d+=t.getTime();break;case"!":d+=1e4*t.getTime()+this._ticksTo1970;break;case"'":h("'")?d+="'":c=!0;break;default:d+=e.charAt(s)}return d},_possibleChars:function(e){var t,i="",s=!1,n=function(i){var s=e.length>t+1&&e.charAt(t+1)===i;return s&&t++,s};for(t=0;e.length>t;t++)if(s)"'"!==e.charAt(t)||n("'")?i+=e.charAt(t):s=!1;else switch(e.charAt(t)){case"d":case"m":case"y":case"@":i+="0123456789";break;case"D":case"M":return null;case"'":n("'")?i+="'":s=!0;break;default:i+=e.charAt(t)}return i},_get:function(e,t){return void 0!==e.settings[t]?e.settings[t]:this._defaults[t]},_setDateFromField:function(e,t){if(e.input.val()!==e.lastVal){var i=this._get(e,"dateFormat"),s=e.lastVal=e.input?e.input.val():null,n=this._getDefaultDate(e),a=n,o=this._getFormatConfig(e);try{a=this.parseDate(i,s,o)||n}catch(r){s=t?"":s}e.selectedDay=a.getDate(),e.drawMonth=e.selectedMonth=a.getMonth(),e.drawYear=e.selectedYear=a.getFullYear(),e.currentDay=s?a.getDate():0,e.currentMonth=s?a.getMonth():0,e.currentYear=s?a.getFullYear():0,this._adjustInstDate(e)}},_getDefaultDate:function(e){return this._restrictMinMax(e,this._determineDate(e,this._get(e,"defaultDate"),new Date))},_determineDate:function(t,i,s){var n=function(e){var t=new Date;return t.setDate(t.getDate()+e),t},a=function(i){try{return e.datepicker.parseDate(e.datepicker._get(t,"dateFormat"),i,e.datepicker._getFormatConfig(t))}catch(s){}for(var n=(i.toLowerCase().match(/^c/)?e.datepicker._getDate(t):null)||new Date,a=n.getFullYear(),o=n.getMonth(),r=n.getDate(),h=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,l=h.exec(i);l;){switch(l[2]||"d"){case"d":case"D":r+=parseInt(l[1],10);break;case"w":case"W":r+=7*parseInt(l[1],10);break;case"m":case"M":o+=parseInt(l[1],10),r=Math.min(r,e.datepicker._getDaysInMonth(a,o));break;case"y":case"Y":a+=parseInt(l[1],10),r=Math.min(r,e.datepicker._getDaysInMonth(a,o))}l=h.exec(i)}return new Date(a,o,r)},o=null==i||""===i?s:"string"==typeof i?a(i):"number"==typeof i?isNaN(i)?s:n(i):new Date(i.getTime());return o=o&&"Invalid Date"==""+o?s:o,o&&(o.setHours(0),o.setMinutes(0),o.setSeconds(0),o.setMilliseconds(0)),this._daylightSavingAdjust(o)},_daylightSavingAdjust:function(e){return e?(e.setHours(e.getHours()>12?e.getHours()+2:0),e):null},_setDate:function(e,t,i){var s=!t,n=e.selectedMonth,a=e.selectedYear,o=this._restrictMinMax(e,this._determineDate(e,t,new Date));e.selectedDay=e.currentDay=o.getDate(),e.drawMonth=e.selectedMonth=e.currentMonth=o.getMonth(),e.drawYear=e.selectedYear=e.currentYear=o.getFullYear(),n===e.selectedMonth&&a===e.selectedYear||i||this._notifyChange(e),this._adjustInstDate(e),e.input&&e.input.val(s?"":this._formatDate(e))},_getDate:function(e){var t=!e.currentYear||e.input&&""===e.input.val()?null:this._daylightSavingAdjust(new Date(e.currentYear,e.currentMonth,e.currentDay));return t},_attachHandlers:function(t){var i=this._get(t,"stepMonths"),s="#"+t.id.replace(/\\\\/g,"\\");t.dpDiv.find("[data-handler]").map(function(){var t={prev:function(){e.datepicker._adjustDate(s,-i,"M")},next:function(){e.datepicker._adjustDate(s,+i,"M")},hide:function(){e.datepicker._hideDatepicker()},today:function(){e.datepicker._gotoToday(s)},selectDay:function(){return e.datepicker._selectDay(s,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return e.datepicker._selectMonthYear(s,this,"M"),!1},selectYear:function(){return e.datepicker._selectMonthYear(s,this,"Y"),!1}};e(this).bind(this.getAttribute("data-event"),t[this.getAttribute("data-handler")])})},_generateHTML:function(e){var t,i,s,n,a,o,r,h,l,u,d,c,p,f,m,g,v,y,b,_,x,w,k,T,D,S,M,C,N,A,P,I,H,z,F,E,O,j,W,L=new Date,R=this._daylightSavingAdjust(new Date(L.getFullYear(),L.getMonth(),L.getDate())),Y=this._get(e,"isRTL"),B=this._get(e,"showButtonPanel"),J=this._get(e,"hideIfNoPrevNext"),q=this._get(e,"navigationAsDateFormat"),K=this._getNumberOfMonths(e),V=this._get(e,"showCurrentAtPos"),U=this._get(e,"stepMonths"),Q=1!==K[0]||1!==K[1],G=this._daylightSavingAdjust(e.currentDay?new Date(e.currentYear,e.currentMonth,e.currentDay):new Date(9999,9,9)),X=this._getMinMaxDate(e,"min"),$=this._getMinMaxDate(e,"max"),Z=e.drawMonth-V,et=e.drawYear;if(0>Z&&(Z+=12,et--),$)for(t=this._daylightSavingAdjust(new Date($.getFullYear(),$.getMonth()-K[0]*K[1]+1,$.getDate())),t=X&&X>t?X:t;this._daylightSavingAdjust(new Date(et,Z,1))>t;)Z--,0>Z&&(Z=11,et--);for(e.drawMonth=Z,e.drawYear=et,i=this._get(e,"prevText"),i=q?this.formatDate(i,this._daylightSavingAdjust(new Date(et,Z-U,1)),this._getFormatConfig(e)):i,s=this._canAdjustMonth(e,-1,et,Z)?"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>":J?"":"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>",n=this._get(e,"nextText"),n=q?this.formatDate(n,this._daylightSavingAdjust(new Date(et,Z+U,1)),this._getFormatConfig(e)):n,a=this._canAdjustMonth(e,1,et,Z)?"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>":J?"":"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>",o=this._get(e,"currentText"),r=this._get(e,"gotoCurrent")&&e.currentDay?G:R,o=q?this.formatDate(o,r,this._getFormatConfig(e)):o,h=e.inline?"":"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>"+this._get(e,"closeText")+"</button>",l=B?"<div class='ui-datepicker-buttonpane ui-widget-content'>"+(Y?h:"")+(this._isInRange(e,r)?"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>"+o+"</button>":"")+(Y?"":h)+"</div>":"",u=parseInt(this._get(e,"firstDay"),10),u=isNaN(u)?0:u,d=this._get(e,"showWeek"),c=this._get(e,"dayNames"),p=this._get(e,"dayNamesMin"),f=this._get(e,"monthNames"),m=this._get(e,"monthNamesShort"),g=this._get(e,"beforeShowDay"),v=this._get(e,"showOtherMonths"),y=this._get(e,"selectOtherMonths"),b=this._getDefaultDate(e),_="",w=0;K[0]>w;w++){for(k="",this.maxRows=4,T=0;K[1]>T;T++){if(D=this._daylightSavingAdjust(new Date(et,Z,e.selectedDay)),S=" ui-corner-all",M="",Q){if(M+="<div class='ui-datepicker-group",K[1]>1)switch(T){case 0:M+=" ui-datepicker-group-first",S=" ui-corner-"+(Y?"right":"left");break;case K[1]-1:M+=" ui-datepicker-group-last",S=" ui-corner-"+(Y?"left":"right");break;default:M+=" ui-datepicker-group-middle",S=""}M+="'>"}for(M+="<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix"+S+"'>"+(/all|left/.test(S)&&0===w?Y?a:s:"")+(/all|right/.test(S)&&0===w?Y?s:a:"")+this._generateMonthYearHeader(e,Z,et,X,$,w>0||T>0,f,m)+"</div><table class='ui-datepicker-calendar'><thead>"+"<tr>",C=d?"<th class='ui-datepicker-week-col'>"+this._get(e,"weekHeader")+"</th>":"",x=0;7>x;x++)N=(x+u)%7,C+="<th scope='col'"+((x+u+6)%7>=5?" class='ui-datepicker-week-end'":"")+">"+"<span title='"+c[N]+"'>"+p[N]+"</span></th>";for(M+=C+"</tr></thead><tbody>",A=this._getDaysInMonth(et,Z),et===e.selectedYear&&Z===e.selectedMonth&&(e.selectedDay=Math.min(e.selectedDay,A)),P=(this._getFirstDayOfMonth(et,Z)-u+7)%7,I=Math.ceil((P+A)/7),H=Q?this.maxRows>I?this.maxRows:I:I,this.maxRows=H,z=this._daylightSavingAdjust(new Date(et,Z,1-P)),F=0;H>F;F++){for(M+="<tr>",E=d?"<td class='ui-datepicker-week-col'>"+this._get(e,"calculateWeek")(z)+"</td>":"",x=0;7>x;x++)O=g?g.apply(e.input?e.input[0]:null,[z]):[!0,""],j=z.getMonth()!==Z,W=j&&!y||!O[0]||X&&X>z||$&&z>$,E+="<td class='"+((x+u+6)%7>=5?" ui-datepicker-week-end":"")+(j?" ui-datepicker-other-month":"")+(z.getTime()===D.getTime()&&Z===e.selectedMonth&&e._keyEvent||b.getTime()===z.getTime()&&b.getTime()===D.getTime()?" "+this._dayOverClass:"")+(W?" "+this._unselectableClass+" ui-state-disabled":"")+(j&&!v?"":" "+O[1]+(z.getTime()===G.getTime()?" "+this._currentClass:"")+(z.getTime()===R.getTime()?" ui-datepicker-today":""))+"'"+(j&&!v||!O[2]?"":" title='"+O[2].replace(/'/g,"&#39;")+"'")+(W?"":" data-handler='selectDay' data-event='click' data-month='"+z.getMonth()+"' data-year='"+z.getFullYear()+"'")+">"+(j&&!v?"&#xa0;":W?"<span class='ui-state-default'>"+z.getDate()+"</span>":"<a class='ui-state-default"+(z.getTime()===R.getTime()?" ui-state-highlight":"")+(z.getTime()===G.getTime()?" ui-state-active":"")+(j?" ui-priority-secondary":"")+"' href='#'>"+z.getDate()+"</a>")+"</td>",z.setDate(z.getDate()+1),z=this._daylightSavingAdjust(z);M+=E+"</tr>"}Z++,Z>11&&(Z=0,et++),M+="</tbody></table>"+(Q?"</div>"+(K[0]>0&&T===K[1]-1?"<div class='ui-datepicker-row-break'></div>":""):""),k+=M}_+=k}return _+=l,e._keyEvent=!1,_},_generateMonthYearHeader:function(e,t,i,s,n,a,o,r){var h,l,u,d,c,p,f,m,g=this._get(e,"changeMonth"),v=this._get(e,"changeYear"),y=this._get(e,"showMonthAfterYear"),b="<div class='ui-datepicker-title'>",_="";if(a||!g)_+="<span class='ui-datepicker-month'>"+o[t]+"</span>";else{for(h=s&&s.getFullYear()===i,l=n&&n.getFullYear()===i,_+="<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>",u=0;12>u;u++)(!h||u>=s.getMonth())&&(!l||n.getMonth()>=u)&&(_+="<option value='"+u+"'"+(u===t?" selected='selected'":"")+">"+r[u]+"</option>");_+="</select>"}if(y||(b+=_+(!a&&g&&v?"":"&#xa0;")),!e.yearshtml)if(e.yearshtml="",a||!v)b+="<span class='ui-datepicker-year'>"+i+"</span>";else{for(d=this._get(e,"yearRange").split(":"),c=(new Date).getFullYear(),p=function(e){var t=e.match(/c[+\-].*/)?i+parseInt(e.substring(1),10):e.match(/[+\-].*/)?c+parseInt(e,10):parseInt(e,10);return isNaN(t)?c:t},f=p(d[0]),m=Math.max(f,p(d[1]||"")),f=s?Math.max(f,s.getFullYear()):f,m=n?Math.min(m,n.getFullYear()):m,e.yearshtml+="<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";m>=f;f++)e.yearshtml+="<option value='"+f+"'"+(f===i?" selected='selected'":"")+">"+f+"</option>";e.yearshtml+="</select>",b+=e.yearshtml,e.yearshtml=null}return b+=this._get(e,"yearSuffix"),y&&(b+=(!a&&g&&v?"":"&#xa0;")+_),b+="</div>"},_adjustInstDate:function(e,t,i){var s=e.drawYear+("Y"===i?t:0),n=e.drawMonth+("M"===i?t:0),a=Math.min(e.selectedDay,this._getDaysInMonth(s,n))+("D"===i?t:0),o=this._restrictMinMax(e,this._daylightSavingAdjust(new Date(s,n,a)));e.selectedDay=o.getDate(),e.drawMonth=e.selectedMonth=o.getMonth(),e.drawYear=e.selectedYear=o.getFullYear(),("M"===i||"Y"===i)&&this._notifyChange(e)},_restrictMinMax:function(e,t){var i=this._getMinMaxDate(e,"min"),s=this._getMinMaxDate(e,"max"),n=i&&i>t?i:t;return s&&n>s?s:n},_notifyChange:function(e){var t=this._get(e,"onChangeMonthYear");t&&t.apply(e.input?e.input[0]:null,[e.selectedYear,e.selectedMonth+1,e])},_getNumberOfMonths:function(e){var t=this._get(e,"numberOfMonths");return null==t?[1,1]:"number"==typeof t?[1,t]:t},_getMinMaxDate:function(e,t){return this._determineDate(e,this._get(e,t+"Date"),null)},_getDaysInMonth:function(e,t){return 32-this._daylightSavingAdjust(new Date(e,t,32)).getDate()},_getFirstDayOfMonth:function(e,t){return new Date(e,t,1).getDay()},_canAdjustMonth:function(e,t,i,s){var n=this._getNumberOfMonths(e),a=this._daylightSavingAdjust(new Date(i,s+(0>t?t:n[0]*n[1]),1));return 0>t&&a.setDate(this._getDaysInMonth(a.getFullYear(),a.getMonth())),this._isInRange(e,a)},_isInRange:function(e,t){var i,s,n=this._getMinMaxDate(e,"min"),a=this._getMinMaxDate(e,"max"),o=null,r=null,h=this._get(e,"yearRange");return h&&(i=h.split(":"),s=(new Date).getFullYear(),o=parseInt(i[0],10),r=parseInt(i[1],10),i[0].match(/[+\-].*/)&&(o+=s),i[1].match(/[+\-].*/)&&(r+=s)),(!n||t.getTime()>=n.getTime())&&(!a||t.getTime()<=a.getTime())&&(!o||t.getFullYear()>=o)&&(!r||r>=t.getFullYear())},_getFormatConfig:function(e){var t=this._get(e,"shortYearCutoff");return t="string"!=typeof t?t:(new Date).getFullYear()%100+parseInt(t,10),{shortYearCutoff:t,dayNamesShort:this._get(e,"dayNamesShort"),dayNames:this._get(e,"dayNames"),monthNamesShort:this._get(e,"monthNamesShort"),monthNames:this._get(e,"monthNames")}},_formatDate:function(e,t,i,s){t||(e.currentDay=e.selectedDay,e.currentMonth=e.selectedMonth,e.currentYear=e.selectedYear);var n=t?"object"==typeof t?t:this._daylightSavingAdjust(new Date(s,i,t)):this._daylightSavingAdjust(new Date(e.currentYear,e.currentMonth,e.currentDay));return this.formatDate(this._get(e,"dateFormat"),n,this._getFormatConfig(e))}}),e.fn.datepicker=function(t){if(!this.length)return this;e.datepicker.initialized||(e(document).mousedown(e.datepicker._checkExternalClick),e.datepicker.initialized=!0),0===e("#"+e.datepicker._mainDivId).length&&e("body").append(e.datepicker.dpDiv);var i=Array.prototype.slice.call(arguments,1);return"string"!=typeof t||"isDisabled"!==t&&"getDate"!==t&&"widget"!==t?"option"===t&&2===arguments.length&&"string"==typeof arguments[1]?e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this[0]].concat(i)):this.each(function(){"string"==typeof t?e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this].concat(i)):e.datepicker._attachDatepicker(this,t)}):e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this[0]].concat(i))},e.datepicker=new n,e.datepicker.initialized=!1,e.datepicker.uuid=(new Date).getTime(),e.datepicker.version="1.11.4",e.datepicker,e.widget("ui.draggable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._setHandleClassName(),this._mouseInit()},_setOption:function(e,t){this._super(e,t),"handle"===e&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(t){var i=this.options;return this._blurActiveElement(t),this.helper||i.disabled||e(t.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(t),this.handle?(this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(t){this.iframeBlocks=this.document.find(t).map(function(){var t=e(this);return e("<div>").css("position","absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(t){var i=this.document[0];if(this.handleElement.is(t.target))try{i.activeElement&&"body"!==i.activeElement.nodeName.toLowerCase()&&e(i.activeElement).blur()}catch(s){}},_mouseStart:function(t){var i=this.options;return this.helper=this._createHelper(t),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),e.ui.ddmanager&&(e.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===e(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(t),this.originalPosition=this.position=this._generatePosition(t,!1),this.originalPageX=t.pageX,this.originalPageY=t.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",t)===!1?(this._clear(),!1):(this._cacheHelperProportions(),e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this._normalizeRightBottom(),this._mouseDrag(t,!0),e.ui.ddmanager&&e.ui.ddmanager.dragStart(this,t),!0)},_refreshOffsets:function(e){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:e.pageX-this.offset.left,top:e.pageY-this.offset.top}},_mouseDrag:function(t,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(t,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",t,s)===!1)return this._mouseUp({}),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var i=this,s=!1;return e.ui.ddmanager&&!this.options.dropBehaviour&&(s=e.ui.ddmanager.drop(this,t)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||e.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?e(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",t)!==!1&&i._clear()}):this._trigger("stop",t)!==!1&&this._clear(),!1},_mouseUp:function(t){return this._unblockFrames(),e.ui.ddmanager&&e.ui.ddmanager.dragStop(this,t),this.handleElement.is(t.target)&&this.element.focus(),e.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(t){return this.options.handle?!!e(t.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this.handleElement.addClass("ui-draggable-handle")},_removeHandleClassName:function(){this.handleElement.removeClass("ui-draggable-handle")},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper),n=s?e(i.helper.apply(this.element[0],[t])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_isRootNode:function(e){return/(html|body)/i.test(e.tagName)||e===this.document[0]},_getParentOffset:function(){var t=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var e=this.element.position(),t=this._isRootNode(this.scrollParent[0]);return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+(t?0:this.scrollParent.scrollTop()),left:e.left-(parseInt(this.helper.css("left"),10)||0)+(t?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,n=this.options,a=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[e(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,e(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,e(window).scrollLeft()+e(window).width()-this.helperProportions.width-this.margins.left,e(window).scrollTop()+(e(window).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,e(a).width()-this.helperProportions.width-this.margins.left,(e(a).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=e(n.containment),s=i[0],s&&(t=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(t?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(t?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)
},_convertPositionTo:function(e,t){t||(t=this.position);var i="absolute"===e?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:t.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:t.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(e,t){var i,s,n,a,o=this.options,r=this._isRootNode(this.scrollParent[0]),h=e.pageX,l=e.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),t&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,e.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),e.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),e.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),e.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),o.grid&&(n=o.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/o.grid[1])*o.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-o.grid[1]:n+o.grid[1]:n,a=o.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/o.grid[0])*o.grid[0]:this.originalPageX,h=i?a-this.offset.click.left>=i[0]||a-this.offset.click.left>i[2]?a:a-this.offset.click.left>=i[0]?a-o.grid[0]:a+o.grid[0]:a),"y"===o.axis&&(h=this.originalPageX),"x"===o.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_normalizeRightBottom:function(){"y"!==this.options.axis&&"auto"!==this.helper.css("right")&&(this.helper.width(this.helper.width()),this.helper.css("right","auto")),"x"!==this.options.axis&&"auto"!==this.helper.css("bottom")&&(this.helper.height(this.helper.height()),this.helper.css("bottom","auto"))},_trigger:function(t,i,s){return s=s||this._uiHash(),e.ui.plugin.call(this,t,[i,s,this],!0),/^(drag|start|stop)/.test(t)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),e.Widget.prototype._trigger.call(this,t,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),e.ui.plugin.add("draggable","connectToSortable",{start:function(t,i,s){var n=e.extend({},i,{item:s.element});s.sortables=[],e(s.options.connectToSortable).each(function(){var i=e(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",t,n))})},stop:function(t,i,s){var n=e.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,e.each(s.sortables,function(){var e=this;e.isOver?(e.isOver=0,s.cancelHelperRemoval=!0,e.cancelHelperRemoval=!1,e._storedCSS={position:e.placeholder.css("position"),top:e.placeholder.css("top"),left:e.placeholder.css("left")},e._mouseStop(t),e.options.helper=e.options._helper):(e.cancelHelperRemoval=!0,e._trigger("deactivate",t,n))})},drag:function(t,i,s){e.each(s.sortables,function(){var n=!1,a=this;a.positionAbs=s.positionAbs,a.helperProportions=s.helperProportions,a.offset.click=s.offset.click,a._intersectsWith(a.containerCache)&&(n=!0,e.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==a&&this._intersectsWith(this.containerCache)&&e.contains(a.element[0],this.element[0])&&(n=!1),n})),n?(a.isOver||(a.isOver=1,s._parent=i.helper.parent(),a.currentItem=i.helper.appendTo(a.element).data("ui-sortable-item",!0),a.options._helper=a.options.helper,a.options.helper=function(){return i.helper[0]},t.target=a.currentItem[0],a._mouseCapture(t,!0),a._mouseStart(t,!0,!0),a.offset.click.top=s.offset.click.top,a.offset.click.left=s.offset.click.left,a.offset.parent.left-=s.offset.parent.left-a.offset.parent.left,a.offset.parent.top-=s.offset.parent.top-a.offset.parent.top,s._trigger("toSortable",t),s.dropped=a.element,e.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,a.fromOutside=s),a.currentItem&&(a._mouseDrag(t),i.position=a.position)):a.isOver&&(a.isOver=0,a.cancelHelperRemoval=!0,a.options._revert=a.options.revert,a.options.revert=!1,a._trigger("out",t,a._uiHash(a)),a._mouseStop(t,!0),a.options.revert=a.options._revert,a.options.helper=a.options._helper,a.placeholder&&a.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(t),i.position=s._generatePosition(t,!0),s._trigger("fromSortable",t),s.dropped=!1,e.each(s.sortables,function(){this.refreshPositions()}))})}}),e.ui.plugin.add("draggable","cursor",{start:function(t,i,s){var n=e("body"),a=s.options;n.css("cursor")&&(a._cursor=n.css("cursor")),n.css("cursor",a.cursor)},stop:function(t,i,s){var n=s.options;n._cursor&&e("body").css("cursor",n._cursor)}}),e.ui.plugin.add("draggable","opacity",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("opacity")&&(a._opacity=n.css("opacity")),n.css("opacity",a.opacity)},stop:function(t,i,s){var n=s.options;n._opacity&&e(i.helper).css("opacity",n._opacity)}}),e.ui.plugin.add("draggable","scroll",{start:function(e,t,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(t,i,s){var n=s.options,a=!1,o=s.scrollParentNotHidden[0],r=s.document[0];o!==r&&"HTML"!==o.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+o.offsetHeight-t.pageY<n.scrollSensitivity?o.scrollTop=a=o.scrollTop+n.scrollSpeed:t.pageY-s.overflowOffset.top<n.scrollSensitivity&&(o.scrollTop=a=o.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+o.offsetWidth-t.pageX<n.scrollSensitivity?o.scrollLeft=a=o.scrollLeft+n.scrollSpeed:t.pageX-s.overflowOffset.left<n.scrollSensitivity&&(o.scrollLeft=a=o.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(t.pageY-e(r).scrollTop()<n.scrollSensitivity?a=e(r).scrollTop(e(r).scrollTop()-n.scrollSpeed):e(window).height()-(t.pageY-e(r).scrollTop())<n.scrollSensitivity&&(a=e(r).scrollTop(e(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(t.pageX-e(r).scrollLeft()<n.scrollSensitivity?a=e(r).scrollLeft(e(r).scrollLeft()-n.scrollSpeed):e(window).width()-(t.pageX-e(r).scrollLeft())<n.scrollSensitivity&&(a=e(r).scrollLeft(e(r).scrollLeft()+n.scrollSpeed)))),a!==!1&&e.ui.ddmanager&&!n.dropBehaviour&&e.ui.ddmanager.prepareOffsets(s,t)}}),e.ui.plugin.add("draggable","snap",{start:function(t,i,s){var n=s.options;s.snapElements=[],e(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var t=e(this),i=t.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:t.outerWidth(),height:t.outerHeight(),top:i.top,left:i.left})})},drag:function(t,i,s){var n,a,o,r,h,l,u,d,c,p,f=s.options,m=f.snapTolerance,g=i.offset.left,v=g+s.helperProportions.width,y=i.offset.top,b=y+s.helperProportions.height;for(c=s.snapElements.length-1;c>=0;c--)h=s.snapElements[c].left-s.margins.left,l=h+s.snapElements[c].width,u=s.snapElements[c].top-s.margins.top,d=u+s.snapElements[c].height,h-m>v||g>l+m||u-m>b||y>d+m||!e.contains(s.snapElements[c].item.ownerDocument,s.snapElements[c].item)?(s.snapElements[c].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=!1):("inner"!==f.snapMode&&(n=m>=Math.abs(u-b),a=m>=Math.abs(d-y),o=m>=Math.abs(h-v),r=m>=Math.abs(l-g),n&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),p=n||a||o||r,"outer"!==f.snapMode&&(n=m>=Math.abs(u-y),a=m>=Math.abs(d-b),o=m>=Math.abs(h-g),r=m>=Math.abs(l-v),n&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d-s.helperProportions.height,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[c].snapping&&(n||a||o||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=n||a||o||r||p)}}),e.ui.plugin.add("draggable","stack",{start:function(t,i,s){var n,a=s.options,o=e.makeArray(e(a.stack)).sort(function(t,i){return(parseInt(e(t).css("zIndex"),10)||0)-(parseInt(e(i).css("zIndex"),10)||0)});o.length&&(n=parseInt(e(o[0]).css("zIndex"),10)||0,e(o).each(function(t){e(this).css("zIndex",n+t)}),this.css("zIndex",n+o.length))}}),e.ui.plugin.add("draggable","zIndex",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("zIndex")&&(a._zIndex=n.css("zIndex")),n.css("zIndex",a.zIndex)},stop:function(t,i,s){var n=s.options;n._zIndex&&e(i.helper).css("zIndex",n._zIndex)}}),e.ui.draggable,e.widget("ui.resizable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(e){return parseInt(e,10)||0},_isNumber:function(e){return!isNaN(parseInt(e,10))},_hasScroll:function(t,i){if("hidden"===e(t).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",n=!1;return t[s]>0?!0:(t[s]=1,n=t[s]>0,t[s]=0,n)},_create:function(){var t,i,s,n,a,o=this,r=this.options;if(this.element.addClass("ui-resizable"),e.extend(this,{_aspectRatio:!!r.aspectRatio,aspectRatio:r.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:r.helper||r.ghost||r.animate?r.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(e("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")}),this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0}),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css({margin:this.originalElement.css("margin")}),this._proportionallyResize()),this.handles=r.handles||(e(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=e(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),t=this.handles.split(","),this.handles={},i=0;t.length>i;i++)s=e.trim(t[i]),a="ui-resizable-"+s,n=e("<div class='ui-resizable-handle "+a+"'></div>"),n.css({zIndex:r.zIndex}),"se"===s&&n.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),this.handles[s]=".ui-resizable-"+s,this.element.append(n);this._renderAxis=function(t){var i,s,n,a;t=t||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=e(this.handles[i]),this._on(this.handles[i],{mousedown:o._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=e(this.handles[i],this.element),a=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),t.css(n,a),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.mouseover(function(){o.resizing||(this.className&&(n=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),o.axis=n&&n[1]?n[1]:"se")}),r.autoHide&&(this._handles.hide(),e(this.element).addClass("ui-resizable-autohide").mouseenter(function(){r.disabled||(e(this).removeClass("ui-resizable-autohide"),o._handles.show())}).mouseleave(function(){r.disabled||o.resizing||(e(this).addClass("ui-resizable-autohide"),o._handles.hide())})),this._mouseInit()},_destroy:function(){this._mouseDestroy();var t,i=function(t){e(t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),t=this.element,this.originalElement.css({position:t.css("position"),width:t.outerWidth(),height:t.outerHeight(),top:t.css("top"),left:t.css("left")}).insertAfter(t),t.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_mouseCapture:function(t){var i,s,n=!1;for(i in this.handles)s=e(this.handles[i])[0],(s===t.target||e.contains(s,t.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(t){var i,s,n,a=this.options,o=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),a.containment&&(i+=e(a.containment).scrollLeft()||0,s+=e(a.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:o.width(),height:o.height()},this.originalSize=this._helper?{width:o.outerWidth(),height:o.outerHeight()}:{width:o.width(),height:o.height()},this.sizeDiff={width:o.outerWidth()-o.width(),height:o.outerHeight()-o.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:t.pageX,top:t.pageY},this.aspectRatio="number"==typeof a.aspectRatio?a.aspectRatio:this.originalSize.width/this.originalSize.height||1,n=e(".ui-resizable-"+this.axis).css("cursor"),e("body").css("cursor","auto"===n?this.axis+"-resize":n),o.addClass("ui-resizable-resizing"),this._propagate("start",t),!0},_mouseDrag:function(t){var i,s,n=this.originalMousePosition,a=this.axis,o=t.pageX-n.left||0,r=t.pageY-n.top||0,h=this._change[a];return this._updatePrevProperties(),h?(i=h.apply(this,[t,o,r]),this._updateVirtualBoundaries(t.shiftKey),(this._aspectRatio||t.shiftKey)&&(i=this._updateRatio(i,t)),i=this._respectSize(i,t),this._updateCache(i),this._propagate("resize",t),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),e.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",t,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(t){this.resizing=!1;var i,s,n,a,o,r,h,l=this.options,u=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&this._hasScroll(i[0],"left")?0:u.sizeDiff.height,a=s?0:u.sizeDiff.width,o={width:u.helper.width()-a,height:u.helper.height()-n},r=parseInt(u.element.css("left"),10)+(u.position.left-u.originalPosition.left)||null,h=parseInt(u.element.css("top"),10)+(u.position.top-u.originalPosition.top)||null,l.animate||this.element.css(e.extend(o,{top:h,left:r})),u.helper.height(u.size.height),u.helper.width(u.size.width),this._helper&&!l.animate&&this._proportionallyResize()),e("body").css("cursor","auto"),this.element.removeClass("ui-resizable-resizing"),this._propagate("stop",t),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var e={};return this.position.top!==this.prevPosition.top&&(e.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(e.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(e.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(e.height=this.size.height+"px"),this.helper.css(e),e},_updateVirtualBoundaries:function(e){var t,i,s,n,a,o=this.options;a={minWidth:this._isNumber(o.minWidth)?o.minWidth:0,maxWidth:this._isNumber(o.maxWidth)?o.maxWidth:1/0,minHeight:this._isNumber(o.minHeight)?o.minHeight:0,maxHeight:this._isNumber(o.maxHeight)?o.maxHeight:1/0},(this._aspectRatio||e)&&(t=a.minHeight*this.aspectRatio,s=a.minWidth/this.aspectRatio,i=a.maxHeight*this.aspectRatio,n=a.maxWidth/this.aspectRatio,t>a.minWidth&&(a.minWidth=t),s>a.minHeight&&(a.minHeight=s),a.maxWidth>i&&(a.maxWidth=i),a.maxHeight>n&&(a.maxHeight=n)),this._vBoundaries=a},_updateCache:function(e){this.offset=this.helper.offset(),this._isNumber(e.left)&&(this.position.left=e.left),this._isNumber(e.top)&&(this.position.top=e.top),this._isNumber(e.height)&&(this.size.height=e.height),this._isNumber(e.width)&&(this.size.width=e.width)},_updateRatio:function(e){var t=this.position,i=this.size,s=this.axis;return this._isNumber(e.height)?e.width=e.height*this.aspectRatio:this._isNumber(e.width)&&(e.height=e.width/this.aspectRatio),"sw"===s&&(e.left=t.left+(i.width-e.width),e.top=null),"nw"===s&&(e.top=t.top+(i.height-e.height),e.left=t.left+(i.width-e.width)),e},_respectSize:function(e){var t=this._vBoundaries,i=this.axis,s=this._isNumber(e.width)&&t.maxWidth&&t.maxWidth<e.width,n=this._isNumber(e.height)&&t.maxHeight&&t.maxHeight<e.height,a=this._isNumber(e.width)&&t.minWidth&&t.minWidth>e.width,o=this._isNumber(e.height)&&t.minHeight&&t.minHeight>e.height,r=this.originalPosition.left+this.originalSize.width,h=this.position.top+this.size.height,l=/sw|nw|w/.test(i),u=/nw|ne|n/.test(i);return a&&(e.width=t.minWidth),o&&(e.height=t.minHeight),s&&(e.width=t.maxWidth),n&&(e.height=t.maxHeight),a&&l&&(e.left=r-t.minWidth),s&&l&&(e.left=r-t.maxWidth),o&&u&&(e.top=h-t.minHeight),n&&u&&(e.top=h-t.maxHeight),e.width||e.height||e.left||!e.top?e.width||e.height||e.top||!e.left||(e.left=null):e.top=null,e},_getPaddingPlusBorderDimensions:function(e){for(var t=0,i=[],s=[e.css("borderTopWidth"),e.css("borderRightWidth"),e.css("borderBottomWidth"),e.css("borderLeftWidth")],n=[e.css("paddingTop"),e.css("paddingRight"),e.css("paddingBottom"),e.css("paddingLeft")];4>t;t++)i[t]=parseInt(s[t],10)||0,i[t]+=parseInt(n[t],10)||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var e,t=0,i=this.helper||this.element;this._proportionallyResizeElements.length>t;t++)e=this._proportionallyResizeElements[t],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(e)),e.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var t=this.element,i=this.options;this.elementOffset=t.offset(),this._helper?(this.helper=this.helper||e("<div style='overflow:hidden;'></div>"),this.helper.addClass(this._helper).css({width:this.element.outerWidth()-1,height:this.element.outerHeight()-1,position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(e,t){return{width:this.originalSize.width+t}},w:function(e,t){var i=this.originalSize,s=this.originalPosition;return{left:s.left+t,width:i.width-t}},n:function(e,t,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(e,t,i){return{height:this.originalSize.height+i}},se:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},sw:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[t,i,s]))},ne:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},nw:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[t,i,s]))}},_propagate:function(t,i){e.ui.plugin.call(this,t,[i,this.ui()]),"resize"!==t&&this._trigger(t,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),e.ui.plugin.add("resizable","animate",{stop:function(t){var i=e(this).resizable("instance"),s=i.options,n=i._proportionallyResizeElements,a=n.length&&/textarea/i.test(n[0].nodeName),o=a&&i._hasScroll(n[0],"left")?0:i.sizeDiff.height,r=a?0:i.sizeDiff.width,h={width:i.size.width-r,height:i.size.height-o},l=parseInt(i.element.css("left"),10)+(i.position.left-i.originalPosition.left)||null,u=parseInt(i.element.css("top"),10)+(i.position.top-i.originalPosition.top)||null;i.element.animate(e.extend(h,u&&l?{top:u,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseInt(i.element.css("width"),10),height:parseInt(i.element.css("height"),10),top:parseInt(i.element.css("top"),10),left:parseInt(i.element.css("left"),10)};n&&n.length&&e(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",t)}})}}),e.ui.plugin.add("resizable","containment",{start:function(){var t,i,s,n,a,o,r,h=e(this).resizable("instance"),l=h.options,u=h.element,d=l.containment,c=d instanceof e?d.get(0):/parent/.test(d)?u.parent().get(0):d;c&&(h.containerElement=e(c),/document/.test(d)||d===document?(h.containerOffset={left:0,top:0},h.containerPosition={left:0,top:0},h.parentData={element:e(document),left:0,top:0,width:e(document).width(),height:e(document).height()||document.body.parentNode.scrollHeight}):(t=e(c),i=[],e(["Top","Right","Left","Bottom"]).each(function(e,s){i[e]=h._num(t.css("padding"+s))}),h.containerOffset=t.offset(),h.containerPosition=t.position(),h.containerSize={height:t.innerHeight()-i[3],width:t.innerWidth()-i[1]},s=h.containerOffset,n=h.containerSize.height,a=h.containerSize.width,o=h._hasScroll(c,"left")?c.scrollWidth:a,r=h._hasScroll(c)?c.scrollHeight:n,h.parentData={element:c,left:s.left,top:s.top,width:o,height:r}))},resize:function(t){var i,s,n,a,o=e(this).resizable("instance"),r=o.options,h=o.containerOffset,l=o.position,u=o._aspectRatio||t.shiftKey,d={top:0,left:0},c=o.containerElement,p=!0;c[0]!==document&&/static/.test(c.css("position"))&&(d=h),l.left<(o._helper?h.left:0)&&(o.size.width=o.size.width+(o._helper?o.position.left-h.left:o.position.left-d.left),u&&(o.size.height=o.size.width/o.aspectRatio,p=!1),o.position.left=r.helper?h.left:0),l.top<(o._helper?h.top:0)&&(o.size.height=o.size.height+(o._helper?o.position.top-h.top:o.position.top),u&&(o.size.width=o.size.height*o.aspectRatio,p=!1),o.position.top=o._helper?h.top:0),n=o.containerElement.get(0)===o.element.parent().get(0),a=/relative|absolute/.test(o.containerElement.css("position")),n&&a?(o.offset.left=o.parentData.left+o.position.left,o.offset.top=o.parentData.top+o.position.top):(o.offset.left=o.element.offset().left,o.offset.top=o.element.offset().top),i=Math.abs(o.sizeDiff.width+(o._helper?o.offset.left-d.left:o.offset.left-h.left)),s=Math.abs(o.sizeDiff.height+(o._helper?o.offset.top-d.top:o.offset.top-h.top)),i+o.size.width>=o.parentData.width&&(o.size.width=o.parentData.width-i,u&&(o.size.height=o.size.width/o.aspectRatio,p=!1)),s+o.size.height>=o.parentData.height&&(o.size.height=o.parentData.height-s,u&&(o.size.width=o.size.height*o.aspectRatio,p=!1)),p||(o.position.left=o.prevPosition.left,o.position.top=o.prevPosition.top,o.size.width=o.prevSize.width,o.size.height=o.prevSize.height)},stop:function(){var t=e(this).resizable("instance"),i=t.options,s=t.containerOffset,n=t.containerPosition,a=t.containerElement,o=e(t.helper),r=o.offset(),h=o.outerWidth()-t.sizeDiff.width,l=o.outerHeight()-t.sizeDiff.height;t._helper&&!i.animate&&/relative/.test(a.css("position"))&&e(this).css({left:r.left-n.left-s.left,width:h,height:l}),t._helper&&!i.animate&&/static/.test(a.css("position"))&&e(this).css({left:r.left-n.left-s.left,width:h,height:l})}}),e.ui.plugin.add("resizable","alsoResize",{start:function(){var t=e(this).resizable("instance"),i=t.options;e(i.alsoResize).each(function(){var t=e(this);t.data("ui-resizable-alsoresize",{width:parseInt(t.width(),10),height:parseInt(t.height(),10),left:parseInt(t.css("left"),10),top:parseInt(t.css("top"),10)})})},resize:function(t,i){var s=e(this).resizable("instance"),n=s.options,a=s.originalSize,o=s.originalPosition,r={height:s.size.height-a.height||0,width:s.size.width-a.width||0,top:s.position.top-o.top||0,left:s.position.left-o.left||0};e(n.alsoResize).each(function(){var t=e(this),s=e(this).data("ui-resizable-alsoresize"),n={},a=t.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];e.each(a,function(e,t){var i=(s[t]||0)+(r[t]||0);i&&i>=0&&(n[t]=i||null)}),t.css(n)})},stop:function(){e(this).removeData("resizable-alsoresize")}}),e.ui.plugin.add("resizable","ghost",{start:function(){var t=e(this).resizable("instance"),i=t.options,s=t.size;t.ghost=t.originalElement.clone(),t.ghost.css({opacity:.25,display:"block",position:"relative",height:s.height,width:s.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass("string"==typeof i.ghost?i.ghost:""),t.ghost.appendTo(t.helper)},resize:function(){var t=e(this).resizable("instance");t.ghost&&t.ghost.css({position:"relative",height:t.size.height,width:t.size.width})},stop:function(){var t=e(this).resizable("instance");t.ghost&&t.helper&&t.helper.get(0).removeChild(t.ghost.get(0))}}),e.ui.plugin.add("resizable","grid",{resize:function(){var t,i=e(this).resizable("instance"),s=i.options,n=i.size,a=i.originalSize,o=i.originalPosition,r=i.axis,h="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=h[0]||1,u=h[1]||1,d=Math.round((n.width-a.width)/l)*l,c=Math.round((n.height-a.height)/u)*u,p=a.width+d,f=a.height+c,m=s.maxWidth&&p>s.maxWidth,g=s.maxHeight&&f>s.maxHeight,v=s.minWidth&&s.minWidth>p,y=s.minHeight&&s.minHeight>f;s.grid=h,v&&(p+=l),y&&(f+=u),m&&(p-=l),g&&(f-=u),/^(se|s|e)$/.test(r)?(i.size.width=p,i.size.height=f):/^(ne)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.top=o.top-c):/^(sw)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.left=o.left-d):((0>=f-u||0>=p-l)&&(t=i._getPaddingPlusBorderDimensions(this)),f-u>0?(i.size.height=f,i.position.top=o.top-c):(f=u-t.height,i.size.height=f,i.position.top=o.top+a.height-f),p-l>0?(i.size.width=p,i.position.left=o.left-d):(p=l-t.width,i.size.width=p,i.position.left=o.left+a.width-p))}}),e.ui.resizable,e.widget("ui.dialog",{version:"1.11.4",options:{appendTo:"body",autoOpen:!0,buttons:[],closeOnEscape:!0,closeText:"Close",dialogClass:"",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(t){var i=e(this).css(t).offset().top;0>i&&e(this).css("top",t.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),this.options.title=this.options.title||this.originalTitle,this._createWrapper(),this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&e.fn.draggable&&this._makeDraggable(),this.options.resizable&&e.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var t=this.options.appendTo;return t&&(t.jquery||t.nodeType)?e(t):this.document.find(t||"body").eq(0)},_destroy:function(){var e,t=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach(),this.uiDialog.stop(!0,!0).remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),e=t.parent.children().eq(t.index),e.length&&e[0]!==this.element[0]?e.before(this.element):t.parent.append(this.element)},widget:function(){return this.uiDialog},disable:e.noop,enable:e.noop,close:function(t){var i,s=this;if(this._isOpen&&this._trigger("beforeClose",t)!==!1){if(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),!this.opener.filter(":focusable").focus().length)try{i=this.document[0].activeElement,i&&"body"!==i.nodeName.toLowerCase()&&e(i).blur()}catch(n){}this._hide(this.uiDialog,this.options.hide,function(){s._trigger("close",t)})}},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(t,i){var s=!1,n=this.uiDialog.siblings(".ui-front:visible").map(function(){return+e(this).css("z-index")}).get(),a=Math.max.apply(null,n);return a>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",a+1),s=!0),s&&!i&&this._trigger("focus",t),s},open:function(){var t=this;return this._isOpen?(this._moveToTop()&&this._focusTabbable(),void 0):(this._isOpen=!0,this.opener=e(this.document[0].activeElement),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){t._focusTabbable(),t._trigger("focus")}),this._makeFocusTarget(),this._trigger("open"),void 0)},_focusTabbable:function(){var e=this._focusedElement;e||(e=this.element.find("[autofocus]")),e.length||(e=this.element.find(":tabbable")),e.length||(e=this.uiDialogButtonPane.find(":tabbable")),e.length||(e=this.uiDialogTitlebarClose.filter(":tabbable")),e.length||(e=this.uiDialog),e.eq(0).focus()},_keepFocus:function(t){function i(){var t=this.document[0].activeElement,i=this.uiDialog[0]===t||e.contains(this.uiDialog[0],t);i||this._focusTabbable()}t.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=e("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front "+this.options.dialogClass).hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._on(this.uiDialog,{keydown:function(t){if(this.options.closeOnEscape&&!t.isDefaultPrevented()&&t.keyCode&&t.keyCode===e.ui.keyCode.ESCAPE)return t.preventDefault(),this.close(t),void 0;
if(t.keyCode===e.ui.keyCode.TAB&&!t.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),n=i.filter(":last");t.target!==n[0]&&t.target!==this.uiDialog[0]||t.shiftKey?t.target!==s[0]&&t.target!==this.uiDialog[0]||!t.shiftKey||(this._delay(function(){n.focus()}),t.preventDefault()):(this._delay(function(){s.focus()}),t.preventDefault())}},mousedown:function(e){this._moveToTop(e)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var t;this.uiDialogTitlebar=e("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog),this._on(this.uiDialogTitlebar,{mousedown:function(t){e(t.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.focus()}}),this.uiDialogTitlebarClose=e("<button type='button'></button>").button({label:this.options.closeText,icons:{primary:"ui-icon-closethick"},text:!1}).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar),this._on(this.uiDialogTitlebarClose,{click:function(e){e.preventDefault(),this.close(e)}}),t=e("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar),this._title(t),this.uiDialog.attr({"aria-labelledby":t.attr("id")})},_title:function(e){this.options.title||e.html("&#160;"),e.text(this.options.title)},_createButtonPane:function(){this.uiDialogButtonPane=e("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),this.uiButtonSet=e("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane),this._createButtons()},_createButtons:function(){var t=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),e.isEmptyObject(i)||e.isArray(i)&&!i.length?(this.uiDialog.removeClass("ui-dialog-buttons"),void 0):(e.each(i,function(i,s){var n,a;s=e.isFunction(s)?{click:s,text:i}:s,s=e.extend({type:"button"},s),n=s.click,s.click=function(){n.apply(t.element[0],arguments)},a={icons:s.icons,text:s.showText},delete s.icons,delete s.showText,e("<button></button>",s).button(a).appendTo(t.uiButtonSet)}),this.uiDialog.addClass("ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog),void 0)},_makeDraggable:function(){function t(e){return{position:e.position,offset:e.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,n){e(this).addClass("ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,t(n))},drag:function(e,s){i._trigger("drag",e,t(s))},stop:function(n,a){var o=a.offset.left-i.document.scrollLeft(),r=a.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(o>=0?"+":"")+o+" "+"top"+(r>=0?"+":"")+r,of:i.window},e(this).removeClass("ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",n,t(a))}})},_makeResizable:function(){function t(e){return{originalPosition:e.originalPosition,originalSize:e.originalSize,position:e.position,size:e.size}}var i=this,s=this.options,n=s.resizable,a=this.uiDialog.css("position"),o="string"==typeof n?n:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:o,start:function(s,n){e(this).addClass("ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,t(n))},resize:function(e,s){i._trigger("resize",e,t(s))},stop:function(n,a){var o=i.uiDialog.offset(),r=o.left-i.document.scrollLeft(),h=o.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" "+"top"+(h>=0?"+":"")+h,of:i.window},e(this).removeClass("ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",n,t(a))}}).css("position",a)},_trackFocus:function(){this._on(this.widget(),{focusin:function(t){this._makeFocusTarget(),this._focusedElement=e(t.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var t=this._trackingInstances(),i=e.inArray(this,t);-1!==i&&t.splice(i,1)},_trackingInstances:function(){var e=this.document.data("ui-dialog-instances");return e||(e=[],this.document.data("ui-dialog-instances",e)),e},_minHeight:function(){var e=this.options;return"auto"===e.height?e.minHeight:Math.min(e.minHeight,e.height)},_position:function(){var e=this.uiDialog.is(":visible");e||this.uiDialog.show(),this.uiDialog.position(this.options.position),e||this.uiDialog.hide()},_setOptions:function(t){var i=this,s=!1,n={};e.each(t,function(e,t){i._setOption(e,t),e in i.sizeRelatedOptions&&(s=!0),e in i.resizableRelatedOptions&&(n[e]=t)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",n)},_setOption:function(e,t){var i,s,n=this.uiDialog;"dialogClass"===e&&n.removeClass(this.options.dialogClass).addClass(t),"disabled"!==e&&(this._super(e,t),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:""+t}),"draggable"===e&&(i=n.is(":data(ui-draggable)"),i&&!t&&n.draggable("destroy"),!i&&t&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(s=n.is(":data(ui-resizable)"),s&&!t&&n.resizable("destroy"),s&&"string"==typeof t&&n.resizable("option","handles",t),s||t===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var e,t,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),e=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),t=Math.max(0,s.minHeight-e),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-e):"none","auto"===s.height?this.element.css({minHeight:t,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-e)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var t=e(this);return e("<div>").css({position:"absolute",width:t.outerWidth(),height:t.outerHeight()}).appendTo(t.parent()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(t){return e(t.target).closest(".ui-dialog").length?!0:!!e(t.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var t=!0;this._delay(function(){t=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(e){t||this._allowInteraction(e)||(e.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=e("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo()),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var e=this.document.data("ui-dialog-overlays")-1;e?this.document.data("ui-dialog-overlays",e):this.document.unbind("focusin").removeData("ui-dialog-overlays"),this.overlay.remove(),this.overlay=null}}}),e.widget("ui.droppable",{version:"1.11.4",widgetEventPrefix:"drop",options:{accept:"*",activeClass:!1,addClasses:!0,greedy:!1,hoverClass:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var t,i=this.options,s=i.accept;this.isover=!1,this.isout=!0,this.accept=e.isFunction(s)?s:function(e){return e.is(s)},this.proportions=function(){return arguments.length?(t=arguments[0],void 0):t?t:t={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight}},this._addToManager(i.scope),i.addClasses&&this.element.addClass("ui-droppable")},_addToManager:function(t){e.ui.ddmanager.droppables[t]=e.ui.ddmanager.droppables[t]||[],e.ui.ddmanager.droppables[t].push(this)},_splice:function(e){for(var t=0;e.length>t;t++)e[t]===this&&e.splice(t,1)},_destroy:function(){var t=e.ui.ddmanager.droppables[this.options.scope];this._splice(t),this.element.removeClass("ui-droppable ui-droppable-disabled")},_setOption:function(t,i){if("accept"===t)this.accept=e.isFunction(i)?i:function(e){return e.is(i)};else if("scope"===t){var s=e.ui.ddmanager.droppables[this.options.scope];this._splice(s),this._addToManager(i)}this._super(t,i)},_activate:function(t){var i=e.ui.ddmanager.current;this.options.activeClass&&this.element.addClass(this.options.activeClass),i&&this._trigger("activate",t,this.ui(i))},_deactivate:function(t){var i=e.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass),i&&this._trigger("deactivate",t,this.ui(i))},_over:function(t){var i=e.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.addClass(this.options.hoverClass),this._trigger("over",t,this.ui(i)))},_out:function(t){var i=e.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("out",t,this.ui(i)))},_drop:function(t,i){var s=i||e.ui.ddmanager.current,n=!1;return s&&(s.currentItem||s.element)[0]!==this.element[0]?(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var i=e(this).droppable("instance");return i.options.greedy&&!i.options.disabled&&i.options.scope===s.options.scope&&i.accept.call(i.element[0],s.currentItem||s.element)&&e.ui.intersect(s,e.extend(i,{offset:i.element.offset()}),i.options.tolerance,t)?(n=!0,!1):void 0}),n?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this.options.activeClass&&this.element.removeClass(this.options.activeClass),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("drop",t,this.ui(s)),this.element):!1):!1},ui:function(e){return{draggable:e.currentItem||e.element,helper:e.helper,position:e.position,offset:e.positionAbs}}}),e.ui.intersect=function(){function e(e,t,i){return e>=t&&t+i>e}return function(t,i,s,n){if(!i.offset)return!1;var a=(t.positionAbs||t.position.absolute).left+t.margins.left,o=(t.positionAbs||t.position.absolute).top+t.margins.top,r=a+t.helperProportions.width,h=o+t.helperProportions.height,l=i.offset.left,u=i.offset.top,d=l+i.proportions().width,c=u+i.proportions().height;switch(s){case"fit":return a>=l&&d>=r&&o>=u&&c>=h;case"intersect":return a+t.helperProportions.width/2>l&&d>r-t.helperProportions.width/2&&o+t.helperProportions.height/2>u&&c>h-t.helperProportions.height/2;case"pointer":return e(n.pageY,u,i.proportions().height)&&e(n.pageX,l,i.proportions().width);case"touch":return(o>=u&&c>=o||h>=u&&c>=h||u>o&&h>c)&&(a>=l&&d>=a||r>=l&&d>=r||l>a&&r>d);default:return!1}}}(),e.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(t,i){var s,n,a=e.ui.ddmanager.droppables[t.options.scope]||[],o=i?i.type:null,r=(t.currentItem||t.element).find(":data(ui-droppable)").addBack();e:for(s=0;a.length>s;s++)if(!(a[s].options.disabled||t&&!a[s].accept.call(a[s].element[0],t.currentItem||t.element))){for(n=0;r.length>n;n++)if(r[n]===a[s].element[0]){a[s].proportions().height=0;continue e}a[s].visible="none"!==a[s].element.css("display"),a[s].visible&&("mousedown"===o&&a[s]._activate.call(a[s],i),a[s].offset=a[s].element.offset(),a[s].proportions({width:a[s].element[0].offsetWidth,height:a[s].element[0].offsetHeight}))}},drop:function(t,i){var s=!1;return e.each((e.ui.ddmanager.droppables[t.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&e.ui.intersect(t,this,this.options.tolerance,i)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],t.currentItem||t.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,i)))}),s},dragStart:function(t,i){t.element.parentsUntil("body").bind("scroll.droppable",function(){t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,i)})},drag:function(t,i){t.options.refreshPositions&&e.ui.ddmanager.prepareOffsets(t,i),e.each(e.ui.ddmanager.droppables[t.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s,n,a,o=e.ui.intersect(t,this,this.options.tolerance,i),r=!o&&this.isover?"isout":o&&!this.isover?"isover":null;r&&(this.options.greedy&&(n=this.options.scope,a=this.element.parents(":data(ui-droppable)").filter(function(){return e(this).droppable("instance").options.scope===n}),a.length&&(s=e(a[0]).droppable("instance"),s.greedyChild="isover"===r)),s&&"isover"===r&&(s.isover=!1,s.isout=!0,s._out.call(s,i)),this[r]=!0,this["isout"===r?"isover":"isout"]=!1,this["isover"===r?"_over":"_out"].call(this,i),s&&"isout"===r&&(s.isout=!1,s.isover=!0,s._over.call(s,i)))}})},dragStop:function(t,i){t.element.parentsUntil("body").unbind("scroll.droppable"),t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,i)}},e.ui.droppable;var y="ui-effects-",b=e;e.effects={effect:{}},function(e,t){function i(e,t,i){var s=d[t.type]||{};return null==e?i||!t.def?null:t.def:(e=s.floor?~~e:parseFloat(e),isNaN(e)?t.def:s.mod?(e+s.mod)%s.mod:0>e?0:e>s.max?s.max:e)}function s(i){var s=l(),n=s._rgba=[];return i=i.toLowerCase(),f(h,function(e,a){var o,r=a.re.exec(i),h=r&&a.parse(r),l=a.space||"rgba";return h?(o=s[l](h),s[u[l].cache]=o[u[l].cache],n=s._rgba=o._rgba,!1):t}),n.length?("0,0,0,0"===n.join()&&e.extend(n,a.transparent),s):a[i]}function n(e,t,i){return i=(i+1)%1,1>6*i?e+6*(t-e)*i:1>2*i?t:2>3*i?e+6*(t-e)*(2/3-i):e}var a,o="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",r=/^([\-+])=\s*(\d+\.?\d*)/,h=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(e){return[e[1],e[2],e[3],e[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(e){return[2.55*e[1],2.55*e[2],2.55*e[3],e[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(e){return[parseInt(e[1],16),parseInt(e[2],16),parseInt(e[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(e){return[parseInt(e[1]+e[1],16),parseInt(e[2]+e[2],16),parseInt(e[3]+e[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(e){return[e[1],e[2]/100,e[3]/100,e[4]]}}],l=e.Color=function(t,i,s,n){return new e.Color.fn.parse(t,i,s,n)},u={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},d={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},c=l.support={},p=e("<p>")[0],f=e.each;p.style.cssText="background-color:rgba(1,1,1,.5)",c.rgba=p.style.backgroundColor.indexOf("rgba")>-1,f(u,function(e,t){t.cache="_"+e,t.props.alpha={idx:3,type:"percent",def:1}}),l.fn=e.extend(l.prototype,{parse:function(n,o,r,h){if(n===t)return this._rgba=[null,null,null,null],this;(n.jquery||n.nodeType)&&(n=e(n).css(o),o=t);var d=this,c=e.type(n),p=this._rgba=[];return o!==t&&(n=[n,o,r,h],c="array"),"string"===c?this.parse(s(n)||a._default):"array"===c?(f(u.rgba.props,function(e,t){p[t.idx]=i(n[t.idx],t)}),this):"object"===c?(n instanceof l?f(u,function(e,t){n[t.cache]&&(d[t.cache]=n[t.cache].slice())}):f(u,function(t,s){var a=s.cache;f(s.props,function(e,t){if(!d[a]&&s.to){if("alpha"===e||null==n[e])return;d[a]=s.to(d._rgba)}d[a][t.idx]=i(n[e],t,!0)}),d[a]&&0>e.inArray(null,d[a].slice(0,3))&&(d[a][3]=1,s.from&&(d._rgba=s.from(d[a])))}),this):t},is:function(e){var i=l(e),s=!0,n=this;return f(u,function(e,a){var o,r=i[a.cache];return r&&(o=n[a.cache]||a.to&&a.to(n._rgba)||[],f(a.props,function(e,i){return null!=r[i.idx]?s=r[i.idx]===o[i.idx]:t})),s}),s},_space:function(){var e=[],t=this;return f(u,function(i,s){t[s.cache]&&e.push(i)}),e.pop()},transition:function(e,t){var s=l(e),n=s._space(),a=u[n],o=0===this.alpha()?l("transparent"):this,r=o[a.cache]||a.to(o._rgba),h=r.slice();return s=s[a.cache],f(a.props,function(e,n){var a=n.idx,o=r[a],l=s[a],u=d[n.type]||{};null!==l&&(null===o?h[a]=l:(u.mod&&(l-o>u.mod/2?o+=u.mod:o-l>u.mod/2&&(o-=u.mod)),h[a]=i((l-o)*t+o,n)))}),this[n](h)},blend:function(t){if(1===this._rgba[3])return this;var i=this._rgba.slice(),s=i.pop(),n=l(t)._rgba;return l(e.map(i,function(e,t){return(1-s)*n[t]+s*e}))},toRgbaString:function(){var t="rgba(",i=e.map(this._rgba,function(e,t){return null==e?t>2?1:0:e});return 1===i[3]&&(i.pop(),t="rgb("),t+i.join()+")"},toHslaString:function(){var t="hsla(",i=e.map(this.hsla(),function(e,t){return null==e&&(e=t>2?1:0),t&&3>t&&(e=Math.round(100*e)+"%"),e});return 1===i[3]&&(i.pop(),t="hsl("),t+i.join()+")"},toHexString:function(t){var i=this._rgba.slice(),s=i.pop();return t&&i.push(~~(255*s)),"#"+e.map(i,function(e){return e=(e||0).toString(16),1===e.length?"0"+e:e}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}}),l.fn.parse.prototype=l.fn,u.hsla.to=function(e){if(null==e[0]||null==e[1]||null==e[2])return[null,null,null,e[3]];var t,i,s=e[0]/255,n=e[1]/255,a=e[2]/255,o=e[3],r=Math.max(s,n,a),h=Math.min(s,n,a),l=r-h,u=r+h,d=.5*u;return t=h===r?0:s===r?60*(n-a)/l+360:n===r?60*(a-s)/l+120:60*(s-n)/l+240,i=0===l?0:.5>=d?l/u:l/(2-u),[Math.round(t)%360,i,d,null==o?1:o]},u.hsla.from=function(e){if(null==e[0]||null==e[1]||null==e[2])return[null,null,null,e[3]];var t=e[0]/360,i=e[1],s=e[2],a=e[3],o=.5>=s?s*(1+i):s+i-s*i,r=2*s-o;return[Math.round(255*n(r,o,t+1/3)),Math.round(255*n(r,o,t)),Math.round(255*n(r,o,t-1/3)),a]},f(u,function(s,n){var a=n.props,o=n.cache,h=n.to,u=n.from;l.fn[s]=function(s){if(h&&!this[o]&&(this[o]=h(this._rgba)),s===t)return this[o].slice();var n,r=e.type(s),d="array"===r||"object"===r?s:arguments,c=this[o].slice();return f(a,function(e,t){var s=d["object"===r?e:t.idx];null==s&&(s=c[t.idx]),c[t.idx]=i(s,t)}),u?(n=l(u(c)),n[o]=c,n):l(c)},f(a,function(t,i){l.fn[t]||(l.fn[t]=function(n){var a,o=e.type(n),h="alpha"===t?this._hsla?"hsla":"rgba":s,l=this[h](),u=l[i.idx];return"undefined"===o?u:("function"===o&&(n=n.call(this,u),o=e.type(n)),null==n&&i.empty?this:("string"===o&&(a=r.exec(n),a&&(n=u+parseFloat(a[2])*("+"===a[1]?1:-1))),l[i.idx]=n,this[h](l)))})})}),l.hook=function(t){var i=t.split(" ");f(i,function(t,i){e.cssHooks[i]={set:function(t,n){var a,o,r="";if("transparent"!==n&&("string"!==e.type(n)||(a=s(n)))){if(n=l(a||n),!c.rgba&&1!==n._rgba[3]){for(o="backgroundColor"===i?t.parentNode:t;(""===r||"transparent"===r)&&o&&o.style;)try{r=e.css(o,"backgroundColor"),o=o.parentNode}catch(h){}n=n.blend(r&&"transparent"!==r?r:"_default")}n=n.toRgbaString()}try{t.style[i]=n}catch(h){}}},e.fx.step[i]=function(t){t.colorInit||(t.start=l(t.elem,i),t.end=l(t.end),t.colorInit=!0),e.cssHooks[i].set(t.elem,t.start.transition(t.end,t.pos))}})},l.hook(o),e.cssHooks.borderColor={expand:function(e){var t={};return f(["Top","Right","Bottom","Left"],function(i,s){t["border"+s+"Color"]=e}),t}},a=e.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(b),function(){function t(t){var i,s,n=t.ownerDocument.defaultView?t.ownerDocument.defaultView.getComputedStyle(t,null):t.currentStyle,a={};if(n&&n.length&&n[0]&&n[n[0]])for(s=n.length;s--;)i=n[s],"string"==typeof n[i]&&(a[e.camelCase(i)]=n[i]);else for(i in n)"string"==typeof n[i]&&(a[i]=n[i]);return a}function i(t,i){var s,a,o={};for(s in i)a=i[s],t[s]!==a&&(n[s]||(e.fx.step[s]||!isNaN(parseFloat(a)))&&(o[s]=a));return o}var s=["add","remove","toggle"],n={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};e.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(t,i){e.fx.step[i]=function(e){("none"!==e.end&&!e.setAttr||1===e.pos&&!e.setAttr)&&(b.style(e.elem,i,e.end),e.setAttr=!0)}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e.effects.animateClass=function(n,a,o,r){var h=e.speed(a,o,r);return this.queue(function(){var a,o=e(this),r=o.attr("class")||"",l=h.children?o.find("*").addBack():o;l=l.map(function(){var i=e(this);return{el:i,start:t(this)}}),a=function(){e.each(s,function(e,t){n[t]&&o[t+"Class"](n[t])})},a(),l=l.map(function(){return this.end=t(this.el[0]),this.diff=i(this.start,this.end),this}),o.attr("class",r),l=l.map(function(){var t=this,i=e.Deferred(),s=e.extend({},h,{queue:!1,complete:function(){i.resolve(t)}});return this.el.animate(this.diff,s),i.promise()}),e.when.apply(e,l.get()).done(function(){a(),e.each(arguments,function(){var t=this.el;e.each(this.diff,function(e){t.css(e,"")})}),h.complete.call(o[0])})})},e.fn.extend({addClass:function(t){return function(i,s,n,a){return s?e.effects.animateClass.call(this,{add:i},s,n,a):t.apply(this,arguments)}}(e.fn.addClass),removeClass:function(t){return function(i,s,n,a){return arguments.length>1?e.effects.animateClass.call(this,{remove:i},s,n,a):t.apply(this,arguments)}}(e.fn.removeClass),toggleClass:function(t){return function(i,s,n,a,o){return"boolean"==typeof s||void 0===s?n?e.effects.animateClass.call(this,s?{add:i}:{remove:i},n,a,o):t.apply(this,arguments):e.effects.animateClass.call(this,{toggle:i},s,n,a)}}(e.fn.toggleClass),switchClass:function(t,i,s,n,a){return e.effects.animateClass.call(this,{add:i,remove:t},s,n,a)}})}(),function(){function t(t,i,s,n){return e.isPlainObject(t)&&(i=t,t=t.effect),t={effect:t},null==i&&(i={}),e.isFunction(i)&&(n=i,s=null,i={}),("number"==typeof i||e.fx.speeds[i])&&(n=s,s=i,i={}),e.isFunction(s)&&(n=s,s=null),i&&e.extend(t,i),s=s||i.duration,t.duration=e.fx.off?0:"number"==typeof s?s:s in e.fx.speeds?e.fx.speeds[s]:e.fx.speeds._default,t.complete=n||i.complete,t}function i(t){return!t||"number"==typeof t||e.fx.speeds[t]?!0:"string"!=typeof t||e.effects.effect[t]?e.isFunction(t)?!0:"object"!=typeof t||t.effect?!1:!0:!0}e.extend(e.effects,{version:"1.11.4",save:function(e,t){for(var i=0;t.length>i;i++)null!==t[i]&&e.data(y+t[i],e[0].style[t[i]])},restore:function(e,t){var i,s;for(s=0;t.length>s;s++)null!==t[s]&&(i=e.data(y+t[s]),void 0===i&&(i=""),e.css(t[s],i))},setMode:function(e,t){return"toggle"===t&&(t=e.is(":hidden")?"show":"hide"),t},getBaseline:function(e,t){var i,s;switch(e[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=e[0]/t.height}switch(e[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=e[1]/t.width}return{x:s,y:i}},createWrapper:function(t){if(t.parent().is(".ui-effects-wrapper"))return t.parent();var i={width:t.outerWidth(!0),height:t.outerHeight(!0),"float":t.css("float")},s=e("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),n={width:t.width(),height:t.height()},a=document.activeElement;try{a.id}catch(o){a=document.body}return t.wrap(s),(t[0]===a||e.contains(t[0],a))&&e(a).focus(),s=t.parent(),"static"===t.css("position")?(s.css({position:"relative"}),t.css({position:"relative"})):(e.extend(i,{position:t.css("position"),zIndex:t.css("z-index")}),e.each(["top","left","bottom","right"],function(e,s){i[s]=t.css(s),isNaN(parseInt(i[s],10))&&(i[s]="auto")}),t.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),t.css(n),s.css(i).show()},removeWrapper:function(t){var i=document.activeElement;return t.parent().is(".ui-effects-wrapper")&&(t.parent().replaceWith(t),(t[0]===i||e.contains(t[0],i))&&e(i).focus()),t},setTransition:function(t,i,s,n){return n=n||{},e.each(i,function(e,i){var a=t.cssUnit(i);a[0]>0&&(n[i]=a[0]*s+a[1])}),n}}),e.fn.extend({effect:function(){function i(t){function i(){e.isFunction(a)&&a.call(n[0]),e.isFunction(t)&&t()}var n=e(this),a=s.complete,r=s.mode;(n.is(":hidden")?"hide"===r:"show"===r)?(n[r](),i()):o.call(n[0],s,i)}var s=t.apply(this,arguments),n=s.mode,a=s.queue,o=e.effects.effect[s.effect];return e.fx.off||!o?n?this[n](s.duration,s.complete):this.each(function(){s.complete&&s.complete.call(this)}):a===!1?this.each(i):this.queue(a||"fx",i)},show:function(e){return function(s){if(i(s))return e.apply(this,arguments);var n=t.apply(this,arguments);return n.mode="show",this.effect.call(this,n)}}(e.fn.show),hide:function(e){return function(s){if(i(s))return e.apply(this,arguments);var n=t.apply(this,arguments);return n.mode="hide",this.effect.call(this,n)}}(e.fn.hide),toggle:function(e){return function(s){if(i(s)||"boolean"==typeof s)return e.apply(this,arguments);var n=t.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)}}(e.fn.toggle),cssUnit:function(t){var i=this.css(t),s=[];return e.each(["em","px","%","pt"],function(e,t){i.indexOf(t)>0&&(s=[parseFloat(i),t])}),s}})}(),function(){var t={};e.each(["Quad","Cubic","Quart","Quint","Expo"],function(e,i){t[i]=function(t){return Math.pow(t,e+2)}}),e.extend(t,{Sine:function(e){return 1-Math.cos(e*Math.PI/2)},Circ:function(e){return 1-Math.sqrt(1-e*e)},Elastic:function(e){return 0===e||1===e?e:-Math.pow(2,8*(e-1))*Math.sin((80*(e-1)-7.5)*Math.PI/15)},Back:function(e){return e*e*(3*e-2)},Bounce:function(e){for(var t,i=4;((t=Math.pow(2,--i))-1)/11>e;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*t-2)/22-e,2)}}),e.each(t,function(t,i){e.easing["easeIn"+t]=i,e.easing["easeOut"+t]=function(e){return 1-i(1-e)},e.easing["easeInOut"+t]=function(e){return.5>e?i(2*e)/2:1-i(-2*e+2)/2}})}(),e.effects,e.effects.effect.blind=function(t,i){var s,n,a,o=e(this),r=/up|down|vertical/,h=/up|left|vertical|horizontal/,l=["position","top","bottom","left","right","height","width"],u=e.effects.setMode(o,t.mode||"hide"),d=t.direction||"up",c=r.test(d),p=c?"height":"width",f=c?"top":"left",m=h.test(d),g={},v="show"===u;o.parent().is(".ui-effects-wrapper")?e.effects.save(o.parent(),l):e.effects.save(o,l),o.show(),s=e.effects.createWrapper(o).css({overflow:"hidden"}),n=s[p](),a=parseFloat(s.css(f))||0,g[p]=v?n:0,m||(o.css(c?"bottom":"right",0).css(c?"top":"left","auto").css({position:"absolute"}),g[f]=v?a:n+a),v&&(s.css(p,0),m||s.css(f,a+n)),s.animate(g,{duration:t.duration,easing:t.easing,queue:!1,complete:function(){"hide"===u&&o.hide(),e.effects.restore(o,l),e.effects.removeWrapper(o),i()}})},e.effects.effect.bounce=function(t,i){var s,n,a,o=e(this),r=["position","top","bottom","left","right","height","width"],h=e.effects.setMode(o,t.mode||"effect"),l="hide"===h,u="show"===h,d=t.direction||"up",c=t.distance,p=t.times||5,f=2*p+(u||l?1:0),m=t.duration/f,g=t.easing,v="up"===d||"down"===d?"top":"left",y="up"===d||"left"===d,b=o.queue(),_=b.length;for((u||l)&&r.push("opacity"),e.effects.save(o,r),o.show(),e.effects.createWrapper(o),c||(c=o["top"===v?"outerHeight":"outerWidth"]()/3),u&&(a={opacity:1},a[v]=0,o.css("opacity",0).css(v,y?2*-c:2*c).animate(a,m,g)),l&&(c/=Math.pow(2,p-1)),a={},a[v]=0,s=0;p>s;s++)n={},n[v]=(y?"-=":"+=")+c,o.animate(n,m,g).animate(a,m,g),c=l?2*c:c/2;l&&(n={opacity:0},n[v]=(y?"-=":"+=")+c,o.animate(n,m,g)),o.queue(function(){l&&o.hide(),e.effects.restore(o,r),e.effects.removeWrapper(o),i()}),_>1&&b.splice.apply(b,[1,0].concat(b.splice(_,f+1))),o.dequeue()},e.effects.effect.clip=function(t,i){var s,n,a,o=e(this),r=["position","top","bottom","left","right","height","width"],h=e.effects.setMode(o,t.mode||"hide"),l="show"===h,u=t.direction||"vertical",d="vertical"===u,c=d?"height":"width",p=d?"top":"left",f={};e.effects.save(o,r),o.show(),s=e.effects.createWrapper(o).css({overflow:"hidden"}),n="IMG"===o[0].tagName?s:o,a=n[c](),l&&(n.css(c,0),n.css(p,a/2)),f[c]=l?a:0,f[p]=l?0:a/2,n.animate(f,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){l||o.hide(),e.effects.restore(o,r),e.effects.removeWrapper(o),i()}})},e.effects.effect.drop=function(t,i){var s,n=e(this),a=["position","top","bottom","left","right","opacity","height","width"],o=e.effects.setMode(n,t.mode||"hide"),r="show"===o,h=t.direction||"left",l="up"===h||"down"===h?"top":"left",u="up"===h||"left"===h?"pos":"neg",d={opacity:r?1:0};e.effects.save(n,a),n.show(),e.effects.createWrapper(n),s=t.distance||n["top"===l?"outerHeight":"outerWidth"](!0)/2,r&&n.css("opacity",0).css(l,"pos"===u?-s:s),d[l]=(r?"pos"===u?"+=":"-=":"pos"===u?"-=":"+=")+s,n.animate(d,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){"hide"===o&&n.hide(),e.effects.restore(n,a),e.effects.removeWrapper(n),i()}})},e.effects.effect.explode=function(t,i){function s(){b.push(this),b.length===d*c&&n()}function n(){p.css({visibility:"visible"}),e(b).remove(),m||p.hide(),i()}var a,o,r,h,l,u,d=t.pieces?Math.round(Math.sqrt(t.pieces)):3,c=d,p=e(this),f=e.effects.setMode(p,t.mode||"hide"),m="show"===f,g=p.show().css("visibility","hidden").offset(),v=Math.ceil(p.outerWidth()/c),y=Math.ceil(p.outerHeight()/d),b=[];for(a=0;d>a;a++)for(h=g.top+a*y,u=a-(d-1)/2,o=0;c>o;o++)r=g.left+o*v,l=o-(c-1)/2,p.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-o*v,top:-a*y}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:v,height:y,left:r+(m?l*v:0),top:h+(m?u*y:0),opacity:m?0:1}).animate({left:r+(m?0:l*v),top:h+(m?0:u*y),opacity:m?1:0},t.duration||500,t.easing,s)},e.effects.effect.fade=function(t,i){var s=e(this),n=e.effects.setMode(s,t.mode||"toggle");s.animate({opacity:n},{queue:!1,duration:t.duration,easing:t.easing,complete:i})},e.effects.effect.fold=function(t,i){var s,n,a=e(this),o=["position","top","bottom","left","right","height","width"],r=e.effects.setMode(a,t.mode||"hide"),h="show"===r,l="hide"===r,u=t.size||15,d=/([0-9]+)%/.exec(u),c=!!t.horizFirst,p=h!==c,f=p?["width","height"]:["height","width"],m=t.duration/2,g={},v={};e.effects.save(a,o),a.show(),s=e.effects.createWrapper(a).css({overflow:"hidden"}),n=p?[s.width(),s.height()]:[s.height(),s.width()],d&&(u=parseInt(d[1],10)/100*n[l?0:1]),h&&s.css(c?{height:0,width:u}:{height:u,width:0}),g[f[0]]=h?n[0]:u,v[f[1]]=h?n[1]:0,s.animate(g,m,t.easing).animate(v,m,t.easing,function(){l&&a.hide(),e.effects.restore(a,o),e.effects.removeWrapper(a),i()})},e.effects.effect.highlight=function(t,i){var s=e(this),n=["backgroundImage","backgroundColor","opacity"],a=e.effects.setMode(s,t.mode||"show"),o={backgroundColor:s.css("backgroundColor")};"hide"===a&&(o.opacity=0),e.effects.save(s,n),s.show().css({backgroundImage:"none",backgroundColor:t.color||"#ffff99"}).animate(o,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){"hide"===a&&s.hide(),e.effects.restore(s,n),i()}})},e.effects.effect.size=function(t,i){var s,n,a,o=e(this),r=["position","top","bottom","left","right","width","height","overflow","opacity"],h=["position","top","bottom","left","right","overflow","opacity"],l=["width","height","overflow"],u=["fontSize"],d=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],c=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],p=e.effects.setMode(o,t.mode||"effect"),f=t.restore||"effect"!==p,m=t.scale||"both",g=t.origin||["middle","center"],v=o.css("position"),y=f?r:h,b={height:0,width:0,outerHeight:0,outerWidth:0};"show"===p&&o.show(),s={height:o.height(),width:o.width(),outerHeight:o.outerHeight(),outerWidth:o.outerWidth()},"toggle"===t.mode&&"show"===p?(o.from=t.to||b,o.to=t.from||s):(o.from=t.from||("show"===p?b:s),o.to=t.to||("hide"===p?b:s)),a={from:{y:o.from.height/s.height,x:o.from.width/s.width},to:{y:o.to.height/s.height,x:o.to.width/s.width}},("box"===m||"both"===m)&&(a.from.y!==a.to.y&&(y=y.concat(d),o.from=e.effects.setTransition(o,d,a.from.y,o.from),o.to=e.effects.setTransition(o,d,a.to.y,o.to)),a.from.x!==a.to.x&&(y=y.concat(c),o.from=e.effects.setTransition(o,c,a.from.x,o.from),o.to=e.effects.setTransition(o,c,a.to.x,o.to))),("content"===m||"both"===m)&&a.from.y!==a.to.y&&(y=y.concat(u).concat(l),o.from=e.effects.setTransition(o,u,a.from.y,o.from),o.to=e.effects.setTransition(o,u,a.to.y,o.to)),e.effects.save(o,y),o.show(),e.effects.createWrapper(o),o.css("overflow","hidden").css(o.from),g&&(n=e.effects.getBaseline(g,s),o.from.top=(s.outerHeight-o.outerHeight())*n.y,o.from.left=(s.outerWidth-o.outerWidth())*n.x,o.to.top=(s.outerHeight-o.to.outerHeight)*n.y,o.to.left=(s.outerWidth-o.to.outerWidth)*n.x),o.css(o.from),("content"===m||"both"===m)&&(d=d.concat(["marginTop","marginBottom"]).concat(u),c=c.concat(["marginLeft","marginRight"]),l=r.concat(d).concat(c),o.find("*[width]").each(function(){var i=e(this),s={height:i.height(),width:i.width(),outerHeight:i.outerHeight(),outerWidth:i.outerWidth()};
f&&e.effects.save(i,l),i.from={height:s.height*a.from.y,width:s.width*a.from.x,outerHeight:s.outerHeight*a.from.y,outerWidth:s.outerWidth*a.from.x},i.to={height:s.height*a.to.y,width:s.width*a.to.x,outerHeight:s.height*a.to.y,outerWidth:s.width*a.to.x},a.from.y!==a.to.y&&(i.from=e.effects.setTransition(i,d,a.from.y,i.from),i.to=e.effects.setTransition(i,d,a.to.y,i.to)),a.from.x!==a.to.x&&(i.from=e.effects.setTransition(i,c,a.from.x,i.from),i.to=e.effects.setTransition(i,c,a.to.x,i.to)),i.css(i.from),i.animate(i.to,t.duration,t.easing,function(){f&&e.effects.restore(i,l)})})),o.animate(o.to,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){0===o.to.opacity&&o.css("opacity",o.from.opacity),"hide"===p&&o.hide(),e.effects.restore(o,y),f||("static"===v?o.css({position:"relative",top:o.to.top,left:o.to.left}):e.each(["top","left"],function(e,t){o.css(t,function(t,i){var s=parseInt(i,10),n=e?o.to.left:o.to.top;return"auto"===i?n+"px":s+n+"px"})})),e.effects.removeWrapper(o),i()}})},e.effects.effect.scale=function(t,i){var s=e(this),n=e.extend(!0,{},t),a=e.effects.setMode(s,t.mode||"effect"),o=parseInt(t.percent,10)||(0===parseInt(t.percent,10)?0:"hide"===a?0:100),r=t.direction||"both",h=t.origin,l={height:s.height(),width:s.width(),outerHeight:s.outerHeight(),outerWidth:s.outerWidth()},u={y:"horizontal"!==r?o/100:1,x:"vertical"!==r?o/100:1};n.effect="size",n.queue=!1,n.complete=i,"effect"!==a&&(n.origin=h||["middle","center"],n.restore=!0),n.from=t.from||("show"===a?{height:0,width:0,outerHeight:0,outerWidth:0}:l),n.to={height:l.height*u.y,width:l.width*u.x,outerHeight:l.outerHeight*u.y,outerWidth:l.outerWidth*u.x},n.fade&&("show"===a&&(n.from.opacity=0,n.to.opacity=1),"hide"===a&&(n.from.opacity=1,n.to.opacity=0)),s.effect(n)},e.effects.effect.puff=function(t,i){var s=e(this),n=e.effects.setMode(s,t.mode||"hide"),a="hide"===n,o=parseInt(t.percent,10)||150,r=o/100,h={height:s.height(),width:s.width(),outerHeight:s.outerHeight(),outerWidth:s.outerWidth()};e.extend(t,{effect:"scale",queue:!1,fade:!0,mode:n,complete:i,percent:a?o:100,from:a?h:{height:h.height*r,width:h.width*r,outerHeight:h.outerHeight*r,outerWidth:h.outerWidth*r}}),s.effect(t)},e.effects.effect.pulsate=function(t,i){var s,n=e(this),a=e.effects.setMode(n,t.mode||"show"),o="show"===a,r="hide"===a,h=o||"hide"===a,l=2*(t.times||5)+(h?1:0),u=t.duration/l,d=0,c=n.queue(),p=c.length;for((o||!n.is(":visible"))&&(n.css("opacity",0).show(),d=1),s=1;l>s;s++)n.animate({opacity:d},u,t.easing),d=1-d;n.animate({opacity:d},u,t.easing),n.queue(function(){r&&n.hide(),i()}),p>1&&c.splice.apply(c,[1,0].concat(c.splice(p,l+1))),n.dequeue()},e.effects.effect.shake=function(t,i){var s,n=e(this),a=["position","top","bottom","left","right","height","width"],o=e.effects.setMode(n,t.mode||"effect"),r=t.direction||"left",h=t.distance||20,l=t.times||3,u=2*l+1,d=Math.round(t.duration/u),c="up"===r||"down"===r?"top":"left",p="up"===r||"left"===r,f={},m={},g={},v=n.queue(),y=v.length;for(e.effects.save(n,a),n.show(),e.effects.createWrapper(n),f[c]=(p?"-=":"+=")+h,m[c]=(p?"+=":"-=")+2*h,g[c]=(p?"-=":"+=")+2*h,n.animate(f,d,t.easing),s=1;l>s;s++)n.animate(m,d,t.easing).animate(g,d,t.easing);n.animate(m,d,t.easing).animate(f,d/2,t.easing).queue(function(){"hide"===o&&n.hide(),e.effects.restore(n,a),e.effects.removeWrapper(n),i()}),y>1&&v.splice.apply(v,[1,0].concat(v.splice(y,u+1))),n.dequeue()},e.effects.effect.slide=function(t,i){var s,n=e(this),a=["position","top","bottom","left","right","width","height"],o=e.effects.setMode(n,t.mode||"show"),r="show"===o,h=t.direction||"left",l="up"===h||"down"===h?"top":"left",u="up"===h||"left"===h,d={};e.effects.save(n,a),n.show(),s=t.distance||n["top"===l?"outerHeight":"outerWidth"](!0),e.effects.createWrapper(n).css({overflow:"hidden"}),r&&n.css(l,u?isNaN(s)?"-"+s:-s:s),d[l]=(r?u?"+=":"-=":u?"-=":"+=")+s,n.animate(d,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){"hide"===o&&n.hide(),e.effects.restore(n,a),e.effects.removeWrapper(n),i()}})},e.effects.effect.transfer=function(t,i){var s=e(this),n=e(t.to),a="fixed"===n.css("position"),o=e("body"),r=a?o.scrollTop():0,h=a?o.scrollLeft():0,l=n.offset(),u={top:l.top-r,left:l.left-h,height:n.innerHeight(),width:n.innerWidth()},d=s.offset(),c=e("<div class='ui-effects-transfer'></div>").appendTo(document.body).addClass(t.className).css({top:d.top-r,left:d.left-h,height:s.innerHeight(),width:s.innerWidth(),position:a?"fixed":"absolute"}).animate(u,t.duration,t.easing,function(){c.remove(),i()})},e.widget("ui.progressbar",{version:"1.11.4",options:{max:100,value:0,change:null,complete:null},min:0,_create:function(){this.oldValue=this.options.value=this._constrainedValue(),this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({role:"progressbar","aria-valuemin":this.min}),this.valueDiv=e("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element),this._refreshValue()},_destroy:function(){this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"),this.valueDiv.remove()},value:function(e){return void 0===e?this.options.value:(this.options.value=this._constrainedValue(e),this._refreshValue(),void 0)},_constrainedValue:function(e){return void 0===e&&(e=this.options.value),this.indeterminate=e===!1,"number"!=typeof e&&(e=0),this.indeterminate?!1:Math.min(this.options.max,Math.max(this.min,e))},_setOptions:function(e){var t=e.value;delete e.value,this._super(e),this.options.value=this._constrainedValue(t),this._refreshValue()},_setOption:function(e,t){"max"===e&&(t=Math.max(this.min,t)),"disabled"===e&&this.element.toggleClass("ui-state-disabled",!!t).attr("aria-disabled",t),this._super(e,t)},_percentage:function(){return this.indeterminate?100:100*(this.options.value-this.min)/(this.options.max-this.min)},_refreshValue:function(){var t=this.options.value,i=this._percentage();this.valueDiv.toggle(this.indeterminate||t>this.min).toggleClass("ui-corner-right",t===this.options.max).width(i.toFixed(0)+"%"),this.element.toggleClass("ui-progressbar-indeterminate",this.indeterminate),this.indeterminate?(this.element.removeAttr("aria-valuenow"),this.overlayDiv||(this.overlayDiv=e("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv))):(this.element.attr({"aria-valuemax":this.options.max,"aria-valuenow":t}),this.overlayDiv&&(this.overlayDiv.remove(),this.overlayDiv=null)),this.oldValue!==t&&(this.oldValue=t,this._trigger("change")),t===this.options.max&&this._trigger("complete")}}),e.widget("ui.selectable",e.ui.mouse,{version:"1.11.4",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var t,i=this;this.element.addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){t=e(i.options.filter,i.element[0]),t.addClass("ui-selectee"),t.each(function(){var t=e(this),i=t.offset();e.data(this,"selectable-item",{element:this,$element:t,left:i.left,top:i.top,right:i.left+t.outerWidth(),bottom:i.top+t.outerHeight(),startselected:!1,selected:t.hasClass("ui-selected"),selecting:t.hasClass("ui-selecting"),unselecting:t.hasClass("ui-unselecting")})})},this.refresh(),this.selectees=t.addClass("ui-selectee"),this._mouseInit(),this.helper=e("<div class='ui-selectable-helper'></div>")},_destroy:function(){this.selectees.removeClass("ui-selectee").removeData("selectable-item"),this.element.removeClass("ui-selectable ui-selectable-disabled"),this._mouseDestroy()},_mouseStart:function(t){var i=this,s=this.options;this.opos=[t.pageX,t.pageY],this.options.disabled||(this.selectees=e(s.filter,this.element[0]),this._trigger("start",t),e(s.appendTo).append(this.helper),this.helper.css({left:t.pageX,top:t.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=e.data(this,"selectable-item");s.startselected=!0,t.metaKey||t.ctrlKey||(s.$element.removeClass("ui-selected"),s.selected=!1,s.$element.addClass("ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",t,{unselecting:s.element}))}),e(t.target).parents().addBack().each(function(){var s,n=e.data(this,"selectable-item");return n?(s=!t.metaKey&&!t.ctrlKey||!n.$element.hasClass("ui-selected"),n.$element.removeClass(s?"ui-unselecting":"ui-selected").addClass(s?"ui-selecting":"ui-unselecting"),n.unselecting=!s,n.selecting=s,n.selected=s,s?i._trigger("selecting",t,{selecting:n.element}):i._trigger("unselecting",t,{unselecting:n.element}),!1):void 0}))},_mouseDrag:function(t){if(this.dragged=!0,!this.options.disabled){var i,s=this,n=this.options,a=this.opos[0],o=this.opos[1],r=t.pageX,h=t.pageY;return a>r&&(i=r,r=a,a=i),o>h&&(i=h,h=o,o=i),this.helper.css({left:a,top:o,width:r-a,height:h-o}),this.selectees.each(function(){var i=e.data(this,"selectable-item"),l=!1;i&&i.element!==s.element[0]&&("touch"===n.tolerance?l=!(i.left>r||a>i.right||i.top>h||o>i.bottom):"fit"===n.tolerance&&(l=i.left>a&&r>i.right&&i.top>o&&h>i.bottom),l?(i.selected&&(i.$element.removeClass("ui-selected"),i.selected=!1),i.unselecting&&(i.$element.removeClass("ui-unselecting"),i.unselecting=!1),i.selecting||(i.$element.addClass("ui-selecting"),i.selecting=!0,s._trigger("selecting",t,{selecting:i.element}))):(i.selecting&&((t.metaKey||t.ctrlKey)&&i.startselected?(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.$element.addClass("ui-selected"),i.selected=!0):(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.startselected&&(i.$element.addClass("ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",t,{unselecting:i.element}))),i.selected&&(t.metaKey||t.ctrlKey||i.startselected||(i.$element.removeClass("ui-selected"),i.selected=!1,i.$element.addClass("ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",t,{unselecting:i.element})))))}),!1}},_mouseStop:function(t){var i=this;return this.dragged=!1,e(".ui-unselecting",this.element[0]).each(function(){var s=e.data(this,"selectable-item");s.$element.removeClass("ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",t,{unselected:s.element})}),e(".ui-selecting",this.element[0]).each(function(){var s=e.data(this,"selectable-item");s.$element.removeClass("ui-selecting").addClass("ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",t,{selected:s.element})}),this._trigger("stop",t),this.helper.remove(),!1}}),e.widget("ui.selectmenu",{version:"1.11.4",defaultElement:"<select>",options:{appendTo:null,disabled:null,icons:{button:"ui-icon-triangle-1-s"},position:{my:"left top",at:"left bottom",collision:"none"},width:null,change:null,close:null,focus:null,open:null,select:null},_create:function(){var e=this.element.uniqueId().attr("id");this.ids={element:e,button:e+"-button",menu:e+"-menu"},this._drawButton(),this._drawMenu(),this.options.disabled&&this.disable()},_drawButton:function(){var t=this;this.label=e("label[for='"+this.ids.element+"']").attr("for",this.ids.button),this._on(this.label,{click:function(e){this.button.focus(),e.preventDefault()}}),this.element.hide(),this.button=e("<span>",{"class":"ui-selectmenu-button ui-widget ui-state-default ui-corner-all",tabindex:this.options.disabled?-1:0,id:this.ids.button,role:"combobox","aria-expanded":"false","aria-autocomplete":"list","aria-owns":this.ids.menu,"aria-haspopup":"true"}).insertAfter(this.element),e("<span>",{"class":"ui-icon "+this.options.icons.button}).prependTo(this.button),this.buttonText=e("<span>",{"class":"ui-selectmenu-text"}).appendTo(this.button),this._setText(this.buttonText,this.element.find("option:selected").text()),this._resizeButton(),this._on(this.button,this._buttonEvents),this.button.one("focusin",function(){t.menuItems||t._refreshMenu()}),this._hoverable(this.button),this._focusable(this.button)},_drawMenu:function(){var t=this;this.menu=e("<ul>",{"aria-hidden":"true","aria-labelledby":this.ids.button,id:this.ids.menu}),this.menuWrap=e("<div>",{"class":"ui-selectmenu-menu ui-front"}).append(this.menu).appendTo(this._appendTo()),this.menuInstance=this.menu.menu({role:"listbox",select:function(e,i){e.preventDefault(),t._setSelection(),t._select(i.item.data("ui-selectmenu-item"),e)},focus:function(e,i){var s=i.item.data("ui-selectmenu-item");null!=t.focusIndex&&s.index!==t.focusIndex&&(t._trigger("focus",e,{item:s}),t.isOpen||t._select(s,e)),t.focusIndex=s.index,t.button.attr("aria-activedescendant",t.menuItems.eq(s.index).attr("id"))}}).menu("instance"),this.menu.addClass("ui-corner-bottom").removeClass("ui-corner-all"),this.menuInstance._off(this.menu,"mouseleave"),this.menuInstance._closeOnDocumentClick=function(){return!1},this.menuInstance._isDivider=function(){return!1}},refresh:function(){this._refreshMenu(),this._setText(this.buttonText,this._getSelectedItem().text()),this.options.width||this._resizeButton()},_refreshMenu:function(){this.menu.empty();var e,t=this.element.find("option");t.length&&(this._parseOptions(t),this._renderMenu(this.menu,this.items),this.menuInstance.refresh(),this.menuItems=this.menu.find("li").not(".ui-selectmenu-optgroup"),e=this._getSelectedItem(),this.menuInstance.focus(null,e),this._setAria(e.data("ui-selectmenu-item")),this._setOption("disabled",this.element.prop("disabled")))},open:function(e){this.options.disabled||(this.menuItems?(this.menu.find(".ui-state-focus").removeClass("ui-state-focus"),this.menuInstance.focus(null,this._getSelectedItem())):this._refreshMenu(),this.isOpen=!0,this._toggleAttr(),this._resizeMenu(),this._position(),this._on(this.document,this._documentClick),this._trigger("open",e))},_position:function(){this.menuWrap.position(e.extend({of:this.button},this.options.position))},close:function(e){this.isOpen&&(this.isOpen=!1,this._toggleAttr(),this.range=null,this._off(this.document),this._trigger("close",e))},widget:function(){return this.button},menuWidget:function(){return this.menu},_renderMenu:function(t,i){var s=this,n="";e.each(i,function(i,a){a.optgroup!==n&&(e("<li>",{"class":"ui-selectmenu-optgroup ui-menu-divider"+(a.element.parent("optgroup").prop("disabled")?" ui-state-disabled":""),text:a.optgroup}).appendTo(t),n=a.optgroup),s._renderItemData(t,a)})},_renderItemData:function(e,t){return this._renderItem(e,t).data("ui-selectmenu-item",t)},_renderItem:function(t,i){var s=e("<li>");return i.disabled&&s.addClass("ui-state-disabled"),this._setText(s,i.label),s.appendTo(t)},_setText:function(e,t){t?e.text(t):e.html("&#160;")},_move:function(e,t){var i,s,n=".ui-menu-item";this.isOpen?i=this.menuItems.eq(this.focusIndex):(i=this.menuItems.eq(this.element[0].selectedIndex),n+=":not(.ui-state-disabled)"),s="first"===e||"last"===e?i["first"===e?"prevAll":"nextAll"](n).eq(-1):i[e+"All"](n).eq(0),s.length&&this.menuInstance.focus(t,s)},_getSelectedItem:function(){return this.menuItems.eq(this.element[0].selectedIndex)},_toggle:function(e){this[this.isOpen?"close":"open"](e)},_setSelection:function(){var e;this.range&&(window.getSelection?(e=window.getSelection(),e.removeAllRanges(),e.addRange(this.range)):this.range.select(),this.button.focus())},_documentClick:{mousedown:function(t){this.isOpen&&(e(t.target).closest(".ui-selectmenu-menu, #"+this.ids.button).length||this.close(t))}},_buttonEvents:{mousedown:function(){var e;window.getSelection?(e=window.getSelection(),e.rangeCount&&(this.range=e.getRangeAt(0))):this.range=document.selection.createRange()},click:function(e){this._setSelection(),this._toggle(e)},keydown:function(t){var i=!0;switch(t.keyCode){case e.ui.keyCode.TAB:case e.ui.keyCode.ESCAPE:this.close(t),i=!1;break;case e.ui.keyCode.ENTER:this.isOpen&&this._selectFocusedItem(t);break;case e.ui.keyCode.UP:t.altKey?this._toggle(t):this._move("prev",t);break;case e.ui.keyCode.DOWN:t.altKey?this._toggle(t):this._move("next",t);break;case e.ui.keyCode.SPACE:this.isOpen?this._selectFocusedItem(t):this._toggle(t);break;case e.ui.keyCode.LEFT:this._move("prev",t);break;case e.ui.keyCode.RIGHT:this._move("next",t);break;case e.ui.keyCode.HOME:case e.ui.keyCode.PAGE_UP:this._move("first",t);break;case e.ui.keyCode.END:case e.ui.keyCode.PAGE_DOWN:this._move("last",t);break;default:this.menu.trigger(t),i=!1}i&&t.preventDefault()}},_selectFocusedItem:function(e){var t=this.menuItems.eq(this.focusIndex);t.hasClass("ui-state-disabled")||this._select(t.data("ui-selectmenu-item"),e)},_select:function(e,t){var i=this.element[0].selectedIndex;this.element[0].selectedIndex=e.index,this._setText(this.buttonText,e.label),this._setAria(e),this._trigger("select",t,{item:e}),e.index!==i&&this._trigger("change",t,{item:e}),this.close(t)},_setAria:function(e){var t=this.menuItems.eq(e.index).attr("id");this.button.attr({"aria-labelledby":t,"aria-activedescendant":t}),this.menu.attr("aria-activedescendant",t)},_setOption:function(e,t){"icons"===e&&this.button.find("span.ui-icon").removeClass(this.options.icons.button).addClass(t.button),this._super(e,t),"appendTo"===e&&this.menuWrap.appendTo(this._appendTo()),"disabled"===e&&(this.menuInstance.option("disabled",t),this.button.toggleClass("ui-state-disabled",t).attr("aria-disabled",t),this.element.prop("disabled",t),t?(this.button.attr("tabindex",-1),this.close()):this.button.attr("tabindex",0)),"width"===e&&this._resizeButton()},_appendTo:function(){var t=this.options.appendTo;return t&&(t=t.jquery||t.nodeType?e(t):this.document.find(t).eq(0)),t&&t[0]||(t=this.element.closest(".ui-front")),t.length||(t=this.document[0].body),t},_toggleAttr:function(){this.button.toggleClass("ui-corner-top",this.isOpen).toggleClass("ui-corner-all",!this.isOpen).attr("aria-expanded",this.isOpen),this.menuWrap.toggleClass("ui-selectmenu-open",this.isOpen),this.menu.attr("aria-hidden",!this.isOpen)},_resizeButton:function(){var e=this.options.width;e||(e=this.element.show().outerWidth(),this.element.hide()),this.button.outerWidth(e)},_resizeMenu:function(){this.menu.outerWidth(Math.max(this.button.outerWidth(),this.menu.width("").outerWidth()+1))},_getCreateOptions:function(){return{disabled:this.element.prop("disabled")}},_parseOptions:function(t){var i=[];t.each(function(t,s){var n=e(s),a=n.parent("optgroup");i.push({element:n,index:t,value:n.val(),label:n.text(),optgroup:a.attr("label")||"",disabled:a.prop("disabled")||n.prop("disabled")})}),this.items=i},_destroy:function(){this.menuWrap.remove(),this.button.remove(),this.element.show(),this.element.removeUniqueId(),this.label.attr("for",this.ids.element)}}),e.widget("ui.slider",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"slide",options:{animate:!1,distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this._calculateNewMax(),this.element.addClass("ui-slider ui-slider-"+this.orientation+" ui-widget"+" ui-widget-content"+" ui-corner-all"),this._refresh(),this._setOption("disabled",this.options.disabled),this._animateOff=!1},_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var t,i,s=this.options,n=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),a="<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",o=[];for(i=s.values&&s.values.length||1,n.length>i&&(n.slice(i).remove(),n=n.slice(0,i)),t=n.length;i>t;t++)o.push(a);this.handles=n.add(e(o.join("")).appendTo(this.element)),this.handle=this.handles.eq(0),this.handles.each(function(t){e(this).data("ui-slider-handle-index",t)})},_createRange:function(){var t=this.options,i="";t.range?(t.range===!0&&(t.values?t.values.length&&2!==t.values.length?t.values=[t.values[0],t.values[0]]:e.isArray(t.values)&&(t.values=t.values.slice(0)):t.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({left:"",bottom:""}):(this.range=e("<div></div>").appendTo(this.element),i="ui-slider-range ui-widget-header ui-corner-all"),this.range.addClass(i+("min"===t.range||"max"===t.range?" ui-slider-range-"+t.range:""))):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-widget ui-widget-content ui-corner-all"),this._mouseDestroy()},_mouseCapture:function(t){var i,s,n,a,o,r,h,l,u=this,d=this.options;return d.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),i={x:t.pageX,y:t.pageY},s=this._normValueFromMouse(i),n=this._valueMax()-this._valueMin()+1,this.handles.each(function(t){var i=Math.abs(s-u.values(t));(n>i||n===i&&(t===u._lastChangedValue||u.values(t)===d.min))&&(n=i,a=e(this),o=t)}),r=this._start(t,o),r===!1?!1:(this._mouseSliding=!0,this._handleIndex=o,a.addClass("ui-state-active").focus(),h=a.offset(),l=!e(t.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:t.pageX-h.left-a.width()/2,top:t.pageY-h.top-a.height()/2-(parseInt(a.css("borderTopWidth"),10)||0)-(parseInt(a.css("borderBottomWidth"),10)||0)+(parseInt(a.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(t,o,s),this._animateOff=!0,!0))},_mouseStart:function(){return!0},_mouseDrag:function(e){var t={x:e.pageX,y:e.pageY},i=this._normValueFromMouse(t);return this._slide(e,this._handleIndex,i),!1},_mouseStop:function(e){return this.handles.removeClass("ui-state-active"),this._mouseSliding=!1,this._stop(e,this._handleIndex),this._change(e,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(e){var t,i,s,n,a;return"horizontal"===this.orientation?(t=this.elementSize.width,i=e.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(t=this.elementSize.height,i=e.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),s=i/t,s>1&&(s=1),0>s&&(s=0),"vertical"===this.orientation&&(s=1-s),n=this._valueMax()-this._valueMin(),a=this._valueMin()+s*n,this._trimAlignValue(a)},_start:function(e,t){var i={handle:this.handles[t],value:this.value()};return this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._trigger("start",e,i)},_slide:function(e,t,i){var s,n,a;this.options.values&&this.options.values.length?(s=this.values(t?0:1),2===this.options.values.length&&this.options.range===!0&&(0===t&&i>s||1===t&&s>i)&&(i=s),i!==this.values(t)&&(n=this.values(),n[t]=i,a=this._trigger("slide",e,{handle:this.handles[t],value:i,values:n}),s=this.values(t?0:1),a!==!1&&this.values(t,i))):i!==this.value()&&(a=this._trigger("slide",e,{handle:this.handles[t],value:i}),a!==!1&&this.value(i))},_stop:function(e,t){var i={handle:this.handles[t],value:this.value()};this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._trigger("stop",e,i)},_change:function(e,t){if(!this._keySliding&&!this._mouseSliding){var i={handle:this.handles[t],value:this.value()};this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._lastChangedValue=t,this._trigger("change",e,i)}},value:function(e){return arguments.length?(this.options.value=this._trimAlignValue(e),this._refreshValue(),this._change(null,0),void 0):this._value()},values:function(t,i){var s,n,a;if(arguments.length>1)return this.options.values[t]=this._trimAlignValue(i),this._refreshValue(),this._change(null,t),void 0;if(!arguments.length)return this._values();if(!e.isArray(arguments[0]))return this.options.values&&this.options.values.length?this._values(t):this.value();for(s=this.options.values,n=arguments[0],a=0;s.length>a;a+=1)s[a]=this._trimAlignValue(n[a]),this._change(null,a);this._refreshValue()},_setOption:function(t,i){var s,n=0;switch("range"===t&&this.options.range===!0&&("min"===i?(this.options.value=this._values(0),this.options.values=null):"max"===i&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),e.isArray(this.options.values)&&(n=this.options.values.length),"disabled"===t&&this.element.toggleClass("ui-state-disabled",!!i),this._super(t,i),t){case"orientation":this._detectOrientation(),this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation),this._refreshValue(),this.handles.css("horizontal"===i?"bottom":"left","");break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":for(this._animateOff=!0,this._refreshValue(),s=0;n>s;s+=1)this._change(null,s);this._animateOff=!1;break;case"step":case"min":case"max":this._animateOff=!0,this._calculateNewMax(),this._refreshValue(),this._animateOff=!1;break;case"range":this._animateOff=!0,this._refresh(),this._animateOff=!1}},_value:function(){var e=this.options.value;return e=this._trimAlignValue(e)},_values:function(e){var t,i,s;if(arguments.length)return t=this.options.values[e],t=this._trimAlignValue(t);if(this.options.values&&this.options.values.length){for(i=this.options.values.slice(),s=0;i.length>s;s+=1)i[s]=this._trimAlignValue(i[s]);return i}return[]},_trimAlignValue:function(e){if(this._valueMin()>=e)return this._valueMin();if(e>=this._valueMax())return this._valueMax();var t=this.options.step>0?this.options.step:1,i=(e-this._valueMin())%t,s=e-i;return 2*Math.abs(i)>=t&&(s+=i>0?t:-t),parseFloat(s.toFixed(5))},_calculateNewMax:function(){var e=this.options.max,t=this._valueMin(),i=this.options.step,s=Math.floor(+(e-t).toFixed(this._precision())/i)*i;e=s+t,this.max=parseFloat(e.toFixed(this._precision()))},_precision:function(){var e=this._precisionOf(this.options.step);return null!==this.options.min&&(e=Math.max(e,this._precisionOf(this.options.min))),e},_precisionOf:function(e){var t=""+e,i=t.indexOf(".");return-1===i?0:t.length-i-1},_valueMin:function(){return this.options.min},_valueMax:function(){return this.max},_refreshValue:function(){var t,i,s,n,a,o=this.options.range,r=this.options,h=this,l=this._animateOff?!1:r.animate,u={};this.options.values&&this.options.values.length?this.handles.each(function(s){i=100*((h.values(s)-h._valueMin())/(h._valueMax()-h._valueMin())),u["horizontal"===h.orientation?"left":"bottom"]=i+"%",e(this).stop(1,1)[l?"animate":"css"](u,r.animate),h.options.range===!0&&("horizontal"===h.orientation?(0===s&&h.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({width:i-t+"%"},{queue:!1,duration:r.animate})):(0===s&&h.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({height:i-t+"%"},{queue:!1,duration:r.animate}))),t=i}):(s=this.value(),n=this._valueMin(),a=this._valueMax(),i=a!==n?100*((s-n)/(a-n)):0,u["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](u,r.animate),"min"===o&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},r.animate),"max"===o&&"horizontal"===this.orientation&&this.range[l?"animate":"css"]({width:100-i+"%"},{queue:!1,duration:r.animate}),"min"===o&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},r.animate),"max"===o&&"vertical"===this.orientation&&this.range[l?"animate":"css"]({height:100-i+"%"},{queue:!1,duration:r.animate}))},_handleEvents:{keydown:function(t){var i,s,n,a,o=e(t.target).data("ui-slider-handle-index");switch(t.keyCode){case e.ui.keyCode.HOME:case e.ui.keyCode.END:case e.ui.keyCode.PAGE_UP:case e.ui.keyCode.PAGE_DOWN:case e.ui.keyCode.UP:case e.ui.keyCode.RIGHT:case e.ui.keyCode.DOWN:case e.ui.keyCode.LEFT:if(t.preventDefault(),!this._keySliding&&(this._keySliding=!0,e(t.target).addClass("ui-state-active"),i=this._start(t,o),i===!1))return}switch(a=this.options.step,s=n=this.options.values&&this.options.values.length?this.values(o):this.value(),t.keyCode){case e.ui.keyCode.HOME:n=this._valueMin();break;case e.ui.keyCode.END:n=this._valueMax();break;case e.ui.keyCode.PAGE_UP:n=this._trimAlignValue(s+(this._valueMax()-this._valueMin())/this.numPages);break;case e.ui.keyCode.PAGE_DOWN:n=this._trimAlignValue(s-(this._valueMax()-this._valueMin())/this.numPages);break;case e.ui.keyCode.UP:case e.ui.keyCode.RIGHT:if(s===this._valueMax())return;n=this._trimAlignValue(s+a);break;case e.ui.keyCode.DOWN:case e.ui.keyCode.LEFT:if(s===this._valueMin())return;n=this._trimAlignValue(s-a)}this._slide(t,o,n)},keyup:function(t){var i=e(t.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(t,i),this._change(t,i),e(t.target).removeClass("ui-state-active"))}}}),e.widget("ui.sortable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(e,t,i){return e>=t&&t+i>e},_isFloating:function(e){return/left|right/.test(e.css("float"))||/inline|table-cell/.test(e.css("display"))},_create:function(){this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(e,t){this._super(e,t),"handle"===e&&this._setHandleClassName()},_setHandleClassName:function(){this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle"),e.each(this.items,function(){(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item).addClass("ui-sortable-handle")})},_destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle"),this._mouseDestroy();for(var e=this.items.length-1;e>=0;e--)this.items[e].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(t,i){var s=null,n=!1,a=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(t),e(t.target).parents().each(function(){return e.data(this,a.widgetName+"-item")===a?(s=e(this),!1):void 0}),e.data(t.target,a.widgetName+"-item")===a&&(s=e(t.target)),s?!this.options.handle||i||(e(this.options.handle,s).find("*").addBack().each(function(){this===t.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(t,i,s){var n,a,o=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(t),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,o.cursorAt&&this._adjustOffsetFromHelper(o.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),o.containment&&this._setContainment(),o.cursor&&"auto"!==o.cursor&&(a=this.document.find("body"),this.storedCursor=a.css("cursor"),a.css("cursor",o.cursor),this.storedStylesheet=e("<style>*{ cursor: "+o.cursor+" !important; }</style>").appendTo(a)),o.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",o.opacity)),o.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",o.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",t,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",t,this._uiHash(this));
return e.ui.ddmanager&&(e.ui.ddmanager.current=this),e.ui.ddmanager&&!o.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(t),!0},_mouseDrag:function(t){var i,s,n,a,o=this.options,r=!1;for(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-t.pageY<o.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+o.scrollSpeed:t.pageY-this.overflowOffset.top<o.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-o.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-t.pageX<o.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+o.scrollSpeed:t.pageX-this.overflowOffset.left<o.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-o.scrollSpeed)):(t.pageY-this.document.scrollTop()<o.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-o.scrollSpeed):this.window.height()-(t.pageY-this.document.scrollTop())<o.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+o.scrollSpeed)),t.pageX-this.document.scrollLeft()<o.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-o.scrollSpeed):this.window.width()-(t.pageX-this.document.scrollLeft())<o.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+o.scrollSpeed))),r!==!1&&e.ui.ddmanager&&!o.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],a=this._intersectsWithPointer(s),a&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===a?"next":"prev"]()[0]!==n&&!e.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!e.contains(this.element[0],n):!0)){if(this.direction=1===a?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(t,s),this._trigger("change",t,this._uiHash());break}return this._contactContainers(t),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),this._trigger("sort",t,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(t,i){if(t){if(e.ui.ddmanager&&!this.options.dropBehaviour&&e.ui.ddmanager.drop(this,t),this.options.revert){var s=this,n=this.placeholder.offset(),a=this.options.axis,o={};a&&"x"!==a||(o.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),a&&"y"!==a||(o.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,e(this.helper).animate(o,parseInt(this.options.revert,10)||500,function(){s._clear(t)})}else this._clear(t,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"===this.options.helper?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var t=this.containers.length-1;t>=0;t--)this.containers[t]._trigger("deactivate",null,this._uiHash(this)),this.containers[t].containerCache.over&&(this.containers[t]._trigger("out",null,this._uiHash(this)),this.containers[t].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),e.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?e(this.domPosition.prev).after(this.currentItem):e(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},e(i).each(function(){var i=(e(t.item||this).attr(t.attribute||"id")||"").match(t.expression||/(.+)[\-=_](.+)/);i&&s.push((t.key||i[1]+"[]")+"="+(t.key&&t.expression?i[1]:i[2]))}),!s.length&&t.key&&s.push(t.key+"="),s.join("&")},toArray:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},i.each(function(){s.push(e(t.item||this).attr(t.attribute||"id")||"")}),s},_intersectsWith:function(e){var t=this.positionAbs.left,i=t+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,a=e.left,o=a+e.width,r=e.top,h=r+e.height,l=this.offset.click.top,u=this.offset.click.left,d="x"===this.options.axis||s+l>r&&h>s+l,c="y"===this.options.axis||t+u>a&&o>t+u,p=d&&c;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>e[this.floating?"width":"height"]?p:t+this.helperProportions.width/2>a&&o>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&h>n-this.helperProportions.height/2},_intersectsWithPointer:function(e){var t="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,e.top,e.height),i="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,e.left,e.width),s=t&&i,n=this._getDragVerticalDirection(),a=this._getDragHorizontalDirection();return s?this.floating?a&&"right"===a||"down"===n?2:1:n&&("down"===n?2:1):!1},_intersectsWithSides:function(e){var t=this._isOverAxis(this.positionAbs.top+this.offset.click.top,e.top+e.height/2,e.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,e.left+e.width/2,e.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&t||"up"===s&&!t)},_getDragVerticalDirection:function(){var e=this.positionAbs.top-this.lastPositionAbs.top;return 0!==e&&(e>0?"down":"up")},_getDragHorizontalDirection:function(){var e=this.positionAbs.left-this.lastPositionAbs.left;return 0!==e&&(e>0?"right":"left")},refresh:function(e){return this._refreshItems(e),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var e=this.options;return e.connectWith.constructor===String?[e.connectWith]:e.connectWith},_getItemsAsjQuery:function(t){function i(){r.push(this)}var s,n,a,o,r=[],h=[],l=this._connectWith();if(l&&t)for(s=l.length-1;s>=0;s--)for(a=e(l[s],this.document[0]),n=a.length-1;n>=0;n--)o=e.data(a[n],this.widgetFullName),o&&o!==this&&!o.options.disabled&&h.push([e.isFunction(o.options.items)?o.options.items.call(o.element):e(o.options.items,o.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),o]);for(h.push([e.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):e(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return e(r)},_removeCurrentsFromItems:function(){var t=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=e.grep(this.items,function(e){for(var i=0;t.length>i;i++)if(t[i]===e.item[0])return!1;return!0})},_refreshItems:function(t){this.items=[],this.containers=[this];var i,s,n,a,o,r,h,l,u=this.items,d=[[e.isFunction(this.options.items)?this.options.items.call(this.element[0],t,{item:this.currentItem}):e(this.options.items,this.element),this]],c=this._connectWith();if(c&&this.ready)for(i=c.length-1;i>=0;i--)for(n=e(c[i],this.document[0]),s=n.length-1;s>=0;s--)a=e.data(n[s],this.widgetFullName),a&&a!==this&&!a.options.disabled&&(d.push([e.isFunction(a.options.items)?a.options.items.call(a.element[0],t,{item:this.currentItem}):e(a.options.items,a.element),a]),this.containers.push(a));for(i=d.length-1;i>=0;i--)for(o=d[i][1],r=d[i][0],s=0,l=r.length;l>s;s++)h=e(r[s]),h.data(this.widgetName+"-item",o),u.push({item:h,instance:o,width:0,height:0,left:0,top:0})},refreshPositions:function(t){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,a;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?e(this.options.toleranceElement,s.item):s.item,t||(s.width=n.outerWidth(),s.height=n.outerHeight()),a=n.offset(),s.left=a.left,s.top=a.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)a=this.containers[i].element.offset(),this.containers[i].containerCache.left=a.left,this.containers[i].containerCache.top=a.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(t){t=t||this;var i,s=t.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=t.currentItem[0].nodeName.toLowerCase(),n=e("<"+s+">",t.document[0]).addClass(i||t.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper");return"tbody"===s?t._createTrPlaceholder(t.currentItem.find("tr").eq(0),e("<tr>",t.document[0]).appendTo(n)):"tr"===s?t._createTrPlaceholder(t.currentItem,n):"img"===s&&n.attr("src",t.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(e,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(t.currentItem.innerHeight()-parseInt(t.currentItem.css("paddingTop")||0,10)-parseInt(t.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(t.currentItem.innerWidth()-parseInt(t.currentItem.css("paddingLeft")||0,10)-parseInt(t.currentItem.css("paddingRight")||0,10)))}}),t.placeholder=e(s.placeholder.element.call(t.element,t.currentItem)),t.currentItem.after(t.placeholder),s.placeholder.update(t,t.placeholder)},_createTrPlaceholder:function(t,i){var s=this;t.children().each(function(){e("<td>&#160;</td>",s.document[0]).attr("colspan",e(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(t){var i,s,n,a,o,r,h,l,u,d,c=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!e.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(c&&e.contains(this.containers[i].element[0],c.element[0]))continue;c=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",t,this._uiHash(this)),this.containers[i].containerCache.over=0);if(c)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",t,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,a=null,u=c.floating||this._isFloating(this.currentItem),o=u?"left":"top",r=u?"width":"height",d=u?"clientX":"clientY",s=this.items.length-1;s>=0;s--)e.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(h=this.items[s].item.offset()[o],l=!1,t[d]-h>this.items[s][r]/2&&(l=!0),n>Math.abs(t[d]-h)&&(n=Math.abs(t[d]-h),a=this.items[s],this.direction=l?"up":"down"));if(!a&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",t,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;a?this._rearrange(t,a,null,!0):this._rearrange(t,null,this.containers[p].element,!0),this._trigger("change",t,this._uiHash()),this.containers[p]._trigger("change",t,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",t,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||e("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&e.ui.ie)&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var e=this.currentItem.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.width():this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(t=e(n.containment)[0],i=e(n.containment).offset(),s="hidden"!==e(t).css("overflow"),this.containment=[i.left+(parseInt(e(t).css("borderLeftWidth"),10)||0)+(parseInt(e(t).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(e(t).css("borderTopWidth"),10)||0)+(parseInt(e(t).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(t.scrollWidth,t.offsetWidth):t.offsetWidth)-(parseInt(e(t).css("borderLeftWidth"),10)||0)-(parseInt(e(t).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(t.scrollHeight,t.offsetHeight):t.offsetHeight)-(parseInt(e(t).css("borderTopWidth"),10)||0)-(parseInt(e(t).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(t,i){i||(i=this.position);var s="absolute"===t?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,a=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():a?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():a?0:n.scrollLeft())*s}},_generatePosition:function(t){var i,s,n=this.options,a=t.pageX,o=t.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(t.pageX-this.offset.click.left<this.containment[0]&&(a=this.containment[0]+this.offset.click.left),t.pageY-this.offset.click.top<this.containment[1]&&(o=this.containment[1]+this.offset.click.top),t.pageX-this.offset.click.left>this.containment[2]&&(a=this.containment[2]+this.offset.click.left),t.pageY-this.offset.click.top>this.containment[3]&&(o=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((o-this.originalPageY)/n.grid[1])*n.grid[1],o=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((a-this.originalPageX)/n.grid[0])*n.grid[0],a=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:o-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:r.scrollTop()),left:a-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:r.scrollLeft())}},_rearrange:function(e,t,i,s){i?i[0].appendChild(this.placeholder[0]):t.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?t.item[0]:t.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(e,t){function i(e,t,i){return function(s){i._trigger(e,s,t._uiHash(t))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!t&&n.push(function(e){this._trigger("receive",e,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||t||n.push(function(e){this._trigger("update",e,this._uiHash())}),this!==this.currentContainer&&(t||(n.push(function(e){this._trigger("remove",e,this._uiHash())}),n.push(function(e){return function(t){e._trigger("receive",t,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(e){return function(t){e._trigger("update",t,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)t||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,t||this._trigger("beforeStop",e,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!t){for(s=0;n.length>s;s++)n[s].call(this,e);this._trigger("stop",e,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){e.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(t){var i=t||this;return{helper:i.helper,placeholder:i.placeholder||e([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:t?t.element:null}}}),e.widget("ui.spinner",{version:"1.11.4",defaultElement:"<input>",widgetEventPrefix:"spin",options:{culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),""!==this.value()&&this._value(this.element.val(),!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var t={},i=this.element;return e.each(["min","max","step"],function(e,s){var n=i.attr(s);void 0!==n&&n.length&&(t[s]=n)}),t},_events:{keydown:function(e){this._start(e)&&this._keydown(e)&&e.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(e){return this.cancelBlur?(delete this.cancelBlur,void 0):(this._stop(),this._refresh(),this.previous!==this.element.val()&&this._trigger("change",e),void 0)},mousewheel:function(e,t){if(t){if(!this.spinning&&!this._start(e))return!1;this._spin((t>0?1:-1)*this.options.step,e),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(e)},100),e.preventDefault()}},"mousedown .ui-spinner-button":function(t){function i(){var e=this.element[0]===this.document[0].activeElement;e||(this.element.focus(),this.previous=s,this._delay(function(){this.previous=s}))}var s;s=this.element[0]===this.document[0].activeElement?this.previous:this.element.val(),t.preventDefault(),i.call(this),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,i.call(this)}),this._start(t)!==!1&&this._repeat(null,e(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(t){return e(t.currentTarget).hasClass("ui-state-active")?this._start(t)===!1?!1:(this._repeat(null,e(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t),void 0):void 0},"mouseleave .ui-spinner-button":"_stop"},_draw:function(){var e=this.uiSpinner=this.element.addClass("ui-spinner-input").attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());this.element.attr("role","spinbutton"),this.buttons=e.find(".ui-spinner-button").attr("tabIndex",-1).button().removeClass("ui-corner-all"),this.buttons.height()>Math.ceil(.5*e.height())&&e.height()>0&&e.height(e.height()),this.options.disabled&&this.disable()},_keydown:function(t){var i=this.options,s=e.ui.keyCode;switch(t.keyCode){case s.UP:return this._repeat(null,1,t),!0;case s.DOWN:return this._repeat(null,-1,t),!0;case s.PAGE_UP:return this._repeat(null,i.page,t),!0;case s.PAGE_DOWN:return this._repeat(null,-i.page,t),!0}return!1},_uiSpinnerHtml:function(){return"<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>"},_buttonHtml:function(){return"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'><span class='ui-icon "+this.options.icons.up+"'>&#9650;</span>"+"</a>"+"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>"+"<span class='ui-icon "+this.options.icons.down+"'>&#9660;</span>"+"</a>"},_start:function(e){return this.spinning||this._trigger("start",e)!==!1?(this.counter||(this.counter=1),this.spinning=!0,!0):!1},_repeat:function(e,t,i){e=e||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,t,i)},e),this._spin(t*this.options.step,i)},_spin:function(e,t){var i=this.value()||0;this.counter||(this.counter=1),i=this._adjustValue(i+e*this._increment(this.counter)),this.spinning&&this._trigger("spin",t,{value:i})===!1||(this._value(i),this.counter++)},_increment:function(t){var i=this.options.incremental;return i?e.isFunction(i)?i(t):Math.floor(t*t*t/5e4-t*t/500+17*t/200+1):1},_precision:function(){var e=this._precisionOf(this.options.step);return null!==this.options.min&&(e=Math.max(e,this._precisionOf(this.options.min))),e},_precisionOf:function(e){var t=""+e,i=t.indexOf(".");return-1===i?0:t.length-i-1},_adjustValue:function(e){var t,i,s=this.options;return t=null!==s.min?s.min:0,i=e-t,i=Math.round(i/s.step)*s.step,e=t+i,e=parseFloat(e.toFixed(this._precision())),null!==s.max&&e>s.max?s.max:null!==s.min&&s.min>e?s.min:e},_stop:function(e){this.spinning&&(clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!1,this._trigger("stop",e))},_setOption:function(e,t){if("culture"===e||"numberFormat"===e){var i=this._parse(this.element.val());return this.options[e]=t,this.element.val(this._format(i)),void 0}("max"===e||"min"===e||"step"===e)&&"string"==typeof t&&(t=this._parse(t)),"icons"===e&&(this.buttons.first().find(".ui-icon").removeClass(this.options.icons.up).addClass(t.up),this.buttons.last().find(".ui-icon").removeClass(this.options.icons.down).addClass(t.down)),this._super(e,t),"disabled"===e&&(this.widget().toggleClass("ui-state-disabled",!!t),this.element.prop("disabled",!!t),this.buttons.button(t?"disable":"enable"))},_setOptions:h(function(e){this._super(e)}),_parse:function(e){return"string"==typeof e&&""!==e&&(e=window.Globalize&&this.options.numberFormat?Globalize.parseFloat(e,10,this.options.culture):+e),""===e||isNaN(e)?null:e},_format:function(e){return""===e?"":window.Globalize&&this.options.numberFormat?Globalize.format(e,this.options.numberFormat,this.options.culture):e},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},isValid:function(){var e=this.value();return null===e?!1:e===this._adjustValue(e)},_value:function(e,t){var i;""!==e&&(i=this._parse(e),null!==i&&(t||(i=this._adjustValue(i)),e=this._format(i))),this.element.val(e),this._refresh()},_destroy:function(){this.element.removeClass("ui-spinner-input").prop("disabled",!1).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:h(function(e){this._stepUp(e)}),_stepUp:function(e){this._start()&&(this._spin((e||1)*this.options.step),this._stop())},stepDown:h(function(e){this._stepDown(e)}),_stepDown:function(e){this._start()&&(this._spin((e||1)*-this.options.step),this._stop())},pageUp:h(function(e){this._stepUp((e||1)*this.options.page)}),pageDown:h(function(e){this._stepDown((e||1)*this.options.page)}),value:function(e){return arguments.length?(h(this._value).call(this,e),void 0):this._parse(this.element.val())},widget:function(){return this.uiSpinner}}),e.widget("ui.tabs",{version:"1.11.4",delay:300,options:{active:null,collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:function(){var e=/#.*$/;return function(t){var i,s;t=t.cloneNode(!1),i=t.href.replace(e,""),s=location.href.replace(e,"");try{i=decodeURIComponent(i)}catch(n){}try{s=decodeURIComponent(s)}catch(n){}return t.hash.length>1&&i===s}}(),_create:function(){var t=this,i=this.options;this.running=!1,this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible",i.collapsible),this._processTabs(),i.active=this._initialActive(),e.isArray(i.disabled)&&(i.disabled=e.unique(i.disabled.concat(e.map(this.tabs.filter(".ui-state-disabled"),function(e){return t.tabs.index(e)}))).sort()),this.active=this.options.active!==!1&&this.anchors.length?this._findActive(i.active):e(),this._refresh(),this.active.length&&this.load(i.active)},_initialActive:function(){var t=this.options.active,i=this.options.collapsible,s=location.hash.substring(1);return null===t&&(s&&this.tabs.each(function(i,n){return e(n).attr("aria-controls")===s?(t=i,!1):void 0}),null===t&&(t=this.tabs.index(this.tabs.filter(".ui-tabs-active"))),(null===t||-1===t)&&(t=this.tabs.length?0:!1)),t!==!1&&(t=this.tabs.index(this.tabs.eq(t)),-1===t&&(t=i?!1:0)),!i&&t===!1&&this.anchors.length&&(t=0),t},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):e()}},_tabKeydown:function(t){var i=e(this.document[0].activeElement).closest("li"),s=this.tabs.index(i),n=!0;if(!this._handlePageNav(t)){switch(t.keyCode){case e.ui.keyCode.RIGHT:case e.ui.keyCode.DOWN:s++;break;case e.ui.keyCode.UP:case e.ui.keyCode.LEFT:n=!1,s--;break;case e.ui.keyCode.END:s=this.anchors.length-1;break;case e.ui.keyCode.HOME:s=0;break;case e.ui.keyCode.SPACE:return t.preventDefault(),clearTimeout(this.activating),this._activate(s),void 0;case e.ui.keyCode.ENTER:return t.preventDefault(),clearTimeout(this.activating),this._activate(s===this.options.active?!1:s),void 0;default:return}t.preventDefault(),clearTimeout(this.activating),s=this._focusNextTab(s,n),t.ctrlKey||t.metaKey||(i.attr("aria-selected","false"),this.tabs.eq(s).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",s)},this.delay))}},_panelKeydown:function(t){this._handlePageNav(t)||t.ctrlKey&&t.keyCode===e.ui.keyCode.UP&&(t.preventDefault(),this.active.focus())},_handlePageNav:function(t){return t.altKey&&t.keyCode===e.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!1)),!0):t.altKey&&t.keyCode===e.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!0)),!0):void 0},_findNextTab:function(t,i){function s(){return t>n&&(t=0),0>t&&(t=n),t}for(var n=this.tabs.length-1;-1!==e.inArray(s(),this.options.disabled);)t=i?t+1:t-1;return t},_focusNextTab:function(e,t){return e=this._findNextTab(e,t),this.tabs.eq(e).focus(),e},_setOption:function(e,t){return"active"===e?(this._activate(t),void 0):"disabled"===e?(this._setupDisabled(t),void 0):(this._super(e,t),"collapsible"===e&&(this.element.toggleClass("ui-tabs-collapsible",t),t||this.options.active!==!1||this._activate(0)),"event"===e&&this._setupEvents(t),"heightStyle"===e&&this._setupHeightStyle(t),void 0)},_sanitizeSelector:function(e){return e?e.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var t=this.options,i=this.tablist.children(":has(a[href])");t.disabled=e.map(i.filter(".ui-state-disabled"),function(e){return i.index(e)}),this._processTabs(),t.active!==!1&&this.anchors.length?this.active.length&&!e.contains(this.tablist[0],this.active[0])?this.tabs.length===t.disabled.length?(t.active=!1,this.active=e()):this._activate(this._findNextTab(Math.max(0,t.active-1),!1)):t.active=this.tabs.index(this.active):(t.active=!1,this.active=e()),this._refresh()},_refresh:function(){this._setupDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.addClass("ui-tabs-active ui-state-active").attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var t=this,i=this.tabs,s=this.anchors,n=this.panels;
this.tablist=this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role","tablist").delegate("> li","mousedown"+this.eventNamespace,function(t){e(this).is(".ui-state-disabled")&&t.preventDefault()}).delegate(".ui-tabs-anchor","focus"+this.eventNamespace,function(){e(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this.tabs=this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({role:"tab",tabIndex:-1}),this.anchors=this.tabs.map(function(){return e("a",this)[0]}).addClass("ui-tabs-anchor").attr({role:"presentation",tabIndex:-1}),this.panels=e(),this.anchors.each(function(i,s){var n,a,o,r=e(s).uniqueId().attr("id"),h=e(s).closest("li"),l=h.attr("aria-controls");t._isLocal(s)?(n=s.hash,o=n.substring(1),a=t.element.find(t._sanitizeSelector(n))):(o=h.attr("aria-controls")||e({}).uniqueId()[0].id,n="#"+o,a=t.element.find(n),a.length||(a=t._createPanel(o),a.insertAfter(t.panels[i-1]||t.tablist)),a.attr("aria-live","polite")),a.length&&(t.panels=t.panels.add(a)),l&&h.data("ui-tabs-aria-controls",l),h.attr({"aria-controls":o,"aria-labelledby":r}),a.attr("aria-labelledby",r)}),this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role","tabpanel"),i&&(this._off(i.not(this.tabs)),this._off(s.not(this.anchors)),this._off(n.not(this.panels)))},_getList:function(){return this.tablist||this.element.find("ol,ul").eq(0)},_createPanel:function(t){return e("<div>").attr("id",t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy",!0)},_setupDisabled:function(t){e.isArray(t)&&(t.length?t.length===this.anchors.length&&(t=!0):t=!1);for(var i,s=0;i=this.tabs[s];s++)t===!0||-1!==e.inArray(s,t)?e(i).addClass("ui-state-disabled").attr("aria-disabled","true"):e(i).removeClass("ui-state-disabled").removeAttr("aria-disabled");this.options.disabled=t},_setupEvents:function(t){var i={};t&&e.each(t.split(" "),function(e,t){i[t]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!0,this.anchors,{click:function(e){e.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(t){var i,s=this.element.parent();"fill"===t?(i=s.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var t=e(this),s=t.css("position");"absolute"!==s&&"fixed"!==s&&(i-=t.outerHeight(!0))}),this.element.children().not(this.panels).each(function(){i-=e(this).outerHeight(!0)}),this.panels.each(function(){e(this).height(Math.max(0,i-e(this).innerHeight()+e(this).height()))}).css("overflow","auto")):"auto"===t&&(i=0,this.panels.each(function(){i=Math.max(i,e(this).height("").height())}).height(i))},_eventHandler:function(t){var i=this.options,s=this.active,n=e(t.currentTarget),a=n.closest("li"),o=a[0]===s[0],r=o&&i.collapsible,h=r?e():this._getPanelForTab(a),l=s.length?this._getPanelForTab(s):e(),u={oldTab:s,oldPanel:l,newTab:r?e():a,newPanel:h};t.preventDefault(),a.hasClass("ui-state-disabled")||a.hasClass("ui-tabs-loading")||this.running||o&&!i.collapsible||this._trigger("beforeActivate",t,u)===!1||(i.active=r?!1:this.tabs.index(a),this.active=o?e():a,this.xhr&&this.xhr.abort(),l.length||h.length||e.error("jQuery UI Tabs: Mismatching fragment identifier."),h.length&&this.load(this.tabs.index(a),t),this._toggle(t,u))},_toggle:function(t,i){function s(){a.running=!1,a._trigger("activate",t,i)}function n(){i.newTab.closest("li").addClass("ui-tabs-active ui-state-active"),o.length&&a.options.show?a._show(o,a.options.show,s):(o.show(),s())}var a=this,o=i.newPanel,r=i.oldPanel;this.running=!0,r.length&&this.options.hide?this._hide(r,this.options.hide,function(){i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),n()}):(i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),r.hide(),n()),r.attr("aria-hidden","true"),i.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),o.length&&r.length?i.oldTab.attr("tabIndex",-1):o.length&&this.tabs.filter(function(){return 0===e(this).attr("tabIndex")}).attr("tabIndex",-1),o.attr("aria-hidden","false"),i.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(t){var i,s=this._findActive(t);s[0]!==this.active[0]&&(s.length||(s=this.active),i=s.find(".ui-tabs-anchor")[0],this._eventHandler({target:i,currentTarget:i,preventDefault:e.noop}))},_findActive:function(t){return t===!1?e():this.tabs.eq(t)},_getIndex:function(e){return"string"==typeof e&&(e=this.anchors.index(this.anchors.filter("[href$='"+e+"']"))),e},_destroy:function(){this.xhr&&this.xhr.abort(),this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"),this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"),this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId(),this.tablist.unbind(this.eventNamespace),this.tabs.add(this.panels).each(function(){e.data(this,"ui-tabs-destroy")?e(this).remove():e(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role")}),this.tabs.each(function(){var t=e(this),i=t.data("ui-tabs-aria-controls");i?t.attr("aria-controls",i).removeData("ui-tabs-aria-controls"):t.removeAttr("aria-controls")}),this.panels.show(),"content"!==this.options.heightStyle&&this.panels.css("height","")},enable:function(t){var i=this.options.disabled;i!==!1&&(void 0===t?i=!1:(t=this._getIndex(t),i=e.isArray(i)?e.map(i,function(e){return e!==t?e:null}):e.map(this.tabs,function(e,i){return i!==t?i:null})),this._setupDisabled(i))},disable:function(t){var i=this.options.disabled;if(i!==!0){if(void 0===t)i=!0;else{if(t=this._getIndex(t),-1!==e.inArray(t,i))return;i=e.isArray(i)?e.merge([t],i).sort():[t]}this._setupDisabled(i)}},load:function(t,i){t=this._getIndex(t);var s=this,n=this.tabs.eq(t),a=n.find(".ui-tabs-anchor"),o=this._getPanelForTab(n),r={tab:n,panel:o},h=function(e,t){"abort"===t&&s.panels.stop(!1,!0),n.removeClass("ui-tabs-loading"),o.removeAttr("aria-busy"),e===s.xhr&&delete s.xhr};this._isLocal(a[0])||(this.xhr=e.ajax(this._ajaxSettings(a,i,r)),this.xhr&&"canceled"!==this.xhr.statusText&&(n.addClass("ui-tabs-loading"),o.attr("aria-busy","true"),this.xhr.done(function(e,t,n){setTimeout(function(){o.html(e),s._trigger("load",i,r),h(n,t)},1)}).fail(function(e,t){setTimeout(function(){h(e,t)},1)})))},_ajaxSettings:function(t,i,s){var n=this;return{url:t.attr("href"),beforeSend:function(t,a){return n._trigger("beforeLoad",i,e.extend({jqXHR:t,ajaxSettings:a},s))}}},_getPanelForTab:function(t){var i=e(t).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+i))}}),e.widget("ui.tooltip",{version:"1.11.4",options:{content:function(){var t=e(this).attr("title")||"";return e("<a>").text(t).html()},hide:!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flip"},show:!0,tooltipClass:null,track:!1,close:null,open:null},_addDescribedBy:function(t,i){var s=(t.attr("aria-describedby")||"").split(/\s+/);s.push(i),t.data("ui-tooltip-id",i).attr("aria-describedby",e.trim(s.join(" ")))},_removeDescribedBy:function(t){var i=t.data("ui-tooltip-id"),s=(t.attr("aria-describedby")||"").split(/\s+/),n=e.inArray(i,s);-1!==n&&s.splice(n,1),t.removeData("ui-tooltip-id"),s=e.trim(s.join(" ")),s?t.attr("aria-describedby",s):t.removeAttr("aria-describedby")},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.options.disabled&&this._disable(),this.liveRegion=e("<div>").attr({role:"log","aria-live":"assertive","aria-relevant":"additions"}).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body)},_setOption:function(t,i){var s=this;return"disabled"===t?(this[i?"_disable":"_enable"](),this.options[t]=i,void 0):(this._super(t,i),"content"===t&&e.each(this.tooltips,function(e,t){s._updateContent(t.element)}),void 0)},_disable:function(){var t=this;e.each(this.tooltips,function(i,s){var n=e.Event("blur");n.target=n.currentTarget=s.element[0],t.close(n,!0)}),this.element.find(this.options.items).addBack().each(function(){var t=e(this);t.is("[title]")&&t.data("ui-tooltip-title",t.attr("title")).removeAttr("title")})},_enable:function(){this.element.find(this.options.items).addBack().each(function(){var t=e(this);t.data("ui-tooltip-title")&&t.attr("title",t.data("ui-tooltip-title"))})},open:function(t){var i=this,s=e(t?t.target:this.element).closest(this.options.items);s.length&&!s.data("ui-tooltip-id")&&(s.attr("title")&&s.data("ui-tooltip-title",s.attr("title")),s.data("ui-tooltip-open",!0),t&&"mouseover"===t.type&&s.parents().each(function(){var t,s=e(this);s.data("ui-tooltip-open")&&(t=e.Event("blur"),t.target=t.currentTarget=this,i.close(t,!0)),s.attr("title")&&(s.uniqueId(),i.parents[this.id]={element:this,title:s.attr("title")},s.attr("title",""))}),this._registerCloseHandlers(t,s),this._updateContent(s,t))},_updateContent:function(e,t){var i,s=this.options.content,n=this,a=t?t.type:null;return"string"==typeof s?this._open(t,e,s):(i=s.call(e[0],function(i){n._delay(function(){e.data("ui-tooltip-open")&&(t&&(t.type=a),this._open(t,e,i))})}),i&&this._open(t,e,i),void 0)},_open:function(t,i,s){function n(e){l.of=e,o.is(":hidden")||o.position(l)}var a,o,r,h,l=e.extend({},this.options.position);if(s){if(a=this._find(i))return a.tooltip.find(".ui-tooltip-content").html(s),void 0;i.is("[title]")&&(t&&"mouseover"===t.type?i.attr("title",""):i.removeAttr("title")),a=this._tooltip(i),o=a.tooltip,this._addDescribedBy(i,o.attr("id")),o.find(".ui-tooltip-content").html(s),this.liveRegion.children().hide(),s.clone?(h=s.clone(),h.removeAttr("id").find("[id]").removeAttr("id")):h=s,e("<div>").html(h).appendTo(this.liveRegion),this.options.track&&t&&/^mouse/.test(t.type)?(this._on(this.document,{mousemove:n}),n(t)):o.position(e.extend({of:i},this.options.position)),o.hide(),this._show(o,this.options.show),this.options.show&&this.options.show.delay&&(r=this.delayedShow=setInterval(function(){o.is(":visible")&&(n(l.of),clearInterval(r))},e.fx.interval)),this._trigger("open",t,{tooltip:o})}},_registerCloseHandlers:function(t,i){var s={keyup:function(t){if(t.keyCode===e.ui.keyCode.ESCAPE){var s=e.Event(t);s.currentTarget=i[0],this.close(s,!0)}}};i[0]!==this.element[0]&&(s.remove=function(){this._removeTooltip(this._find(i).tooltip)}),t&&"mouseover"!==t.type||(s.mouseleave="close"),t&&"focusin"!==t.type||(s.focusout="close"),this._on(!0,i,s)},close:function(t){var i,s=this,n=e(t?t.currentTarget:this.element),a=this._find(n);return a?(i=a.tooltip,a.closing||(clearInterval(this.delayedShow),n.data("ui-tooltip-title")&&!n.attr("title")&&n.attr("title",n.data("ui-tooltip-title")),this._removeDescribedBy(n),a.hiding=!0,i.stop(!0),this._hide(i,this.options.hide,function(){s._removeTooltip(e(this))}),n.removeData("ui-tooltip-open"),this._off(n,"mouseleave focusout keyup"),n[0]!==this.element[0]&&this._off(n,"remove"),this._off(this.document,"mousemove"),t&&"mouseleave"===t.type&&e.each(this.parents,function(t,i){e(i.element).attr("title",i.title),delete s.parents[t]}),a.closing=!0,this._trigger("close",t,{tooltip:i}),a.hiding||(a.closing=!1)),void 0):(n.removeData("ui-tooltip-open"),void 0)},_tooltip:function(t){var i=e("<div>").attr("role","tooltip").addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content "+(this.options.tooltipClass||"")),s=i.uniqueId().attr("id");return e("<div>").addClass("ui-tooltip-content").appendTo(i),i.appendTo(this.document[0].body),this.tooltips[s]={element:t,tooltip:i}},_find:function(e){var t=e.data("ui-tooltip-id");return t?this.tooltips[t]:null},_removeTooltip:function(e){e.remove(),delete this.tooltips[e.attr("id")]},_destroy:function(){var t=this;e.each(this.tooltips,function(i,s){var n=e.Event("blur"),a=s.element;n.target=n.currentTarget=a[0],t.close(n,!0),e("#"+i).remove(),a.data("ui-tooltip-title")&&(a.attr("title")||a.attr("title",a.data("ui-tooltip-title")),a.removeData("ui-tooltip-title"))}),this.liveRegion.remove()}})});
/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */
/*eslint no-console: ["error", { allow: ["warn", "error","log"] }] */

/**
 * Error dialog module
 */
define('gw/Gui/dialog/ErrorDialog',["../../Utils/Constants", "jquery", "jquery.ui"], function(
    Constants,
    $
) {
    var isDebug = false;

    // The main div for error
    var errorDiv =
        "<div id=\"errorDiv\" style=\"text-align: left\" title=\"Error\"></div>";

    // Create the div, use jQuery UI dialog

    var $text = "";
    var $buttonName = "";

    var $errorDiv = $(errorDiv)
        .appendTo("body")
        .dialog({
            autoOpen: false,
            width: 500,
            minHeight: 300,
            maxHeight: 500,
            dialogClass: "errorBox",
            beforeClose: function(event, ui) {
                $text = "";
            }
        });
    var $active = false;

    var _consoleError = function(txt) {
        if (isDebug) {            
            console.error(txt);
        }
    };

    var _consoleWarn = function(txt) {
        if (isDebug) {
            console.warn(txt);
        }
    };  
    
    var _consoleLog = function(txt) {
        if (isDebug) {
            console.log(txt);
        }
    };      

    var _recordError = function(html) {
        $text += html + "<br/>";
        if ($("#warningContainer")) {
            $("#warningContainer").show();
            $errorDiv.on("dialogclose", function(event) {
                if ($buttonName) {
                    $buttonName.hide();
                }
            });
        }
        if ($active === true) {
            $errorDiv.html($text).dialog("open");
            $errorDiv.scrollTop(5000);
        }
    };

    var _computeMessageHTML = function(message, description) {
        if (description != null && message != null) {
            message = message + " - <font style='color:white'>";
            if (typeof description === "string") {
                message = message + description;
            } else if(description.message) {
                message = message + description.message;
            } else {
                message = message + JSON.stringify(description);
            }
            message = message + "</font>";
        }  
        return message;      
    };

    var _computeMessageASCII = function(message, description) {
        if (description != null && message != null) {  
            if (typeof description === "string") {
                message = message + ":" + description;
            } else if(description.message) {
                message = message +":" + description.message;
            } else {
                message = message + ":" + JSON.stringify(description);
            }                      
        }  
        return message;      
    };  


    return {
        /**
         * Open dialog
         * @param {LEVEL} LEVEL Log level
         * @param {string} title error title
         * @param {string} description error description
         */
        open: function(LEVEL, title, description) {
            var message = "";
            if (LEVEL === Constants.LEVEL.WARNING) {
                message =
                    message +
                    "<font style='color:orange'>Warning : " +
                    title +
                    "</font>";
                _consoleWarn(_computeMessageASCII(title, description));
                _recordError(_computeMessageHTML(message, description));                
            } else if (LEVEL === Constants.LEVEL.ERROR) {
                message =
                    message +
                    "<font style='color:red'>Error : " +
                    title +
                    "</font>";
                _consoleError(_computeMessageASCII(title, description));
                _recordError(_computeMessageHTML(message, description));
            } else if (LEVEL === Constants.LEVEL.DEBUG) {
                _consoleLog(_computeMessageASCII(title, description));
            } else {
                throw new TypeError("LEVEL must be set with a valid value", "ErrorDialog.js");
            }
                      
        },
        /**
         * View the messages in the GUI.
         */
        view: function() {
            $errorDiv.html($text).dialog("open");
            $errorDiv.scrollTop(5000);
            $active = true;
        },
        /**
         * Hides the GUI
         */
        hide: function() {
            $errorDiv.dialog("close");
            $active = false;
        },
        /**
         * GUI is active ?
         * @return {boolean} true when the GUI is shown otherwise false
         */
        isActive: function() {
            return $active;
        },
        /**
         * Sets the icon.
         * @param {string} ID
         */
        setIcon: function(buttonName) {
            $buttonName = $(buttonName);
        },
        /**
         * Has error.
         * @returns {boolean} true when error otherise false
         */
        hasError: function() {
            return $text.length > 0;
        },
        /**
         * Returns the message
         * @returns {string} the message
         */
        getTxt: function() {
            return $text;
        },
        /**
         * Sets debug enable/disable.
         * By default debug is disable.
         * @param {boolean} debug Set to true to show debug message in the console otherwise False 
         */
        setDebug: function(debug) {
            isDebug = debug;
        }

    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/HEALPixBase',["underscore-min","./HEALPixTables", "../Utils/Long", "../Utils/CircleFinder", "../Utils/Constants", "../Gui/dialog/ErrorDialog"], function(
    _,
    HealPixTables,
    Long,
    CircleFinder,
    Constants,
    ErrorDialog
) {
    /**************************************************************************************************************/

    var HALF_PI = Math.PI * 0.5;

    var lonLat2ang = function(lon, lat) {
        if (lon < 0) {
            lon += 360;
        }

        var phi = (lon * Math.PI) / 180.0;

        var theta = ((-lat + 90.0) * Math.PI) / 180.0;
        return [phi, theta];
    };

    /**************************************************************************************************************/

    /** Returns the remainder of the division {@code v1/v2}.
     The result is non-negative.
     @param v1 dividend; can be positive or negative
     @param v2 divisor; must be positive
     @return Remainder of the division; positive and smaller than {@code v2} */
    var fmodulo = function(v1, v2) {
        if (v1 >= 0.0) {
            return v1 < v2 ? v1 : v1 % v2;
        }
        var tmp = (v1 % v2) + v2;
        return tmp === v2 ? 0.0 : tmp;
    };

    /**************************************************************************************************************/

    var spread_bits = function(v) {
        return (
            HealPixTables.utab[v & 0xff] |
            (HealPixTables.utab[(v >>> 8) & 0xff] << 16) |
            (HealPixTables.utab[(v >>> 16) & 0xff] << 32) |
            (HealPixTables.utab[(v >>> 24) & 0xff] << 48)
        );
    };

    /**************************************************************************************************************/

    var xyf2nest = function(ix, iy, face_num, order) {
        return (
            (face_num << (2 * order)) + spread_bits(ix) + (spread_bits(iy) << 1)
        );
    };

    /**************************************************************************************************************/

    var loc2pix = function(order, phi, theta) {
        var nside2 = Math.pow(2, order);
        var z = Math.cos(theta);
        //var phi = phi;

        var loc = {
            phi: phi,
            theta: theta,
            z: z
        };

        if (Math.abs(z) > 9.0 / 10.0) {
            loc.sth = Math.sin(theta);
            loc.have_sth = true;
        }

        var inv_halfpi = 2.0 / Math.PI;
        var tt = fmodulo(phi * inv_halfpi, 4.0); // in [0,4)
        var jp, jm, nSideMinusOne;
        var za = Math.abs(z);
        if (za <= 2.0 / 3.0) {
            // Equatorial region
            var temp1 = nside2 * (0.5 + tt);
            var temp2 = nside2 * (z * 0.75);

            jp = Long.fromNumber(temp1 - temp2);
            jm = Long.fromNumber(temp1 + temp2);
            var ifp = jp.shiftRightUnsigned(order);
            var ifm = jm.shiftRightUnsigned(order);
            var face_num;
            if (ifp.equals(ifm)) {
                face_num = ifp.or(Long.fromInt(4));
            } else {
                if (ifp.lessThan(ifm)) {
                    face_num = ifp;
                } else {
                    face_num = ifm.add(Long.fromInt(8));
                }
            }

            nSideMinusOne = Long.fromNumber(nside2 - 1);
            var ix = jm.and(nSideMinusOne);
            var iy = nSideMinusOne.subtract(jp.and(nSideMinusOne));

            return xyf2nest(ix.toInt(), iy.toInt(), face_num.toInt(), order);
        } // polar region, za > 2/3
        else {
            var ntt = parseInt(Math.min(3, parseInt(tt, 10)), 10);
            var tp = tt - ntt;
            var tmp =
                za < 9.0 / 10.0 || !loc.have_sth
                    ? nside2 * Math.sqrt(3 * (1 - za))
                    : (nside2 * loc.sth) / Math.sqrt((1.0 + za) / 3.0);

            jp = Long.fromNumber(tp * tmp);
            jm = Long.fromNumber((1.0 - tp) * tmp);
            var lNside = Long.fromNumber(nside2);
            nSideMinusOne = Long.fromNumber(nside2 - 1.0);
            var lOne = Long.fromInt(1);
            if (jp.greaterThanOrEqual(lNside)) {
                jp = nSideMinusOne;
            }
            if (jm.greaterThanOrEqual(lNside)) {
                jm = nSideMinusOne;
            }

            if (z >= 0) {
                return xyf2nest(
                    lNside
                        .subtract(jm)
                        .subtract(lOne)
                        .toInt(),
                    lNside
                        .subtract(jp)
                        .subtract(lOne)
                        .toInt(),
                    ntt,
                    order
                );
            } else {
                return xyf2nest(jp.toInt(), jm.toInt(), ntt + 8, order);
            }
        }
    };

    var pstack = function(sz) {
        this.p = new Array(sz);
        this.o = new Array(sz);

        for (var i = 0; i < this.p.length; i++) {
            //this.p[i] = Long.fromInt(0);
            this.p[i] = 0;
            this.o[i] = 0;
        }

        this.s = this.m = 0;
    };

    pstack.prototype.push = function(p_, o_) {
        this.p[this.s] = p_;
        this.o[this.s] = o_;
        ++this.s;
    };

    pstack.prototype.otop = function() {
        return this.o[this.s - 1];
    };

    pstack.prototype.ptop = function() {
        return this.p[this.s - 1];
    };

    pstack.prototype.pop = function() {
        this.s--;
    };

    pstack.prototype.popToMark = function() {
        this.s = this.m;
    };

    pstack.prototype.mark = function() {
        this.m = this.s;
    };

    pstack.prototype.size = function() {
        return this.s;
    };

    /**************************************************************************************************************/

    var HEALPixBase = {
        init: function(options) {
            this.order_max = 29;
            this.bn = [];
            this.nside = null;

            try {
                for (var i = 0; i <= this.order_max; ++i) {
                    this.bn[i] = this.createBoundaries(1.0 << i, "NESTED");
                }
            } catch (ex) {
                /*doesn't happen*/
            }
        },

        createBoundaries: function(nside_in, scheme_in) {
            this.nside = nside_in - 1;
            return this.calculateBoundaries(nside_in, scheme_in);
        },

        compress_bits: function(v) {
            var longV = Long.fromNumber(v);
            var longMask = Long.fromNumber(0x5555555555555);
            var raw = longV.and(longMask);
            var dec = raw.shiftRightUnsigned(15);
            raw = raw.or(dec);
            var raw1 = raw.and(Long.fromNumber(0xffff)).toInt();
            var dec2 = raw.shiftRightUnsigned(32);
            var raw2 = dec2.and(Long.fromNumber(0xffff)).toInt();

            return (
                HealPixTables.ctab[raw1 & 0xff] |
                (HealPixTables.ctab[raw1 >>> 8] << 4) |
                (HealPixTables.ctab[raw2 & 0xff] << 16) |
                (HealPixTables.ctab[raw2 >>> 8] << 20)
            );
        },

        /**
         *    Function describing a location on the sphere
         */
        fxyf: function(_fx, _fy, _face) {
            var jr = HealPixTables.jrll[_face] - _fx - _fy;
            var z = 0;
            var phi = 0;
            var sth = 0;
            var have_sth = false;

            var nr, tmp;
            if (jr < 1) {
                nr = jr;
                tmp = (nr * nr) / 3.0;
                z = 1 - tmp;
                if (z > 0.99) {
                    sth = Math.sqrt(tmp * (2.0 - tmp));
                    have_sth = true;
                }
            } else if (jr > 3) {
                nr = 4 - jr;
                tmp = (nr * nr) / 3.0;
                z = tmp - 1;
                if (z < -0.99) {
                    sth = Math.sqrt(tmp * (2.0 - tmp));
                    have_sth = true;
                }
            } else {
                nr = 1;
                z = ((2 - jr) * 2.0) / 3.0;
            }

            tmp = HealPixTables.jpll[_face] * nr + _fx - _fy;
            if (tmp < 0) {
                tmp += 8;
            }
            if (tmp >= 8) {
                tmp -= 8;
            }

            phi = nr < 1e-15 ? 0 : (0.5 * HALF_PI * tmp) / nr;

            var st = have_sth ? sth : Math.sqrt((1.0 - z) * (1.0 + z));
            return [st * Math.cos(phi), st * Math.sin(phi), z];
        },

        /** Returns the maximum angular distance between a pixel center and its
         corners.
         @return number angular distance between a pixel center and its
         corners. */
        maxPixrad: function(order, nl4) {
            var nside2 = Math.pow(2, order);
            var va = vec3.createZPhi(2.0 / 3.0, Math.PI / nl4);
            var t1 = 1.0 - 1.0 / nside2;
            t1 *= t1;
            var vb = vec3.createZPhi(1 - t1 / 3, 0);
            return vec3.angle2(va, vb);
        },

        pix2vec: function(pix, boundaries) {
            var loc = this.pix2loc(pix, boundaries);
            var st = loc.have_sth
                ? loc.sth
                : Math.sqrt((1.0 - loc.z) * (1.0 + loc.z));
            return vec3.createFrom(
                st * Math.cos(loc.phi),
                st * Math.sin(loc.phi),
                loc.z
            );
        },

        pix2loc: function(pix, boundaries) {
            var z, phi, sth, have_sth;

            //var fact2 = 4.0 / pix;
            //var fact1 = (nside << 1) * fact2;
            //var nl2 = 2 * nside;
            //var nl3 = 3 * nside;
            //var nl4 = 4 * nside;
            //var npface = nside * nside;
            //var ncap = 2 * nside * (nside - 1); // pixels in each polar cap
            //var npix = 12 * npface;
            //var fact2 = 4.0 / npix;
            //var fact1 = (nside << 1) * fact2;

            var loc = {
                phi: null,
                sth: 0.0,
                have_sth: false,
                z: null
            };

            var xyf = this.nest2xyf(pix, boundaries.npface, boundaries.order);

            var jr =
                (HealPixTables.jrll[xyf.face] << boundaries.order) -
                xyf.ix -
                xyf.iy -
                1;

            var nr, tmp;
            if (jr < boundaries.nside) {
                nr = jr;
                tmp = nr * nr * boundaries.fact2;
                loc.z = 1 - tmp;
                if (loc.z > 0.99) {
                    loc.sth = Math.sqrt(tmp * (2.0 - tmp));
                    loc.have_sth = true;
                }
            } else if (jr > boundaries.nl3) {
                nr = boundaries.nl4 - jr;
                tmp = nr * nr * boundaries.fact2;
                loc.z = tmp - 1;
                if (loc.z < -0.99) {
                    loc.sth = Math.sqrt(tmp * (2.0 - tmp));
                    loc.have_sth = true;
                }
            } else {
                nr = boundaries.nside;
                loc.z = (boundaries.nl2 - jr) * boundaries.fact1;
            }

            tmp = HealPixTables.jpll[xyf.face] * nr + xyf.ix - xyf.iy;
            //assert (tmp < 8 * nr); // must not happen

            if (tmp < 0) {
                tmp += 8 * nr;
            }

            loc.phi =
                nr === boundaries.nside
                    ? 0.75 * HALF_PI * tmp * boundaries.fact1
                    : (0.5 * HALF_PI * tmp) / nr;
            return loc;
        },

        nest2xyf: function(ipix, npface, order) {
            var pix = ipix & (npface - 1);

            var ix = HEALPixBase.compress_bits(pix);
            var iy = HEALPixBase.compress_bits(pix >>> 1);
            var face = ipix >>> (2 * order);

            return {
                ix: ix,
                iy: iy,
                face: face
            };
        },

        /**
         *    Static function
         *    Convert nside to order
         *    (ilog2(nside))
         */
        nside2order: function(arg) {
            var res = 0;
            while (arg > 0x0000ffff) {
                res += 16;
                arg >>>= 16;
            }
            if (arg > 0x000000ff) {
                res |= 8;
                arg >>>= 8;
            }
            if (arg > 0x0000000f) {
                res |= 4;
                arg >>>= 4;
            }
            if (arg > 0x00000003) {
                res |= 2;
                arg >>>= 2;
            }
            if (arg > 0x00000001) {
                res |= 1;
            }
            return res;
        },

        calculateBoundaries: function(nside_in, scheme_in) {
            if (this.nside === nside_in) {
                return;
            }
            this.nside = nside_in;

            var order = this.nside2order(nside_in);

            if (scheme_in === "NESTED" && order < 0) {
                throw new Error(
                    "Nside must be a power of 2 for NESTED scheme"
                );
            }

            var nl2 = 2 * this.nside;
            var nl3 = 3 * this.nside;
            var nl4 = 4 * this.nside;
            var npface = this.nside * this.nside;
            var ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap
            var npix = 12 * npface;
            var fact2 = 4.0 / npix;
            var fact1 = (this.nside << 1) * fact2;

            return {
                order: order,
                nside: this.nside,
                scheme: scheme_in,
                nl2: nl2,
                nl3: nl3,
                nl4: nl4,
                npface: npface,
                ncap: ncap,
                npix: npix,
                fact1: fact1,
                fact2: fact2
            };
        },

        // MATH lib from Java Astro lib

        convertPolygonToHealpixOrder: function(coordinates, fact, order) {
            var vertex = [];
            var factor = fact || 4;
            var healpixOrder = order || 5;

            _.each(coordinates, function(point) {
                var cPr = Math.PI / 180;

                var cd = Math.cos(point[1] * cPr);
                var x = Math.cos(point[0] * cPr) * cd;
                var y = Math.sin(point[0] * cPr) * cd;
                var z = Math.sin(point[1] * cPr);

                var theta = Math.atan2(Math.sqrt(x * x + y * y), z);
                var phi = Math.atan2(y, x);
                if (phi < 0.0) {
                    phi += 2 * Math.PI;
                }
                if (phi >= 2 * Math.PI) {
                    phi -= 2 * Math.PI;
                }

                vertex.push({
                    theta: theta,
                    phi: phi
                });
            });

            return this.queryPolygonInclusive(vertex, factor, healpixOrder);
        },

        queryPolygonInclusive: function(vertex, fact, healpixOrder) {
            Math.PI = 3.14159265358979323846;
            var halfpi = Math.PI / 2.0;

            var inclusive = fact !== 0;
            var nv = vertex.length;
            var ncirc = inclusive ? nv + 1 : nv;

            if (nv < 3) {
                ErrorDialog.open(Constants.LEVEL.DEBUG, "HEALPixBase.js", "not enough vertices in polygon");
                return;
            }

            var vv = new Array(nv);
            var i;
            for (i = 0; i < nv; ++i) {
                vv[i] = vec3.createPhiTheta(vertex[i].phi, vertex[i].theta);
            }

            var normal = new Array(ncirc);
            var flip = 0;

            for (i = 0; i < nv; ++i) {
                normal[i] = vec3.cross2(vv[i], vv[(i + 1) % nv]);

                //var hnd = normal[i].dot(vv[(i + 2) % nv]);
                var hnd = vec3.dot2(normal[i], vv[(i + 2) % nv]);

                if (i === 0) {
                    flip = hnd < 0.0 ? -1 : 1;
                }

                normal[i] = vec3.scale2(
                    normal[i],
                    flip / vec3.length2(normal[i])
                );
            }

            var rad = new Array(ncirc);
            this.fill(rad, halfpi);

            if (inclusive) {
                var cf = new CircleFinder(vv);

                normal[nv] = cf.getCenter();
                rad[nv] = Math.acos(cf.getCosRad());
            }

            var res = this.queryMultiDisc(normal, rad, fact, healpixOrder);
            ErrorDialog.open(Constants.LEVEL.DEBUG, "HEALPixBase.js", res);
            return res;
        },

        fill: function(a, val) {
            for (var i = 0, len = a.length; i < len; i++) {
                a[i] = val;
            }
        },

        queryMultiDisc: function(norm, rad, fact, healpixOrder) {
            var order = healpixOrder;
            var inclusive = fact !== 0;
            var nv = norm.length;
            //HealpixUtils.check(nv == rad.length, "inconsistent input arrays");
            var res = [];

            var oplus = 0;
            if (inclusive) {
                //HealpixUtils.check((1L << (order_max - order)) >= fact, "invalid oversampling factor");
                //HealpixUtils.check((fact & (fact - 1)) == 0, "oversampling factor must be a power of 2");
                oplus = this.ilog2(fact);
            }
            var omax = order + oplus; // the order up to which we test
            var currentBoundaries;

            // TODO: ignore all disks with radius>=pi

            // building 3 dimensions array
            var crlimit = new Array(omax + 1);
            for (var i = 0; i < omax + 1; i++) {
                crlimit[i] = new Array(nv);
                for (var j = 0; j < nv; j++) {
                    crlimit[i][j] = new Array(3);
                }
            }

            var options = {
                order: order
            };
            HEALPixBase.init(options); // set variables nl2, nl3, npix, nface...
            var o;
            for (
                o = 0;
                o <= omax;
                ++o // prepare data at the required orders
            ) {
                currentBoundaries = HEALPixBase.bn[o];
                var dr = HEALPixBase.maxPixrad(o, currentBoundaries.nl4); // safety distance

                for (i = 0; i < nv; ++i) {
                    crlimit[o][i][0] =
                        rad[i] + dr > Math.PI ? -1 : Math.cos(rad[i] + dr);
                    crlimit[o][i][1] =
                        o === 0 ? Math.cos(rad[i]) : crlimit[0][i][1];
                    crlimit[o][i][2] =
                        rad[i] - dr < 0.0 ? 1.0 : Math.cos(rad[i] - dr);
                }
            }

            var stk = new pstack(12 + 3 * omax);
            for (i = 0; i < 12; i++) {
                // insert the 12 base pixels in reverse order
                stk.push(11 - i, 0);
            }

            while (stk.size() > 0) {
                // as long as there are pixels on the stack
                // pop current pixel number and order from the stack
                var pix = stk.ptop();
                o = stk.otop();
                stk.pop();

                currentBoundaries = HEALPixBase.bn[o];

                var pv = HEALPixBase.pix2vec(pix, currentBoundaries);

                var zone = 3;
                for (i = 0; i < nv && zone > 0; ++i) {
                    var crad = vec3.dot2(pv, norm[i]);

                    for (var iz = 0; iz < zone; ++iz) {
                        if (crad < crlimit[o][i][iz]) {
                            zone = iz;
                            //console.log("zone :" + zone + " pix:" + pix + " crad:" + crad);
                        }
                    }
                }

                if (zone > 0) {
                    this.check_pixel(
                        o,
                        omax,
                        zone,
                        res,
                        pix,
                        stk,
                        inclusive,
                        healpixOrder
                    );
                }
            }
            return res;
        },

        check_pixel: function(
            o,
            omax,
            zone,
            pixset,
            pix,
            stk,
            inclusive,
            healpixOrder
        ) {
            var order = healpixOrder;
            var i;
            if (zone === 0) {
                return;
            }

            if (o < order) {
                if (zone >= 3) {
                    // output all subpixels
                    var sdist = 2 * (order - o); // the "bit-shift distance" between map orders
                    var start = pix << sdist;
                    var end = (pix + 1) << sdist;
                    for (i = start; i <= end; i++) {
                        pixset.push(i);
                    }
                } else {
                    // (zone>=1)
                    for (i = 0; i < 4; ++i) {
                        stk.push(4 * pix + 3 - i, o + 1); // add children
                    }
                }
            } else if (o > order) {
                // this implies that inclusive==true
                if (zone >= 2) {
                    // pixel center in shape
                    pixset.push(pix >>> (2 * (o - order))); // output the parent pixel at order
                    stk.popToMark(); // unwind the stack
                } // (zone>=1): pixel center in safety range
                else {
                    if (o < omax) {
                        // check sublevels
                        for (i = 0; i < 4; ++i) {
                            // add children in reverse order
                            stk.push(4 * pix + 3 - i, o + 1); // add children
                        }
                    } else {
                        // at resolution limit
                        pixset.push(pix >>> (2 * (o - order))); // output the parent pixel at order
                        stk.popToMark(); // unwind the stack
                    }
                }
            } // o==order
            else {
                if (zone >= 2) {
                    pixset.push(pix);
                } else if (inclusive) {
                    // and (zone>=1)
                    if (order < omax) {
                        // check sublevels
                        stk.mark(); // remember current stack position
                        for (i = 0; i < 4; ++i) {
                            // add children in reverse order
                            stk.push(4 * pix + 3 - i, o + 1); // add children
                        }
                    } else {
                        // at resolution limit
                        pixset.push(pix); // output the pixel
                    }
                }
            }
        },

        ilog2: function(arg) {
            var res = 0;
            while (arg > 0x0000ffff) {
                res += 16;
                arg >>>= 16;
            }
            if (arg > 0x000000ff) {
                res |= 8;
                arg >>>= 8;
            }
            if (arg > 0x0000000f) {
                res |= 4;
                arg >>>= 4;
            }
            if (arg > 0x00000003) {
                res |= 2;
                arg >>>= 2;
            }
            if (arg > 0x00000001) {
                res |= 1;
            }
            return res;
        },
        /**
         *    Returns pixel index of point on sphere
         *
         *    @param order Tile order
         *    @param lon Longitude
         *    @param lat Latitude
         */
        lonLat2pix: function(order, lon, lat) {
            var loc = lonLat2ang(lon, lat);
            return loc2pix(order, loc[0], loc[1]);
        },

        /**
         Create the children of the given pixel
         */
        getChildren: function(npix) {
            return [npix * 4, npix * 4 + 1, npix * 4 + 2, npix * 4 + 3];
        },

        uniq2hpix: function(uniq, hpix) {
            if (hpix == null) {
                hpix = [];
            }
            hpix[0] = HEALPixBase.log2(uniq / 4) / 2;
            var nside = HEALPixBase.pow2(hpix[0]);
            hpix[1] = uniq - 4 * nside * nside;
            hpix[0] = parseInt(hpix[0], 10);
            return hpix;
        },

        log2: function(nside) {
            var i = 0;
            while (nside >>> ++i > 0) {
                // nop
            }
            return --i;
        },

        pow2: function(order) {
            return 1 << order;
        },

        /**
         * calculates angular resolution of the pixel map in arc seconds.
         *
         * @param nside
         * @return double resolution in arcsec
         */
        getPixRes: function(nside) {
            var rad2arcsec = (180.0 * 60.0 * 60.0) / Math.PI;
            return rad2arcsec * Math.sqrt((4 * Math.PI) / (12 * nside * nside));
        }
    };

    /**************************************************************************************************************/

    return HEALPixBase;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Utils/UtilsIntersection',["./Numeric", "./Constants","../Tiling/HEALPixBase"], function(Numeric, Constants, HEALPixBase) {
    var UtilsIntersection = {};

    UtilsIntersection.convertPolygonToHealpixOrder = function(
        coordinates,
        fact,
        order
    ) {
        return HEALPixBase.convertPolygonToHealpixOrder(
            coordinates,
            fact,
            order
        );
    };

    /**
     * Check if a point lies on a line
     * @param point
     * @param segmentStart
     * @param segmentEnd
     * @returns {boolean}
     */
    UtilsIntersection.pointInLine = function(point, segmentStart, segmentEnd) {
        var deltax = segmentEnd[0] - segmentStart[0];
        var deltay, t;
        var liesInXDir = false;

        if (deltax === 0) {
            liesInXDir = point[0] === segmentStart[0];
        } else {
            t = (point[0] - segmentStart[0]) / deltax;
            liesInXDir = t >= 0 && t <= 1;
        }

        if (liesInXDir) {
            deltay = segmentEnd[1] - segmentStart[1];
            if (deltax === 0) {
                return point[1] === segmentStart[1];
            } else {
                t = (point[1] - segmentStart[1]) / deltay;
                return t >= 0 && t <= 1;
            }
        } else {
            return false;
        }
    };

    /**
     *    Determine if a point lies inside a sphere of radius depending on viewport
     */
    UtilsIntersection.pointInSphere = function(
        ctx,
        point,
        sphere,
        pointTextureHeight
    ) {
        var point3D = [];
        var sphere3D = [];

        // Compute pixel size vector to offset the points from the earth
        var pixelSizeVector = ctx.getRenderContext().computePixelSizeVector();

        ctx.getCoordinateSystem().get3DFromWorld(point, point3D);
        ctx.getCoordinateSystem().get3DFromWorld(sphere, sphere3D);

        var radius =
            pointTextureHeight *
            (pixelSizeVector[0] * sphere3D[0] +
                pixelSizeVector[1] * sphere3D[1] +
                pixelSizeVector[2] * sphere3D[2] +
                pixelSizeVector[3]);

        //Calculate the squared distance from the point to the center of the sphere
        var vecDist = [];
        vec3.subtract(point3D, sphere3D, vecDist);
        vecDist = vec3.dot(vecDist, vecDist);

        //Calculate if the squared distance between the sphere's center and the point
        //is less than the squared radius of the sphere
        if (vecDist < radius * radius) {
            return true;
        }

        //If not, return false
        return false;
    };

    /**
     * Convert spherical coordinate to cartesian
     */
    function to3D(pt) {
        var lon = (pt[0] * Math.PI) / 180;
        var lat = (pt[1] * Math.PI) / 180;
        var x = Math.cos(lat) * Math.cos(lon);
        var y = Math.cos(lat) * Math.sin(lon);
        var z = Math.sin(lat);
        return [x, y, z];
    }

    function greatArcIntersection(a0, a1, b0, b1) {
        var p = vec3.cross(a0, a1, []);
        var q = vec3.cross(b0, b1, []);
        var t = vec3.normalize(vec3.cross(p, q, []));

        var s1 = vec3.dot(vec3.cross(a0, p, []), t);
        var s2 = vec3.dot(vec3.cross(a1, p, []), t);
        var s3 = vec3.dot(vec3.cross(b0, q, []), t);
        var s4 = vec3.dot(vec3.cross(b1, q, []), t);

        var st =
            Numeric.sign(-s1) +
            Numeric.sign(s2) +
            Numeric.sign(-s3) +
            Numeric.sign(s4);
        return Math.abs(st) === 4;
    }

    /**
     * Point in ring with spherical geometry
     */
    UtilsIntersection.pointInRing = function(point, ring) {
        var nvert = ring.length;
        var nbinter = 0;

        var p0 = to3D(point);
        var p1 = to3D([point[0], point[1] + 90]);

        for (var i = 0; i < nvert - 1; i++) {
            if (
                greatArcIntersection(to3D(ring[i]), to3D(ring[i + 1]), p0, p1)
            ) {
                nbinter++;
            }
        }
        return nbinter % 2 === 1;
    };

    /**
     * Checks if a value v is between the interval [min, max].
     * @function isValueBetween
     * @param {float} v - value
     * @param {float} min - min value
     * @param {float} max - max value
     * @return {boolean} true when v is between min and max otherwise talse
     */
    UtilsIntersection.isValueBetween = function(v, min, max) {
        return min <= v && v <= max;
    };

    /**
     * Checks is two bounding boxes intersect
     * @function boundsIntersects
     * @param {{west:float, north:float, east:float, south:float}} a - bounding box
     * @param {{west:float, north:float, east:float, south:float}} b - bounding box
     * @return {boolean} true when the two bounding boxes intersect otherwise false
     */
    UtilsIntersection.boundsIntersects = function(a, b) {
        if (a === null || b === null) {
            return false;
        }
        if (a.north == null || b.north == null) {
            return false;
        }
        var xOk =
            UtilsIntersection.isValueBetween(a.west, b.west, b.east) ||
            UtilsIntersection.isValueBetween(a.east, b.west, b.east) ||
            (a.west <= b.west && a.east >= b.east);

        var yOk =
            UtilsIntersection.isValueBetween(a.north, b.south, b.north) ||
            UtilsIntersection.isValueBetween(a.south, b.south, b.north) ||
            (a.south <= b.south && a.north >= b.north);

        return xOk && yOk;
    };


    /**
     * Returns true when t1 intersects with t2 otherwise false
     * @function tileIntersectHealpixTile
     * @param {Tile} t1
     * @param {Tile} t2
     * @returns {boolean} true when t1 intersects with t2 otherwise false
     */
    UtilsIntersection.tileIntersectHealpixTile = function(t1, t2) {
        if (t1 === null || t2 === null) {
            return false;
        }

        var result;
        if (t1.level === t2.level) {
            result = t1.pixelIndex === t2.pixelIndex;
        } else if (t1.level > t2.level) {
            var diffLevel = t1.level - t2.level;
            result = t1.pixelIndex >> Math.pow(2, diffLevel) === t2.pixelIndex;
        } else {
            diffLevel = t2.level - t1.level;
            result = t2.pixelIndex >> Math.pow(2, diffLevel) === t1.pixelIndex;
        }
        return result;
    };

    /**
     * Returns true when t1 intersects with t2 otherwise false
     * @function tileIntersectGeoTile
     * @param {Tile} t1
     * @param {Tile} t2
     * @returns {boolean} true when t1 intersects with t2 otherwise false
     */
    UtilsIntersection.tileIntersectGeoTile = function(t1, t2) {
        if (t1 === null || t2 === null) {
            return false;
        }

        var result;
        if (t1.level === t2.level) {
            result = t1.x === t2.x && t1.y === t2.y;
        } else if (t1.level > t2.level) {
            var diffLevel = t1.level - t2.level;
            var x1 = Math.pow(2, diffLevel) * t2.x;
            var x2 = Math.pow(2, diffLevel) * (t2.x + 1) - 1;
            var y1 = Math.pow(2, diffLevel) * t2.y;
            var y2 = Math.pow(2, diffLevel) * (t2.y + 1) - 1;
            result = UtilsIntersection.isValueBetween(t1.x, x1, x2) && UtilsIntersection.isValueBetween(t1.y, y1, y2);
        } else {
            diffLevel = t2.level - t1.level;
            x1 = Math.pow(2, diffLevel) * t1.x;
            x2 = Math.pow(2, diffLevel) * (t1.x + 1) - 1;
            y1 = Math.pow(2, diffLevel) * t1.y;
            y2 = Math.pow(2, diffLevel) * (t1.y + 1) - 1;
            result = UtilsIntersection.isValueBetween(t2.x, x1, x2) && UtilsIntersection.isValueBetween(t2.y, y1, y2);
        }
        return result;
    };

    /**
     * Returns true when t1 intersects with t2 otherwise false
     * @function tileIntersect
     * @param {Tile} t1
     * @param {Tile} t2
     * @returns {boolean} true when t1 intersects with t2 otherwise false
     */
    UtilsIntersection.tileIntersect = function(t1, t2) {
        if (t1 === null || t2 === null) {
            return false;
        }
        var result;
        if (t1.type === Constants.TILE.GEO_TILE || t1.type === Constants.TILE.MERCATOR_TILE) {
            result = UtilsIntersection.tileIntersectGeoTile(t1, t2);
        } else if (t1.type === Constants.TILE.HEALPIX_TILE) {
            result = UtilsIntersection.tileIntersectHealpixTile(t1, t2);
        } else {
            throw new "Unknown tiling";
        }
        return result;
    };

    /**
     * Checks is one tile intersects intersect with a set of tiles
     * @function tileIntersects
     * @param {Tile} a - tile
     * @param {Tile[]} b - index
     * @return {boolean} true when intersection otherwise false
     */
    UtilsIntersection.tileIntersects = function(a, b) {
        if (a === null || b === null) {
            return false;
        }
        var result = false;
        for(var i=0; i<b.length && !result; i++) {
            var tile = b[i];
            result = UtilsIntersection.tileIntersect(a, tile);
        }
        return result;
    };

    /**
     * Checks if the coordinates cross the date line.
     * @function isCrossDateLine
     * @param {float} minLong - min longitude
     * @param {float} maxLong - max longitude
     * @return {boolean} true when the coordinates cross the date line otherwise false
     */
    UtilsIntersection.isCrossDateLine = function(minLong, maxLong) {
        return Math.abs(minLong - maxLong) > 180;
    };

    /**
     * Checks if the 2d screen point is inside (meter-sized) billboard described
     * by its origin  (given by o, see below) and its size in meters.
     *
     *     *-------*
     *     |       |
     *     |       |
     *     *---o---*
     *
     * @function isInBillboard
     * @param {Geometry} geometry The geometry to test, in geo coordinates
     * @param {Array(float)} origin The origin of the rectangle, in geo coordinates
     * @param {Array(float)} size The size of the rectangle, in meters
     * @param {Array(float)} eventPos The click position
     *
     * @return {boolean} true when the point is inside the given billboard
     */
    UtilsIntersection.isInBillboard = function(pickPoint, originGeometry, size, eventPos) {
        // point is in 2d screen position, hence we need to convert origin and size
        // (which is in geo coordinates) to screen.
        if (!originGeometry._bucket || !originGeometry._bucket.renderer) {
            return false;
        }

        const from3dToScreenSpace = function(point) {
            var result = vec3.create();

            const viewMatrix = rc.viewMatrix;
            const projMatrix = rc.projectionMatrix;
            const viewProjMatrix = mat4.create();
            mat4.multiply(projMatrix, viewMatrix, viewProjMatrix);

            const p = [point[0], point[1], point[2], 1.0];
            mat4.project(viewProjMatrix, p, result);
            const w = rc.canvas.clientWidth;
            const h = rc.canvas.clientHeight;

            result[0] = (result[0] + 1.0) * 0.5 * w;
            result[1] = (1.0 - result[1]) * 0.5 * h;

            return result;
        };

        const renderer = originGeometry._bucket.renderer;
        const globe = renderer.globe;
        const crs = globe.getCoordinateSystem();
        const rc = renderer.tileManager.renderContext;

        // Compute mouse position. We do not always use eventPos, to keep the z position.
        var mouse2d;
        if (pickPoint) {
            const pickPoint3D = crs.get3DFromWorld(pickPoint);
            mouse2d = from3dToScreenSpace(pickPoint3D);
        } else {
            mouse2d = [eventPos[0], eventPos[1], -1.0];
        }

        // Get the "center" of the billboard in 3D
        const elevation = crs.getElevation(globe, originGeometry) + 200; // match the rendering
        const originGeo = [originGeometry.coordinates[0], originGeometry.coordinates[1], elevation];
        const origin3d = crs.get3DFromWorldInCrs(originGeo, originGeometry.crs.properties.name);
        const origin2d = from3dToScreenSpace(origin3d);

        // Compute top left and bottom right corners
        const camRight = vec3.create([rc.viewMatrix[0], rc.viewMatrix[4], rc.viewMatrix[8]]);
        const camUp = vec3.create([rc.viewMatrix[1], rc.viewMatrix[5], rc.viewMatrix[9]]);

        const radius = crs.getGeoide().getRealPlanetRadius();
        const billboardSize = vec3.create([size[0] / radius, size[1] / radius, 1.0]);

        const billboardTo3d = function(o, p, size, camRight, camUp) {
            var x = vec3.create();
            vec3.scale(camRight, p[0], x);
            vec3.scale(x, size[0]);

            var y = vec3.create();
            vec3.scale(camUp, p[1], y);
            vec3.scale(y, size[1]);

            var result = vec3.create();
            vec3.add(o, x, result);
            vec3.add(result, y);
            return result;
        };

        const topLeftLocal = vec3.create([-0.5, 1.0, 0.0]);
        const topLeft3d = billboardTo3d(origin3d, topLeftLocal, billboardSize, camRight, camUp);
        const topLeft2d = from3dToScreenSpace(topLeft3d);

        const bottomRightLocal = vec3.create([0.5, 0.0, 0.0]);
        const bottomRight3d = billboardTo3d(origin3d, bottomRightLocal, billboardSize, camRight, camUp);
        const bottomRight2d = from3dToScreenSpace(bottomRight3d);


        const left = topLeft2d[0];
        const right = bottomRight2d[0];
        const top = topLeft2d[1];
        const bottom = bottomRight2d[1];

        // Check if point is in the 2d bounds
        if (mouse2d[0] > left && mouse2d[0] < right && mouse2d[1] > top && mouse2d[1] < bottom) {
            // Check the z value, we do not want to pick a point behind the terrain
            // If the z is negative, that means we are picking outside the terrain,
            // so we always have an intersection
            if (mouse2d[2] < 0.0 || mouse2d[2] > origin2d[2]) {
                return true;
            }
        }

        return false;
    };

    return UtilsIntersection;
});

define('gw/Error/NetworkError',[], function() {
    var NetworkError = function() {
        var superInstance = Error.apply(null, arguments);
        this.name = "NetworkError";
        this.code = arguments.length > 2 ? arguments[2] : null;
        copyOwnPropertiesFrom(this, superInstance);
        this.layerDescription = null;
    };

    function copyOwnPropertiesFrom(target, source) {
        Object.getOwnPropertyNames(source).forEach(function(propKey) {
            var desc = Object.getOwnPropertyDescriptor(source, propKey);
            Object.defineProperty(target, propKey, desc);
        });
        return target;
    }

    NetworkError.prototype = Object.create(Error.prototype);

    NetworkError.prototype.constructor = NetworkError;

    NetworkError.prototype.setLayerDescription = function(layerDescription) {
        this.layerDescription = layerDescription;
    };

    NetworkError.prototype.getLayerDescription = function() {
        return this.layerDescription;
    };

    return NetworkError;
});


/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Utils/Proxy',[],function () {

    var _proxyUse = false;
    var _proxyUrl = "";

    return {
        /**
         * Sets the use of the proxy.
         * @function setProxyUse
         * @param {boolean} proxyUse Set to true to use a defined proxy otherwise false.
         * @throws {TypeError} proxyUse must be a boolean
         */
        setProxyUse: function(proxyUse) {
            if (typeof(proxyUse) !== "boolean") {
                throw new TypeError("proxyUse must be a boolean", "Proxy.js");
            }
            _proxyUse = proxyUse;
        },
        /**
         * Sets the proxy URL.
         * The proxy should look like http://localhost:8081/?url=
         * @function setProxyUrl
         * @param {string} proxyUrl proxy URL;
         * @throws {TypeError} proxyUrl must be a string
         */
        setProxyUrl: function(proxyUrl) {
            if (typeof(proxyUrl) !== "string") {
                throw new TypeError("proxyUrl must be a string", "Proxy.js");
            }            
            _proxyUrl = proxyUrl;
        },

        /**
         * Proxyfy the url is the proxy is used.
         * @function proxify
         * @param {string} url URL to proxify
         * @returns {string} the proxified URL.
         */
        proxify: function(url) {
            if (typeof url !== "string") {
                return url;
            }
            var proxifiedUrl;
            if (_proxyUse === true) {
                if (url.toLowerCase().startsWith("http") === false) {
                    proxifiedUrl = url;
                } else if (url.startsWith(_proxyUrl)) {
                    proxifiedUrl = url; // No change, proxy always set
                } else {
                    proxifiedUrl = _proxyUrl + encodeURIComponent(url); // Add proxy redirection
                }
            } else {
                proxifiedUrl = url;
            }
            
            return proxifiedUrl;
        }
    };
});
/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Utils/Utils',[
    "jquery",
    "moment",
    "./Numeric",
    "./UtilsIntersection",
    "./Constants",
    "../Error/NetworkError",
    "../Utils/Proxy"
], function($, Moment, Numeric, UtilsIntersection, Constants, NetworkError, Proxy) {
    var Utils = {};

    /**
     * Inherits from an object
     */
    Utils.inherits = function(base, sub) {
        function tempCtor() {}

        tempCtor.prototype = base.prototype;
        sub.prototype = new tempCtor();
        sub.prototype.constructor = sub;
    };

    /**
     *    HSV values in [0..1[
     *    returns [r, g, b] values from 0 to 255
     */
    function hsv_to_rgb(h, s, v) {
        var h_i = Math.floor(h * 6);
        var f = h * 6 - h_i;
        var p = v * (1 - s);
        var q = v * (1 - f * s);
        var t = v * (1 - (1 - f) * s);
        var r;
        var g;
        var b;
        switch (h_i) {
        case 0:
            r = v;
            g = t;
            b = p;
            break;
        case 1:
            r = q;
            g = v;
            b = p;
            break;
        case 2:
            r = p;
            g = v;
            b = t;
            break;
        case 3:
            r = p;
            g = q;
            b = v;
            break;
        case 4:
            r = t;
            g = p;
            b = v;
            break;
        case 5:
            r = v;
            g = p;
            b = q;
            break;
        default:
            r = 1;
            g = 1;
            b = 1;
        }
        return [r, g, b];
    }

    /**
     * Generates eye-friendly color based on hsv.
     * @return {int[]} rgb array
     */
    Utils.generateColor = function() {
        //use golden ratio
        var golden_ratio_conjugate = 0.618033988749895;
        var h = Math.random();
        h += golden_ratio_conjugate;
        h %= 1;
        return hsv_to_rgb(h, 0.5, 0.95);
    };

    /**
     * Format the given feature identifier to remove special caracters(as ?, [, ], ., etc..) which cannot be used as HTML id's
     * @param {string} id - identifier
     * @return {string} HTML identifier
     */
    Utils.formatId = function(id) {
        var result;
        if (typeof id === "string") {
            result = id.replace(
                /\s{1,}|\.{1,}|\[{1,}|\]{1,}|\({1,}|\){1,}|~{1,}|\+{1,}|{1,}|-{1,}|'{1,}|"{1,}/g,
                ""
            );
        } else {
            result = id;
        }
        return result;
    };

    /**
     * Checks if a value v is between the interval [min, max].
     * @function isValueBetween
     * @param {float} v - value
     * @param {float} min - min value
     * @param {float} max - max value
     * @return {boolean} true when v is between min and max otherwise false
     */
    Utils.isValueBetween = function(v, min, max) {
        return v >= min && v <= max;
    };

    /**
     * Computes base URL from getCapabilities URL.
     * @function computeBaseUrlFromCapabilities
     * @param {string} capabilitiesUrl - getCapabilities URL
     * @param {string[]} parameters - parameters of the getCapabilities
     * @return {string} base URL
     */
    Utils.computeBaseUrlFromCapabilities = function(
        capabilitiesUrl,
        parameters
    ) {
        if (
            typeof capabilitiesUrl != "string" ||
            capabilitiesUrl.length == 0 ||
            !Array.isArray(parameters)
        )
            return null;

        var url = capabilitiesUrl;
        if (url.indexOf("?") > -1) {
            url = url.substr(0, url.indexOf("?"));
        }
        // url cannot be undefined because we need to query a getCapabilities or something else with a parameter
        var queryString =
            capabilitiesUrl.replace(url + "?", "") || capabilitiesUrl;
        var query = Utils.parseQuery(queryString);
        // we delete all parameters required by a standard.
        for (var i = 0; i < parameters.length; i++) {
            var parameter = parameters[i];
            delete query[parameter];
        }
        // we build the new Url with remaining parameters.
        var nbParameter = 0;
        for (var key in query) {
            var value = query[key];
            if (nbParameter == 0) {
                url = url + "?" + key + "=" + value;
            } else {
                url = url + "&" + key + "=" + value;
            }
            nbParameter++;
        }

        return url;
    };

    Utils.parseQuery = function(str) {
        if (typeof str != "string" || str.length == 0) return {};
        var s = str.split("&");
        var s_length = s.length;
        var bit,
            query = {},
            first,
            second;
        for (var i = 0; i < s_length; i++) {
            bit = s[i].split("=");
            first = decodeURIComponent(bit[0]);
            if (first.length == 0) continue;
            second = decodeURIComponent(bit[1]);
            if (typeof query[first] == "undefined") query[first] = second;
            else if (query[first] instanceof Array) query[first].push(second);
            else query[first] = [query[first], second];
        }
        return query;
    };

    /**
     * Add parameter to
     * @function addParameterTo
     * @param {string} url - parameter url
     * @param {string} name - parameter name
     * @param {string} value - parameter value
     * @return {string} url updated
     */
    Utils.addParameterTo = function(url, name, value) {
        var separator = "&";
        if (typeof url !== "string" || url.indexOf("?", 0) === -1) {
            separator = "?";
        }
        return url + separator + name + "=" + value;
    };

    /**
     * Parses the base URL.
     * @function parseBaseURL
     * @param {string} url - the URL
     * @return {*} the base URL
     */
    Utils.parseBaseURL = function(url) {
        var result;
        var index = url.indexOf("?");
        if (index == -1) {
            result = url;
        } else {
            result = url.substring(0, url.indexOf("?") + 1);
        }
        return result;
    };

    /**
     * Parses the query string and returns the parameters of the URL.
     * @function parseQueryString
     * @param {string} url - query string
     * @return {{}} parameters of the query string
     */
    Utils.parseQueryString = function(url) {
        var queryString = url.substring(url.indexOf("?") + 1).split("&");
        var params = {};
        var pair;
        // march and parse
        for (var i = queryString.length - 1; i >= 0; i--) {
            pair = queryString[i].split("=");
            params[decodeURIComponent(pair[0])] = decodeURIComponent(
                pair[1] || ""
            );
        }
        return params;
    };

    /**
     * Request an URL.
     * @function requestUrl
     * @param {string} url - URL to request
     * @param {string} datatype - datatype of the response
     * @param {string} acceptDatatype - value for the Accept keyword in the header
     * @param {Object} options - options for callback (set to null if no options)
     * @param {Utils~requestCallback} callback - The callback that handles the response.
     * @param {Utils~requestFallback} [fallBack] - The fallback that handles the error.
     * @param {Utils~requestComplete} [complete] - The completeback that is executed afet the callback/fallback
     */
    Utils.requestUrl = function(
        url,
        datatype,
        acceptDatatype,
        options,
        callback,
        fallBack,
        complete
    ) {
        $.ajax({
            type: "GET",
            url: Proxy.proxify(url),
            dataType: datatype,
            beforeSend: function(xhr) {
                xhr.setRequestHeader("Accept", acceptDatatype);
            },
            success: function(response) {
                if (callback) {
                    callback(response, options);
                }
            },
            error: function(xhr, ajaxOptions, thrownError) {
                var message;
                var code;
                if (xhr.status === 0) {
                    message =
                        "Unreachable URL or No 'Access-Control-Allow-Origin' header is present on the " +
                        url;
                    code = 0;
                } else {
                    message = thrownError.message
                        ? thrownError.message
                        : thrownError;
                    code = thrownError.code ? thrownError.code : -1;
                    if (typeof ajaxOptions === "string") {
                        message = ajaxOptions + ": " + message;
                    }
                }
                if (fallBack) {
                    fallBack(new NetworkError(message, "Utils.js", code));
                }
            },
            complete: function(xhr, textSatus) {
                if (complete) {
                    complete(xhr, textSatus);
                }
            }
        });
    };

    /**
     * This callback process the response when the request is a success.
     * @callback Utils~requestCallback
     * @param {Object} response - the response of the server
     * @param {Object} options - options
     */

    /**
     * This fallback process the error of the server.
     * @callback Utils~requestFallback
     * @param {string} error
     */

    /**
     * A function to be called when the request finishes (after success and error callbacks are executed).
     * The function gets passed two arguments: The jqXHR (in jQuery 1.4.x, XMLHTTPRequest) object and a
     * string categorizing the status of the request ("success", "notmodified", "nocontent", "error",
     * "timeout", "abort", or "parsererror").
     * @callback Utils~requestComplete
     * @param {Object} xhr - xhr object
     * @param {string} status - status text
     */

    /**
     * Converts UTC hms from date to hours.
     * @function _UT
     * @param {date} date - date
     * @returns {number} hours
     * @private
     */
    function _UT(date) {
        var hour = date.getUTCHours();
        var min = date.getUTCMinutes();
        var sec = date.getUTCSeconds();
        return hour + min / 60 + sec / 3600;
    }

    /**
     * Computes Julian day number at 0 hr UT.
     * @function _J0
     * @param {date} date - date
     * @returns {number} Julian day number at 0 hr UT
     * @private
     */
    function _J0(date) {
        var year = date.getUTCFullYear();
        var month = date.getUTCMonth() + 1;
        var day = date.getUTCDate();
        var UT = _UT(date);
        //TODO check 1721013.5 should be -730531.5 !!!
        return (
            367 * year -
            Math.floor((7 / 4) * (year + Math.floor((month + 9) / 12))) +
            Math.floor((275 * month) / 9) +
            day +
            1721013.5
        );
    }

    /**
     * Computes Julian day.
     * @function JD
     * @param {date} date - date
     * @returns {number} julian day
     * @private
     */
    Utils.JD = function(date) {
        return _J0(date) + _UT(date) / 24;
    };

    /**
     * Computes the Greenwich sidereal time at 0 hr UT.
     * See equation [Seidelmann,1992]
     * @function _GST0
     * @param date date
     * @returns {number} the Greenwich sidereal time at 0 hr UT
     * @private
     */
    function _GST0(date) {
        //JC is Julian centuries between the Julian day J0 and J2000(2,451,545.0)
        var julianCentury = (_J0(date) - 2451545.0) / 36525;
        var GST0 =
            100.4606184 +
            36000.77004 * julianCentury +
            0.000387933 * julianCentury * julianCentury -
            2.583e-8 * julianCentury * julianCentury * julianCentury;
        return GST0 % 360;
    }

    /**
     * Computes the Greenwich sidereal time at any other UT time.
     * @function GST
     * @param {date} date - date
     * @returns {number} the Greenwich sidereal time at any other UT time
     */
    Utils.GST = function(date) {
        return (_GST0(date) + (360.98564724 * _UT(date)) / 24) % 360;
    };

    /**
     * Computes the local sidereal time.
     * @function LST
     * @param {date} date - date
     * @param {float} longitude - longitude
     * @returns {number}
     */
    Utils.LST = function(date, longitude) {
        return (Utils.GST(date) + longitude) % 360;
    };

    /**
     * Computes the Sidereal Hour Angle
     * @function SHA
     * @param {float} ra - right ascension in decimal degree
     * @returns {number} SHA in decimal degree
     */
    Utils.SHA = function(ra) {
        return 360.0 - (15.0 * ra * 24.0) / 360.0;
    };

    /**
     * Computes the GHA (Greenwich Hour Angle).
     * GHA indicates the position past the plane of the Greenwich meridian measured in degrees. Equivalent to longitude on earth.
     * @function GHA
     * @param {date} date - date
     * @param {float} ra - right ascension in decimal degree
     * @returns {number} Greenwich Hour Angle in decimal degree
     */
    Utils.GHA = function(date, ra) {
        var GHA_Aries = (15.0 * Utils.GST(date) * 24.0) / 360.0;
        return (Utils.SHA(ra) + GHA_Aries) % 360;
    };

    /**
     * Converts longitude/latitude to XYZ
     * @function longLat2XYZ
     * @param {float} longitude - longitude in decimal degree
     * @param {float} latitude - latitude in decimal degree
     * @returns {{x: float, y: float, z: float}} the cartesian coordinates
     */
    Utils.longLat2XYZ = function(longitude, latitude) {
        var latInRadians = Numeric.toRadian(latitude);
        var longInRadians = Numeric.toRadian(longitude);
        var cosLat = Math.cos(latInRadians);
        return {
            x: cosLat * Math.cos(longInRadians),
            y: cosLat * Math.sin(longInRadians),
            z: Math.sin(latInRadians)
        };
    };

    /**
     * Computes the distance of the camera in meters for which the bbox of the target is the camera FOV.
     * @function computeDistanceCameraFromBbox
     * @param {float[]} bbox - bbox of the target
     * @param {float} fov - camera FOV
     * @param {float} planetRadius - planet radius in meters
     * @param {boolean} isFlat - is it a projected CRS
     * @return {float} the distance of the camera in meters.
     */
    Utils.computeDistanceCameraFromBbox = function(
        bbox,
        fov,
        planetRadius,
        isFlat
    ) {
        var angularDistance = Math.abs(bbox[2] - bbox[0]);
        if (UtilsIntersection.isCrossDateLine(bbox[0], bbox[2])) {
            angularDistance = 360 - angularDistance;
        }
        var visibleAngularDistance;
        if (isFlat) {
            visibleAngularDistance = angularDistance;
        } else if (angularDistance > 180) {
            visibleAngularDistance = 360 - angularDistance;
        } else {
            visibleAngularDistance = angularDistance;
        }

        var distance =
            (2 * Math.PI * planetRadius * visibleAngularDistance) / 360;
        return (0.5 * distance) / Math.tan(0.5 * Numeric.toRadian(fov));
    };

    Utils.defineTimeRequest = function(temporalRanges, timeRequest) {
        var startDate = timeRequest.from;
        var stopDate = timeRequest.to;

        var times = temporalRanges.split(",");
        if (times.length == 1) {
            // no range
            var time = times[0];
        } else {
            // temporalRange
            var startTime = times[0];
            var stopTime = times[1];
            var frequency = times[2];
        }
    };

    Utils.formatResolution = function(format) {
        var timeResolution;
        if (Utils.aContainsB.call(this, format, "ss")) {
            timeResolution = "seconds";
        } else if (Utils.aContainsB.call(this, format, "mm")) {
            timeResolution = "minutes";
        } else if (Utils.aContainsB.call(this, format, "HH")) {
            timeResolution = "hours";
        } else if (Utils.aContainsB.call(this, format, "DD")) {
            timeResolution = "days";
        } else if (Utils.aContainsB.call(this, format, "MM")) {
            timeResolution = "months";
        } else if (Utils.aContainsB.call(this, format, "YYYY")) {
            timeResolution = "years";
        } else {
            throw new Error();
        }
        return timeResolution;
    };

    Utils.aContainsB = function(a, b) {
        return a.indexOf(b) >= 0;
    };

    Utils.convertToMoment = function(time) {
        return time instanceof Moment() ? time : Moment().utc(time);
    };

    Utils.isPassiveSupported = function() {
        var passiveSupported = false;

        try {
            var options = Object.defineProperty({}, "passive", {
                get: function() {
                    passiveSupported = true;
                    return passiveSupported;
                }
            });

            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
        } catch (err) {
            passiveSupported = false;
        }
        return passiveSupported;
    };

    /**
     * Assert function.
     * @param {Boolean} condition test condition
     * @param {string} message Output when the assert is not true
     * @param {string} [filename] where the error occurs
     * @throws {Error} sent message when the condition is false
     */
    Utils.assert = function(condition, message, filename) {
        if (!condition) {
            if (filename == null) {
                message = filename + ": " + message;
            }
            throw new Error(
                "Assert failed" +
                    (typeof message !== "undefined" ? " - " + message : "")
            );
        }
    };

    Utils.getBBox = function(geometry) {
        // Get the coordinates
        var coords;
        var checkDateLine = true;
        switch (geometry.type) {
        case Constants.GEOMETRY.Point:
            coords = geometry.coordinates;
            return [coords[0], coords[1], coords[0], coords[1]];
        case Constants.GEOMETRY.MultiPoint:
            coords = geometry.coordinates;
            checkDateLine = false;
            break;
        case Constants.GEOMETRY.Polygon:
            coords = geometry.coordinates[0];
            break;
        case Constants.GEOMETRY.MultiPolygon:
            coords = geometry.coordinates[0][0];
            break;
        case Constants.GEOMETRY.LineString:
            coords = geometry.coordinates;
            break;
        case Constants.GEOMETRY.MultiLineString:
            coords = geometry.coordinates[0];
            break;
        }

        if (!coords || coords.length === 0) {
            return;
        }

        var minX = coords[0][0];
        var minY = coords[0][1];
        var maxX = coords[0][0];
        var maxY = coords[0][1];

        var numOuterRings =
            geometry.type === Constants.GEOMETRY.MultiPolygon ||
            geometry.type === Constants.GEOMETRY.MultiLineString
                ? geometry.coordinates.length
                : 1;
        for (var j = 0; j < numOuterRings; j++) {
            switch (geometry.type) {
            case Constants.GEOMETRY.MultiPolygon:
                coords = geometry.coordinates[j][0];
                break;
            case Constants.GEOMETRY.MultiLineString:
                coords = geometry.coordinates[j];
                break;
            }

            for (var i = 0; i < coords.length; i++) {
                minX = Math.min(minX, coords[i][0]);
                minY = Math.min(minY, coords[i][1]);
                maxX = Math.max(maxX, coords[i][0]);
                maxY = Math.max(maxY, coords[i][1]);

                // Check if the coordinates cross dateline
                if (
                    checkDateLine &&
                    i > 0 &&
                    UtilsIntersection.isCrossDateLine(
                        coords[i - 1][0],
                        coords[i][0]
                    )
                ) {
                    minX = -180;
                    maxX = 180;
                }
            }
        }

        return { north: maxY, south: minY, west: minX, east: maxX };
    };

    return Utils;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Utils/Event',[],function() {
    /**************************************************************************************************************/

    /**
     @name Event
     @class
         A light-weight event object.
     */
    var Event = function() {
        // Event callbacks
        this.callbacks = {};
    };

    /**************************************************************************************************************/

    /**
     Subscribe to an event

     @param name Event name
     <ul>
     <li>startNavigation : called when navigation is started (by the user or through animation)</li>
     <li>endNavigation : called when navigation is ended (by the user or through animation)t</li>
     <li>baseLayersReady : called when the base layers are ready to be displayed</li>
     <li>baseLayersError : called when the base layers are not valid, or not accessible, in that case nothing is displayed so this event is useful to provide an error message to the user</li>
     <li>startBackgroundLoad : called when background layers (imagery and/or elevation) start to be loaded</li>
     <li>endBackgroundLoad : called when background layers (imagery and/or elevation) end loading</li>
     <li>startLoad : called when a layer start to be loaded</li>
     <li>endLoad : called when layer end loading</li>
     </ul>
     @param callback Callback function
     */
    Event.prototype.subscribe = function(name, callback) {
        if (!this.callbacks[name]) {
            this.callbacks[name] = [callback];
        } else {
            this.callbacks[name].push(callback);
        }
    };

    /**************************************************************************************************************/

    /**
     Unsubscribe to an event

     @param name Event name {@link Globe#subscribe}
     @param callback Callback function
     */
    Event.prototype.unsubscribe = function(name, callback) {
        if (this.callbacks[name]) {
            var i = this.callbacks[name].indexOf(callback);
            if (i !== -1) {
                this.callbacks[name].splice(i, 1);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     Publish an event

     @param name Event name
     @param context Context
     */
    Event.prototype.publish = function(name, context) {
        if (this.callbacks[name]) {
            var cbs = this.callbacks[name];
            for (var i = 0; i < cbs.length; i++) {
                cbs[i](context);
            }
        }
    };

    /**************************************************************************************************************/

    return Event;
});

define('gw/Time/Time',["jquery", "moment", "../Utils/Constants", "../Utils/Utils"], function(
    $,
    Moment,
    Constants,
    Utils
) {
    /**
     * Time parameter
     * @typedef {Object} Time.time
     * @property {moment} date - Date of the event
     * @property {moment} display - date as defined in the server level
     * @property {Time.period} period - period of the event
     */

    /**
     * Period parameter
     * @typedef {Object} Time.period
     * @property {moment} from - Start date
     * @property {moment} to - Stop date
     */

    const REGEXP_YEAR = /^\d{4}$/;

    /**
     * @class
     * Handles time.
     * @param {Time.time} time
     * @constructor
     */
    var Time = function(time) {
        this.date = time.date;
        this.display = time.display;
        this.period = time.period;
    };

    /**
     * Tests if the time input parameter is based on TimeTravel.
     * @param {Time.time} value time
     * @return {boolean} true when TimeTravel parameter is used otherwise false
     * @function _isTimeTravel
     * @memberof Time#
     * @private
     */
    function _isTimeTravel(value) {
        return (
            value.hasOwnProperty("date") &&
            value.hasOwnProperty("display") &&
            value.hasOwnProperty("period")
        );
    }

    /**
     * Tests if the time input parameter is based on a period
     * @param {Time.period} value time
     * @return {boolean} true when period parameter is used otherwise false
     * @function _isPeriod
     * @memberof Time#
     * @private
     */
    function _isPeriod(value) {
        return value.hasOwnProperty("from") && value.hasOwnProperty("to");
    }

    /**
     * Tests if the time input parameter is based on a semi-period (to not defined)
     * @param {Time.period} value time
     * @return {boolean} true when period parameter is used otherwise false
     * @function _isOpenedInterval
     * @memberof Time#
     * @private
     */
    function _isOpenedInterval(value) {
        return value.hasOwnProperty("from");
    }

    /**
     * Tests if the time input parameter is based on a string
     * @param {string} value time
     * @return {boolean} true when a string is used to define the date
     * @function _isDateString
     * @memberof Time#
     * @private
     */
    function _isDateString(value) {
        return typeof value === "string";
    }

    /**
     * Tests if the time input parameter is based on a Date object
     * @param {Date} value time
     * @return {boolean} true when a Date object is used to define the date
     * @function _isDate
     * @memberof Time#
     * @private
     */
    function _isDate(value) {
        return value instanceof Date;
    }

    /**
     * Tests is value is a numeric value.
     * @param value value to test
     * @return {boolean} true when value is a numeric otherwise false
     * @function _isNumeric
     * @memberof Time#
     * @private
     */
    function _isNumeric(value) {
        return !isNaN(value);
    }

    /**
     * Returns the unit (year, mont, day) of the date
     * @param {UNIT_TIME_WMS} unit
     * @return {TIME_STEP} the unit
     * @function _unitWithoutTime
     * @memberof Time#
     * @private
     */
    function _unitWithoutTime(unit) {
        var unitTime;
        switch (unit) {
        case Constants.UNIT_TIME_WMS.YEAR:
            unitTime = Constants.TIME_STEP.YEAR;
            break;
        case Constants.UNIT_TIME_WMS.MONTH:
            unitTime = Constants.TIME_STEP.MONTH;
            break;
        case Constants.UNIT_TIME_WMS.DAY:
            unitTime = Constants.TIME_STEP.DAY;
            break;
        default:
            throw new Error("Unknown date format");
        }
        return unitTime;
    }

    /**
     * Returns the unit (hour, minute, second) of the time.
     * @param {UNIT_TIME_WMS} unit unit of the time
     * @return {TIME_STEP} Unit of the time
     * @function _unitWithTime
     * @memberof Time#
     * @private
     */
    function _unitWithTime(unit) {
        var unitTime;
        switch (unit) {
        case Constants.UNIT_TIME_WMS.HOUR:
            unitTime = Constants.TIME_STEP.HOUR;
            break;
        case Constants.UNIT_TIME_WMS.MINUTE:
            unitTime = Constants.TIME_STEP.MINUTE;
            break;
        case Constants.UNIT_TIME_WMS.SECONDE:
            unitTime = Constants.TIME_STEP.SECONDE;
            break;
        default:
            throw new Error("Onknown time format");
        }
        return unitTime;
    }

    /**
     * Parses the resolution returned by the server side.
     * @param resolution
     * @return {{step: *, unit: *}} The resolution of the temporal step
     * @function _timeResolution
     * @memberof Time#
     * @private
     */
    function _timeResolution(resolution) {
        var stepTime, unitTime;
        var unit = resolution.slice(-1);
        if (resolution.startsWith(Constants.UNIT_RESOLUTION_WMS.TIME)) {
            //time => hour, min, sec
            stepTime = resolution.substring(2, resolution.length - 1);
            unitTime = _unitWithTime(unit);
        } else if (
            resolution.startsWith(Constants.UNIT_RESOLUTION_WMS.NOT_TIME)
        ) {
            //day, month year
            stepTime = resolution.substring(1, resolution.length - 1);
            unitTime = _unitWithoutTime(unit);
        } else {
            throw new Error("Unknown resolution");
        }

        var res = {
            step: stepTime,
            unit: unitTime
        };
        return res;
    }

    /**
     * Tests if the time definition is a sampling (min/max/step)
     * @param {string} timeDefinition
     * @return {boolean} true when timeDefinition is a sampling
     * @function _isSampling
     * @memberof Time#
     * @private
     */
    function _isSampling(timeDefinition) {
        return timeDefinition.indexOf("/") !== -1;
    }

    /**
     * Tests if the time definition is a single value
     * @param {string} timeDefinition
     * @return {boolean} true when timeDefinition is a discrete value
     * @function _isDistinctValue
     * @memberof Time#
     * @private
     */
    function _isDistinctValue(timeDefinition) {
        return (
            !_isSampling(timeDefinition) && timeDefinition.indexOf(",") === -1
        );
    }

    /**
     * Tests if two dates are equals
     * @param {moment} date1
     * @param {moment} date2
     * @return {boolean} true when dates are equals otherwise false
     * @function _isEqual
     * @memberof Time#
     * @private
     */
    function _isEqual(date1, date2) {
        var interval1 = _createPeriod(date1);
        var interval2 = _createPeriod(date2);
        return (
            (interval2.from <= interval1.from &&
                interval1.from <= interval2.to) ||
            (interval2.from <= interval1.to && interval1.to <= interval2.to) ||
            (interval1.from <= interval2.from &&
                interval2.from <= interval1.to) ||
            (interval1.from <= interval2.to && interval2.to <= interval1.to)
        );
    }

    /**
     * Create a period from a given date
     * @param {moment} date
     * @return {{from, to}} the period
     * @function _createPeriod
     * @memberof Time#
     * @private
     */
    function _createPeriod(date) {
        var format = date.creationData().format;
        var timeResolution = _lowestFormatResolution(format);
        return {
            from: Moment(date).startOf(timeResolution),
            to: Moment(date).endOf(timeResolution)
        };
    }

    /**
     *
     * @param {*} period1
     * @param {*} date2
     * @function _isIntersect
     * @memberof Time#
     * @private
     */
    function _isIntersect(period1, date2) {
        var interval2 = _createPeriod(date2);
        return (
            (interval2.from <= period1.from && period1.from <= interval2.to) ||
            (interval2.from <= period1.to && period1.to <= interval2.to) ||
            (period1.from <= interval2.from && interval2.from <= period1.to) ||
            (period1.from <= interval2.to && interval2.to <= period1.to)
        );
    }

    /**
     * Binary Search to find the date in min/max/resolution for which the date is equal to requestedTime
     * @param {moment} requestedTime requested time
     * @param {{from,to}} requestedPeriodTime requested period time
     * @param {moment} startTime start date
     * @param {int} nbValues number of value between startDate/stopDate
     * @param {{step,unit}} timeResolution time resolution
     * @return {number} -1 when the requestedTime is not find in the binarySearch otherwise false
     * @function _binarySearch
     * @memberof Time#
     * @private
     */
    function _binarySearch(
        requestedTime,
        requestedPeriodTime,
        startTime,
        nbValues,
        timeResolution
    ) {
        var guess,
            start,
            currentDate,
            min = 0,
            max = nbValues;

        while (min <= max) {
            guess = Math.floor((min + max) / 2);
            currentDate = Moment(startTime);
            currentDate.add(guess * timeResolution.step, timeResolution.unit);
            if (
                _isEqual(requestedTime, currentDate) ||
                _isIntersect(requestedPeriodTime, currentDate)
            )
                return guess;
            else if (requestedTime > currentDate) min = guess + 1;
            else max = guess - 1;
        }
        return -1;
    }

    /**
     * Lowest format resolution.
     * @param {string} format
     * @return The time moment unit
     * @private
     * @function _lowestFormatResolution
     * @memberof Time#
     */
    function _lowestFormatResolution(format) {
        var timeResolution;
        if (Utils.aContainsB.call(this, format, "ss")) {
            timeResolution = Constants.TIME_MOMENT_STEP.SECOND;
        } else if (Utils.aContainsB.call(this, format, "mm")) {
            timeResolution = Constants.TIME_MOMENT_STEP.MINUTE;
        } else if (Utils.aContainsB.call(this, format, "HH")) {
            timeResolution = Constants.TIME_MOMENT_STEP.HOUR;
        } else if (Utils.aContainsB.call(this, format, "DD")) {
            timeResolution = Constants.TIME_MOMENT_STEP.DAY;
        } else if (Utils.aContainsB.call(this, format, "MM")) {
            timeResolution = Constants.TIME_MOMENT_STEP.MONTH;
        } else if (Utils.aContainsB.call(this, format, "YYYY")) {
            timeResolution = Constants.TIME_MOMENT_STEP.YEAR;
        } else {
            throw new Error();
        }
        return timeResolution;
    }

    /**
     * Template for time travel
     * @param {string} date date
     * @param {string} display the real value from the server
     * @param {string} from start date
     * @param {string} to stop date
     * @param {boolean} computed true when we do not find the real date from the server
     * @return {{date: *, display: *, period: {from: *, to: *}, computed: *}}
     * @private
     * @function _templateTimeTravel
     * @memberof Time#
     */
    function _templateTimeTravel(date, display, from, to, computed) {
        return {
            date: _convertMoment(date),
            display: display,
            period: {
                from: _convertMoment(from),
                to: _convertMoment(to)
            },
            computed: computed
        };
    }

    /**
     *
     * @param {*} date
     * @memberof Time#
     * @function _convertMoment
     */
    function _convertMoment(date) {
        var time;
        if (REGEXP_YEAR.test(date)) {
            time = Moment.utc(date, "YYYY");
        } else if (date instanceof Date) {
            time = Moment.utc(date.toISOString());
        } else {
            time = Moment.utc(date);
        }
        return time;
    }

    /**
     * Converts a string date to a Time object
     * @param {string} time
     * @return {{date, display, period, computed}|{date: *, display: *, period: {from: *, to: *}, computed: *}}
     * @private
     * @function _convertStringDateToTime
     * @memberof Time#
     */
    function _convertStringDateToTime(time) {
        var timeRequested = _convertMoment(time);
        var format = timeRequested.creationData().format;
        var timeResolution = _lowestFormatResolution(format);
        var from = Moment.utc(timeRequested).startOf(timeResolution);
        var to = Moment.utc(timeRequested).endOf(timeResolution);
        return _templateTimeTravel(time, time, from, to, false);
    }

    /**
     * Lowest format resolution.
     * @param {string} format
     * @return The time moment unit
     */
    Time.lowestFormatResolution = function(format) {
        return _lowestFormatResolution(format);
    };

    /**
     * Parses the resolution returned by the server side.
     * @param resolution
     * @return {{step: *, unit: *}} The resolution of the temporal step
     */
    Time.timeResolution = function(resolution) {
        return _timeResolution(resolution);
    };

    /**
     * Tests if the time definition is a sampling (min/max/step)
     * @param {string} timeDefinition
     * @return {boolean} true when timeDefinition is a sampling
     */
    Time.isSampling = function(timeDefinition) {
        return _isSampling(timeDefinition);
    };

    /**
     * Tests if the time definition is a single value
     * @param {string} timeDefinition
     * @return {boolean} true when timeDefinition is a discrete value
     */
    Time.isDistinctValue = function(timeDefinition) {
        return _isDistinctValue(timeDefinition);
    };

    /**
     * Parses the date and returns Time.
     * @param {Time.time|Time.period|string|Date} time
     * @return {Time} time object
     */
    Time.parse = function(time) {
        var result;
        if (_isTimeTravel(time)) {
            result = _templateTimeTravel(
                time.date,
                time.display,
                time.period.from,
                time.period.to,
                true
            );
        } else if (_isPeriod(time)) {
            result = _templateTimeTravel(
                time.from,
                time.from,
                time.from,
                time.to,
                false
            );
        } else if (_isOpenedInterval(time)) {
            result = _templateTimeTravel(
                time.from,
                time.from,
                time.from,
                Moment(),
                false
            );
        } else if (_isDateString(time)) {
            result = _convertStringDateToTime(time);
        } else if (_isDate(time)) {
            result = _convertStringDateToTime(time.toISOString());
        } else {
            throw new Error("Unsupported time format");
        }
        return new Time(result);
    };

    /**
     * Tests if the singleDefinition is equal to the time object.
     * @param {string} singleTimeDefinition
     * @return {boolean} true when the singleDefinition is equal to the time object otherwise false
     * @function isEqual
     * @memberof Time#
     */
    Time.prototype.isEqual = function(singleTimeDefinition) {
        var singleTimeMoment = _convertMoment(singleTimeDefinition);
        var isEqual = _isEqual(this.date, singleTimeMoment);
        if (isEqual) {
            var format = singleTimeMoment.creationData().format;
            this.display = singleTimeMoment.format(format);
        }
        return isEqual;
    };

    /**
     * Tests if the samplingDefinition is in the sample.
     * @param {string} samplingTimeDefinition
     * @return {boolean} true when the samplingDefinition is in the sample otherwise false.
     * @function isInSampling
     * @memberof Time#
     */
    Time.prototype.isInSampling = function(samplingTimeDefinition) {
        samplingTimeDefinition = samplingTimeDefinition.trim();
        var minMaxStepTimeDef = samplingTimeDefinition.split("/");
        var startDateTimeDef = _convertMoment(minMaxStepTimeDef[0]);
        var stopDateTimeDef = _convertMoment(minMaxStepTimeDef[1]);
        var stepDateTimeDef = minMaxStepTimeDef[2];
        var timeResolutionDef = _timeResolution(stepDateTimeDef);
        var nbValues = Math.floor(
            stopDateTimeDef.diff(startDateTimeDef, timeResolutionDef.unit) /
                parseInt(timeResolutionDef.step)
        );
        var idx = _binarySearch(
            this.date,
            this.period,
            startDateTimeDef,
            nbValues,
            timeResolutionDef
        );
        var isFound;
        if (idx === -1) {
            isFound = false;
        } else {
            isFound = true;
            var format = startDateTimeDef.creationData().format;
            this.display = Moment.utc(startDateTimeDef)
                .add(idx * timeResolutionDef.step, timeResolutionDef.unit)
                .format(format);
        }
        return isFound;
    };

    /**
     * Tests if the timeDefinition is in Time definition.
     * TimeDefinition can be a sample of discrete values and/or start/stop/resolution
     * @param {string} timeDefinition
     * @return {boolean} true when the timeDefinition is in Time definition otherwise false
     * @function isInTimeDefinition
     * @memberof Time#
     */
    Time.prototype.isInTimeDefinition = function(timeDefinition) {
        timeDefinition = timeDefinition.trim();
        var dataTime, momentDataTime, timeIdx;
        var isInside = false;
        var times = timeDefinition.split(",");
        for (timeIdx = 0; timeIdx < times.length && !isInside; timeIdx++) {
            dataTime = times[timeIdx].trim();
            if (_isDistinctValue(dataTime)) {
                isInside = this.isEqual(dataTime);
            } else if (_isSampling(dataTime)) {
                isInside = this.isInSampling(dataTime);
            } else {
                throw new Error("Unknown timeDefinition format");
            }
        }
        return isInside;
    };

    /**
     * Returns the real value coming from the server.
     * @return {string} the real value coming from the server
     * @function getDisplayValue
     * @memberof Time#
     */
    Time.prototype.getDisplayValue = function() {
        return this.display;
    };

    return Time;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/FeatureStyle',["../Utils/Constants"], function(Constants) {
    // Simple colors
    var simple_colors = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
    };

    var parseHex = /^(\w{2})(\w{2})(\w{2})$/;
    var parseRgb = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/;
    var parseRgba = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3},\s*(\d{1,3}))\)$/;

    /**************************************************************************************************************/

    /**
     @name FeatureStyle
     @class
         The style to display a Feature
     @param {JSON} style an object containing the following style properties
     <ul>
     <li>strokeColor : the color for line, or polygon outline</li>
     <li>strokeWidth : the width of a line</li>
     <li>fillColor : the color for solid polygon or point</li>
     <li>fillTextureUrl : the texture for solid polygon</li>
     <li>iconUrl : the icon to be used for point</li>
     <li>pointMaxSize : Distance maximum (in meter) from the ground to the camera for which a point is displayed</li>
     <li>extrusionScale : extrusion scale (in meter)</li>
     </ul>
     @constructor
     */
    var FeatureStyle = function(style) {
        // Color used for lines or polygon outline
        this.strokeColor = [1.0, 0.0, 0.0, 1.0];
        // Color used to fill polygon
        this.fillColor = [1.0, 0.0, 0.0, 1.0];
        this.fillTextureUrl = null;
        this.fillTexture = null;
        this.fillShader = null;
        this.strokeWidth = 1;
        this.iconUrl = null;
        this.icon = null;
        this.label = null;
        this.textColor = [1.0, 1.0, 1.0, 1.0];
        this.fill = false;
        this.pointMaxSize = 40;
        this.opacity = 1.0;
        this.zIndex = Constants.DISPLAY.DEFAULT_RASTER;
        this.extrusionScale = 1.0;
        this.onTerrain = true;

        if (style) {
            for (var s in style) {
                if (style.hasOwnProperty(s)) {
                    this[s] = style[s];
                }
            }
        }
    };

    /**
     Convert a color from a string to RGB
     @function fromStringToColor
     @memberof FeatureStyle
     @param {string} color_string Color string
     @return {float[]} array with [r,g,b,alpha]
     */
    FeatureStyle.fromStringToColor = function(color_string) {
        var r = 0,
            g = 0,
            b = 0,
            a = 255;
        var match;

        color_string = color_string.trim();
        color_string = color_string.toLowerCase();
        // strip any leading #
        if (color_string.charAt(0) === "#") {
            // remove # if any
            color_string = color_string.substr(1, 6);
        }

        // Convert a litteral color to rgb string
        if (simple_colors.hasOwnProperty(color_string)) {
            color_string = simple_colors[color_string];
        }

        match = parseHex.exec(color_string);
        if (match) {
            r = parseInt(match[1], 16);
            g = parseInt(match[2], 16);
            b = parseInt(match[3], 16);
        }

        match = parseRgb.exec(color_string);
        if (match) {
            r = parseInt(match[1], 10);
            g = parseInt(match[2], 10);
            b = parseInt(match[3], 10);
        }

        match = parseRgba.exec(color_string);
        if (match) {
            r = parseInt(match[1], 10);
            g = parseInt(match[2], 10);
            b = parseInt(match[3], 10);
            a = parseInt(match[4], 10);
        }

        // validate/cleanup values
        r = r < 0 ? 0 : r > 255 ? 255 : r;
        g = g < 0 ? 0 : g > 255 ? 255 : g;
        b = b < 0 ? 0 : b > 255 ? 255 : b;
        a = a < 0 ? 0 : a > 255 ? 255 : a;

        return [r / 255.0, g / 255.0, b / 255.0, a / 255.0];
    };

    /**************************************************************************************************************/

    /**
     Convert an internal color to a string based color representation
     @function fromColorToString
     @memberof FeatureStyle
     @param {float[]} color array with [r,g,b]
     @return {string}Color string
     */
    FeatureStyle.fromColorToString = function(color) {
        var hashColor = "#";
        for (var i = 0; i < 3; i++) {
            var component = parseInt(color[i] * 255.0, 10).toString(16);
            hashColor += component < 10 ? "0" + component : component;
        }

        return hashColor;
    };

    FeatureStyle.prototype.getStrokeColor = function() {
        return this.strokeColor;
    };

    FeatureStyle.prototype.setStrokeColor = function(strokeColor) {
        this.strokeColor = strokeColor;
        return this.strokeColor;
    };

    FeatureStyle.prototype.getFillColor = function() {
        return this.fillColor;
    };

    FeatureStyle.prototype.setFillColor = function(fillColor) {
        this.fillColor = fillColor;
        return this.fillColor;
    };

    FeatureStyle.prototype.getFillTextureURL = function() {
        return this.fillTextureUrl;
    };

    FeatureStyle.prototype.setFillTextureURL = function(fillTextureURL) {
        this.fillTextureUrl = fillTextureURL;
        return this.fillTextureUrl;
    };

    FeatureStyle.prototype.getFillTexture = function() {
        return this.fillTexture;
    };

    FeatureStyle.prototype.setFillTexture = function(fillTexture) {
        this.fillShader = fillTexture;
        return this.fillShader;
    };

    FeatureStyle.prototype.getFillShader = function() {
        return this.fillShader;
    };

    FeatureStyle.prototype.setFillShader = function(fillShader) {
        this.fillShader = fillShader;
        return this.fillShader;
    };

    FeatureStyle.prototype.getStrokeWidth = function() {
        return this.strokeWidth;
    };

    FeatureStyle.prototype.setStrokeWidth = function(strokeWidth) {
        this.strokeWidth = strokeWidth;
        return this.strokeWidth;
    };

    FeatureStyle.prototype.getIconURL = function() {
        return this.iconUrl;
    };

    FeatureStyle.prototype.setIconURL = function(iconURL) {
        this.iconUrl = iconURL;
        return this.iconUrl;
    };

    FeatureStyle.prototype.getIcon = function() {
        return this.icon;
    };

    FeatureStyle.prototype.setIcon = function(icon) {
        this.icon = icon;
    };

    FeatureStyle.prototype.getLabel = function() {
        return this.label;
    };

    FeatureStyle.prototype.setLabel = function(label) {
        this.label = label;
    };

    FeatureStyle.prototype.getTextColor = function() {
        return this.textColor;
    };

    FeatureStyle.prototype.setTextColor = function(textColor) {
        this.textColor = textColor;
        return this.textColor;
    };

    FeatureStyle.prototype.isFill = function() {
        return this.isFill;
    };

    FeatureStyle.prototype.setFill = function(isFill) {
        this.isFill = isFill;
        return this.isFill;
    };

    FeatureStyle.prototype.getPointMaxSize = function() {
        return this.pointMaxSize;
    };

    FeatureStyle.prototype.setPointMaxSize = function(pointMaxSize) {
        this.pointMaxSize = pointMaxSize;
    };

    FeatureStyle.prototype.getOpacity = function() {
        return this.opacity;
    };

    FeatureStyle.prototype.setOpacity = function(opacity) {
        if (typeof opacity === "number") {
            this.opacity = Math.min(1.0, Math.max(0.0, opacity));
        } else {
            throw new RangeError(
                "opacity value should be a value in [0..1]",
                "AbstractLayer.js"
            );
        }
    };

    FeatureStyle.prototype.getZIndex = function() {
        return this.zIndex;
    };

    FeatureStyle.prototype.setZIndex = function(zIndex) {
        this.zIndex = zIndex;
        return this.zIndex;
    };

    /**
     * Get extrusion scale
     * @function getExtrusionScale
     * @memberof FeatureStyle.prototype
     *
     * @return {float} Extrusion scale
     */
    FeatureStyle.prototype.getExtrusionScale = function() {
        return this.extrusionScale;
    };

    /**
     * Set extrusion scale
     * @function setExtrusionScale
     * @memberof FeatureStyle.prototype
     *
     * @param {float} value Extrusion scale
     */
    FeatureStyle.prototype.setExtrusionScale = function(value) {
        this.extrusionScale = value;
    };

    FeatureStyle.prototype.isOnTerrain = function(value) {
        return this.onTerrain;
    };

    FeatureStyle.prototype.setOnTerrain = function(value) {
        this.onTerrain = value;
    };

    /**************************************************************************************************************/

    return FeatureStyle;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

define('gw/Renderer/ColorMap',["../Utils/Numeric","../Utils/Constants", "../Gui/dialog/ErrorDialog"], function(Numeric, Constants, ErrorDialog) {
    /**************************************************************************************************************/
    var transferFonctions = {
        linear: [],
        asin: [],
        sqrt: [],
        sqr: [],
        log: []
    };

    var computeTransferFunctions = function() {
        for (var x in transferFonctions) {
            if (transferFonctions.hasOwnProperty(x)) {
                var min = Number.MAX_VALUE;
                var max = Number.MIN_VALUE;
                var v;
                var val = [];
                for (var i = 0; i < 256; i++) {
                    v = i;
                    switch (x) {
                    case "linear":
                        val[i] = v;
                        break;
                    case "asin":
                        val[i] = Math.log(
                            v + Math.sqrt(Math.pow(v, 2) + 1.0)
                        );
                        break;
                    case "log":
                        val[i] = Math.log(v / 10.0 + 1);
                        break;
                    case "sqrt":
                        val[i] = Math.sqrt(v / 10.0);
                        break;
                    case "sqr":
                        val[i] = v * v;
                        break;
                    default:
                        break;
                    }

                    if (val[i] < min) {
                        min = val[i];
                    }
                    if (val[i] > max) {
                        max = val[i];
                    }
                }

                // Normalize between [0..256]
                for (i = 0; i < 256; i++) {
                    v = 256 * ((val[i] - min) / (max - min));

                    // Clamp
                    if (v > 256.0) {
                        v = 256.0;
                    } else {
                        if (v < 0.0) {
                            v = 0.0;
                        }
                    }

                    transferFonctions[x][i] = Math.floor(v);
                }
            }
        }
    };

    computeTransferFunctions();

    // Contstant colormaps
    var colormaps = {
        // composantes de la table 'Fire' (ImageJ)
        fire: {
            red: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                4,
                7,
                10,
                13,
                16,
                19,
                22,
                25,
                28,
                31,
                34,
                37,
                40,
                43,
                46,
                49,
                52,
                55,
                58,
                61,
                64,
                67,
                70,
                73,
                76,
                79,
                82,
                85,
                88,
                91,
                94,
                98,
                101,
                104,
                107,
                110,
                113,
                116,
                119,
                122,
                125,
                128,
                131,
                134,
                137,
                140,
                143,
                146,
                148,
                150,
                152,
                154,
                156,
                158,
                160,
                162,
                163,
                164,
                166,
                167,
                168,
                170,
                171,
                173,
                174,
                175,
                177,
                178,
                179,
                181,
                182,
                184,
                185,
                186,
                188,
                189,
                190,
                192,
                193,
                195,
                196,
                198,
                199,
                201,
                202,
                204,
                205,
                207,
                208,
                209,
                210,
                212,
                213,
                214,
                215,
                217,
                218,
                220,
                221,
                223,
                224,
                226,
                227,
                229,
                230,
                231,
                233,
                234,
                235,
                237,
                238,
                240,
                241,
                243,
                244,
                246,
                247,
                249,
                250,
                252,
                252,
                252,
                253,
                253,
                253,
                254,
                254,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255
            ],

            green: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                3,
                5,
                7,
                8,
                10,
                12,
                14,
                16,
                19,
                21,
                24,
                27,
                29,
                32,
                35,
                37,
                40,
                43,
                46,
                48,
                51,
                54,
                57,
                59,
                62,
                65,
                68,
                70,
                73,
                76,
                79,
                81,
                84,
                87,
                90,
                92,
                95,
                98,
                101,
                103,
                105,
                107,
                109,
                111,
                113,
                115,
                117,
                119,
                121,
                123,
                125,
                127,
                129,
                131,
                133,
                134,
                136,
                138,
                140,
                141,
                143,
                145,
                147,
                148,
                150,
                152,
                154,
                155,
                157,
                159,
                161,
                162,
                164,
                166,
                168,
                169,
                171,
                173,
                175,
                176,
                178,
                180,
                182,
                184,
                186,
                188,
                190,
                191,
                193,
                195,
                197,
                199,
                201,
                203,
                205,
                206,
                208,
                210,
                212,
                213,
                215,
                217,
                219,
                220,
                222,
                224,
                226,
                228,
                230,
                232,
                234,
                235,
                237,
                239,
                241,
                242,
                244,
                246,
                248,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255
            ],

            blue: [
                0,
                7,
                15,
                22,
                30,
                38,
                45,
                53,
                61,
                65,
                69,
                74,
                78,
                82,
                87,
                91,
                96,
                100,
                104,
                108,
                113,
                117,
                121,
                125,
                130,
                134,
                138,
                143,
                147,
                151,
                156,
                160,
                165,
                168,
                171,
                175,
                178,
                181,
                185,
                188,
                192,
                195,
                199,
                202,
                206,
                209,
                213,
                216,
                220,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                224,
                222,
                220,
                218,
                216,
                214,
                212,
                210,
                206,
                202,
                199,
                195,
                191,
                188,
                184,
                181,
                177,
                173,
                169,
                166,
                162,
                158,
                154,
                151,
                147,
                143,
                140,
                136,
                132,
                129,
                125,
                122,
                118,
                114,
                111,
                107,
                103,
                100,
                96,
                93,
                89,
                85,
                82,
                78,
                74,
                71,
                67,
                64,
                60,
                56,
                53,
                49,
                45,
                42,
                38,
                35,
                31,
                27,
                23,
                20,
                16,
                12,
                8,
                5,
                4,
                3,
                3,
                2,
                1,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                4,
                8,
                13,
                17,
                21,
                26,
                30,
                35,
                42,
                50,
                58,
                66,
                74,
                82,
                90,
                98,
                105,
                113,
                121,
                129,
                136,
                144,
                152,
                160,
                167,
                175,
                183,
                191,
                199,
                207,
                215,
                223,
                227,
                231,
                235,
                239,
                243,
                247,
                251,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255
            ]
        },

        // composantes de la table EOSB (IDL color table 27)
        eosb: {
            red: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                9,
                18,
                27,
                36,
                45,
                49,
                57,
                72,
                81,
                91,
                100,
                109,
                118,
                127,
                136,
                131,
                139,
                163,
                173,
                182,
                191,
                200,
                209,
                218,
                227,
                213,
                221,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                253,
                251,
                249,
                247,
                245,
                243,
                241,
                215,
                214,
                235,
                234,
                232,
                230,
                228,
                226,
                224,
                222,
                198,
                196,
                216,
                215,
                213,
                211,
                209,
                207,
                205,
                203,
                181,
                179,
                197,
                196,
                194,
                192,
                190,
                188,
                186,
                184,
                164,
                162,
                178,
                176,
                175,
                173,
                171,
                169,
                167,
                165,
                147,
                145,
                159,
                157,
                156,
                154,
                152,
                150,
                148,
                146,
                130,
                128,
                140,
                138,
                137,
                135,
                133,
                131,
                129,
                127,
                113,
                111,
                121,
                119,
                117,
                117
            ],

            green: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                7,
                15,
                23,
                31,
                39,
                47,
                55,
                57,
                64,
                79,
                87,
                95,
                103,
                111,
                119,
                127,
                135,
                129,
                136,
                159,
                167,
                175,
                183,
                191,
                199,
                207,
                215,
                200,
                207,
                239,
                247,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                250,
                246,
                242,
                238,
                233,
                229,
                225,
                198,
                195,
                212,
                208,
                204,
                199,
                195,
                191,
                187,
                182,
                160,
                156,
                169,
                165,
                161,
                157,
                153,
                148,
                144,
                140,
                122,
                118,
                127,
                125,
                123,
                121,
                119,
                116,
                114,
                112,
                99,
                97,
                106,
                104,
                102,
                99,
                97,
                95,
                93,
                91,
                80,
                78,
                84,
                82,
                80,
                78,
                76,
                74,
                72,
                70,
                61,
                59,
                63,
                61,
                59,
                57,
                55,
                53,
                50,
                48,
                42,
                40,
                42,
                40,
                38,
                36,
                33,
                31,
                29,
                27,
                22,
                21,
                21,
                19,
                16,
                14,
                12,
                13,
                8,
                6,
                3,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ],

            blue: [
                116,
                121,
                127,
                131,
                136,
                140,
                144,
                148,
                153,
                157,
                145,
                149,
                170,
                174,
                178,
                182,
                187,
                191,
                195,
                199,
                183,
                187,
                212,
                216,
                221,
                225,
                229,
                233,
                238,
                242,
                221,
                225,
                255,
                247,
                239,
                231,
                223,
                215,
                207,
                199,
                172,
                164,
                175,
                167,
                159,
                151,
                143,
                135,
                127,
                119,
                100,
                93,
                95,
                87,
                79,
                71,
                63,
                55,
                47,
                39,
                28,
                21,
                15,
                7,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },

        // tableau des composantes pour Stern
        stern: {
            red: [
                0,
                18,
                36,
                54,
                72,
                90,
                108,
                127,
                145,
                163,
                199,
                217,
                235,
                254,
                249,
                244,
                239,
                234,
                229,
                223,
                218,
                213,
                208,
                203,
                197,
                192,
                187,
                182,
                177,
                172,
                161,
                156,
                151,
                146,
                140,
                135,
                130,
                125,
                120,
                115,
                109,
                104,
                99,
                94,
                89,
                83,
                78,
                73,
                68,
                63,
                52,
                47,
                42,
                37,
                32,
                26,
                21,
                16,
                11,
                6,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254
            ],

            green: [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254
            ],

            blue: [
                0,
                1,
                3,
                5,
                7,
                9,
                11,
                13,
                15,
                17,
                21,
                23,
                25,
                27,
                29,
                31,
                33,
                35,
                37,
                39,
                41,
                43,
                45,
                47,
                49,
                51,
                53,
                55,
                57,
                59,
                63,
                65,
                67,
                69,
                71,
                73,
                75,
                77,
                79,
                81,
                83,
                85,
                87,
                89,
                91,
                93,
                95,
                97,
                99,
                101,
                105,
                107,
                109,
                111,
                113,
                115,
                117,
                119,
                121,
                123,
                127,
                129,
                131,
                133,
                135,
                137,
                139,
                141,
                143,
                145,
                149,
                151,
                153,
                155,
                157,
                159,
                161,
                163,
                165,
                167,
                169,
                171,
                173,
                175,
                177,
                179,
                181,
                183,
                185,
                187,
                191,
                193,
                195,
                197,
                199,
                201,
                203,
                205,
                207,
                209,
                211,
                213,
                215,
                217,
                219,
                221,
                223,
                225,
                227,
                229,
                233,
                235,
                237,
                239,
                241,
                243,
                245,
                247,
                249,
                251,
                255,
                251,
                247,
                243,
                238,
                234,
                230,
                226,
                221,
                217,
                209,
                204,
                200,
                196,
                192,
                187,
                183,
                179,
                175,
                170,
                166,
                162,
                158,
                153,
                149,
                145,
                141,
                136,
                132,
                128,
                119,
                115,
                111,
                107,
                102,
                98,
                94,
                90,
                85,
                81,
                77,
                73,
                68,
                64,
                60,
                56,
                51,
                47,
                43,
                39,
                30,
                26,
                22,
                17,
                13,
                9,
                5,
                0,
                3,
                7,
                15,
                19,
                22,
                26,
                30,
                34,
                38,
                41,
                45,
                49,
                57,
                60,
                64,
                68,
                72,
                76,
                79,
                83,
                87,
                91,
                95,
                98,
                102,
                106,
                110,
                114,
                117,
                121,
                125,
                129,
                137,
                140,
                144,
                148,
                152,
                156,
                159,
                163,
                167,
                171,
                175,
                178,
                182,
                186,
                190,
                194,
                197,
                201,
                205,
                209,
                216,
                220,
                224,
                228,
                232,
                235,
                239,
                243,
                247,
                251
            ]
        },

        // composantes de la table rainbow (IDL color table 13)
        rainbow: {
            red: [
                0,
                4,
                9,
                13,
                18,
                22,
                27,
                31,
                36,
                40,
                45,
                50,
                54,
                58,
                61,
                64,
                68,
                69,
                72,
                74,
                77,
                79,
                80,
                82,
                83,
                85,
                84,
                86,
                87,
                88,
                86,
                87,
                87,
                87,
                85,
                84,
                84,
                84,
                83,
                79,
                78,
                77,
                76,
                71,
                70,
                68,
                66,
                60,
                58,
                55,
                53,
                46,
                43,
                40,
                36,
                33,
                25,
                21,
                16,
                12,
                4,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                4,
                8,
                12,
                21,
                25,
                29,
                33,
                42,
                46,
                51,
                55,
                63,
                67,
                72,
                76,
                80,
                89,
                93,
                97,
                101,
                110,
                114,
                119,
                123,
                131,
                135,
                140,
                144,
                153,
                157,
                161,
                165,
                169,
                178,
                182,
                187,
                191,
                199,
                203,
                208,
                212,
                221,
                225,
                229,
                233,
                242,
                246,
                250,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255
            ],
            green: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                4,
                8,
                16,
                21,
                25,
                29,
                38,
                42,
                46,
                51,
                55,
                63,
                67,
                72,
                76,
                84,
                89,
                93,
                97,
                106,
                110,
                114,
                119,
                127,
                131,
                135,
                140,
                144,
                152,
                157,
                161,
                165,
                174,
                178,
                182,
                187,
                195,
                199,
                203,
                208,
                216,
                220,
                225,
                229,
                233,
                242,
                246,
                250,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                250,
                242,
                238,
                233,
                229,
                221,
                216,
                212,
                208,
                199,
                195,
                191,
                187,
                178,
                174,
                170,
                165,
                161,
                153,
                148,
                144,
                140,
                131,
                127,
                123,
                119,
                110,
                106,
                102,
                97,
                89,
                85,
                80,
                76,
                72,
                63,
                59,
                55,
                51,
                42,
                38,
                34,
                29,
                21,
                17,
                12,
                8,
                0
            ],
            blue: [
                0,
                3,
                7,
                10,
                14,
                19,
                23,
                28,
                32,
                38,
                43,
                48,
                53,
                59,
                63,
                68,
                72,
                77,
                81,
                86,
                91,
                95,
                100,
                104,
                109,
                113,
                118,
                122,
                127,
                132,
                136,
                141,
                145,
                150,
                154,
                159,
                163,
                168,
                173,
                177,
                182,
                186,
                191,
                195,
                200,
                204,
                209,
                214,
                218,
                223,
                227,
                232,
                236,
                241,
                245,
                250,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                246,
                242,
                238,
                233,
                225,
                220,
                216,
                212,
                203,
                199,
                195,
                191,
                187,
                178,
                174,
                170,
                165,
                157,
                152,
                148,
                144,
                135,
                131,
                127,
                123,
                114,
                110,
                106,
                102,
                97,
                89,
                84,
                80,
                76,
                67,
                63,
                59,
                55,
                46,
                42,
                38,
                34,
                25,
                21,
                16,
                12,
                8,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },

        // Simple grey levels
        grey: {
            red: [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255
            ],
            green: [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255
            ],
            blue: [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255
            ]
        }
    };

    /**
     *    Create texture from array
     *    TODO : maybe move this function to renderContext ?
     *
     *    @param gl Context
     *    @param dataArray Array creating the texture
     *    @param format Content format(gl.LUMINANCE, gl.RGB...)
     *    @param dataType Type of data(gl.UNSIGNED_BYTE or gl.FLOAT)
     *    @param width Width of texture
     *    @param height Height of texture
     *
     *    @return GLTexture, or null caused by not supported format
     */
    function _textureFromPixelArray(
        gl,
        dataArray,
        format,
        dataType,
        width,
        height
    ) {
        var dataTypedArray;
        if (dataType === gl.UNSIGNED_BYTE) {
            dataTypedArray = new Uint8Array(dataArray);
        } else {
            if (dataType === gl.FLOAT) {
                dataTypedArray = new Float32Array(dataArray);
            } else {
                return null;
            }
        }

        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            format,
            width,
            height,
            0,
            format,
            dataType,
            dataTypedArray
        );

        // NPOT properties
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        return texture;
    }

    return {
        /**
         *    Create custom colormap with equidistant intervals
         *
         *    @param name Colormap name
         *    @param colors The array of colors defining the colormap(must have length at least >=2)
         */
        addCustomColormap: function(name, colors) {
            if (colors.length < 2) {
                ErrorDialog.open(Constants.LEVEL.DEBUG, "ColorMap.js", "Colors length must be >= 2");
                return null;
            }

            var colormapSize = 256;
            var colormap = {
                red: [],
                green: [],
                blue: []
            };

            var nbIntervals = colors.length - 1;
            for (var i = 0; i < nbIntervals; i++) {
                var c1 = colors[i];
                var c2 = colors[i + 1];

                var intervalLength = colormapSize / (colors.length - 1);
                var start = colormap.red.length;
                var end = Math.floor((i + 1) * intervalLength);
                for (var j = start; j < end; j++) {
                    colormap.red.push(Numeric.lerp(j / end, c1[0], c2[0]));
                    colormap.green.push(Numeric.lerp(j / end, c1[1], c2[1]));
                    colormap.blue.push(Numeric.lerp(j / end, c1[2], c2[2]));
                }
            }

            // Add to colormaps object
            colormaps[name] = colormap;
        },

        /**
         * Generate colormap
         */
        generateColormap: function(gl, transferFonction, colormap, inverse) {
            // var pas1 = 128./(tr1-tr0);
            // var pas2 = 128./(tr2-tr1);

            // Get transfer function
            var fctGap = transferFonctions[transferFonction];

            var cm = [];

            var Sr, Sg, Sb;
            Sr = colormaps[colormap].red;
            Sg = colormaps[colormap].green;
            Sb = colormaps[colormap].blue;
            var max = Sr.length - 1;
            for (var i = 0; i < 256; i++) {
                // int j= i<tr0 ? 0 :
                //       i<tr1 ? (int)Math.round((i-tr0)*pas1) :
                //       i<tr2 ? 128+(int)Math.round((i-tr1)*pas2) :
                //               max;

                var j = fctGap[i];

                // Clamp
                if (j > max) {
                    j = max;
                } else {
                    if (j < 0) {
                        j = 0;
                    }
                }
                if (inverse) {
                    j = max - j;
                }

                // Normalize between [0..1]
                cm[i * 3] = Sr[j] / 256.0;
                cm[i * 3 + 1] = Sg[j] / 256.0;
                cm[i * 3 + 2] = Sb[j] / 256.0;
            }

            // Create new texture
            return _textureFromPixelArray(
                gl,
                cm,
                gl.RGB,
                gl.FLOAT,
                cm.length / 3,
                1
            );
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/DynamicImage',["./ColorMap"], function(ColorMap) {
    /**************************************************************************************************************/

    // TODO : Unify shader programs between TileManager, ConvexPolygonRenderer and ImageRenderer
    //		* inverse Y coordinates(if needed)
    //		* vTextureCoord name refactor
    var defaultFragmentCode = "precision highp float; \n";
    defaultFragmentCode += "varying vec2 vTextureCoord;\n";
    defaultFragmentCode += "uniform sampler2D texture; \n";
    defaultFragmentCode += "uniform sampler2D colormap; \n";
    defaultFragmentCode += "uniform float min; \n";
    defaultFragmentCode += "uniform float max; \n";
    defaultFragmentCode += "uniform vec4 color; \n";
    defaultFragmentCode += "void main(void)\n";
    defaultFragmentCode += "{\n";
    defaultFragmentCode += "	float i = texture2D(texture,vTextureCoord).r;\n";
    defaultFragmentCode +=
        "	float d = clamp( ( i - min ) / (max - min), 0.0, 1.0 );\n";
    defaultFragmentCode += "	vec4 cmValue = texture2D(colormap, vec2(d,0.));\n";
    defaultFragmentCode +=
        "	gl_FragColor = vec4(cmValue.r,cmValue.g,cmValue.b,color.a);\n";
    defaultFragmentCode += "}\n";

    var defaultCallback = function(gl, renderable, program) {
        if (!program) {
            program = renderable.polygonProgram;
        }
        gl.uniform1f(program.uniforms.max, renderable.style.uniformValues.tmax);
        gl.uniform1f(program.uniforms.min, renderable.style.uniformValues.tmin);

        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(
            gl.TEXTURE_2D,
            renderable.style.uniformValues.colormapTex
        );
        gl.uniform1i(program.uniforms.colormap, 1);
    };

    /**************************************************************************************************************/

    /**
	 @name DynamicImage
	 @class
		DynamicImage constructor
	 @param renderContext
	 @param pixels
	 @param format
	 @param dataType
	 @param width
	 @param height
	 @param options
	 @constructor
	 */
    var DynamicImage = function(
        renderContext,
        pixels,
        format,
        dataType,
        width,
        height,
        options
    ) {
        // Initialize fragment shader and uniformsCallback if needed
        defaultFragmentCode =
            options && options.fragmentCode
                ? options.fragmentCode
                : defaultFragmentCode;
        defaultCallback =
            options && options.updateUniforms
                ? options.updateUniforms
                : defaultCallback;

        this.fragmentCode = defaultFragmentCode;
        this.updateUniforms = defaultCallback;
        this.tmin = 0.0;
        this.tmax = 1.0;
        this.colormapTex = null;
        this.renderContext = renderContext;

        // Parameters for histogram generation
        this.pixels = pixels;
        this.transferFn = "raw";
        this.inverse = false;

        // Create texture
        var gl = renderContext.gl;
        var tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        // TODO : Flip around X axis
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            format,
            width,
            height,
            0,
            format,
            dataType,
            pixels
        );

        if (dataType === gl.FLOAT) {
            // Choose floating point texture filtering depending on extension support
            var float_linear_ext = gl.getExtension("OES_texture_float_linear");
            var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST;
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_MIN_FILTER,
                float_filtering
            );
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_MAG_FILTER,
                float_filtering
            );
        } else {
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_MIN_FILTER,
                gl.LINEAR_MIPMAP_LINEAR
            );
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }

        // NPOT properties
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        this.texture = tex;
        this.width = width;
        this.height = height;

        this.computeMinMax(pixels);
        renderContext.requestFrame();
    };

    /**************************************************************************************************************/

    /**
     * Compute min/max of fits data
     * @function computeMinMax
     * @memberof DynamicImage.prototype
     * @param pixels Fits data
     */
    DynamicImage.prototype.computeMinMax = function(pixels) {
        var max = Number.MIN_VALUE;
        var min = Number.MAX_VALUE;
        for (var i = 1; i < pixels.length; i++) {
            var val = pixels[i];
            if (isNaN(val)) {
                continue;
            }
            if (max < val) {
                max = val;
            }
            if (min > val) {
                min = val;
            }
        }
        this.min = min;
        this.max = max;
        this.tmax = max;
        this.tmin = min;
    };

    /**************************************************************************************************************/

    /**
     * Update colormap of current image
     * @function updateColormap
     * @memberof DynamicImage.prototype
     * @param transferFn Transfer function("linear", "log", "sqrt", "pow2", "asin")
     * @param colormap Colormap("grey", "rainbow", "fire", "stern", "eosb")
     * @param inverse Boolean indicating if colormap is inversed
     */
    DynamicImage.prototype.updateColormap = function(
        transferFn,
        colormap,
        inverse
    ) {
        var gl = this.renderContext.gl;
        if (transferFn !== "raw") {
            this.fragmentCode = defaultFragmentCode;
            this.updateUniforms = defaultCallback;
            // Dispose current texture
            if (this.colormapTex) {
                gl.deleteTexture(this.colormapTex);
            }

            this.colormapTex = ColorMap.generateColormap(
                gl,
                transferFn,
                colormap,
                inverse
            );
        } else {
            this.fragmentCode = null;
            this.updateUniforms = null;
        }
        this.transferFn = transferFn;
        this.inverse = inverse;
    };

    /**************************************************************************************************************/

    /**
     * Dispose textures
     * @function dispose
     * @memberof DynamicImage.prototype
     */
    DynamicImage.prototype.dispose = function() {
        var gl = this.renderContext.gl;
        if (this.colormapTex) {
            gl.deleteTexture(this.colormapTex);
        }
        if (this.texture) {
            gl.deleteTexture(this.texture);
        }

        this.colormapTex = null;
        this.texture = null;
    };

    /**************************************************************************************************************/

    return DynamicImage;
});

// Generated by CoffeeScript 1.4.0
(function() {
  var BinaryTable, CompressedImage, DataUnit, Decompress, FITS, File, HDU, Header, HeaderVerify, Image, ImageUtils, Module, Table, Tabular, moduleKeywords,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if (this.astro == null) {
    this.astro = {};
  }

  FITS = {};

  FITS.version = '0.2.3';

  this.astro.FITS = FITS;

  moduleKeywords = ['included', 'extended'];

  Module = (function() {

    function Module() {}

    Module.include = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'include(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((_ref = obj.included) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.extend = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'extend(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((_ref = obj.extended) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    Module.prototype.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    return Module;

  })();

  this.astro.FITS.Module = Module;

  DataUnit = (function(_super) {

    __extends(DataUnit, _super);

    function DataUnit(view, header) {
      this.view = view;
      this.begin = this.current = view.tell();
      this.length = void 0;
    }

    return DataUnit;

  })(Module);

  this.astro.FITS.DataUnit = DataUnit;

  HeaderVerify = {
    verifyOrder: function(keyword, order) {
      if (order !== this.cardIndex) {
        return console.warn("" + keyword + " should appear at index " + this.cardIndex + " in the FITS header");
      }
    },
    verifyBetween: function(keyword, value, lower, upper) {
      if (!(value >= lower && value <= upper)) {
        throw "The " + keyword + " value of " + value + " is not between " + lower + " and " + upper;
      }
    },
    verifyBoolean: function(value) {
      if (value === "T") {
        return true;
      } else {
        return false;
      }
    },
    Functions: {
      SIMPLE: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.primary = true;
        this.verifyOrder("SIMPLE", 0);
        return this.verifyBoolean(value);
      },
      XTENSION: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.extension = true;
        this.extensionType = value;
        this.verifyOrder("XTENSION", 0);
        return value;
      },
      BITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BITPIX";
        value = parseInt(arguments[0]);
        this.verifyOrder(key, 1);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return value;
      },
      NAXIS: function() {
        var args, array, key, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "NAXIS";
        value = parseInt(arguments[0]);
        array = arguments[1];
        if (!array) {
          this.verifyOrder(key, 2);
          this.verifyBetween(key, value, 0, 999);
          if (this.isExtension()) {
            if ((_ref = this.extensionType) === "TABLE" || _ref === "BINTABLE") {
              required = 2;
              if (value !== required) {
                throw "" + key + " must be " + required + " for TABLE and BINTABLE extensions";
              }
            }
          }
        }
        return value;
      },
      PCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "PCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this["NAXIS"];
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE") {
            required = 0;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      GCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "GCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this["NAXIS"] + 1;
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE" || _ref === "BINTABLE") {
            required = 1;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      EXTEND: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTEND";
        value = arguments[0];
        if (!this.isPrimary()) {
          throw "" + key + " must only appear in the primary header";
        }
        return this.verifyBoolean(value);
      },
      BSCALE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BZERO: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BLANK: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BLANK";
        value = arguments[0];
        // if (!(this["BITPIX"] > 0)) {
        //   throw "" + key + " is not to be used for BITPIX = " + this['BITPIX'];
        // }
        return parseInt(value);
      },
      DATAMIN: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      DATAMAX: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      EXTVER: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTVER";
        value = arguments[0];
        value = parseInt(value);
        return value;
      },
      EXTLEVEL: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTLEVEL";
        value = arguments[0];
        value = parseInt(value);
        return value;
      },
      TFIELDS: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "TFIELDS";
        value = arguments[0];
        value = parseInt(value);
        this.verifyBetween(key, value, 0, 999);
        return value;
      },
      TBCOL: function() {
        var args, index, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "TBCOL";
        value = arguments[0];
        index = arguments[2];
        this.verifyBetween(key, index, 0, this["TFIELDS"]);
        return value;
      },
      ZIMAGE: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZIMAGE";
        value = arguments[0];
        return this.verifyBoolean(value);
      },
      ZCMPTYPE: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZCMPTYPE";
        value = arguments[0];
        if (value !== 'GZIP_1' && value !== 'RICE_1' && value !== 'PLIO_1' && value !== 'HCOMPRESS_1') {
          throw "" + key + " value " + value + " is not permitted";
        }
        if (value !== 'RICE_1' && value !== 'GZIP_1') {
          throw "Compress type " + value + " is not yet implement";
        }
        return value;
      },
      ZBITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZBITPIX";
        value = parseInt(arguments[0]);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return value;
      },
      ZNAXIS: function() {
        var args, array, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZNAXIS";
        value = parseInt(arguments[0]);
        array = arguments[1];
        value = value;
        if (!array) {
          this.verifyBetween(key, value, 0, 999);
        }
        return value;
      },
      ZTILE: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZTILE";
        return parseInt(arguments[0]);
      },
      ZSIMPLE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (arguments[0] === "T") {
          return true;
        } else {
          return false;
        }
      },
      ZPCOUNT: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZPCOUNT";
        return parseInt(arguments[0]);
      },
      ZGCOUNT: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZGCOUNT";
        return parseInt(arguments[0]);
      }
    }
  };

  this.astro.FITS.HeaderVerify = HeaderVerify;

  Header = (function(_super) {

    __extends(Header, _super);

    Header.keywordPattern = /^([A-Z0-9_-]+)\s*=\s*(.*)/;

    Header.nonStringPattern = /([^\/]*)\s*\/*(.*)/;

    Header.stringPattern = /'(.*)'\s*\/*(.*)/;

    Header.arrayPattern = /([A-Za-z]+)(\d+)/;

    Header.include(HeaderVerify);

    function Header() {
      this.init = __bind(this.init, this);

      var method, name, _ref;
      this.primary = false;
      this.extension = false;
      this.verifyCard = {};
      _ref = this.Functions;
      for (name in _ref) {
        method = _ref[name];
        this.verifyCard[name] = this.proxy(method);
      }
      this.cards = {};
      this.cardIndex = 0;
    }

    Header.prototype.get = function(key) {
      if (this.contains(key)) {
        return this.cards[key];
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getIndex = function(key) {
      if (this.contains(key)) {
        return this.cards[key][0];
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getComment = function(key) {
      if (this.contains(key)) {
        if (this.cards[key][2] != null) {
          return this.cards[key][2];
        } else {
          return console.warn("" + key + " does not contain a comment");
        }
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getComments = function() {
      if (this.contains('COMMENT')) {
        return this.cards['COMMENT'];
      } else {
        return console.warn("Header does not contain any COMMENT fields");
      }
    };

    Header.prototype.getHistory = function() {
      if (this.contains('HISTORY')) {
        return this.cards['HISTORY'];
      } else {
        return console.warn("Header does not contain any HISTORY fields");
      }
    };

    Header.prototype.set = function(key, value, comment) {
      this.cards[key] = comment ? [this.cardIndex, value, comment] : [this.cardIndex, value];
      return this.cardIndex += 1;
    };

    Header.prototype.setComment = function(comment) {
      if (!this.contains("COMMENT")) {
        this.cards["COMMENT"] = [];
        this.cardIndex += 1;
      }
      return this.cards["COMMENT"].push(comment);
    };

    Header.prototype.setHistory = function(history) {
      if (!this.contains("HISTORY")) {
        this.cards["HISTORY"] = [];
        this.cardIndex += 1;
      }
      return this.cards["HISTORY"].push(history);
    };

    Header.prototype.contains = function(keyword) {
      return this.cards.hasOwnProperty(keyword);
    };

    Header.prototype.readCard = function(line) {
      var array, comment, index, key, keyToVerify, match, value, _ref, _ref1, _ref2, _ref3, _ref4;
      match = line.match(Header.keywordPattern);
      if (match == null) {
        return;
      }
      _ref = match.slice(1), key = _ref[0], value = _ref[1];
      if (key === "COMMENT" || key === "HISTORY") {
        match[1] = value.trim();
      } else if (value[0] === "'") {
        match = value.match(Header.stringPattern);
        match[1] = match[1].trim();
      } else {
        match = value.match(Header.nonStringPattern);
        match[1] = (_ref1 = match[1][0]) === "T" || _ref1 === "F" ? match[1].trim() : parseFloat(match[1]);
      }
      match[2] = match[2].trim();
      _ref2 = match.slice(1), value = _ref2[0], comment = _ref2[1];
      keyToVerify = key;
      _ref3 = [false, void 0], array = _ref3[0], index = _ref3[1];
      match = key.match(Header.arrayPattern);
      if (match != null) {
        keyToVerify = match[1];
        _ref4 = [true, match[2]], array = _ref4[0], index = _ref4[1];
      }
      if (this.verifyCard.hasOwnProperty(keyToVerify)) {
        value = this.verifyCard[keyToVerify](value, array, index);
      }
      switch (key) {
        case "COMMENT":
          return this.setComment(value);
        case "HISTORY":
          return this.setHistory(value);
        default:
          this.set(key, value, comment);
          return this.__defineGetter__(key, function() {
            return this.cards[key][1];
          });
      }
    };

    Header.prototype.init = function(block) {
      var i, line, lineWidth, maxNumLines, numLines, _i, _ref, _results;
      lineWidth = 80;
      numLines = block.length / lineWidth;
      maxNumLines = 600;
      numLines = numLines < maxNumLines ? numLines : maxNumLines;
      _results = [];
      for (i = _i = 0, _ref = numLines - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = block.slice(i * lineWidth, (i + 1) * lineWidth);
        _results.push(this.readCard(line));
      }
      return _results;
    };

    Header.prototype.hasDataUnit = function() {
      if (this["NAXIS"] === 0) {
        return false;
      } else {
        return true;
      }
    };

    Header.prototype.isPrimary = function() {
      return this.primary;
    };

    Header.prototype.isExtension = function() {
      return this.extension;
    };

    return Header;

  })(Module);

  this.astro.FITS.Header = Header;

  ImageUtils = {
    initArray: function(arrayType) {
      return this.data = new arrayType(this.width * this.height);
    },
    getExtremes: function() {
      var index, max, min, value, _ref, _ref1;
      if ((this.min != null) && (this.max != null)) {
        return [this.min, this.max];
      }
      index = this.data.length;
      while (index--) {
        value = this.data[index];
        if (isNaN(value)) {
          continue;
        }
        _ref = [value, value], min = _ref[0], max = _ref[1];
        break;
      }
      while (index--) {
        value = this.data[index];
        if (isNaN(value)) {
          continue;
        }
        if (value < min) {
          min = value;
        }
        if (value > max) {
          max = value;
        }
      }
      _ref1 = [min, max], this.min = _ref1[0], this.max = _ref1[1];
      return [this.min, this.max];
    },
    getPixel: function(x, y) {
      return this.data[y * this.width + x];
    }
  };

  this.astro.FITS.ImageUtils = ImageUtils;

  Image = (function(_super) {

    __extends(Image, _super);

    Image.include(ImageUtils);

    function Image(view, header) {
      var bitpix, i, naxis, _i,
        _this = this;
      Image.__super__.constructor.apply(this, arguments);
      naxis = header["NAXIS"];
      bitpix = header["BITPIX"];
      this.naxis = [];
      for (i = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; i = 1 <= naxis ? ++_i : --_i) {
        this.naxis.push(header["NAXIS" + i]);
      }
      this.width = header["NAXIS1"];
      this.height = header["NAXIS2"] || 1;
      this.bzero = header["BZERO"] || 0;
      this.bscale = header["BSCALE"] || 1;
      this.rowByteSize = this.width * Math.abs(bitpix) / 8;
      this.totalRowsRead = 0;
      this.length = this.naxis.reduce(function(a, b) {
        return a * b;
      }) * Math.abs(bitpix) / 8;
      this.data = void 0;
      this.frame = 0;
      switch (bitpix) {
        case 8:
          if (this.bscale % 1 === 0) {
            this.arrayType = Uint8Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint8();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint8();
            };
          }
          break;
        case 16:
          if (this.bscale % 1 === 0) {
            this.arrayType = Int16Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getInt16();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getInt16();
            };
          }
          break;
        case 32:
          if (this.bscale % 1 === 0) {
            this.arrayType = Int32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint32();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint32();
            };
          }
          break;
        case 64:
          this.arrayType = this.bscale % 1 === 0 ? Int32Array : Float32Array;
          console.warn("Unusual behaviour with 64 bit integers.");
          this.accessor = function() {
            var factor, highByte, lowByte, mod, value;
            highByte = Math.abs(_this.view.getInt32());
            lowByte = Math.abs(_this.view.getInt32());
            mod = highByte % 10;
            factor = mod ? -1 : 1;
            highByte -= mod;
            value = factor * ((highByte << 32) | lowByte);
            return _this.bzero + _this.bscale * value;
          };
          break;
        case -32:
          this.arrayType = Float32Array;
          this.accessor = function() {
            return _this.bzero + _this.bscale * _this.view.getFloat32();
          };
          break;
        case -64:
          this.arrayType = Float64Array;
          this.accessor = function() {
            return _this.bzero + _this.bscale * _this.view.getFloat64();
          };
          break;
        default:
          throw "Invalid BITPIX.";
      }
    }

    Image.prototype.getRow = function() {
      var i, _i, _ref;
      this.current = this.begin + this.totalRowsRead * this.rowByteSize;
      this.view.seek(this.current);
      for (i = _i = 0, _ref = this.width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.data[this.width * this.rowsRead + i] = this.accessor();
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    Image.prototype.getFrame = function(frame) {
      var height;
      this.frame = frame != null ? frame : this.frame;
      if (this.data == null) {
        this.initArray(this.arrayType);
      }
      this.totalRowsRead = this.width * this.frame;
      this.rowsRead = 0;
      height = this.height;
      while (height--) {
        this.getRow();
      }
      this.frame += 1;
      return this.data;
    };

    Image.prototype.seek = function(frame) {
      if (frame == null) {
        frame = 0;
      }
      if (this.naxis.length === 2) {
        this.totalRowsRead = 0;
        return this.frame = 0;
      } else {
        this.totalRowsRead = this.height * frame;
        return this.frame = this.height / this.totalRowsRead - 1;
      }
    };

    Image.prototype.isDataCube = function() {
      if (this.naxis.length > 2) {
        return true;
      } else {
        return false;
      }
    };

    return Image;

  })(DataUnit);

  this.astro.FITS.Image = Image;

  Tabular = (function(_super) {

    __extends(Tabular, _super);

    Tabular.dataAccessors = {
      L: function(view) {
        if (view.getInt8() === 84) {
          return true;
        } else {
          return false;
        }
      },
      X: function(view) {
        throw "Data type not yet implemented";
      },
      B: function(view) {
        return view.getUint8();
      },
      I: function(view) {
        return view.getInt16();
      },
      J: function(view) {
        return view.getInt32();
      },
      K: function(view) {
        var factor, highByte, lowByte, mod, value;
        highByte = Math.abs(view.getInt32());
        lowByte = Math.abs(view.getInt32());
        mod = highByte % 10;
        factor = mod ? -1 : 1;
        highByte -= mod;
        value = factor * ((highByte << 32) | lowByte);
        console.warn("Something funky happens here when dealing with 64 bit integers.  Be wary!!!");
        return value;
      },
      A: function(view) {
        return view.getChar();
      },
      E: function(view) {
        return view.getFloat32();
      },
      D: function(view) {
        return view.getFloat64();
      },
      C: function(view) {
        return [view.getFloat32(), view.getFloat32()];
      },
      M: function(view) {
        return [view.getFloat64(), view.getFloat64()];
      }
    };

    function Tabular(view, header) {
      this.getRow = __bind(this.getRow, this);
      Tabular.__super__.constructor.apply(this, arguments);
      this.rowByteSize = header["NAXIS1"];
      this.rows = header["NAXIS2"];
      this.cols = header["TFIELDS"];
      this.length = this.tableLength = this.rowByteSize * this.rows;
      this.rowsRead = 0;
      this.columns = this.getColumnNames(header);
      this.accessors = [];
    }

    Tabular.prototype.getRow = function(row) {
      var accessor, index, _i, _len, _ref;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = {};
      _ref = this.accessors;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        accessor = _ref[index];
        row[this.columns[index]] = accessor();
      }
      this.rowsRead += 1;
      return row;
    };

    Tabular.prototype.getColumnNames = function(header) {
      var columnNames, i, key, _i, _ref;
      columnNames = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        key = "TTYPE" + i;
        if (!header.contains(key)) {
          return null;
        }
        columnNames.push(header[key]);
      }
      return columnNames;
    };

    return Tabular;

  })(DataUnit);

  this.astro.FITS.Tabular = Tabular;

  Table = (function(_super) {

    __extends(Table, _super);

    Table.formPattern = /([AIFED])(\d+)\.*(\d+)*/;

    Table.dataAccessors = {
      A: function(value) {
        return value.trim();
      },
      I: function(value) {
        return parseInt(value);
      },
      F: function(value) {
        return parseFloat(value);
      },
      E: function(value) {
        return parseFloat(value);
      },
      D: function(value) {
        return parseFloat(value);
      }
    };

    function Table(view, header) {
      this.getRow = __bind(this.getRow, this);

      var form, i, match, _fn, _i, _ref,
        _this = this;
      Table.__super__.constructor.apply(this, arguments);
      _fn = function() {
        var accessor, dataType, decimals, length, _ref1;
        _ref1 = match.slice(1), dataType = _ref1[0], length = _ref1[1], decimals = _ref1[2];
        accessor = function(value) {
          return Table.dataAccessors[dataType](value);
        };
        return _this.accessors.push(accessor);
      };
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        form = header["TFORM" + i];
        match = form.match(Table.formPattern);
        _fn();
      }
    }

    Table.prototype.getRow = function(row) {
      var i, index, line, value, _i, _j, _len, _ref;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      line = "";
      for (i = _i = 1, _ref = this.rowByteSize; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        line += this.view.getChar();
      }
      line = line.trim().split(/\s+/);
      row = {};
      for (index = _j = 0, _len = line.length; _j < _len; index = ++_j) {
        value = line[index];
        row[this.columns[index]] = this.accessors[index](value);
      }
      this.rowsRead += 1;
      return row;
    };

    return Table;

  })(Tabular);

  this.astro.FITS.Table = Table;

  BinaryTable = (function(_super) {

    __extends(BinaryTable, _super);

    BinaryTable.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    BinaryTable.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    function BinaryTable(view, header) {
      var dataType, i, keyword, length, match, value, _i, _ref, _ref1,
        _this = this;
      BinaryTable.__super__.constructor.apply(this, arguments);
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        keyword = "TFORM" + i;
        value = header[keyword];
        match = value.match(BinaryTable.arrayDescriptorPattern);
        if (match != null) {
          (function() {
            var accessor, dataType;
            dataType = match[1];
            accessor = function() {
              var data, length, offset, _j;
              length = _this.view.getInt32();
              offset = _this.view.getInt32();
              _this.current = _this.view.tell();
              _this.view.seek(_this.begin + _this.tableLength + offset);
              data = [];
              for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                data.push(BinaryTable.dataAccessors[dataType](_this.view));
              }
              _this.view.seek(_this.current);
              return data;
            };
            return _this.accessors.push(accessor);
          })();
        } else {
          match = value.match(BinaryTable.dataTypePattern);
          _ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
          length = length ? parseInt(length) : 0;
          if (length === 0 || length === 1) {
            (function(dataType) {
              var accessor;
              accessor = function() {
                var data;
                data = BinaryTable.dataAccessors[dataType](_this.view);
                return data;
              };
              return _this.accessors.push(accessor);
            })(dataType);
          } else {
            (function(dataType, length) {
              var accessor, numBytes;
              if (dataType === 'X') {
                numBytes = Math.log(length) / Math.log(2);
                accessor = function() {
                  var bit, bitarray, byte, byte2bits, data, _j, _k, _len;
                  byte2bits = function(byte) {
                    var bitarray;
                    bitarray = [];
                    i = 128;
                    while (i >= 1) {
                      bitarray.push((byte & i ? 1 : 0));
                      i /= 2;
                    }
                    return bitarray;
                  };
                  data = [];
                  for (i = _j = 1; 1 <= numBytes ? _j <= numBytes : _j >= numBytes; i = 1 <= numBytes ? ++_j : --_j) {
                    byte = _this.view.getUint8();
                    bitarray = byte2bits(byte);
                    for (_k = 0, _len = bitarray.length; _k < _len; _k++) {
                      bit = bitarray[_k];
                      data.push(bit);
                    }
                  }
                  return data.slice(0, +(length - 1) + 1 || 9e9);
                };
              } else if (dataType === 'A') {
                accessor = function() {
                  var data, _j;
                  data = '';
                  for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                    data += BinaryTable.dataAccessors[dataType](_this.view);
                  }
                  return data.trim();
                };
              } else {
                accessor = function() {
                  var data, _j;
                  data = [];
                  for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                    data.push(BinaryTable.dataAccessors[dataType](_this.view));
                  }
                  return data;
                };
              }
              return _this.accessors.push(accessor);
            })(dataType, length);
          }
        }
      }
    }

    return BinaryTable;

  })(Tabular);

  this.astro.FITS.BinaryTable = BinaryTable;

  Decompress = {
    Rice: function(array, arrayLen, blocksize, bytepix, pixels, nx) {
      var b, bbits, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pointer, _ref, _ref1;
      bbits = 1 << fsbits;
      _ref = this.RiceSetup[bytepix](array), fsbits = _ref[0], fsmax = _ref[1], lastpix = _ref[2], pointer = _ref[3];
      nonzeroCount = new Uint8Array(256);
      nzero = 8;
      _ref1 = [128, 255], k = _ref1[0], i = _ref1[1];
      while (i >= 0) {
        while (i >= k) {
          nonzeroCount[i] = nzero;
          i -= 1;
        }
        k = k / 2;
        nzero -= 1;
      }
      nonzeroCount[0] = 0;
      b = array[pointer];
      pointer += 1;
      nbits = 8;
      i = 0;
      while (i < nx) {
        nbits -= fsbits;
        while (nbits < 0) {
          b = (b << 8) | array[pointer];
          pointer += 1;
          nbits += 8;
        }
        fs = (b >> nbits) - 1;
        b &= (1 << nbits) - 1;
        imax = i + blocksize;
        if (imax > nx) {
          imax = nx;
        }
        if (fs < 0) {
          while (i < imax) {
            array[i] = lastpix;
            i++;
          }
        } else if (fs === fsmax) {
          while (i < imax) {
            k = bbits - nbits;
            diff = b << k;
            k -= 8;
            while (k >= 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b << k;
              k -= 8;
            }
            if (nbits > 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b >> (-k);
              b &= (1 << nbits) - 1;
            } else {
              b = 0;
            }
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            array[i] = diff + lastpix;
            lastpix = array[i];
            i++;
          }
        } else {
          while (i < imax) {
            while (b === 0) {
              nbits += 8;
              b = array[pointer];
              pointer += 1;
            }
            nzero = nbits - nonzeroCount[b];
            nbits -= nzero + 1;
            b ^= 1 << nbits;
            nbits -= fs;
            while (nbits < 0) {
              b = (b << 8) | array[pointer];
              pointer += 1;
              nbits += 8;
            }
            diff = (nzero << fs) | (b >> nbits);
            b &= (1 << nbits) - 1;
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            pixels[i] = diff + lastpix;
            lastpix = pixels[i];
            i++;
          }
        }
      }
      return pixels;
    },
    RiceSetup: {
      1: function(array) {
        var fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 3;
        fsmax = 6;
        lastpix = array[pointer];
        pointer += 1;
        return [fsbits, fsmax, lastpix, pointer];
      },
      2: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 4;
        fsmax = 14;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      },
      4: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 5;
        fsmax = 25;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 24);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 16);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      }
    },
    gzip: function(array) {
      throw "Not yet implemented";
    },
    plio: function(array, length) {
      throw "Not yet implemented";
    },
    hcompress: function(array, length) {
      throw "Not yet implemented";
    }
  };

  this.astro.FITS.Decompress = Decompress;

  CompressedImage = (function(_super) {

    __extends(CompressedImage, _super);

    CompressedImage.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    CompressedImage.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    CompressedImage.include(ImageUtils);

    CompressedImage.extend(Decompress);

    CompressedImage.typedArray = {
      B: Uint8Array,
      I: Int16Array,
      J: Int32Array,
      E: Float32Array,
      D: Float64Array,
      1: Uint8Array,
      2: Uint8Array,
      4: Int16Array,
      8: Int32Array
    };

    function CompressedImage(view, header) {
      var i, key, value, ztile, _i, _ref;
      CompressedImage.__super__.constructor.apply(this, arguments);
      this.length += header["PCOUNT"];
      this.zcmptype = header["ZCMPTYPE"];
      this.zbitpix = header["ZBITPIX"];
      this.znaxis = header["ZNAXIS"];
      this.zblank = CompressedImage.setValue(header, "ZBLANK", void 0);
      this.blank = CompressedImage.setValue(header, "BLANK", void 0);
      this.ztile = [];
      for (i = _i = 1, _ref = this.znaxis; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        ztile = header.contains("ZTILE" + i) ? header["ZTILE" + i] : i === 1 ? header["ZNAXIS1"] : 1;
        this.ztile.push(ztile);
      }
      this.width = header["ZNAXIS1"];
      this.height = header["ZNAXIS2"] || 1;
      this.algorithmParameters = {};
      i = 1;
      while (true) {
        key = "ZNAME" + i;
        if (!header.contains(key)) {
          break;
        }
        value = "ZVAL" + i;
        this.algorithmParameters[header[key]] = header[value];
        i += 1;
      }
      if (this.zcmptype === 'RICE_1') {
        this.setRiceDefaults();
      }
      this.zmaskcmp = CompressedImage.setValue(header, "ZMASKCMP", void 0);
      this.zquantiz = CompressedImage.setValue(header, "ZQUANTIZ", "LINEAR_SCALING");
      this.bzero = CompressedImage.setValue(header, "BZERO", 0);
      this.bscale = CompressedImage.setValue(header, "BSCALE", 1);
      this.defineColumnAccessors(header);
      this.defineGetRow();
    }

    CompressedImage.prototype.defineColumnAccessors = function(header) {
      var accessor, dataType, i, length, match, ttype, value, _i, _ref, _ref1, _results,
        _this = this;
      this.columnNames = {};
      _results = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        value = header["TFORM" + i];
        match = value.match(CompressedImage.arrayDescriptorPattern);
        ttype = header["TTYPE" + i].toUpperCase();
        this.columnNames[ttype] = i - 1;
        accessor = null;
        if (match != null) {
          dataType = match[1];
          switch (ttype) {
            case "COMPRESSED_DATA":
              (function(dataType) {
                return accessor = function() {
                  var data, pixels;
                  data = _this._accessor(dataType);
                  if (data == null) {
                    return new Float32Array(_this.ztile[0]);
                  }
                  pixels = new CompressedImage.typedArray[_this.algorithmParameters["BYTEPIX"]](_this.ztile[0]);
                  CompressedImage.Rice(data, length, _this.algorithmParameters["BLOCKSIZE"], _this.algorithmParameters["BYTEPIX"], pixels, _this.ztile[0]);
                  return pixels;
                };
              })(dataType);
              break;
            case "UNCOMPRESSED_DATA":
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
              break;
            case "GZIP_COMPRESSED_DATA":
              (function(dataType) {
                return accessor = function() {
                  var data, index, item, _j, _len;
                  data = _this._accessor(dataType);
                  if (data != null) {
                    data = new Float32Array(_this.width);
                    for (index = _j = 0, _len = data.length; _j < _len; index = ++_j) {
                      item = data[index];
                      data[index] = NaN;
                    }
                    return data;
                  } else {
                    return null;
                  }
                };
              })(dataType);
              break;
            default:
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
          }
        } else {
          match = value.match(CompressedImage.dataTypePattern);
          _ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
          length = length != null ? parseInt(length) : 0;
          if (length === 0 || length === 1) {
            (function(dataType) {
              return accessor = function() {
                return CompressedImage.dataAccessors[dataType](_this.view);
              };
            })(dataType);
          } else {
            (function(length, dataType) {
              return accessor = function() {
                var data, _j, _ref2;
                data = new CompressedImage.typedArray[dataType](length);
                for (i = _j = 0, _ref2 = length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                  data[i] = CompressedImage.dataAccessors[dataType](_this.view);
                }
                return data;
              };
            })(length, dataType);
          }
        }
        _results.push(this.accessors.push(accessor));
      }
      return _results;
    };

    CompressedImage.prototype.defineGetRow = function() {
      var hasBlanks;
      this.totalRowsRead = 0;
      hasBlanks = (this.zblank != null) || (this.blank != null) || this.columnNames.hasOwnProperty("ZBLANK");
      return this.getRow = hasBlanks ? this.getRowHasBlanks : this.getRowNoBlanks;
    };

    CompressedImage.prototype.setRiceDefaults = function() {
      if (!this.algorithmParameters.hasOwnProperty("BLOCKSIZE")) {
        this.algorithmParameters["BLOCKSIZE"] = 32;
      }
      if (!this.algorithmParameters.hasOwnProperty("BYTEPIX")) {
        return this.algorithmParameters["BYTEPIX"] = 4;
      }
    };

    CompressedImage.setValue = function(header, key, defaultValue) {
      if (header.contains(key)) {
        return header[key];
      } else {
        return defaultValue;
      }
    };

    CompressedImage.prototype.getRowHasBlanks = function() {
      var blank, data, index, location, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        location = this.totalRowsRead * this.width + index;
        this.data[location] = value === blank ? NaN : zero + scale * value;
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    CompressedImage.prototype.getRowNoBlanks = function() {
      var blank, data, index, location, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        location = this.totalRowsRead * this.width + index;
        this.data[location] = zero + scale * value;
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    CompressedImage.prototype.getFrame = function() {
      var height;
      if (this.data == null) {
        this.initArray(Float32Array);
      }
      this.totalRowsRead = 0;
      this.rowsRead = 0;
      height = this.height;
      while (height--) {
        this.getRow();
      }
      return this.data;
    };

    CompressedImage.prototype._accessor = function(dataType) {
      var data, i, length, offset, _i, _ref, _ref1;
      _ref = [this.view.getInt32(), this.view.getInt32()], length = _ref[0], offset = _ref[1];
      if (length === 0) {
        return null;
      }
      data = new CompressedImage.typedArray[dataType](length);
      this.current = this.view.tell();
      this.view.seek(this.begin + this.tableLength + offset);
      for (i = _i = 0, _ref1 = length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        data[i] = CompressedImage.dataAccessors[dataType](this.view);
      }
      this.view.seek(this.current);
      return data;
    };

    CompressedImage.prototype._getRow = function() {
      var accessor, blank, data, row, scale, zero, _i, _len, _ref;
      this.current = this.begin + this.totalRowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = [];
      _ref = this.accessors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        accessor = _ref[_i];
        row.push(accessor());
      }
      data = row[this.columnNames["COMPRESSED_DATA"]] || row[this.columnNames["UNCOMPRESSED_DATA"]] || row[this.columnNames["GZIP_COMPRESSED_DATA"]];
      blank = row[this.columnNames["ZBLANK"]] || this.zblank;
      scale = row[this.columnNames["ZSCALE"]] || this.bscale;
      zero = row[this.columnNames["ZZERO"]] || this.bzero;
      return [data, blank, scale, zero];
    };

    CompressedImage.subtractiveDither1 = function() {
      throw "Not yet implemented";
    };

    CompressedImage.linearScaling = function() {
      throw "Not yet implemented";
    };

    return CompressedImage;

  })(Tabular);

  this.astro.FITS.CompressedImage = CompressedImage;

  HDU = (function() {

    function HDU(header, data) {
      this.header = header;
      this.data = data;
    }

    HDU.prototype.hasData = function() {
      if (this.data != null) {
        return true;
      } else {
        return false;
      }
    };

    HDU.prototype.getCard = function(key) {
      return this.header[key];
    };

    return HDU;

  })();

  this.astro.FITS.HDU = HDU;

  File = (function() {

    File.LINEWIDTH = 80;

    File.BLOCKLENGTH = 2880;

    File.getType = function(obj) {
      return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
    };

    function File(buffer) {
      var name;
      name = File.getType(buffer);
      switch (name) {
        case 'arraybuffer':
          this.initFromBuffer(buffer);
          break;
        case 'object':
          this.initFromObject(buffer);
          break;
        default:
          throw 'fitsjs cannot initialize object';
      }
    }

    File.excessBytes = function(length) {
      return (File.BLOCKLENGTH - (length % File.BLOCKLENGTH)) % File.BLOCKLENGTH;
    };

    File.extendDataView = function(view) {
      var getFloat32, getFloat64, getInt16, getInt32, getInt8, getUint16, getUint32, getUint8;
      DataView.prototype.getString = function(length) {
        var c, i, value, _i, _ref;
        value = '';
        for (i = _i = 0, _ref = length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          c = this.getUint8();
          value += String.fromCharCode(c > 127 ? 65533 : c);
        }
        return value;
      };
      DataView.prototype.getChar = function() {
        return this.getString(1);
      };
      view.offset = 0;
      getInt8 = view.getInt8;
      getUint8 = view.getUint8;
      getInt16 = view.getInt16;
      getUint16 = view.getUint16;
      getInt32 = view.getInt32;
      getUint32 = view.getUint32;
      getFloat32 = view.getFloat32;
      getFloat64 = view.getFloat64;
      view.getInt8 = function() {
        var value;
        value = getInt8.apply(this, [this.offset]);
        this.offset += 1;
        return value;
      };
      view.getUint8 = function() {
        var value;
        value = getUint8.apply(this, [this.offset]);
        this.offset += 1;
        return value;
      };
      view.getInt16 = function() {
        var value;
        value = getInt16.apply(this, [this.offset, false]);
        this.offset += 2;
        return value;
      };
      view.getUint16 = function() {
        var value;
        value = getUint16.apply(this, [this.offset, false]);
        this.offset += 2;
        return value;
      };
      view.getInt32 = function() {
        var value;
        value = getInt32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getUint32 = function() {
        var value;
        value = getUint32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getFloat32 = function() {
        var value;
        value = getFloat32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getFloat64 = function() {
        var value;
        value = getFloat64.apply(this, [this.offset, false]);
        this.offset += 8;
        return value;
      };
      view.seek = function(offset) {
        return this.offset = offset;
      };
      return view.tell = function() {
        return this.offset;
      };
    };

    File.prototype.initFromBuffer = function(buffer) {
      var data, hdu, header, _results;
      this.length = buffer.byteLength;
      this.view = new DataView(buffer);
      this.hdus = [];
      this.eof = false;
      File.extendDataView(this.view);
      _results = [];
      while (true) {
        header = this.readHeader();
        data = this.readData(header);
        hdu = new HDU(header, data);
        this.hdus.push(hdu);
        if (this.eof) {
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    File.prototype.initFromObject = function(buffer) {
      this.length = buffer.length;
      this.view = null;
      this.hdus = buffer.hdus;
      return this.eof = true;
    };

    File.prototype.readHeader = function() {
      var beginOffset, block, done, end, endOffset, endPattern, header, i, line, match, start, whitespacePattern;
      whitespacePattern = /\s{80}/;
      endPattern = /^END\s/;
      beginOffset = this.view.tell();
      done = false;
      while (true) {
        if (done) {
          break;
        }
        block = this.view.getString(File.BLOCKLENGTH);
        i = 0;
        while (true) {
          start = File.BLOCKLENGTH - File.LINEWIDTH * (i + 1);
          end = File.BLOCKLENGTH - File.LINEWIDTH * i;
          line = block.slice(start, end);
          match = line.match(whitespacePattern);
          if (match) {
            i += 1;
            continue;
          }
          match = line.match(endPattern);
          if (match) {
            endOffset = this.view.tell();
            this.view.seek(beginOffset);
            block = this.view.getString(endOffset - beginOffset);
            header = new Header();
            header.init(block);
            done = true;
            this.checkEOF();
            return header;
          }
          break;
        }
      }
    };

    File.prototype.readData = function(header) {
      var data, excess;
      if (!header.hasDataUnit()) {
        return;
      }
      if (header.isPrimary()) {
        data = new Image(this.view, header);
      } else if (header.isExtension()) {
        if (header.extensionType === "BINTABLE") {
          if (header.contains("ZIMAGE")) {
            data = new CompressedImage(this.view, header);
          } else {
            data = new BinaryTable(this.view, header);
          }
        } else if (header.extensionType === "TABLE") {
          data = new Table(this.view, header);
        } else if (header.extensionType === "IMAGE") {
          data = new Image(this.view, header);
        }
      }
      excess = File.excessBytes(data.length);
      this.view.seek(this.view.tell() + data.length + excess);
      this.checkEOF();
      return data;
    };

    File.prototype.checkEOF = function() {
      if (this.view.offset >= this.length) {
        return this.eof = true;
      }
    };

    File.prototype.count = function() {
      return this.hdus.length;
    };

    File.prototype.getHDU = function(index) {
      var hdu, _i, _len, _ref;
      if (index == null) {
        index = void 0;
      }
      if ((index != null) && (this.hdus[index] != null)) {
        return this.hdus[index];
      }
      _ref = this.hdus;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hdu = _ref[_i];
        if (hdu.hasData()) {
          return hdu;
        }
      }
    };

    File.prototype.getHeader = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).header;
    };

    File.prototype.getDataUnit = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).data;
    };

    File.prototype.getData = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).data.getFrame();
    };

    return File;

  })();

  this.astro.FITS.File = File;

}).call(this);

define("fits", function(){});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

define('gw/Layer/FitsLoader',["../Utils/Constants","../Gui/dialog/ErrorDialog","../Utils/Proxy","fits"], function(Constants, ErrorDialog, Proxy) {
    /**
     *    Parse fits file
     *
     *    @param response XHR response containing fits
     *
     *    @return Parsed data
     */
    function parseFits(response) {
        var FITS = astro.FITS;
        // Initialize the FITS.File object using
        // the array buffer returned from the XHR
        var fits = new FITS.File(response);
        // Grab the first HDU with a data unit
        var hdu = fits.getHDU();
        var data = hdu.data;

        var uintPixels;
        var swapPixels = new Uint8Array(
            data.view.buffer,
            data.begin,
            data.length
        ); // with gl.UNSIGNED_byte

        var bpe;
        if (data.arrayType) {
            bpe = data.arrayType.BYTES_PER_ELEMENT;
        } else {
            bpe = Math.abs(hdu.header.BITPIX) / 8;
        }
        for (var i = 0; i < swapPixels.length; i += bpe) {
            var temp;
            // Swap to little-endian
            for (var j = 0; j < bpe / 2; j++) {
                temp = swapPixels[i + j];
                swapPixels[i + j] = swapPixels[i + bpe - 1 - j];
                swapPixels[i + bpe - 1 - j] = temp;
            }
        }

        return fits;
    }

    var loadFits = function(
        url,
        successCallback,
        failCallback,
        onprogressCallback
    ) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function(e) {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    if (xhr.response) {
                        var fits = parseFits(xhr.response);
                        if (successCallback) {
                            successCallback(fits);
                        }
                    }
                } else {
                    ErrorDialog.open(Constants.LEVEL.ERROR, "Error while loading " + url);
                    if (failCallback) {
                        failCallback();
                    }
                }
            }
        };

        // Define default on progress function, otherwise
        // Firefox won't take Content-length header into account
        // so evt.lengthComputable will be always set to false..
        xhr.onprogress = function(evt) {};
        xhr.open("GET", Proxy.proxify(url));
        xhr.responseType = "arraybuffer";
        xhr.send();
        return xhr;
    };

    return {
        loadFits: loadFits,
        parseFits: parseFits
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Image manager
 */
define('gw/Services/FitsVisu',[
    "jquery",
    "../Utils/Constants",
    "../Renderer/FeatureStyle",
    "../Renderer/DynamicImage",
    "../Layer/FitsLoader",
    "fits"
], function($, Constants, FeatureStyle, DynamicImage, FitsLoader) {
    var mizarAPI;

    /**********************************************************************************************/

    /**
     *    Send XHR request for FITS file
     *    @param featureData Feature data(layer,feature)
     *    @param {string} url Url of fits file
     *    @param {Function} preprocessing function if needed
     *    @fires Mizar#image:downloaded
     */
    function computeFits(featureData, url, preprocessing) {
        // Store xhr on feature data object to cancel it if needed
        featureData.xhr = FitsLoader.loadFits(url, function(fits) {
            delete featureData.xhr;

            var fitsData = fits.getHDU().data;
            if (preprocessing) {
                preprocessing(featureData, fits);
            }

            handleFits(fitsData, featureData);
        });
        mizarAPI.publish(Constants.EVENT_MSG.IMAGE_DOWNLOADED, featureData);
    }

    /**********************************************************************************************/

    /**
     *    Send XHR request for quicklook file
     *    @param featureData Feature data(layer,feature)
     *    @param {string} url Url of quicklook file
     *    @fires Mizar#image:downloaded
     */
    function computeQuicklook(featureData, url) {
        handleQuicklook(featureData, url);
        mizarAPI.publish(Constants.EVENT_MSG.IMAGE_DOWNLOADED, featureData);
    }

    /**********************************************************************************************/

    /**
     * Handle fits data on the given feature
     * @param fitsData
     * @param featureData
     * @returns {Image} image
     */
    function handleFits(fitsData, featureData) {
        // Create new image coming from Fits
        var typedArray = new Float32Array(
            fitsData.view.buffer,
            fitsData.begin,
            fitsData.length / 4
        ); // with gl.FLOAT
        var gl = mizarAPI.getRenderContext().gl;
        var image = new DynamicImage(
            mizarAPI.getRenderContext(),
            typedArray,
            gl.LUMINANCE,
            gl.FLOAT,
            fitsData.width,
            fitsData.height
        );

        var feature = featureData.feature;
        var layer = featureData.layer;
        // Attach texture to style
        var targetStyle;
        if (feature.properties.style) {
            targetStyle = new FeatureStyle(feature.properties.style);
        } else {
            targetStyle = new FeatureStyle(layer.style);
        }
        targetStyle.fillTexture = image.texture;
        targetStyle.uniformValues = image;
        targetStyle.fill = true;
        layer.modifyFeatureStyle(feature, targetStyle);

        // Store image url for zScale processing
        if (feature.services) {
            image.url = feature.services.download.url;
        }

        return image;
    }

    /**
     * Handle quicklook data on the given feature
     * @param featureData
     * @returns {Image} image
     */
    function handleQuicklook(featureData, url) {
        var feature = featureData.feature;
        var layer = featureData.layer;

        if (layer.getType() === Constants.LAYER.OpenSearch) {
            layer.loadQuicklook(feature, url);
        }
    }

    /**********************************************************************************************/

    function parseFits(response) {
        return FitsLoader.parseFits(response);
    }

    /**********************************************************************************************/

    /**
     * Remove fits texture from feature
     * @param featureData
     */
    function removeFitsFromRenderer(featureData) {
        // Abort xhr if inprogress
        if (featureData.xhr) {
            featureData.xhr.abort();
            delete featureData.xhr;
        }

        var gl = mizarAPI.getRenderContext().gl;
        if (featureData.feature.properties.style.uniformValues) {
            featureData.feature.properties.style.uniformValues.dispose();
        }
        // TODO : style could still contain fillTextures, is it normal ?
        var texture = featureData.feature.properties.style.fillTexture;
        if (texture) {
            gl.deleteTexture(texture);
        }
        var targetStyle = new FeatureStyle(
            featureData.feature.properties.style
        );
        targetStyle.fillTexture = null;
        targetStyle.fill = false;

        // Remove rendering
        targetStyle.fillShader = {
            fragmentCode: null,
            updateUniforms: null
        };
        delete targetStyle.uniformValues;

        featureData.layer.modifyFeatureStyle(featureData.feature, targetStyle);
    }

    /**********************************************************************************************/

    return {
        /**
         * Initialize ImageManagerCore
         * @param m
         * @param configuration
         */
        init: function(m, configuration) {
            mizarAPI = m;
            // Enable float texture extension to have higher luminance range
            var ext = mizarAPI
                .getRenderContext()
                .gl.getExtension("OES_texture_float");
        },

        /**********************************************************************************************/

        /**
         * Hide image
         * @param {Feature} featureData
         */
        hideImage: function(featureData) {
            var style = new FeatureStyle(featureData.feature.properties.style);
            style.fill = false;
            featureData.layer.modifyFeatureStyle(featureData.feature, style);
        },

        /**********************************************************************************************/

        /**
         * Show image
         * @param {Feature} featureData
         */
        showImage: function(featureData) {
            // Attach texture to style
            var targetStyle = new FeatureStyle(
                featureData.feature.properties.style
            );
            targetStyle.fill = true;
            featureData.layer.modifyFeatureStyle(
                featureData.feature,
                targetStyle
            );
        },

        /**********************************************************************************************/

        /**
         * Remove image from renderer
         * @param {Feature} featureData
         * @fires Mizar#image:removed
         */
        removeImage: function(featureData) {
            // Publish event that the image of the given feature will be removed
            mizarAPI.publish(Constants.EVENT_MSG.IMAGE_REMOVED, featureData);
            if (featureData.isFits) {
                removeFitsFromRenderer(featureData);
                $("#quicklookFits").removeClass("selected");
            } else {
                if (featureData.layer.getType() === "OpenSearch") {
                    featureData.layer.removeQuicklook();
                } else {
                    var style = featureData.feature.properties.style;
                    style.fill = false;
                    style.fillTextureUrl = null;
                    featureData.layer.modifyFeatureStyle(
                        featureData.feature,
                        style
                    );
                }
                $("#quicklook").removeClass("selected");
                $("#quicklookWms").removeClass("selected");
            }
            mizarAPI.getActivatedContext().refresh();
        },

        /**********************************************************************************************/

        /**
         *    Start download of texture
         *    @param {Feature} featureData
         *    @fires Mizar#image:added
         */
        addImage: function(featureData) {
            var feature = featureData.feature;
            // Set fill to true while loading
            var style = new FeatureStyle(feature.properties.style);
            var url = null;
            style.fill = true;

            // Publish event that the image for the given feature will be loaded
            mizarAPI.publish(Constants.EVENT_MSG.IMAGE_ADDED, featureData);

            if (featureData.isFits) {
                url = feature.services.download.url;
                this.computeFits(featureData, url);
                $("#quicklookFits").addClass("selected");
            } else {
                style.fill = true;
                if (featureData.isWms) {
                    url = feature.properties.services.browse.layer.getUrl();
                } else {
                    url = feature.properties.quicklook;
                }
                this.computeQuicklook(featureData, url);
                // For DEBUG : 'upload/ADP_WFI_30DOR_RGB_V1.0_degraded.jpg';
                if (featureData.isWms) {
                    $("#quicklookWms").addClass("selected");
                } else {
                    $("#quicklook").addClass("selected");
                }
            }
            featureData.layer.modifyFeatureStyle(feature, style);
            mizarAPI.getActivatedContext().refresh();
        },

        computeFits: computeFits,
        computeQuicklook: computeQuicklook,
        handleFits: handleFits,
        handleQuicklook: handleQuicklook,
        parseFits: parseFits
    };

    /**********************************************************************************************/
});

define('gw/Services/FitsHips',["../Utils/Constants"], function(Constants) {
    var mizarAPI;

    /**
     * Creates a fits layer
     * @param {Layer} layer
     * @fires Context#backgroundLayer:changed
     * @fires Context#backgroundLayer:added
     * @fires Context#layer:added
     * @fires Layer#visibility:changed
     */
    function _createFitsLayer(layer) {
        var isCreated;
        try {
            var selectedLayer = {
                name: layer.getName(),
                type: layer.getType(),
                format: "fits",
                hipsMetadata: layer.getHipsMetadata()
            };
            var fitsLayer = mizarAPI.LayerFactory.create(selectedLayer);
            fitsLayer.ID = layer.getID();
            if (layer.isBackground()) {
                mizarAPI
                    .getActivatedContext()
                    ._getGlobe()
                    .setBaseImagery(fitsLayer);
            } else {
                mizarAPI
                    .getActivatedContext()
                    ._getGlobe()
                    .addLayer(fitsLayer);
            }
            fitsLayer.setVisible(true);
            isCreated = true;
            mizarAPI
                .getActivatedContext()
                .publish(
                    Constants.EVENT_MSG.LAYER_BACKGROUND_CHANGED,
                    fitsLayer
                );
        } catch (e) {
            isCreated = false;
        }
        return isCreated;
    }

    function _removeFitsLayer(ID) {
        var isRemoved;
        var layer = mizarAPI.getActivatedContext().getLayerByID(ID);
        if (layer && layer.getFormat() !== "fits") {
            mizarAPI
                .getActivatedContext()
                ._getGlobe()
                .setBaseImagery(layer);
            isRemoved = true;
        } else {
            isRemoved = false;
        }
        return isRemoved;
    }

    return {
        init: function(m, options) {
            mizarAPI = m;
        },

        createFitsLayer: _createFitsLayer,
        removeFitsLayer: _removeFitsLayer
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Triangle Object use in Histogram classe
 */
define('gw/Services/Triangle',[], function() {
    /**************************************************************************************************************/

    /**
     *    Test returning true if p1 and p2 are both lying on the same side of a-b, false otherwise
     */
    function _sameSide(p1, p2, a, b) {
        var temp1 = [];
        var temp2 = [];
        var temp3 = [];
        var cp1 = [];
        var cp2 = [];
        vec3.cross(
            vec3.subtract(b, a, temp1),
            vec3.subtract(p1, a, temp2),
            cp1
        );
        vec3.cross(temp1, vec3.subtract(p2, a, temp3), cp2);
        return vec3.dot(cp1, cp2) >= 0;
    }

    /**************************************************************************************************************/

    /**
     *    Private function to check if point is inside the given triangle
     *    If the point was on the same side of a-b as c and is also on the same side of b-c as a and on the same side of c-a as b, then it is in the triangle
     */
    function _pointInTriangle(p, a, b, c) {
        return (
            _sameSide(p, a, b, c) &&
            _sameSide(p, b, a, c) &&
            _sameSide(p, c, a, b)
        );
    }

    /**************************************************************************************************************/

    /**
     *    Isoscele triangle object for thresholds manipulation
     *
     *    @param a Pointer of threshold pointing on histogram
     *    @param b Isoscele point 1
     *    @param c Isoscele point 2
     */
    var Triangle = function(a, b, c) {
        this.initA = a.slice(0);
        this.initB = b.slice(0);
        this.initC = c.slice(0);

        this.a = a; // Pointer to histogram
        this.b = b; // Isoscele point 1
        this.c = c; // Isoscele point 2

        this.dragging = false;
        this.hover = false;
        this.halfWidth = Math.abs((c[0] - b[0]) / 2);
    };

    /**************************************************************************************************************/

    /**
     *    Reset to initial position
     */
    Triangle.prototype.reset = function() {
        this.a = this.initA.slice(0);
        this.b = this.initB.slice(0);
        this.c = this.initC.slice(0);
    };

    /**************************************************************************************************************/

    /**
     *    Test if triangle contains the given point
     *    @param {Array} p point
     */
    Triangle.prototype.contains = function(p) {
        return _pointInTriangle(p, this.a, this.b, this.c);
    };

    /**************************************************************************************************************/

    /**
     * Draw the triangle
     * @param ctx the context
     * @param options
     *      <ul>
     *          <li>draggingColor : color used when moving triangle</li>
     *          <li>noDraggingColor : color used when triangle do not move</li>
     */
    Triangle.prototype.draw = function(ctx, options) {
        if (!options) {
            options = {};
        }
        if (this.dragging) {
            ctx.fillStyle = options.draggingColor | "#FF0";
        } else {
            ctx.fillStyle = options.noDraggingColor | "#F00";
        }

        ctx.beginPath();
        ctx.moveTo(this.a[0], this.a[1]);
        ctx.lineTo(this.b[0], this.b[1]);
        ctx.lineTo(this.c[0], this.c[1]);
        ctx.closePath();
        ctx.fill();

        if (!this.dragging && this.hover) {
            ctx.strokeStyle = options.draggingColor | "#FF0";
            ctx.stroke();
        }
    };

    /**************************************************************************************************************/

    /**
     *    Modify triangle's position by the given "pointer" point
     *    (could be modified only by X-axis)
     *    @param {Array} point point
     */
    Triangle.prototype.modifyPosition = function(point) {
        this.a[0] = point[0];
        this.b[0] = point[0] - this.halfWidth;
        this.c[0] = point[0] + this.halfWidth;
    };

    /**************************************************************************************************************/

    return Triangle;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Histogram module : create histogram to the given image
 */
define('gw/Services/HistogramCore',["./Triangle"], function(Triangle) {
    // Private variables
    var nbBins;
    var self;

    var canvas;
    var hist = [];
    var hmax; // histogram max to scale in image space

    // Origin histogram point
    var originX;
    var originY;
    var hwidth;
    var paddingBottom;
    var triangleHalfWidth;

    /**************************************************************************************************************/

    /**
     * Get mouse position on canvas
     * @param {HTMLElement} canvas
     * @param {Event} evt
     * @returns {{x: number, y: number}}
     */
    function _getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    function _handleMouseDown(evt) {
        var mousePos = _getMousePos(canvas, evt);

        if (self.minThreshold.contains([mousePos.x, mousePos.y, 0])) {
            self.minThreshold.dragging = true;
            self.minThreshold.draw(self.ctx);
        }

        if (self.maxThreshold.contains([mousePos.x, mousePos.y, 0])) {
            self.maxThreshold.dragging = true;
            self.maxThreshold.draw(self.ctx);
        }
    }

    /**************************************************************************************************************/

    function _handleMouseUp(evt) {
        self.minThreshold.dragging = false;
        self.maxThreshold.dragging = false;

        if (self.onUpdate) {
            var min = self.getHistValue(self.minThreshold.a);
            var max = self.getHistValue(self.maxThreshold.a);

            self.minThreshold.reset();
            self.maxThreshold.reset();

            self.onUpdate(min, max);
        }
    }

    /**************************************************************************************************************/

    function _handleMouseMove(evt) {
        var mousePos = _getMousePos(canvas, evt);

        self.ctx.clearRect(0.0, originY, canvas.width, paddingBottom);

        self.minThreshold.hover = self.minThreshold.contains([
            mousePos.x,
            mousePos.y,
            0
        ]);

        self.maxThreshold.hover = self.maxThreshold.contains([
            mousePos.x,
            mousePos.y,
            0
        ]);

        // Draw threshold controls
        if (
            self.minThreshold.dragging &&
            mousePos.x >= self.minThreshold.initA[0] &&
            mousePos.x < self.maxThreshold.a[0]
        ) {
            self.minThreshold.modifyPosition([
                mousePos.x,
                self.minThreshold.a[1]
            ]);
        }

        if (
            self.maxThreshold.dragging &&
            mousePos.x <= self.maxThreshold.initA[0] &&
            mousePos.x > self.minThreshold.a[0]
        ) {
            self.maxThreshold.modifyPosition([
                mousePos.x,
                self.maxThreshold.a[1]
            ]);
        }
        self.drawThresholdControls();

        // Don't draw histogram values if the mouse is out of histogram canvas
        if (
            mousePos.y > canvas.height ||
            mousePos.y < 0.0 ||
            mousePos.x > originX + nbBins ||
            mousePos.x < originX
        ) {
            return;
        }

        // Draw the text indicating the histogram value on mouse position
        self.ctx.font = "8pt Calibri";
        self.ctx.fillStyle = "yellow";
        var thresholdValue = self.getHistValue([mousePos.x, mousePos.y]);
        self.ctx.fillText(
            thresholdValue,
            canvas.width / 2 - 15.0,
            originY + paddingBottom
        );
        // Draw a tiny line indicating the mouse position on X-axis
        self.ctx.fillRect(mousePos.x, originY, 1, 2);
    }

    /**************************************************************************************************************/

    /**
     * Get histogram value from the given X-position on canvas
     * @param {Array} position
     * @returns {number} value
     */
    function getHistValue(position) {
        return (
            Math.floor(
                (((position[0] - originX) / 256.0) *
                    (this.image.tmax - this.image.tmin) +
                    this.image.tmin) *
                    Math.pow(10, this.accuracy)
            ) / Math.pow(10, this.accuracy)
        );
    }

    /**************************************************************************************************************/

    /**
     * Init Thresholds by creating to
     */
    function initThresholds() {
        originY = canvas.height - paddingBottom;
        hwidth =
            nbBins + originX > canvas.width ? canvas.width : nbBins + originX;

        this.minThreshold = new Triangle(
            [originX, originY + 1, 0],
            [originX - triangleHalfWidth, originY + paddingBottom - 1, 0],
            [originX + triangleHalfWidth, originY + paddingBottom - 1, 0]
        );

        this.maxThreshold = new Triangle(
            [hwidth, originY + 1, 0],
            [hwidth - triangleHalfWidth, originY + paddingBottom - 1, 0],
            [hwidth + triangleHalfWidth, originY + paddingBottom - 1, 0]
        );
    }

    /**************************************************************************************************************/

    function drawThresholdControls() {
        this.minThreshold.draw(this.ctx, {});
        this.maxThreshold.draw(this.ctx, {});
    }

    /**************************************************************************************************************/

    /**
     * Draw histogram
     * @param {Object} options
     *        <ul>
     *            <li>color: inside graph color</li>
     *        </ul>
     *
     */
    function drawHistogram(options) {
        if (options == null) {
            options = {};
        }
        this.ctx.fillStyle = options.color || "blue";
        for (var i = 0; i < hist.length; i++) {
            // Scale to y-axis height
            var rectHeight = (hist[i] / hmax) * originY;
            this.ctx.fillRect(originX + i, originY, 1, -rectHeight);
        }
    }

    /**************************************************************************************************************/

    /**
     *    Draw histogram axis
     */
    function drawAxes() {
        var leftY, rightX;
        leftY = 0;
        rightX = originX + hwidth;
        // Draw y axis.
        this.ctx.beginPath();
        this.ctx.moveTo(originX, leftY);
        this.ctx.lineTo(originX, originY);

        // Draw x axis.
        this.ctx.moveTo(originX, originY);
        this.ctx.lineTo(rightX, originY);

        // Define style and stroke lines.
        this.ctx.closePath();
        this.ctx.strokeStyle = "#fff";
        this.ctx.stroke();
    }

    /**************************************************************************************************************/

    /**
     *    Draw transfer function(linear, log, asin, sqrt, sqr)
     *    @param {Object} options
     *        <ul>
     *            <li>color: transfer stroke color</li>
     *        </ul>
     */
    function drawTransferFunction(options) {
        // Draw transfer functions
        // "Grey" colormap for now(luminance curve only)
        if (options == null) {
            options = {};
        }
        this.ctx.fillStyle = options.color || "red";
        for (var i = 0; i < nbBins; i++) {
            var value = i;
            var posX = originX + value;

            var scaledValue;
            switch (this.image.transferFn) {
            case "linear":
                scaledValue = (value / nbBins) * originY;
                break;
            case "log":
                scaledValue =
                        (Math.log(value / 10.0 + 1) /
                            Math.log(nbBins / 10.0 + 1)) *
                        originY;
                break;
            case "sqrt":
                scaledValue =
                        (Math.sqrt(value / 10.0) / Math.sqrt(nbBins / 10.0)) *
                        originY;
                break;
            case "sqr":
                scaledValue =
                        (Math.pow(value, 2) / Math.pow(nbBins, 2)) * originY;
                break;
            case "asin":
                scaledValue =
                        (Math.log(value + Math.sqrt(Math.pow(value, 2) + 1.0)) /
                            Math.log(
                                nbBins + Math.sqrt(Math.pow(nbBins, 2) + 1.0)
                            )) *
                        originY;
                break;
            default:
                break;
            }

            if (!this.image.inverse) {
                scaledValue = originY - scaledValue;
            }
            this.ctx.fillRect(posX, scaledValue, 1, 1);
        }
    }

    /**************************************************************************************************************/

    /**
     *    Draw the histogram in canvas
     */
    function draw() {
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        this.drawHistogram();
        this.drawTransferFunction();
        this.drawAxes();
        this.drawThresholdControls();
    }

    /**************************************************************************************************************/

    /**
     *    TODO : create different module
     *    Compute histogram values
     */
    function compute() {
        var image = this.image;
        // Initialize histogram
        hist = new Array(nbBins);
        for (var i = 0; i < hist.length; i++) {
            hist[i] = 0;
        }

        // Compute histogram
        hmax = Number.MIN_VALUE;
        for (i = 0; i < image.pixels.length; i++) {
            var val = image.pixels[i];

            // Skip NaN
            if (isNaN(val)) {
                continue;
            }
            // Take only values which belongs to the interval [tmin,tmax]
            if (val < image.tmin) {
                continue;
            }
            if (val >= image.tmax) {
                continue;
            }

            // Scale to [0,255]
            var bin = Math.floor(
                (nbBins * (val - image.tmin)) / (image.tmax - image.tmin)
            );
            hist[bin]++;

            // Compute histogram max value
            if (hist[bin] > hmax) {
                hmax = hist[bin];
            }
        }

        // Logarithmic scale for better layout
        for (i = 0; i < hist.length; i++) {
            hist[i] = Math.log(1 + hist[i]);
        }
        hmax = Math.log(1 + hmax);
    }

    /**************************************************************************************************************/

    /**
     *    Set image
     *    @param {Image} image
     */
    function setImage(image) {
        this.image = image;
    }

    function getCanvas() {
        return canvas;
    }

    /**************************************************************************************************************/

    return {
        /**
         *    Histogram contructor
         *    @param options Histogram options
         *        <ul>
         *            <li>canvas: The canvas context where to draw Histogram</li>
         *            <li>image: The image which is represented by current histogram(required)</li>
         *            <li>nbBins: Number of bins, representing the sampling of histogram(optional)</li>
         *            <li>onUpdate: On update callback
         *            <li>accuracy: The accuracy of histogram(numbers after floating point)
         *            <li>paddingBottom: space at the bottom
         *            <li>triangleHalfWidth: half width of the triangle to draw
         *            <li>originX
         *        </ul>
         */
        init: function(options) {
            this.image = options.image;
            this.onUpdate = options.onUpdate;
            this.accuracy = options.accuracy || 6;

            self = this;
            nbBins = options.nbBins || 256;
            paddingBottom = options.paddingBottom || 15.0;
            originX = options.originX || 5.0;
            triangleHalfWidth = options.triangleHalfWidth || 5;

            // Init canvas
            canvas = document.getElementById(options.canvas);
            canvas.addEventListener("mousemove", _handleMouseMove);

            // Handle threshold controller selection
            canvas.addEventListener("mousedown", _handleMouseDown);

            // Update histogram on mouseup
            canvas.addEventListener("mouseup", _handleMouseUp);
            this.ctx = canvas.getContext("2d");

            this.initThresholds();
        },
        initThresholds: initThresholds,
        getHistValue: getHistValue,
        drawThresholdControls: drawThresholdControls,
        drawHistogram: drawHistogram,
        drawAxes: drawAxes,
        drawTransferFunction: drawTransferFunction,
        draw: draw,
        compute: compute,
        setImage: setImage,
        getCanvas: getCanvas
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 *    ImageProcessing module
 */
define('gw/Services/ImageProcessingCore',["jquery", "../Renderer/FeatureStyle", "jquery.ui"], function(
    $,
    FeatureStyle
) {
    /**************************************************************************************************************/

    var feature;
    var layer;
    var disable;
    var unselect;
    var $dialog;
    var histogramElement;
    var cutOutElement;

    /**************************************************************************************************************/

    /**
     *    Toggle visibility of dialog
     */
    function toggle() {
        if ($dialog.dialog("isOpen")) {
            $dialog.dialog("close");
        } else {
            $dialog.dialog("open");
        }
    }

    /**************************************************************************************************************/

    /**
     *    Remove view
     */
    function remove() {
        if (unselect) {
            unselect();
        }

        if (disable) {
            disable();
        }

        if (histogramElement) {
            histogramElement.remove();
        }

        $dialog.remove();
    }

    /**************************************************************************************************************/

    /**
     *    Set data to process
     *
     *    @param selectedData Object containing feature and layer extracted by <PickingManager>
     */
    function setData(selectedData) {
        if (
            feature &&
            feature.properties.identifier ===
                selectedData.feature.properties.identifier
        ) {
            this.toggle();
        } else {
            if (!$dialog.dialog("isOpen")) {
                this.toggle();
            }
        }

        feature = selectedData.feature;
        layer = selectedData.layer;

        if (selectedData.feature.services) {
            cutOutElement.setUrl(selectedData.feature.services.download.url);
        } /** else {
                // TODO : disable cutOutElement if feature's url isn't defined
            }*/

        var image = selectedData.feature.properties.style.uniformValues;
        if (!image) {
            $dialog
                .find(".histogramContent")
                .children("div")
                .fadeOut(function() {
                    $(this)
                        .siblings("p")
                        .fadeIn();
                });
        } else {
            this.setImage(image);
        }
    }

    /**************************************************************************************************************/

    /**
     * Remove passed feature
     *
     * @param {Feature} data
     */
    function removeData(data) {
        if (
            feature &&
            data.feature.properties.identifier === feature.properties.identifier
        ) {
            if (this.isOpened()) {
                this.toggle();
            }
            $dialog
                .find(".histogramContent")
                .children("div")
                .fadeOut(function() {
                    $(this)
                        .siblings("p")
                        .fadeIn();
                });
            feature = null;
            layer = null;
        }
    }

    /**************************************************************************************************************/

    /**
     * Set image on the Histogram element
     *
     * @param image
     */
    function setImage(image) {
        histogramElement.setImage(image);
        if (image.url) {
            cutOutElement.setUrl(image.url);
        }

        $dialog
            .find(".histogramContent")
            .children("p")
            .fadeOut(function() {
                $(this)
                    .siblings("div")
                    .fadeIn();
            });
    }

    /**************************************************************************************************************/

    /**
     * Change shader callback
     *
     * @param contrast
     */
    function changeShaderCallback(contrast) {
        var targetStyle;
        if (contrast === "raw") {
            targetStyle = new FeatureStyle(feature.properties.style);
            targetStyle.fillShader = {
                fragmentCode: null,
                updateUniforms: null
            };
            layer.modifyFeatureStyle(feature, targetStyle);
        } else {
            targetStyle = new FeatureStyle(feature.properties.style);
            targetStyle.fillShader = {
                fragmentCode: this.image.fragmentCode,
                updateUniforms: this.image.updateUniforms
            };
            layer.modifyFeatureStyle(feature, targetStyle);
        }
    }

    /**************************************************************************************************************/

    /**
     * Check if ImageProcessing is opened
     */
    function isOpened() {
        return $dialog.dialog("isOpen");
    }

    /**************************************************************************************************************/

    return {
        /**
         *    Init ImageProcessingCore
         *
         *    @param options
         *        <ul>
         *            <li>feature: The feature to process
         *            <li>layer: The layer to which the feature belongs to
         *            <li>disable: Disable callback</li>
         *            <li>unselect: Unselect callback</li>
         *        </ul>
         *    @param {HTMLElement} $dl dialogElement
         *    @param {HTMLElement} $histoElmt histogramElement
         *    @param {HTMLElement} $cutOutElmt cutOutElement
         *
         */
        init: function(options, $dl, histoElmt, cutOutElmt) {
            if (options) {
                //this.id = options.id;
                feature = options.feature || null;
                layer = options.layer || null;

                // Callbacks
                disable = options.disable || null;
                unselect = options.unselect || null;
            }

            $dialog = $dl;
            histogramElement = histoElmt;
            cutOutElement = cutOutElmt;
        },

        setData: setData,
        setImage: setImage,
        toggle: toggle
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Utils/UtilsFits',["wcs"], function(wcs) {
    var UtilsFits = {};

    function createCoordinate(x, y) {
        var coordinate = wcs.pixelToCoordinate([x, y]);
        return [coordinate.ra, coordinate.dec];
    }

    /**
     *    Get GeoJson polygon coordinates representing fits using wcs data from header
     */
    UtilsFits.getPolygonCoordinatesFromFits = function(fits) {
        var hdu = fits.getHDU();
        var fitsData = hdu.data;

        // Create mapper
        var wcs = new WCS.Mapper(hdu.header);
        var coords = [];

        // Find coordinates of coming fits
        coords.push(createCoordinate(0, fitsData.height));
        coords.push(createCoordinate(fitsData.width, fitsData.height));
        coords.push(createCoordinate(fitsData.width, 0));
        coords.push(createCoordinate(0, 0));
        // Close the polygon
        coords.push(coords[0]);
        return coords;
    };

    return UtilsFits;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/Utils/UtilityFactory',[
    "./Constants",
    "./UtilsFits",
    "./Numeric",
    "./UtilsIntersection",
    "../Renderer/FeatureStyle"
], function(Constants, UtilsFits, Numeric, UtilsIntersection, FeatureStyle) {
    return {
        create: function(type, options) {
            var obj;
            switch (type) {
            case Constants.UTILITY.Fits:
                obj = UtilsFits;
                break;
            case Constants.UTILITY.Intersection:
                obj = UtilsIntersection;
                break;
            case Constants.UTILITY.Numeric:
                obj = Numeric;
                break;
            case Constants.UTILITY.CreateStyle:
                obj = new FeatureStyle(options);
                break;
            case Constants.UTILITY.FeatureStyle:
                obj = FeatureStyle;
                break;
            default:
                throw new RangeError(
                    "Cannot create the utility " + type,
                    "UtilityFactory.js"
                );
            }
            return obj;
        }
    };
});

var xmlToJSON = function () { this.version = "1.3.5"; var e = { mergeCDATA: !0, grokAttr: !0, grokText: !0, normalize: !0, xmlns: !0, namespaceKey: "_ns", textKey: "_text", valueKey: "_value", attrKey: "_attr", cdataKey: "_cdata", attrsAsObject: !0, stripAttrPrefix: !0, stripElemPrefix: !0, childrenAsArray: !0 }, t = new RegExp(/(?!xmlns)^.*:/), r = new RegExp(/^\s+|\s+$/g); return this.grokType = function (e) { return /^\s*$/.test(e) ? null : /^(?:true|false)$/i.test(e) ? "true" === e.toLowerCase() : isFinite(e) ? parseFloat(e) : e }, this.parseString = function (e, t) { return this.parseXML(this.stringToXML(e), t) }, this.parseXML = function (a, n) { for (var s in n) e[s] = n[s]; var l = {}, i = 0, o = ""; if (e.xmlns && a.namespaceURI && (l[e.namespaceKey] = a.namespaceURI), a.attributes && a.attributes.length > 0) { var c = {}; for (i; i < a.attributes.length; i++) { var u = a.attributes.item(i); m = {}; var p = ""; p = e.stripAttrPrefix ? u.name.replace(t, "") : u.name, e.grokAttr ? m[e.valueKey] = this.grokType(u.value.replace(r, "")) : m[e.valueKey] = u.value.replace(r, ""), e.xmlns && u.namespaceURI && (m[e.namespaceKey] = u.namespaceURI), e.attrsAsObject ? c[p] = m : l[e.attrKey + p] = m } e.attrsAsObject && (l[e.attrKey] = c) } if (a.hasChildNodes()) for (var y, d, m, h = 0; h < a.childNodes.length; h++)4 === (y = a.childNodes.item(h)).nodeType ? e.mergeCDATA ? o += y.nodeValue : l.hasOwnProperty(e.cdataKey) ? (l[e.cdataKey].constructor !== Array && (l[e.cdataKey] = [l[e.cdataKey]]), l[e.cdataKey].push(y.nodeValue)) : e.childrenAsArray ? (l[e.cdataKey] = [], l[e.cdataKey].push(y.nodeValue)) : l[e.cdataKey] = y.nodeValue : 3 === y.nodeType ? o += y.nodeValue : 1 === y.nodeType && (0 === i && (l = {}), d = e.stripElemPrefix ? y.nodeName.replace(t, "") : y.nodeName, m = xmlToJSON.parseXML(y), l.hasOwnProperty(d) ? (l[d].constructor !== Array && (l[d] = [l[d]]), l[d].push(m)) : (e.childrenAsArray ? (l[d] = [], l[d].push(m)) : l[d] = m, i++)); else o || (e.childrenAsArray ? (l[e.textKey] = [], l[e.textKey].push(null)) : l[e.textKey] = null); if (o) if (e.grokText) { var x = this.grokType(o.replace(r, "")); null !== x && void 0 !== x && (l[e.textKey] = x) } else e.normalize ? l[e.textKey] = o.replace(r, "").replace(/\s+/g, " ") : l[e.textKey] = o.replace(r, ""); return l }, this.xmlToString = function (e) { try { return e.xml ? e.xml : (new XMLSerializer).serializeToString(e) } catch (e) { return null } }, this.stringToXML = function (e) { try { var t = null; return window.DOMParser ? t = (new DOMParser).parseFromString(e, "text/xml") : (t = new ActiveXObject("Microsoft.XMLDOM"), t.async = !1, t.loadXML(e), t) } catch (e) { return null } }, this }.call({}); "undefined" != typeof module && null !== module && module.exports ? module.exports = xmlToJSON : "function" == typeof define && define.amd && define('xmltojson',[],function () { return xmlToJSON });
/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/AbstractLayer',[
    "jquery",
    "underscore-min",
    "../Utils/Event",
    "moment",
    "../Time/Time",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "../Utils/UtilityFactory",
    "xmltojson",
    "../Error/NetworkError",
    "../Utils/Proxy"
], function(
    $,
    _,
    Event,
    Moment,
    Time,
    Utils,
    Constants,
    ErrorDialog,
    UtilityFactory,
    XmlToJson,
    NetworkError,
    Proxy
) {
    const DEFAULT_ICON =
        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMBQkVBRMIQtMAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAvklEQVQY012QMWpCURBFz3yfG7CIwSatpLGwsJJsQEHssr2UttapkkK0zRJEFPKLj5UYPGme8vgDt5l7uNwZKEYNdaZO1FR6VQkBT8AbMAGe1e7dTwXUB8bAFPgF9sBWPUXENbWgBTAELkCTw7bqMdR5kTQCehlogB/gE/iqcs9OVhT9I8v7EZU6UJfqh3pWa3WlvqsvakoRcVOPwCYnvQI1sM67Q0T8JYAWvAEOwDewj4jr4z0teJdf84AA/gF1uG92uhcfoAAAAABJRU5ErkJggg==";

    /**
     * AbstractLayer configuration
     * @typedef {Object} AbstractLayer.configuration
     * @property {string} [name=""] - Layer name
     * @property {string} [attribution=""] - Attribution
     * @property {string} [copyrightUrl=""] - Copyright URL
     * @property {string} [ack=""] - ack
     * @property {string} [icon=a default image] - An icon to represent the layer
     * @property {string} [description=""] - A description
     * @property {boolean} [visible=true] - A boolean flag to display the layer
     * @property {Object} [properties={}] properties
     * @property {boolean} [pickable=false] - Sets to true to make the layer pickable
     * @property {boolean} [service=[]] - List of services related to the layer
     * @property {GEOMETRY} dataType - the data type for vector layers
     * @property {boolean} [background = false] -Set to true to render the layer as a background
     * @property category
     * @param {Crs} coordinateSystem
     * @param {string} [format=""]
     * @param {string} [baseUrl=""]
     * @param {boolean} [deletable=""]
     * @param {Array} [color= a random color]
     * @param {float} [opacity=1.0] - An opacity value
     * @param {FeatureStyle} [style]
     * @param {Array} [services=[]}
     * @param {layerCallback} callback - A callback that transfoms data.
     */

    /**
     * Time configuration
     * @typedef {Object} Time.configuration
     * @property {date} date - Current date
     * @property {string} display - Current date as text for display
     * @property {Time.period.configuration}  - Period
     */

    /**
     * Time period configuration
     * @typedef {Object} Time.period.configuration
     * @property {date} from - start date
     * @property {date} to - stop date
     */

    /**
     * This callback allows to transform FeatureCollection from a GeoJson.
     * @callback layerCallback
     * @param {data} FeatureCollection
     */

    /**
     * @name AbstractLayer
     * @class
     *   Abstract class for creating layer.
     * @augments Event
     * @param {LAYER} type - layer type
     * @param {AbstractLayer.configuration} options - Layer Configuration
     * @constructor
     * @implements {Layer}
     */
    var AbstractLayer = function(type, options) {
        Event.prototype.constructor.call(this, options);

        this.globe = null;
        this.options = options || {};
        this.ID = "URN:Mizar:Layer:" + _.uniqueId(this.constructor.name + ":");
        this.name = this.options.name != null ? this.options.name : "";
        this.attribution = this.options.attribution || "";
        this.copyrightUrl = this.options.copyrightUrl || "";
        this.ack = this.options.ack || "";
        this.description = this.options.description || "";
        this.visible = this.options.visible || false;
        this.properties = this.options.properties || {};
        this.services = this.options.services || [];
        this.type = type;
        this.pickable = this.options.pickable || false;
        this.dataType = this.options.dataType || "";
        this.background = options.background || false;
        this.category = this.options.background
            ? "background"
            : this.options.category;
        this.coordinateSystem = options.coordinateSystem;
        this.format = this.options.format || "";
        this.baseUrl = this.options.baseUrl || "";
        this.deletable = this.options.deletable || false;
        this.dimension = this.options.dimension;
        this.callbackContext = null;
        this.linkedTo = this.options.linkedTo || "";
        this.servicesRunningOnCollection = [];
        this.servicesRunningOnRecords = {};
        this.vectorLayer = false;
        this.metadataAPI = this.options.metadataAPI
            ? this.options.metadataAPI
            : null;
        this.time = null;
        // Do we take DEM into account with this layer ?
        this.pickingNoDEM = this.options.pickingNoDEM
            ? this.options.pickingNoDEM
            : false;

        // Set if we need to auto fill the time travel range/step with auto discovered time values
        this.autoFillTimeTravel = this.options.autoFillTimeTravel
            ? this.options.autoFillTimeTravel
            : false;

        // Create style if needed
        this.style = _createStyle.call(this, this.options, this.icon);

        // Ensure that the attribution link will be opened in new tab
        if (
            this.attribution &&
            this.attribution.search("<a") >= 0 &&
            this.attribution.search("target=") < 0
        ) {
            this.attribution = this.attribution.replace(" ", " target=_blank ");
        }

        //this.services = _createAvailableServices(this.options);
        this.multiLayers = [];

        //cache to know which custom (e;g time, style, ...) Raster parameters are send
        this.imageLoadedAtTime = {};

        /**
         * Used to allow/deny http request
         * @type {boolean}
         */
        this.allowedHTTPRequest = true;
    };

    function _createAvailableServices(options) {
        var availableServices;
        if (options.hasOwnProperty("availableServices")) {
            availableServices = options.availableServices;
        } else {
            availableServices = [];
        }
        return availableServices;
    }

    /**
     * Create style
     * @param options
     * @returns {*}
     * @private
     */
    function _createStyle(options) {
        var style;
        if (options.hasOwnProperty("style")) {
            // we use style from layerDescription.
            style = UtilityFactory.create(
                Constants.UTILITY.CreateStyle,
                options.style
            );
        } else if (options.style === "FeatureStyle") {
            // use a previous definition
            style = options.style;
        } else {
            // Update layer color
            var color = _createColor.call(this, options);

            // Layer opacity must be in range [0, 1]
            var opacity = _createOpacity.call(this, options);

            // Create a default icon if needed.
            var icon = _createIcon.call(this, options);

            // Create a default zIndex if needed
            var zIndex = _createZIndex.call(this, options);

            // create default style
            style = UtilityFactory.create(Constants.UTILITY.CreateStyle, {
                rendererHint: "Basic",
                opacity: opacity,
                iconUrl: icon,
                fillColor: color,
                strokeColor: color,
                zIndex: zIndex
            });
        }
        return style;
    }

    function _createZIndex(options) {
        var zIndex;
        if (options.hasOwnProperty("zIndex")) {
            zIndex = options.zIndex;
        } else {
            zIndex = Constants.DISPLAY.DEFAULT_RASTER;
        }
        return zIndex;
    }

    function _createIcon(options) {
        var icon;
        if (options.hasOwnProperty("icon")) {
            icon = options.icon;
        } else {
            icon = DEFAULT_ICON;
        }
        return icon;
    }

    /**
     * Creates opacity
     * @param options
     * @returns {*}
     * @private
     */
    function _createOpacity(options) {
        var opacity;
        if (options.hasOwnProperty("opacity")) {
            opacity = options.opacity / 100.0;
        } else {
            opacity = 1.0;
        }
        return opacity;
    }

    /**
     * Creates color.
     * @param options
     * @returns {*}
     * @private
     */
    function _createColor(options) {
        var color;
        if (options.hasOwnProperty("color")) {
            color =
                options.color instanceof Array
                    ? options.color
                    : UtilityFactory.create(
                        Constants.UTILITY.FeatureStyle
                    ).fromStringToColor(options.color);
        } else {
            // Generate random color
            var rgb = Utils.generateColor();
            color = rgb.concat([1]);
        }
        return color;
    }

    /**************************************************************************************************************/

    Utils.inherits(Event, AbstractLayer);

    /**************************************************************************************************************/

    /**
     * Tests if the layer must be refreshed.
     * @param {string} param parameter
     * @param value value
     * @return {boolean} true when the layer must be refreshed otherwise false
     * @private
     */
    AbstractLayer.prototype._hasToBeRefreshed = function(param, value) {
        var mustBeRefreshed = false;
        if (param === "time" && this.containsDimension(param)) {
            var time = Time.parse(value);
            var isInTimeDimension = time.isInTimeDefinition(
                this.getDimensions().time.value
            );
            value = isInTimeDimension ? time.getDisplayValue() : null;
            this.allowedHTTPRequest = value !== null;
        } else if (param === "time") {
            mustBeRefreshed = false;
            return mustBeRefreshed;
        }
        if (this.imageLoadedAtTime[param] === undefined) {
            // this a new parameter, then we refresh
            mustBeRefreshed = true;
            this.imageLoadedAtTime[param] = value;
        } else if (this.imageLoadedAtTime[param] === value) {
            mustBeRefreshed = false;
        } else {
            mustBeRefreshed = true;
            this.imageLoadedAtTime[param] = value;
        }
        return mustBeRefreshed;
    };

    AbstractLayer.prototype.hasDimension = function() {
        return this.dimension != null;
    };

    AbstractLayer.prototype.getDimensions = function() {
        return this.dimension == null ? {} : this.dimension;
    };

    AbstractLayer.prototype.containsDimension = function(variable) {
        return this.hasDimension() && this.dimension[variable] != null;
    };

    /**
     * return short name
     * @function getShortName
     * @memberof AbstractLayer#
     * @return {string} Short name
     */
    AbstractLayer.prototype.getShortName = function() {
        var shortName = Utils.formatId(this.name);
        if (typeof shortName === "string") {
            shortName = shortName
                .replace(/[^a-z0-9\s]/gi, "")
                .replace(/[_\s]/g, "-");
        }

        return shortName;
    };

    /**************************************************************************************************************/

    /**
     * @function hasServicesRunningOnCollection
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.hasServicesRunningOnCollection = function() {
        return this.servicesRunningOnCollection.length > 0;
    };

    /**************************************************************************************************************/

    /**
     * @function postProcessDateTime
     * @memberof AbstractLayer#
     */
    /*        AbstractLayer.prototype.postProcessTime = function (time) {
         return time;
         };
         */
    /**************************************************************************************************************/

    /**
     * @function setDateTime
     * @memberof AbstractLayer#
     * @param {Time.configuration} time configuration
     */
    AbstractLayer.prototype.setTime = function(time) {
        this.time = time;
    };

    /**************************************************************************************************************/

    /**
     * @function forceRefresh
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.forceRefresh = function() {
        if (this.getGlobe()) {
            var tileManager = this.getGlobe().getTileManager();
            tileManager.updateVisibleTiles(this);
            this.getGlobe().refresh();
        }
    };

    /**
     * @function getServicesRunningOnCollection
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getServicesRunningOnCollection = function() {
        var layers = [];
        for (var layerIndex in this.servicesRunningOnCollection) {
            var layerID = this.servicesRunningOnCollection[layerIndex];
            var layer = this.callbackContext.getLayerByID(layerID);
            if (layer != null) {
                layers.push(layer);
            }
        }
        return layers;
    };

    /**
     * @function removeServicesRunningOnCollection
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.removeServicesRunningOnCollection = function() {
        for (var layerIndex in this.servicesRunningOnCollection) {
            var layerID = this.servicesRunningOnCollection[layerIndex];
            this.callbackContext.removeLayer(layerID);
        }
        return this.servicesRunningOnCollection.length === 0;
    };

    /**
     * @function hasServicesRunningOnRecords
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.hasServicesRunningOnRecords = function() {
        return Object.keys(this.servicesRunningOnRecords).length > 0;
    };

    /**
     * @function getServicesRunningOnRecords
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getServicesRunningOnRecords = function() {
        var layers = [];
        for (var featureIndex in this.servicesRunningOnRecords) {
            var featureID = this.servicesRunningOnRecords[featureIndex];
            layers = layers.concat(this.getServicesRunningOnRecord(featureID));
        }
        return layers;
    };

    /**
     * @function removeServicesRunningOnRecords
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.removeServicesRunningOnRecords = function() {
        for (var featureID in this.servicesRunningOnRecords) {
            this.removeServicesRunningOnRecord(featureID);
        }
        return Object.keys(this.servicesRunningOnRecords).length === 0;
    };

    /**
     * @function hasServicesRunningOnRecord
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.hasServicesRunningOnRecord = function(featureID) {
        return this.servicesRunningOnRecords.hasOwnProperty(featureID);
    };

    /**
     * @function getServicesRunningOnRecord
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getServicesRunningOnRecord = function(featureID) {
        var layers = [];
        if (this.hasServicesRunningOnRecord(featureID)) {
            var servicesForFeatureID = this.servicesRunningOnRecords[featureID];
            for (var layerIndex in servicesForFeatureID.layerIds) {
                var layerID = servicesForFeatureID[layerIndex];
                var layer = this.callbackContext.getLayerByID(layerID);
                if (layer != null) {
                    layers.push(layer);
                }
            }
        } else {
            // do nothing
        }
        return layers;
    };

    /**
     * @function addServicesRunningOnRecord
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.addServicesRunningOnRecord = function(
        featureID,
        layerIDs
    ) {
        var isAdded;
        if (
            featureID != null &&
            layerIDs != null &&
            !this.hasServicesRunningOnRecord(featureID)
        ) {
            var layersIDArray = Array.isArray(layerIDs) ? layerIDs : [layerIDs];
            this.servicesRunningOnRecords[featureID] = {
                layerIds: layersIDArray
            };
            isAdded = true;
        } else {
            isAdded = false;
        }
        return isAdded;
    };

    /**
     * @function removeServicesRunningOnRecord
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.removeServicesRunningOnRecord = function(
        featureID
    ) {
        var isRemoved;
        if (this.hasServicesRunningOnRecord(featureID)) {
            var servicesForFeatureID = this.servicesRunningOnRecords[featureID];
            for (var layerIndex in servicesForFeatureID.layerIds) {
                var layerID = servicesForFeatureID.layerIds[layerIndex];
                this.callbackContext.removeLayer(layerID);
            }
            delete this.servicesRunningOnRecords[featureID];
            isRemoved = true;
        } else {
            isRemoved = false;
        }
        return isRemoved;
    };

    /**
     * @function addServicesRunningOnCollection
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.addServicesRunningOnCollection = function(
        layerIDs
    ) {
        var isAdded;
        if (layerIDs != null) {
            var layersIDArray = Array.isArray(layerIDs) ? layerIDs : [layerIDs];
            this.servicesRunningOnCollection = this.servicesRunningOnCollection.concat(
                layersIDArray
            );
            isAdded = true;
        } else {
            isAdded = false;
        }
        return isAdded;
    };

    /**************************************************************************************************************/

    /**
     * Get getCapabilities url
     * @function getGetCapabilitiesUrl
     * @memberof AbstractLayer#
     * @return {string} url
     */
    AbstractLayer.prototype.getGetCapabilitiesUrl = function() {
        return this.getCapabilitiesUrl;
    };

    /**************************************************************************************************************/

    /**
     * @function getMetadataAPI
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getMetadataAPI = function() {
        return this.metadataAPI;
    };

    /**
     * @function getGlobe
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getGlobe = function() {
        return this.globe;
    };

    /**
     * @function getID
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getID = function() {
        return this.ID;
    };

    /**
     * @function getName
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getName = function() {
        return this.name;
    };

    /**
     * @function getInformationType
     * @memberof AbstractLayer#
     * @abstract
     */
    AbstractLayer.prototype.getInformationType = function() {
        throw new SyntaxError(
            "getInformationType not implemented",
            "AbstractLayer.js"
        );
    };

    /**
     * @function getAttribution
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getAttribution = function() {
        return this.attribution;
    };

    /**
     * @function getCopyrightUrl
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getCopyrightUrl = function() {
        return this.copyrightUrl;
    };

    /**
     * @function getAck
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getAck = function() {
        return this.ack;
    };

    /**
     * @function getDescription
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getDescription = function() {
        return this.description;
    };

    /**
     * @function isVisible
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isVisible = function() {
        return this.visible;
    };

    /**
     * @function setOnTheTop
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.setOnTheTop = function() {
        var manager = this.getGlobe().getRendererManager();
        manager.setSelectedRasterBucket(this);
    };

    /**
     * @function setVisible
     * @memberof AbstractLayer#
     * @throws {TypeError} - The parameter of setVisible should be a boolean
     */
    AbstractLayer.prototype.setVisible = function(arg) {
        if (typeof arg === "boolean") {
            if (this.visible !== arg && this.getGlobe().attributionHandler) {
                this.getGlobe().attributionHandler.toggleAttribution(this);
            }
            this.visible = arg;

            if (!this.isBackground() && this.visible) {
                this.setOnTheTop();
            }

            var ctxTime = this.callbackContext.getTime();
            if (ctxTime !== this.time) {
                this.setTime(ctxTime);
            }

            // Manage autoFillTimeTravel
            if (this.autoFillTimeTravel === true) {
                if (this.visible === true) {
                    //add !
                    if (this.callbackContext.timeTravelService) {
                        this.callbackContext.timeTravelService.update(
                            this.timeTravelValues
                        );
                    }
                } else {
                    // Remove
                    if (this.callbackContext.timeTravelService) {
                        this.callbackContext.timeTravelService.update({
                            remove: { ID: this.ID }
                        });
                    }
                }
            }

            this.getGlobe()
                .getRenderContext()
                .requestFrame();
            this.publish(Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED, this);
        } else {
            throw new TypeError(
                "the parameter of visible should be a boolean",
                "AbstractLayer.js"
            );
        }
    };

    /**
     * @function getOpacity
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getOpacity = function() {
        return this.getStyle().getOpacity();
    };

    /**
     * @function setOpacity
     * @memberof AbstractLayer#
     * @throws {RangeError} opacity - opacity value should be a value in [0..1]
     */
    AbstractLayer.prototype.setOpacity = function(arg) {
        var style = this.getStyle();
        style.setOpacity(arg);
        this.getGlobe()
            .getRenderContext()
            .requestFrame();
        this.publish(Constants.EVENT_MSG.LAYER_OPACITY_CHANGED, this);
    };

    /**
     * @function getProperties
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getProperties = function() {
        return this.properties;
    };

    /**
     * @function getType
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getType = function() {
        return this.type;
    };

    /**
     * @function isPickable
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isPickable = function() {
        return this.pickable;
    };

    /**
     * @function isType
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isType = function(type) {
        return this.type === type;
    };

    /**
     * @function getServices
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getServices = function() {
        return this.services;
    };

    /**
     * @function getCoordinateSystem
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getCoordinateSystem = function() {
        return this.coordinateSystem;
    };

    /**
     * @function isAttached
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isAttached = function() {
        return !this.isDetached;
    };

    /**
     * @function isDetached
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isDetached = function() {
        return this.globe == null;
    };

    /**
     * @function _attach
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype._attach = function(g) {
        this.globe = g;
        if (
            this.attribution &&
            this.globe.attributionHandler &&
            this.isVisible()
        ) {
            this.globe.attributionHandler.addAttribution(this);
        }
    };

    /**
     * @function _detach
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype._detach = function() {
        if (this.attribution && this.globe.attributionHandler) {
            this.globe.attributionHandler.removeAttribution(this);
        }
        this.globe = null;
    };

    /**
     * @function getBaseUrl
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getBaseUrl = function() {
        return this.baseUrl;
    };

    /**
     * @function getDataType
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getDataType = function() {
        return this.dataType;
    };

    /**
     * @function getFormat
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getFormat = function() {
        return this.format;
    };

    /**
     * @function isDeletable
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isDeletable = function() {
        return this.deletable;
    };

    /**
     * @function getStyle
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getStyle = function() {
        return this.style;
    };

    /**
     * Sets the vector layer style.
     * @function setStyle
     * @memberof AbstractLayer#
     * @param {FeatureStyle} arg Feature style
     */
    AbstractLayer.prototype.setStyle = function(arg) {
        this.style = arg;
    };

    /**
     * @function isBackground
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isBackground = function() {
        return this.background;
    };

    /**
     * @function isVectorLayer
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isVectorLayer = function() {
        return this.vectorLayer;
    };

    /**
     * Decrypt time range to generate time travel informations
     * @function generateTimeTravel
     * @param {string} timeDetails Details of time range
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.generateTimeTravel = function(timeDetails) {
        if (timeDetails) {
            // In a general case, timeDetails.value could have this shape:
            //  val1,val2,min1/max1/step1,val3,min2/max2/step2
            var timesDefinition = timeDetails.value.split(",");
            var distinctValues = []; // records the distinct values : val1,val2,val3
            var sampleValues = []; // records the samples values : min1/max1/step1,min2/max2/step2
            var timeDefinition;

            // We need to iter because it is possible that we have a mix of distinct values and sample values
            for (var i = 0; i < timesDefinition.length; i++) {
                timeDefinition = timesDefinition[i].trim();
                if (Time.isDistinctValue(timeDefinition)) {
                    distinctValues.push(timeDefinition);
                } else if (Time.isSampling(timeDefinition)) {
                    sampleValues.push(timeDefinition);
                } else {
                    ErrorDialog.open(Constants.LEVEL.WARNING, "Case not handle by Mizar for timeDefinition "+timeDefinition);
                }
            }
            // Add distinct values in time travel
            if (distinctValues.length > 0) {
                this.timeTravelValues = {
                    add: {
                        enumeratedValues: distinctValues,
                        ID: this.ID
                    }
                };
            }

            // Add sample values in time travel
            if (sampleValues.length > 0) {
                var start, end, step, tmpArray, sampleDefinition;
                for (i = 0; i < sampleValues.length; i++) {
                    sampleDefinition = sampleValues[i];
                    tmpArray = sampleDefinition.split("/");
                    start = Moment(tmpArray[0]);
                    end = Moment(tmpArray[1]);
                    step = Time.timeResolution(tmpArray[2]);
                    this.timeTravelValues = {
                        add: {
                            start: start,
                            end: end,
                            stepKind: step.unit,
                            stepValue: step.step,
                            ID: this.ID
                        }
                    };
                }
            }
        }
    };

    return AbstractLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/Layer/AbstractVectorLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "../Utils/Constants",
    "../Renderer/FeatureStyle"
], function(Utils, AbstractLayer, Constants, FeatureStyle) {
    /**
     * AbstractVectorLayer layer configuration
     * @typedef {AbstractVectorLayer.configuration} AbstractLayer.vector_configuration
     * @property {string} url - the url of json data to load when attaching to globe
     * @property {int} [minLevel = 0] - minimum rendering level depending on tile level
     * @property {int} [maxLevel = 15] - maximum rendering level depending on tile level
     * @property {function} [callback] - the callback function called when data are loaded. Data loaded are passed in parameter of the function.
     */
    /**
     * @name AbstractVectorLayer
     * @class
     *    Create a layer to display vector data in GeoJSON format.
     * @augments AbstractLayer
     * @param {LAYER} type - the type of the layer
     * @param {AbstractVectorLayer.configuration} options - Configuration properties for the AbstractVectorLayer
     * @constructor
     * @implements {VectorLayer}
     */
    var AbstractVectorLayer = function(type, options) {
        this.zIndex = options.zIndex || Constants.DISPLAY.DEFAULT_VECTOR;
        AbstractLayer.prototype.constructor.call(this, type, options);

        this.vectorLayer = true;
        this.url = options.url;
        this.draw = false;

        if (options && options.callback) {
            this.callback = options.callback;
        } else {
            this.callback = null;
        }

        this.minLevel =
            options && options.hasOwnProperty("minLevel")
                ? options.minLevel
                : 0;
        this.maxLevel =
            options && options.hasOwnProperty("maxLevel")
                ? options.maxLevel
                : 21;

        this.features = [];
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, AbstractVectorLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof AbstractVectorLayer#
     */
    AbstractVectorLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.VECTOR;
    };

    /**
     * Returns the min level for which the vector is displayed.
     * @function getMinLevel
     * @memberof AbstractVectorLayer#
     * @returns {int} Returns the min level for which the vector is displayed.
     */
    AbstractVectorLayer.prototype.getMinLevel = function() {
        return this.minLevel;
    };

    /**
     * Returns the max level for which the vector is not displayed.
     * @function getMaxLevel
     * @memberof AbstractVectorLayer#
     * @returns {int} Returns the max level for which the vector is not displayed.
     */
    AbstractVectorLayer.prototype.getMaxLevel = function() {
        return this.maxLevel;
    };

    /**
     * @function getUrl
     * @memberof AbstractVectorLayer#
     */
    AbstractVectorLayer.prototype.getUrl = function() {
        return this.url;
    };

    /**
     * @function isForDataProvider
     * @memberof AbstractVectorLayer#
     */
    AbstractVectorLayer.prototype.isForDataProvider = function() {
        return this.getUrl() === undefined;
    };

    /**
     * @function isDraw
     * @memberof AbstractVectorLayer#
     */
    AbstractVectorLayer.prototype.isDraw = function() {
        return this.draw;
    };

    /**
     * @function isDraw
     * @memberof AbstractVectorLayer#
     */
    AbstractVectorLayer.prototype.setDraw = function(value) {
        Utils.assert(
            typeof value === "boolean",
            "value is not a boolean : " + value,
            "AbstractVectorLayer.js"
        );
        this.draw = value;
    };

    /**
     * Attach the vector layer to the globe
     * @function _attach
     * @memberof AbstractVectorLayer#
     * @param {AbstractGlobe} g globe
     * @private
     */
    AbstractVectorLayer.prototype._attach = function(g) {
        AbstractLayer.prototype._attach.call(this, g);

        // Add the feature to renderers
        for (var i = 0; i < this.features.length; i++) {
            this._addFeatureToRenderers(this.features[i]);
        }
    };

    /**
     * Detach the vector layer from the globe
     * @function _detach
     * @memberof AbstractVectorLayer#
     * @private
     */
    AbstractVectorLayer.prototype._detach = function() {
        // Remove feature from renderers
        for (var i = 0; i < this.features.length; i++) {
            this._removeFeatureFromRenderers(this.features[i]);
        }

        AbstractLayer.prototype._detach.call(this);
    };

    /**
     * Adds a feature collection, in GeoJSON format
     * @function addFeatureCollection
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} featureCollection Feature Collection
     */
    AbstractVectorLayer.prototype.addFeatureCollection = function(
        featureCollection
    ) {
        // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
        var features = featureCollection.features;
        if (features) {
            for (var i = 0; i < features.length; i++) {
                this.addFeature(features[i]);
            }
        }
    };

    /**
     * Removes a feature collection, in GeoJSON format
     * @function removeFeatureCollection
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} featureCollection Feature Collection
     */
    AbstractVectorLayer.prototype.removeFeatureCollection = function(
        featureCollection
    ) {
        // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
        var features = featureCollection.features;
        if (features) {
            for (var i = 0; i < features.length; i++) {
                this.removeFeature(features[i]);
            }
        }
    };

    /**
     * Check whether a feature can be considered on terrain
     */
    AbstractVectorLayer.prototype._isOnTerrain = function(feature) {
        var onTerrain  = true;

        const coords = feature.geometry.coordinates;
        if (coords && coords[0] && coords[0][0]) {
            if (coords[0][0].length === 3) {
                const props = feature.properties || {};
                const style = props.style || {};

                if (!style.rendererHint || style.rendererHint !== "Tiled") {
                    onTerrain = false;
                }
            }
        }

        return onTerrain;
    };

    /**
     * Add a feature to renderers.
     * @function _addFeatureToRenderers
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} feature Feature
     * @private
     */
    AbstractVectorLayer.prototype._addFeatureToRenderers = function(feature) {
        var geometry = feature.geometry;

        // Manage style, if undefined try with properties, otherwise use defaultStyle
        var style;
        var props = feature.properties;
        if (props && props.style) {
            style = props.style;
        } else {
            style = Object.assign({}, this.style);
        }
        style.zIndex = this.zIndex;
        style.onTerrain = this._isOnTerrain(feature);

        // Manage geometry collection
        if (geometry.type === "GeometryCollection") {
            var geoms = geometry.geometries;
            for (var i = 0; i < geoms.length; i++) {
                this.getGlobe()
                    .getRendererManager()
                    .addGeometry(this, geoms[i], style);
            }
        } else {
            // Add geometry to renderers
            this.getGlobe()
                .getRendererManager()
                .addGeometry(this, geometry, style);
        }
    };

    /**
     * Removes a feature from renderers.
     * @function _removeFeatureFromRenderers
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} feature Feature
     * @returns {boolean} true when the feature is removed from the globe otherwise false
     * @private
     */
    AbstractVectorLayer.prototype._removeFeatureFromRenderers = function(
        feature
    ) {
        var isRemoved = true;
        var geometry = feature.geometry;

        // Manage geometry collection
        if (geometry.type === "GeometryCollection") {
            var geoms = geometry.geometries;
            if (this.getGlobe() && this.getGlobe().getRendererManager()) {
                for (var i = 0; i < geoms.length; i++) {
                    isRemoved =
                        isRemoved &&
                        this.getGlobe()
                            .getRendererManager()
                            .removeGeometry(geoms[i], this);
                }
            } else {
                isRemoved = false;
            }
        } else if (this.getGlobe() && this.getGlobe().getRendererManager()) {
            isRemoved = this.getGlobe()
                .getRendererManager()
                .removeGeometry(geometry, this);
        } else {
            isRemoved = false;
        }
        return isRemoved;
    };

    /**
     * Add a feature to the layer
     * @function addFeature
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} feature Feature
     */
    AbstractVectorLayer.prototype.addFeature = function(feature) {
        // Check feature geometry : only add valid feature
        var geometry = feature.geometry;
        if (!geometry || !geometry.type) {
            return;
        }
        this.features.push(feature);

        // Add features to renderer if layer is attached to planet
        if (this.getGlobe()) {
            this._addFeatureToRenderers(feature);
            if (this.isVisible()) {
                this.getGlobe()
                    .getRenderContext()
                    .requestFrame();
            }
        }
    };

    /**
     * Removes a feature from the layer.
     * @function removeFeature
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} feature Feature
     */
    AbstractVectorLayer.prototype.removeFeature = function(feature) {
        var index = this.features.indexOf(feature);
        this.features.splice(index, 1);
        if (this.getGlobe()) {
            this._removeFeatureFromRenderers(feature);
            if (this.isVisible()) {
                this.getGlobe()
                    .getRenderContext()
                    .requestFrame();
            }
        }
    };

    /**
     * Removes all features from the layer.
     * @function removeAllFeatures
     * @memberof AbstractVectorLayer#
     */
    AbstractVectorLayer.prototype.removeAllFeatures = function() {
        // Remove feature from renderers
        if (this.getGlobe()) {
            for (var i = 0; i < this.features.length; i++) {
                this._removeFeatureFromRenderers(this.features[i]);
            }
        }
        this.features.length = 0;

        // Refresh rendering if needed
        if (this.getGlobe() && this.isVisible()) {
            this.getGlobe()
                .getRenderContext()
                .requestFrame();
        }
    };

    /**
     * Modifies the feature style for a specific feature.
     * @function modifyFeatureStyle
     * @memberof AbstractVectorLayer#
     * @param {GeoJson} feature feature for which the feature style is modified
     * @param {FeatureStyle} style Feature style
     */
    AbstractVectorLayer.prototype.modifyFeatureStyle = function(
        feature,
        style
    ) {
        if (this._removeFeatureFromRenderers(feature)) {
            feature.properties.style = style;
            this._addFeatureToRenderers(feature);
        }
    };

    /**
     * Modifies the feature style for all features.
     * @function modifyStyle
     * @memberof AbstractVectorLayer#
     * @param {FeatureStyle} style Feature style
     */
    AbstractVectorLayer.prototype.modifyStyle = function(style) {
        var i;
        for (i = 0; i < this.features.length; i++) {
            this._removeFeatureFromRenderers(this.features[i]);
        }

        this.setStyle(style);

        for (i = 0; i < this.features.length; i++) {
            this._addFeatureToRenderers(this.features[i]);
        }
    };

    return AbstractVectorLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/Layer/VectorLayer',[
    "../Utils/Utils",
    "./AbstractVectorLayer",
    "../Utils/Constants"
], function(Utils, AbstractVectorLayer, Constants) {
    /**
     * Vector layer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.vector_configuration
     * @property {string} url - the url of json data to load when attaching to globe
     * @property {int} [minLevel = 0] - minimum rendering level depending on tile level
     * @property {int} [maxLevel = 15] - maximum rendering level depending on tile level
     * @property {function} [callback] - the callback function called when data are loaded. Data loaded are passed in parameter of the function.
     */
    /**
     * @name VectorLayer
     * @class
     *    Create a layer to display vector data in GeoJSON format.
     * @augments AbstractVectorLayer
     * @param {AbstractLayer.vector_configuration} options - Vector configuration
     * @constructor
     * @memberof module:Layer
     */
    var VectorLayer = function(options) {
        AbstractVectorLayer.prototype.constructor.call(
            this,
            Constants.LAYER.Vector,
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractVectorLayer, VectorLayer);

    /**************************************************************************************************************/

    return VectorLayer;
});

// jshint ignore: start

/*
 * Copyright (c) 2012 Brandon Jones, Colin MacKenzie IV
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *    1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 *    2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 *    3. This notice may not be removed or altered from any source
 *    distribution.
 */

// Modification to plain glMatrix
//	- Always use Array for MatrixType
//	- Remove export management
//	- Remove vec2, mat2, mat3, vec4
//	- Comments some not needed functions
//	- Add mat4.project and mat4.rotateVec3

define('gw/Renderer/glMatrix',[], function() {
    // Tweak to your liking
    var FLOAT_EPSILON = 0.000001;

    /**
     * @class System-specific optimal array type
     * @name MatrixArray
     */
    var MatrixArray = Array;

    /**
     * @class 3 Dimensional Vector
     * @name vec3
     */
    var vec3 = {};

    /**
     * Creates a new instance of a vec3 using the default array type
     * Any javascript array-like objects containing at least 3 numeric elements can serve as a vec3
     *
     * @param {vec3} [vec] vec3 containing values to initialize with
     *
     * @returns {vec3} New vec3
     */
    vec3.create = function(vec) {
        var dest = new MatrixArray(3);

        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
            dest[2] = vec[2];
        } else {
            dest[0] = dest[1] = dest[2] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a vec3, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value

     * @returns {vec3} New vec3
     */
    vec3.createFrom = function(x, y, z) {
        var dest = new MatrixArray(3);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;

        return dest;
    };

    /**
     * Copies the values of one vec3 to another
     *
     * @param {vec3} vec vec3 containing values to copy
     * @param {vec3} dest vec3 receiving copied values
     *
     * @returns {vec3} dest
     */
    vec3.set = function(vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];

        return dest;
    };

    /**
     * Compares two vectors for equality within a certain margin of error
     *
     * @param {vec3} a First vector
     * @param {vec3} b Second vector
     *
     * @returns {Boolean} true if a is equivalent to b
     */
    vec3.equal = function(a, b) {
        return (
            a === b ||
            (Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
                Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
                Math.abs(a[2] - b[2]) < FLOAT_EPSILON)
        );
    };

    /**
     * Performs a vector addition
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.add = function(vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] += vec2[0];
            vec[1] += vec2[1];
            vec[2] += vec2[2];
            return vec;
        }

        dest[0] = vec[0] + vec2[0];
        dest[1] = vec[1] + vec2[1];
        dest[2] = vec[2] + vec2[2];
        return dest;
    };

    /**
     * Performs a vector subtraction
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.subtract = function(vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] -= vec2[0];
            vec[1] -= vec2[1];
            vec[2] -= vec2[2];
            return vec;
        }

        dest[0] = vec[0] - vec2[0];
        dest[1] = vec[1] - vec2[1];
        dest[2] = vec[2] - vec2[2];
        return dest;
    };

    /**
     * Performs a vector multiplication
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.multiply = function(vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] *= vec2[0];
            vec[1] *= vec2[1];
            vec[2] *= vec2[2];
            return vec;
        }

        dest[0] = vec[0] * vec2[0];
        dest[1] = vec[1] * vec2[1];
        dest[2] = vec[2] * vec2[2];
        return dest;
    };

    /**
     * Negates the components of a vec3
     *
     * @param {vec3} vec vec3 to negate
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.negate = function(vec, dest) {
        if (!dest) {
            dest = vec;
        }

        dest[0] = -vec[0];
        dest[1] = -vec[1];
        dest[2] = -vec[2];
        return dest;
    };

    /**
     * Multiplies the components of a vec3 by a scalar value
     *
     * @param {vec3} vec vec3 to scale
     * @param {number} val Value to scale by
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.scale = function(vec, val, dest) {
        if (!dest || vec === dest) {
            vec[0] *= val;
            vec[1] *= val;
            vec[2] *= val;
            return vec;
        }

        dest[0] = vec[0] * val;
        dest[1] = vec[1] * val;
        dest[2] = vec[2] * val;
        return dest;
    };

    /**
     * Generates a unit vector of the same direction as the provided vec3
     * If vector length is 0, returns [0, 0, 0]
     *
     * @param {vec3} vec vec3 to normalize
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.normalize = function(vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        } else if (len === 1) {
            dest[0] = x;
            dest[1] = y;
            dest[2] = z;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };

    /**
     * Generates the cross product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.cross = function(vec, vec2, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2],
            x2 = vec2[0],
            y2 = vec2[1],
            z2 = vec2[2];

        dest[0] = y * z2 - z * y2;
        dest[1] = z * x2 - x * z2;
        dest[2] = x * y2 - y * x2;
        return dest;
    };

    /**
     * Caclulates the length of a vec3
     *
     * @param {vec3} vec vec3 to calculate length of
     *
     * @returns {number} Length of vec
     */
    vec3.length = function(vec) {
        var x = vec[0],
            y = vec[1],
            z = vec[2];
        return Math.sqrt(x * x + y * y + z * z);
    };

    /**
     * Caclulates the squared length of a vec3
     *
     * @param {vec3} vec vec3 to calculate squared length of
     *
     * @returns {number} Squared Length of vec
     */
    vec3.squaredLength = function(vec) {
        var x = vec[0],
            y = vec[1],
            z = vec[2];
        return x * x + y * y + z * z;
    };

    /**
     * Caclulates the dot product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     *
     * @returns {number} Dot product of vec and vec2
     */
    vec3.dot = function(vec, vec2) {
        return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
    };

    /**
     * Generates a unit vector pointing from one vector to another
     *
     * @param {vec3} vec Origin vec3
     * @param {vec3} vec2 vec3 to point to
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    /*   vec3.direction = function (vec, vec2, dest) {
     if (!dest) { dest = vec; }

     var x = vec[0] - vec2[0],
     y = vec[1] - vec2[1],
     z = vec[2] - vec2[2],
     len = Math.sqrt(x * x + y * y + z * z);

     if (!len) {
     dest[0] = 0;
     dest[1] = 0;
     dest[2] = 0;
     return dest;
     }

     len = 1 / len;
     dest[0] = x * len;
     dest[1] = y * len;
     dest[2] = z * len;
     return dest;
     };*/

    /**
     * Performs a linear interpolation between two vec3
     *
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     * @param {number} t Interpolation amount between the two inputs
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.lerp = function(vec, vec2, t, dest) {
        if (!dest) {
            dest = vec;
        }

        const oneMinusT = 1 - t;

        dest[0] = oneMinusT * vec[0] + t * vec2[0];
        dest[1] = oneMinusT * vec[1] + t * vec2[1];
        dest[2] = oneMinusT * vec[2] + t * vec2[2];

        return dest;
    };

    /**
     * Calculates the euclidian distance between two vec3
     *
     * Params:
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     *
     * @returns {number} Distance between vec and vec2
     */
    vec3.dist = function(vec, vec2) {
        var x = vec2[0] - vec[0],
            y = vec2[1] - vec[1],
            z = vec2[2] - vec[2];

        return Math.sqrt(x * x + y * y + z * z);
    };

    /** Vector cross product.
     @param v1 vector
     @param v2 another vector
     @return number vector cross product between this vector and {@code v}
     */
    vec3.angle = function(v1, v2) {
        return Math.atan2(vec3.length(vec3.cross(v1, v2)), vec3.dot(v1, v2));
    };

    // Pre-allocated to prevent unecessary garbage collection
    //var unprojectMat = null;
    //var unprojectVec = new MatrixArray(4);
    /**
     * Projects the specified vec3 from screen space into object space
     * Based on the <a href="http://webcvs.freedesktop.org/mesa/Mesa/src/glu/mesa/project.c?revision=1.4&view=markup">Mesa gluUnProject implementation</a>
     *
     * @param {vec3} vec Screen-space vector to project
     * @param {mat4} view View matrix
     * @param {mat4} proj Projection matrix
     * @param {vec4} viewport Viewport as given to gl.viewport [x, y, width, height]
     * @param {vec3} [dest] vec3 receiving unprojected result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    /*   vec3.unproject = function (vec, view, proj, viewport, dest) {
     if (!dest) { dest = vec; }

     if(!unprojectMat) {
     unprojectMat = mat4.create();
     }

     var m = unprojectMat;
     var v = unprojectVec;

     v[0] = (vec[0] - viewport[0]) * 2.0 / viewport[2] - 1.0;
     v[1] = (vec[1] - viewport[1]) * 2.0 / viewport[3] - 1.0;
     v[2] = 2.0 * vec[2] - 1.0;
     v[3] = 1.0;

     mat4.multiply(proj, view, m);
     if(!mat4.inverse(m)) { return null; }

     mat4.multiplyVec4(m, v);
     if(v[3] === 0.0) { return null; }

     dest[0] = v[0] / v[3];
     dest[1] = v[1] / v[3];
     dest[2] = v[2] / v[3];

     return dest;
     };*/

    /*    var xUnitVec3 = vec3.createFrom(1,0,0);
     var yUnitVec3 = vec3.createFrom(0,1,0);
     var zUnitVec3 = vec3.createFrom(0,0,1);

     var tmpvec3 = vec3.create();*/
    /**
     * Generates a quaternion of rotation between two given normalized vectors
     *
     * @param {vec3} a Normalized source vector
     * @param {vec3} b Normalized target vector
     * @param {quat4} [dest] quat4 receiving operation result.
     *
     * @returns {quat4} dest if specified, a new quat4 otherwise
     */
    /*    vec3.rotationTo = function (a, b, dest) {
     if (!dest) { dest = quat4.create(); }

     var d = vec3.dot(a, b);
     var axis = tmpvec3;
     if (d >= 1.0) {
     quat4.set(identityQuat4, dest);
     } else if (d < (0.000001 - 1.0)) {
     vec3.cross(xUnitVec3, a, axis);
     if (vec3.length(axis) < 0.000001)
     vec3.cross(yUnitVec3, a, axis);
     if (vec3.length(axis) < 0.000001)
     vec3.cross(zUnitVec3, a, axis);
     vec3.normalize(axis);
     quat4.fromAngleAxis(Math.PI, axis, dest);
     } else {
     var s = Math.sqrt((1.0 + d) * 2.0);
     var sInv = 1.0 / s;
     vec3.cross(a, b, axis);
     dest[0] = axis[0] * sInv;
     dest[1] = axis[1] * sInv;
     dest[2] = axis[2] * sInv;
     dest[3] = s * 0.5;
     quat4.normalize(dest);
     }
     if (dest[3] > 1.0) dest[3] = 1.0;
     else if (dest[3] < -1.0) dest[3] = -1.0;
     return dest;
     };*/

    /**
     * Returns a string representation of a vector
     *
     * @param {vec3} vec Vector to represent as a string
     *
     * @returns {string} String representation of vec
     */
    vec3.str = function(vec) {
        return "[" + vec[0] + ", " + vec[1] + ", " + vec[2] + "]";
    };

    // Vec3 lib used for Astro Math lib

    vec3.createZPhi = function(z, phi) {
        var sth = Math.sqrt((1.0 - z) * (1.0 + z));
        var x = sth * Math.cos(phi);
        var y = sth * Math.sin(phi);
        return vec3.createFrom(x, y, z);
    };

    vec3.createPhiTheta = function(phi, theta) {
        var sth = Math.sin(theta);
        var x = sth * Math.cos(phi);
        var y = sth * Math.sin(phi);
        var z = sth * Math.cos(theta);
        return vec3.createFrom(x, y, z);
    };

    vec3.add2 = function(vec, vec2) {
        var x1 = vec[0];
        var y1 = vec[1];
        var z1 = vec[2];
        var x2 = vec2[0];
        var y2 = vec2[1];
        var z2 = vec2[2];

        return [x1 + x2, y1 + y2, z1 + z2];
    };

    vec3.subtract2 = function(vec, vec2) {
        var x1 = vec[0];
        var y1 = vec[1];
        var z1 = vec[2];
        var x2 = vec2[0];
        var y2 = vec2[1];
        var z2 = vec2[2];

        return [x1 - x2, y1 - y2, z1 - z2];
    };

    vec3.flip = function(vec) {
        var x = vec[0];
        var y = vec[1];
        var z = vec[2];

        return [(x = -x), (y = -y), (z = -z)];
    };

    vec3.scale2 = function(vec, val) {
        var x = vec.x;
        var y = vec.y;
        var z = vec.z;

        return {
            x: x * val,
            y: (y *= val),
            z: (z *= val)
        };
    };

    vec3.normalize2 = function(vec) {
        var x = vec[0];
        var y = vec[1];
        var z = vec[2];
        var d = 1.0 / Math.sqrt(x * x + y * y + z * z);

        return [(x *= d), (y *= d), (z *= d)];
    };

    vec3.cross2 = function(vec, vec2) {
        return {
            x: vec[1] * vec2[2] - vec2[1] * vec[2],
            y: vec[2] * vec2[0] - vec2[2] * vec[0],
            z: vec[0] * vec2[1] - vec2[0] * vec[1]
        };
    };

    vec3.length2 = function(vec) {
        var x = vec.x,
            y = vec.y,
            z = vec.z;
        return Math.sqrt(x * x + y * y + z * z);
    };

    vec3.dot2 = function(vec, vec2) {
        var x1 = vec.x !== undefined ? vec.x : vec[0];
        var y1 = vec.y !== undefined ? vec.y : vec[1];
        var z1 = vec.z !== undefined ? vec.z : vec[2];
        var x2 = vec2.x !== undefined ? vec2.x : vec2[0];
        var y2 = vec2.y !== undefined ? vec2.y : vec2[1];
        var z2 = vec2.z !== undefined ? vec2.z : vec2[2];

        return x1 * x2 + y1 * y2 + z1 * z2;
    };

    vec3.angle2 = function(v1, v2) {
        return Math.atan2(vec3.length2(vec3.cross2(v1, v2)), vec3.dot2(v1, v2));
    };
    //

    /**
     * @class 3x3 Matrix
     * @name mat3
     */
    var mat3 = {};

    /**
     * Creates a new isntance of mat3
     *
     * @param {mat3} [mat] mat3 containing values to initialize with
     *
     * @returns {mat3} a new 3x3 matrix
     */
    mat3.create = function(mat) {
        var dest = new MatrixArray(9);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
        }

        return dest;
    };

    /**
     * @class 4x4 Matrix
     * @name mat4
     */
    var mat4 = {};

    /**
     * Creates a new instance of a mat4 using the default array type
     * Any javascript array-like object containing at least 16 numeric elements can serve as a mat4
     *
     * @param {mat4} [mat] mat4 containing values to initialize with
     *
     * @returns {mat4} New mat4
     */
    mat4.create = function(mat) {
        var dest = new MatrixArray(16);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        return dest;
    };

    /**
     * Creates a new instance of a mat4, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m02
     * @param {number} m03
     * @param {number} m10
     * @param {number} m11
     * @param {number} m12
     * @param {number} m13
     * @param {number} m20
     * @param {number} m21
     * @param {number} m22
     * @param {number} m23
     * @param {number} m30
     * @param {number} m31
     * @param {number} m32
     * @param {number} m33

     * @returns {mat4} New mat4
     */
    /*   mat4.createFrom = function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
     var dest = new MatrixArray(16);

     dest[0] = m00;
     dest[1] = m01;
     dest[2] = m02;
     dest[3] = m03;
     dest[4] = m10;
     dest[5] = m11;
     dest[6] = m12;
     dest[7] = m13;
     dest[8] = m20;
     dest[9] = m21;
     dest[10] = m22;
     dest[11] = m23;
     dest[12] = m30;
     dest[13] = m31;
     dest[14] = m32;
     dest[15] = m33;

     return dest;
     };*/

    /**
     * Copies the values of one mat4 to another
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} dest mat4 receiving copied values
     *
     * @returns {mat4} dest
     */
    mat4.set = function(mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Compares two matrices for equality within a certain margin of error
     *
     * @param {mat4} a First matrix
     * @param {mat4} b Second matrix
     *
     * @returns {Boolean} true if a is equivalent to b
     */
    mat4.equal = function(a, b) {
        return (
            a === b ||
            (Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
                Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
                Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
                Math.abs(a[3] - b[3]) < FLOAT_EPSILON &&
                Math.abs(a[4] - b[4]) < FLOAT_EPSILON &&
                Math.abs(a[5] - b[5]) < FLOAT_EPSILON &&
                Math.abs(a[6] - b[6]) < FLOAT_EPSILON &&
                Math.abs(a[7] - b[7]) < FLOAT_EPSILON &&
                Math.abs(a[8] - b[8]) < FLOAT_EPSILON &&
                Math.abs(a[9] - b[9]) < FLOAT_EPSILON &&
                Math.abs(a[10] - b[10]) < FLOAT_EPSILON &&
                Math.abs(a[11] - b[11]) < FLOAT_EPSILON &&
                Math.abs(a[12] - b[12]) < FLOAT_EPSILON &&
                Math.abs(a[13] - b[13]) < FLOAT_EPSILON &&
                Math.abs(a[14] - b[14]) < FLOAT_EPSILON &&
                Math.abs(a[15] - b[15]) < FLOAT_EPSILON)
        );
    };

    /**
     * Sets a mat4 to an identity matrix
     *
     * @param {mat4} dest mat4 to set
     *
     * @returns {mat4} dest
     */
    mat4.identity = function(dest) {
        if (!dest) {
            dest = mat4.create();
        }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 1;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = 1;
        dest[11] = 0;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;
        return dest;
    };

    /**
     * Transposes a mat4 (flips the values over the diagonal)
     *
     * @param {mat4} mat mat4 to transpose
     * @param {mat4} [dest] mat4 receiving transposed values. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise
     */
    mat4.transpose = function(mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a01 = mat[1],
                a02 = mat[2],
                a03 = mat[3],
                a12 = mat[6],
                a13 = mat[7],
                a23 = mat[11];

            mat[1] = mat[4];
            mat[2] = mat[8];
            mat[3] = mat[12];
            mat[4] = a01;
            mat[6] = mat[9];
            mat[7] = mat[13];
            mat[8] = a02;
            mat[9] = a12;
            mat[11] = mat[14];
            mat[12] = a03;
            mat[13] = a13;
            mat[14] = a23;
            return mat;
        }

        dest[0] = mat[0];
        dest[1] = mat[4];
        dest[2] = mat[8];
        dest[3] = mat[12];
        dest[4] = mat[1];
        dest[5] = mat[5];
        dest[6] = mat[9];
        dest[7] = mat[13];
        dest[8] = mat[2];
        dest[9] = mat[6];
        dest[10] = mat[10];
        dest[11] = mat[14];
        dest[12] = mat[3];
        dest[13] = mat[7];
        dest[14] = mat[11];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Calculates the determinant of a mat4
     *
     * @param {mat4} mat mat4 to calculate determinant of
     *
     * @returns {number} determinant of mat
     */
    mat4.determinant = function(mat) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11],
            a30 = mat[12],
            a31 = mat[13],
            a32 = mat[14],
            a33 = mat[15];

        return (
            a30 * a21 * a12 * a03 -
            a20 * a31 * a12 * a03 -
            a30 * a11 * a22 * a03 +
            a10 * a31 * a22 * a03 +
            a20 * a11 * a32 * a03 -
            a10 * a21 * a32 * a03 -
            a30 * a21 * a02 * a13 +
            a20 * a31 * a02 * a13 +
            a30 * a01 * a22 * a13 -
            a00 * a31 * a22 * a13 -
            a20 * a01 * a32 * a13 +
            a00 * a21 * a32 * a13 +
            a30 * a11 * a02 * a23 -
            a10 * a31 * a02 * a23 -
            a30 * a01 * a12 * a23 +
            a00 * a31 * a12 * a23 +
            a10 * a01 * a32 * a23 -
            a00 * a11 * a32 * a23 -
            a20 * a11 * a02 * a33 +
            a10 * a21 * a02 * a33 +
            a20 * a01 * a12 * a33 -
            a00 * a21 * a12 * a33 -
            a10 * a01 * a22 * a33 +
            a00 * a11 * a22 * a33
        );
    };

    /**
     * Calculates the inverse matrix of a mat4
     *
     * @param {mat4} mat mat4 to calculate inverse of
     * @param {mat4} [dest] mat4 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat4.inverse = function(mat, dest) {
        if (!dest) {
            dest = mat;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11],
            a30 = mat[12],
            a31 = mat[13],
            a32 = mat[14],
            a33 = mat[15],
            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,
            d =
                b00 * b11 -
                b01 * b10 +
                b02 * b09 +
                b03 * b08 -
                b04 * b07 +
                b05 * b06,
            invDet;

        // Calculate the determinant
        if (!d) {
            return null;
        }
        invDet = 1 / d;

        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into another mat4
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} [dest] mat4 receiving copied values
     *
     * @returns {mat4} dest is specified, a new mat4 otherwise
     */
    mat4.toRotationMat = function(mat, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into a mat3
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat3} [dest] mat3 receiving copied values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise
     */
    mat4.toMat3 = function(mat, dest) {
        if (!dest) {
            dest = mat3.create();
        }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[4];
        dest[4] = mat[5];
        dest[5] = mat[6];
        dest[6] = mat[8];
        dest[7] = mat[9];
        dest[8] = mat[10];

        return dest;
    };

    /**
     * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
     * The resulting matrix is useful for calculating transformed normals
     *
     * Params:
     * @param {mat4} mat mat4 containing values to invert and copy
     * @param {mat3} [dest] mat3 receiving values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise, null if the matrix cannot be inverted
     */
    /*   mat4.toInverseMat3 = function (mat, dest) {
     // Cache the matrix values (makes for huge speed increases!)
     var a00 = mat[0], a01 = mat[1], a02 = mat[2],
     a10 = mat[4], a11 = mat[5], a12 = mat[6],
     a20 = mat[8], a21 = mat[9], a22 = mat[10],

     b01 = a22 * a11 - a12 * a21,
     b11 = -a22 * a10 + a12 * a20,
     b21 = a21 * a10 - a11 * a20,

     d = a00 * b01 + a01 * b11 + a02 * b21,
     id;

     if (!d) { return null; }
     id = 1 / d;

     if (!dest) { dest = mat3.create(); }

     dest[0] = b01 * id;
     dest[1] = (-a22 * a01 + a02 * a21) * id;
     dest[2] = (a12 * a01 - a02 * a11) * id;
     dest[3] = b11 * id;
     dest[4] = (a22 * a00 - a02 * a20) * id;
     dest[5] = (-a12 * a00 + a02 * a10) * id;
     dest[6] = b21 * id;
     dest[7] = (-a21 * a00 + a01 * a20) * id;
     dest[8] = (a11 * a00 - a01 * a10) * id;

     return dest;
     };*/

    /**
     * Performs a matrix multiplication
     *
     * @param {mat4} mat First operand
     * @param {mat4} mat2 Second operand
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.multiply = function(mat, mat2, dest) {
        if (!dest) {
            dest = mat;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3];
        var a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7];
        var a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];
        var a30 = mat[12],
            a31 = mat[13],
            a32 = mat[14],
            a33 = mat[15];

        // Cache only the current line of the second matrix
        var b0 = mat2[0],
            b1 = mat2[1],
            b2 = mat2[2],
            b3 = mat2[3];
        dest[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = mat2[4];
        b1 = mat2[5];
        b2 = mat2[6];
        b3 = mat2[7];
        dest[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = mat2[8];
        b1 = mat2[9];
        b2 = mat2[10];
        b3 = mat2[11];
        dest[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = mat2[12];
        b1 = mat2[13];
        b2 = mat2[14];
        b3 = mat2[15];
        dest[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        return dest;
    };

    /**
     * Transforms a vec3 with the given matrix
     * 4th vector component is implicitly '1'
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    mat4.multiplyVec3 = function(mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];

        return dest;
    };

    /**
     * Transforms a vec4 with the given matrix
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec4} vec vec4 to transform
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec4} dest if specified, vec otherwise
     */
    mat4.multiplyVec4 = function(mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2],
            w = vec[3];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
        dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;

        return dest;
    };

    /**
     Project a vec3
     */
    mat4.project = function(mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }
        mat4.multiplyVec4(mat, vec, dest);
        var iw = 1.0 / dest[3];
        dest[0] *= iw;
        dest[1] *= iw;
        dest[2] *= iw;
        return dest;
    };

    /**
     * mat4.rotateVec3
     * Rotate a vec3 with the given matrix
     *
     * Params:
     * mat - mat4 to transform the vector with
     * vec - vec3 to transform
     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
     *
     * Returns:
     * dest if specified, vec otherwise
     */
    mat4.rotateVec3 = function(mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z;
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z;
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z;

        return dest;
    };

    /**
     * Translates a matrix by the given vector
     *
     * @param {mat4} mat mat4 to translate
     * @param {vec3} vec vec3 specifying the translation
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.translate = function(mat, vec, dest) {
        var x = vec[0],
            y = vec[1],
            z = vec[2],
            a00,
            a01,
            a02,
            a03,
            a10,
            a11,
            a12,
            a13,
            a20,
            a21,
            a22,
            a23;

        if (!dest || mat === dest) {
            mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
            mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
            mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
            mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
            return mat;
        }

        a00 = mat[0];
        a01 = mat[1];
        a02 = mat[2];
        a03 = mat[3];
        a10 = mat[4];
        a11 = mat[5];
        a12 = mat[6];
        a13 = mat[7];
        a20 = mat[8];
        a21 = mat[9];
        a22 = mat[10];
        a23 = mat[11];

        dest[0] = a00;
        dest[1] = a01;
        dest[2] = a02;
        dest[3] = a03;
        dest[4] = a10;
        dest[5] = a11;
        dest[6] = a12;
        dest[7] = a13;
        dest[8] = a20;
        dest[9] = a21;
        dest[10] = a22;
        dest[11] = a23;

        dest[12] = a00 * x + a10 * y + a20 * z + mat[12];
        dest[13] = a01 * x + a11 * y + a21 * z + mat[13];
        dest[14] = a02 * x + a12 * y + a22 * z + mat[14];
        dest[15] = a03 * x + a13 * y + a23 * z + mat[15];
        return dest;
    };

    /**
     * Scales a matrix by the given vector
     *
     * @param {mat4} mat mat4 to scale
     * @param {vec3} vec vec3 specifying the scale for each axis
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @param {mat4} dest if specified, mat otherwise
     */
    mat4.scale = function(mat, vec, dest) {
        var x = vec[0],
            y = vec[1],
            z = vec[2];

        if (!dest || mat === dest) {
            mat[0] *= x;
            mat[1] *= x;
            mat[2] *= x;
            mat[3] *= x;
            mat[4] *= y;
            mat[5] *= y;
            mat[6] *= y;
            mat[7] *= y;
            mat[8] *= z;
            mat[9] *= z;
            mat[10] *= z;
            mat[11] *= z;
            return mat;
        }

        dest[0] = mat[0] * x;
        dest[1] = mat[1] * x;
        dest[2] = mat[2] * x;
        dest[3] = mat[3] * x;
        dest[4] = mat[4] * y;
        dest[5] = mat[5] * y;
        dest[6] = mat[6] * y;
        dest[7] = mat[7] * y;
        dest[8] = mat[8] * z;
        dest[9] = mat[9] * z;
        dest[10] = mat[10] * z;
        dest[11] = mat[11] * z;
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the specified axis
     * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {vec3} axis vec3 representing the axis to rotate around
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotate = function(mat, angle, axis, dest) {
        var x = axis[0],
            y = axis[1],
            z = axis[2],
            len = Math.sqrt(x * x + y * y + z * z),
            s,
            c,
            t,
            a00,
            a01,
            a02,
            a03,
            a10,
            a11,
            a12,
            a13,
            a20,
            a21,
            a22,
            a23,
            b00,
            b01,
            b02,
            b10,
            b11,
            b12,
            b20,
            b21,
            b22;

        if (!len) {
            return null;
        }
        if (len !== 1) {
            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;
        }

        s = Math.sin(angle);
        c = Math.cos(angle);
        t = 1 - c;

        a00 = mat[0];
        a01 = mat[1];
        a02 = mat[2];
        a03 = mat[3];
        a10 = mat[4];
        a11 = mat[5];
        a12 = mat[6];
        a13 = mat[7];
        a20 = mat[8];
        a21 = mat[9];
        a22 = mat[10];
        a23 = mat[11];

        // Construct the elements of the rotation matrix
        b00 = x * x * t + c;
        b01 = y * x * t + z * s;
        b02 = z * x * t - y * s;
        b10 = x * y * t - z * s;
        b11 = y * y * t + c;
        b12 = z * y * t + x * s;
        b20 = x * z * t + y * s;
        b21 = y * z * t - x * s;
        b22 = z * z * t + c;

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) {
            // If the source and destination differ, copy the unchanged last row
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform rotation-specific matrix multiplication
        dest[0] = a00 * b00 + a10 * b01 + a20 * b02;
        dest[1] = a01 * b00 + a11 * b01 + a21 * b02;
        dest[2] = a02 * b00 + a12 * b01 + a22 * b02;
        dest[3] = a03 * b00 + a13 * b01 + a23 * b02;

        dest[4] = a00 * b10 + a10 * b11 + a20 * b12;
        dest[5] = a01 * b10 + a11 * b11 + a21 * b12;
        dest[6] = a02 * b10 + a12 * b11 + a22 * b12;
        dest[7] = a03 * b10 + a13 * b11 + a23 * b12;

        dest[8] = a00 * b20 + a10 * b21 + a20 * b22;
        dest[9] = a01 * b20 + a11 * b21 + a21 * b22;
        dest[10] = a02 * b20 + a12 * b21 + a22 * b22;
        dest[11] = a03 * b20 + a13 * b21 + a23 * b22;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateX = function(mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) {
            // If the source and destination differ, copy the unchanged rows
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[4] = a10 * c + a20 * s;
        dest[5] = a11 * c + a21 * s;
        dest[6] = a12 * c + a22 * s;
        dest[7] = a13 * c + a23 * s;

        dest[8] = a10 * -s + a20 * c;
        dest[9] = a11 * -s + a21 * c;
        dest[10] = a12 * -s + a22 * c;
        dest[11] = a13 * -s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateY = function(mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) {
            // If the source and destination differ, copy the unchanged rows
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a20 * -s;
        dest[1] = a01 * c + a21 * -s;
        dest[2] = a02 * c + a22 * -s;
        dest[3] = a03 * c + a23 * -s;

        dest[8] = a00 * s + a20 * c;
        dest[9] = a01 * s + a21 * c;
        dest[10] = a02 * s + a22 * c;
        dest[11] = a03 * s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateZ = function(mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) {
            // If the source and destination differ, copy the unchanged last row
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a10 * s;
        dest[1] = a01 * c + a11 * s;
        dest[2] = a02 * c + a12 * s;
        dest[3] = a03 * c + a13 * s;

        dest[4] = a00 * -s + a10 * c;
        dest[5] = a01 * -s + a11 * c;
        dest[6] = a02 * -s + a12 * c;
        dest[7] = a03 * -s + a13 * c;

        return dest;
    };

    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.frustum = function(left, right, bottom, top, near, far, dest) {
        if (!dest) {
            dest = mat4.create();
        }
        var rl = right - left,
            tb = top - bottom,
            fn = far - near;
        dest[0] = (near * 2) / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = (near * 2) / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = (right + left) / rl;
        dest[9] = (top + bottom) / tb;
        dest[10] = -(far + near) / fn;
        dest[11] = -1;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = -(far * near * 2) / fn;
        dest[15] = 0;
        return dest;
    };

    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {number} fovy Vertical field of view
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.perspective = function(fovy, aspect, near, far, dest) {
        var top = near * Math.tan((fovy * Math.PI) / 360.0),
            right = top * aspect;
        return mat4.frustum(-right, right, -top, top, near, far, dest);
    };

    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.ortho = function(left, right, bottom, top, near, far, dest) {
        if (!dest) {
            dest = mat4.create();
        }
        var rl = right - left,
            tb = top - bottom,
            fn = far - near;
        dest[0] = 2 / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 2 / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = -2 / fn;
        dest[11] = 0;
        dest[12] = -(left + right) / rl;
        dest[13] = -(top + bottom) / tb;
        dest[14] = -(far + near) / fn;
        dest[15] = 1;
        return dest;
    };

    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing "up"
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.lookAt = function(eye, center, up, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        var x0,
            x1,
            x2,
            y0,
            y1,
            y2,
            z0,
            z1,
            z2,
            len,
            eyex = eye[0],
            eyey = eye[1],
            eyez = eye[2],
            upx = up[0],
            upy = up[1],
            upz = up[2],
            centerx = center[0],
            centery = center[1],
            centerz = center[2];

        if (eyex === centerx && eyey === centery && eyez === centerz) {
            return mat4.identity(dest);
        }

        //vec3.direction(eye, center, z);
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;

        // normalize (no check needed for 0 because of early return)
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        //vec3.normalize(vec3.cross(up, z, x));
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        //vec3.normalize(vec3.cross(z, x, y));
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        dest[0] = x0;
        dest[1] = y0;
        dest[2] = z0;
        dest[3] = 0;
        dest[4] = x1;
        dest[5] = y1;
        dest[6] = z1;
        dest[7] = 0;
        dest[8] = x2;
        dest[9] = y2;
        dest[10] = z2;
        dest[11] = 0;
        dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        dest[15] = 1;

        return dest;
    };

    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *
     * @param {quat4} quat Rotation quaternion
     * @param {vec3} vec Translation vector
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to a new mat4
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    /*    mat4.fromRotationTranslation = function (quat, vec, dest) {
     if (!dest) { dest = mat4.create(); }

     // Quaternion math
     var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
     x2 = x + x,
     y2 = y + y,
     z2 = z + z,

     xx = x * x2,
     xy = x * y2,
     xz = x * z2,
     yy = y * y2,
     yz = y * z2,
     zz = z * z2,
     wx = w * x2,
     wy = w * y2,
     wz = w * z2;

     dest[0] = 1 - (yy + zz);
     dest[1] = xy + wz;
     dest[2] = xz - wy;
     dest[3] = 0;
     dest[4] = xy - wz;
     dest[5] = 1 - (xx + zz);
     dest[6] = yz + wx;
     dest[7] = 0;
     dest[8] = xz + wy;
     dest[9] = yz - wx;
     dest[10] = 1 - (xx + yy);
     dest[11] = 0;
     dest[12] = vec[0];
     dest[13] = vec[1];
     dest[14] = vec[2];
     dest[15] = 1;

     return dest;
     };*/

    /**
     * Returns a string representation of a mat4
     *
     * @param {mat4} mat mat4 to represent as a string
     *
     * @returns {string} String representation of mat
     */
    mat4.str = function(mat) {
        return (
            "[" +
            mat[0] +
            ", " +
            mat[1] +
            ", " +
            mat[2] +
            ", " +
            mat[3] +
            ", " +
            mat[4] +
            ", " +
            mat[5] +
            ", " +
            mat[6] +
            ", " +
            mat[7] +
            ", " +
            mat[8] +
            ", " +
            mat[9] +
            ", " +
            mat[10] +
            ", " +
            mat[11] +
            ", " +
            mat[12] +
            ", " +
            mat[13] +
            ", " +
            mat[14] +
            ", " +
            mat[15] +
            "]"
        );
    };

    /**
     * @class Quaternion
     * @name quat4
     */
    var quat4 = {};

    /**
     * Creates a new instance of a quat4 using the default array type
     * Any javascript array containing at least 4 numeric elements can serve as a quat4
     *
     * @param {quat4} [quat] quat4 containing values to initialize with
     *
     * @returns {quat4} New quat4
     */
    quat4.create = function(quat) {
        var dest = new MatrixArray(4);

        if (quat) {
            dest[0] = quat[0];
            dest[1] = quat[1];
            dest[2] = quat[2];
            dest[3] = quat[3];
        } else {
            dest[0] = dest[1] = dest[2] = dest[3] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a quat4, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value
     * @param {number} w W value

     * @returns {quat4} New quat4
     */
    quat4.createFrom = function(x, y, z, w) {
        var dest = new MatrixArray(4);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = w;

        return dest;
    };

    /**
     * Copies the values of one quat4 to another
     *
     * @param {quat4} quat quat4 containing values to copy
     * @param {quat4} dest quat4 receiving copied values
     *
     * @returns {quat4} dest
     */
    quat4.set = function(quat, dest) {
        dest[0] = quat[0];
        dest[1] = quat[1];
        dest[2] = quat[2];
        dest[3] = quat[3];

        return dest;
    };

    /**
     * Compares two quaternions for equality within a certain margin of error
     *
     * @param {quat4} a First vector
     * @param {quat4} b Second vector
     *
     * @returns {Boolean} true if a is equivalent to b
     */
    quat4.equal = function(a, b) {
        return (
            a === b ||
            (Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
                Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
                Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
                Math.abs(a[3] - b[3]) < FLOAT_EPSILON)
        );
    };

    /**
     * Creates a new identity Quat4
     *
     * @param {quat4} [dest] quat4 receiving copied values
     *
     * @returns {quat4} dest is specified, new quat4 otherwise
     */
    quat4.identity = function(dest) {
        if (!dest) {
            dest = quat4.create();
        }
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    //var identityQuat4 = quat4.identity();

    /**
     * Calculates the W component of a quat4 from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
     * Any existing W component will be ignored.
     *
     * @param {quat4} quat quat4 to calculate W component of
     * @param {quat4} [dest] quat4 receiving calculated values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.calculateW = function(quat, dest) {
        var x = quat[0],
            y = quat[1],
            z = quat[2];

        if (!dest || quat === dest) {
            quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
            return quat;
        }
        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
        return dest;
    };

    /**
     * Calculates the dot product of two quaternions
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     *
     * @return {number} Dot product of quat and quat2
     */
    quat4.dot = function(quat, quat2) {
        return (
            quat[0] * quat2[0] +
            quat[1] * quat2[1] +
            quat[2] * quat2[2] +
            quat[3] * quat2[3]
        );
    };

    /**
     * Calculates the inverse of a quat4
     *
     * @param {quat4} quat quat4 to calculate inverse of
     * @param {quat4} [dest] quat4 receiving inverse values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.inverse = function(quat, dest) {
        var q0 = quat[0],
            q1 = quat[1],
            q2 = quat[2],
            q3 = quat[3],
            dot = q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3,
            invDot = dot ? 1.0 / dot : 0;

        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

        if (!dest || quat === dest) {
            quat[0] *= -invDot;
            quat[1] *= -invDot;
            quat[2] *= -invDot;
            quat[3] *= invDot;
            return quat;
        }
        dest[0] = -quat[0] * invDot;
        dest[1] = -quat[1] * invDot;
        dest[2] = -quat[2] * invDot;
        dest[3] = quat[3] * invDot;
        return dest;
    };

    /**
     * Calculates the conjugate of a quat4
     * If the quaternion is normalized, this function is faster than quat4.inverse and produces the same result.
     *
     * @param {quat4} quat quat4 to calculate conjugate of
     * @param {quat4} [dest] quat4 receiving conjugate values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.conjugate = function(quat, dest) {
        if (!dest || quat === dest) {
            quat[0] *= -1;
            quat[1] *= -1;
            quat[2] *= -1;
            return quat;
        }
        dest[0] = -quat[0];
        dest[1] = -quat[1];
        dest[2] = -quat[2];
        dest[3] = quat[3];
        return dest;
    };

    /**
     * Calculates the length of a quat4
     *
     * Params:
     * @param {quat4} quat quat4 to calculate length of
     *
     * @returns Length of quat
     */
    quat4.length = function(quat) {
        var x = quat[0],
            y = quat[1],
            z = quat[2],
            w = quat[3];
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };

    /**
     * Generates a unit quaternion of the same direction as the provided quat4
     * If quaternion length is 0, returns [0, 0, 0, 0]
     *
     * @param {quat4} quat quat4 to normalize
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.normalize = function(quat, dest) {
        if (!dest) {
            dest = quat;
        }

        var x = quat[0],
            y = quat[1],
            z = quat[2],
            w = quat[3],
            len = Math.sqrt(x * x + y * y + z * z + w * w);
        if (len === 0) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
            return dest;
        }
        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        dest[3] = w * len;

        return dest;
    };

    /**
     * Performs quaternion addition
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.add = function(quat, quat2, dest) {
        if (!dest || quat === dest) {
            quat[0] += quat2[0];
            quat[1] += quat2[1];
            quat[2] += quat2[2];
            quat[3] += quat2[3];
            return quat;
        }
        dest[0] = quat[0] + quat2[0];
        dest[1] = quat[1] + quat2[1];
        dest[2] = quat[2] + quat2[2];
        dest[3] = quat[3] + quat2[3];
        return dest;
    };

    /**
     * Performs a quaternion multiplication
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.multiply = function(quat, quat2, dest) {
        if (!dest) {
            dest = quat;
        }

        var qax = quat[0],
            qay = quat[1],
            qaz = quat[2],
            qaw = quat[3],
            qbx = quat2[0],
            qby = quat2[1],
            qbz = quat2[2],
            qbw = quat2[3];

        dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        return dest;
    };

    /**
     * Transforms a vec3 with the given quaternion
     *
     * @param {quat4} quat quat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns dest if specified, vec otherwise
     */
    quat4.multiplyVec3 = function(quat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2],
            qx = quat[0],
            qy = quat[1],
            qz = quat[2],
            qw = quat[3],
            // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return dest;
    };

    /**
     * Multiplies the components of a quaternion by a scalar value
     *
     * @param {quat4} quat to scale
     * @param {number} val Value to scale by
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.scale = function(quat, val, dest) {
        if (!dest || quat === dest) {
            quat[0] *= val;
            quat[1] *= val;
            quat[2] *= val;
            quat[3] *= val;
            return quat;
        }
        dest[0] = quat[0] * val;
        dest[1] = quat[1] * val;
        dest[2] = quat[2] * val;
        dest[3] = quat[3] * val;
        return dest;
    };

    /**
     * Calculates a 4x4 matrix from the given quat4
     *
     * @param {quat4} quat quat4 to create matrix from
     * @param {mat4} [dest] mat4 receiving operation result
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    quat4.toMat4 = function(quat, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        var x = quat[0],
            y = quat[1],
            z = quat[2],
            w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,
            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;

        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;

        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;

        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Performs a spherical linear interpolation between two quat4
     *
     * @param {quat4} quat First quaternion
     * @param {quat4} quat2 Second quaternion
     * @param {number} slerp Interpolation amount between the two inputs
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.slerp = function(quat, quat2, slerp, dest) {
        if (!dest) {
            dest = quat;
        }

        var cosHalfTheta =
                quat[0] * quat2[0] +
                quat[1] * quat2[1] +
                quat[2] * quat2[2] +
                quat[3] * quat2[3],
            halfTheta,
            sinHalfTheta,
            ratioA,
            ratioB;

        if (Math.abs(cosHalfTheta) >= 1.0) {
            if (dest !== quat) {
                dest[0] = quat[0];
                dest[1] = quat[1];
                dest[2] = quat[2];
                dest[3] = quat[3];
            }
            return dest;
        }

        halfTheta = Math.acos(cosHalfTheta);
        sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

        if (Math.abs(sinHalfTheta) < 0.001) {
            dest[0] = quat[0] * 0.5 + quat2[0] * 0.5;
            dest[1] = quat[1] * 0.5 + quat2[1] * 0.5;
            dest[2] = quat[2] * 0.5 + quat2[2] * 0.5;
            dest[3] = quat[3] * 0.5 + quat2[3] * 0.5;
            return dest;
        }

        ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;
        ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;

        dest[0] = quat[0] * ratioA + quat2[0] * ratioB;
        dest[1] = quat[1] * ratioA + quat2[1] * ratioB;
        dest[2] = quat[2] * ratioA + quat2[2] * ratioB;
        dest[3] = quat[3] * ratioA + quat2[3] * ratioB;

        return dest;
    };

    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * If dest is omitted, a new quaternion will be created.
     *
     * @param {mat3}  mat    the rotation matrix
     * @param {quat4} [dest] an optional receiving quaternion
     *
     * @returns {quat4} the quaternion constructed from the rotation matrix
     *
     */
    quat4.fromRotationMatrix = function(mat, dest) {
        if (!dest) dest = quat4.create();

        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".

        var fTrace = mat[0] + mat[4] + mat[8];
        var fRoot;

        if (fTrace > 0.0) {
            // |w| > 1/2, may as well choose w > 1/2
            fRoot = Math.sqrt(fTrace + 1.0); // 2w
            dest[3] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot; // 1/(4w)
            dest[0] = (mat[7] - mat[5]) * fRoot;
            dest[1] = (mat[2] - mat[6]) * fRoot;
            dest[2] = (mat[3] - mat[1]) * fRoot;
        } else {
            // |w| <= 1/2
            var s_iNext = (quat4.fromRotationMatrix.s_iNext = quat4
                .fromRotationMatrix.s_iNext || [1, 2, 0]);
            var i = 0;
            if (mat[4] > mat[0]) i = 1;
            if (mat[8] > mat[i * 3 + i]) i = 2;
            var j = s_iNext[i];
            var k = s_iNext[j];

            fRoot = Math.sqrt(
                mat[i * 3 + i] - mat[j * 3 + j] - mat[k * 3 + k] + 1.0
            );
            dest[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            dest[3] = (mat[k * 3 + j] - mat[j * 3 + k]) * fRoot;
            dest[j] = (mat[j * 3 + i] + mat[i * 3 + j]) * fRoot;
            dest[k] = (mat[k * 3 + i] + mat[i * 3 + k]) * fRoot;
        }

        return dest;
    };

    /**
     * Sets a quat4 to the Identity and returns it.
     *
     * @param {quat4} [dest] quat4 to set. If omitted, a
     * new quat4 will be created.
     *
     * @returns {quat4} dest
     */
    quat4.identity = function(dest) {
        if (!dest) dest = quat4.create();
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    /**
     * Sets a quat4 from the given angle and rotation axis,
     * then returns it. If dest is not given, a new quat4 is created.
     *
     * @param {Number} angle  the angle in radians
     * @param {vec3}   axis   the axis around which to rotate
     * @param {quat4}  [dest] the optional quat4 to store the result
     *
     * @returns {quat4} dest
     **/
    quat4.fromAngleAxis = function(angle, axis, dest) {
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
        if (!dest) dest = quat4.create();

        var half = angle * 0.5;
        var s = Math.sin(half);
        dest[3] = Math.cos(half);
        dest[0] = s * axis[0];
        dest[1] = s * axis[1];
        dest[2] = s * axis[2];

        return dest;
    };

    /**
     * Stores the angle and axis in a vec4, where the XYZ components represent
     * the axis and the W (4th) component is the angle in radians.
     *
     * If dest is not given, src will be modified in place and returned, after
     * which it should not be considered not a quaternion (just an axis and angle).
     *
     * @param {quat4} quat   the quaternion whose angle and axis to store
     * @param {vec4}  [dest] the optional vec4 to receive the data
     *
     * @returns {vec4} dest
     */
    quat4.toAngleAxis = function(src, dest) {
        if (!dest) dest = src;
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)

        var sqrlen = src[0] * src[0] + src[1] * src[1] + src[2] * src[2];
        if (sqrlen > 0) {
            dest[3] = 2 * Math.acos(src[3]);
            var invlen = 1.0 / Math.sqrt(sqrlen);
            dest[0] = src[0] * invlen;
            dest[1] = src[1] * invlen;
            dest[2] = src[2] * invlen;
        } else {
            // angle is 0 (mod 2*pi), so any axis will do
            dest[3] = 0;
            dest[0] = 1;
            dest[1] = 0;
            dest[2] = 0;
        }

        return dest;
    };

    /**
     * Returns a string representation of a quaternion
     *
     * @param {quat4} quat quat4 to represent as a string
     *
     * @returns {string} String representation of quat
     */
    quat4.str = function(quat) {
        return (
            "[" +
            quat[0] +
            ", " +
            quat[1] +
            ", " +
            quat[2] +
            ", " +
            quat[3] +
            "]"
        );
    };

    /*
     * Exports
     */

    window.vec3 = vec3;
    window.mat4 = mat4;
    window.quat4 = quat4;

    return mat4;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/Ray',["./glMatrix"], function() {
    /**************************************************************************************************************/

    /**
	 @name Ray
	 @class
	   Ray constructor
	 @param origin
	 @param dir
	 @constructor
	 */
    var Ray = function(orig, dir) {
        this.orig = orig;
        this.dir = dir;
    };

    /**************************************************************************************************************/

    /**
     * Create a ray from a pixel
     * @function createFromPixel
     * @memberof Ray
     * @param renderContext
     * @param x
     * @param y
     * @return {Ray} Ray
     */
    Ray.createFromPixel = function(renderContext, x, y) {
        // reverse y because (0,0) is top left but opengl's normalized
        // device coordinate (-1,-1) is bottom left
        var nx = (x / renderContext.canvas.width) * 2.0 - 1.0;
        var ny = -((y / renderContext.canvas.height) * 2.0 - 1.0);

        var inverseViewProjectionMatrix = mat4.create();
        mat4.inverse(
            renderContext.viewProjectionMatrix,
            inverseViewProjectionMatrix
        );
        // Transform pos to world using inverse viewProjection matrix
        var pos3D = mat4.multiplyVec4(inverseViewProjectionMatrix, [
            nx,
            ny,
            -1,
            1
        ]);

        pos3D[0] /= pos3D[3];
        pos3D[1] /= pos3D[3];
        pos3D[2] /= pos3D[3];

        // console.log('Old EP ' + renderContext.eyePosition );
        var inverseViewMatrix = mat4.create();
        mat4.inverse(renderContext.viewMatrix, inverseViewMatrix);
        vec3.set([0.0, 0.0, 0.0], renderContext.eyePosition);
        mat4.multiplyVec3(inverseViewMatrix, renderContext.eyePosition);
        // console.log('New EP ' + renderContext.eyePosition );

        var orig = vec3.create(renderContext.eyePosition);
        var dir = vec3.subtract(
            pos3D,
            renderContext.eyePosition,
            vec3.create()
        );
        vec3.normalize(dir);

        return new Ray(orig, dir);
    };

    /**************************************************************************************************************/

    /**
     * Create a ray from an event
     * @function createFromEvent
     * @memberof Ray
     * @param renderContext
     * @param event
     * @return {Ray} Ray
     */
    Ray.createFromEvent = function(renderContext, event) {
        var pos = renderContext.getXYRelativeToCanvas(event);
        return Ray.createFromPixel(pos[0], pos[1]);
    };

    /**************************************************************************************************************/

    /**
     * Intersection object returned
     * @function Intersection
     * @memberof Ray
     * @param t
     */
    Ray.Intersection = function(t) {
        this.t = t;
        this.geometry = null;
    };

    /**************************************************************************************************************/

    /**
     * Compute a point on the ray given its t parameter
     * @function computePoint
     * @memberof Ray.prototype
     * @param t
     * @return Point
     */
    Ray.prototype.computePoint = function(t) {
        var pt = vec3.create();
        vec3.scale(this.dir, t, pt);
        vec3.add(pt, this.orig);
        return pt;
    };

    /**************************************************************************************************************/

    /**
     *	Compute intersection between a plan and ray
     * @function planeIntersect
     * @memberof Ray.prototype
     * @param {vec3} pt
     * @param {vec3} normal
     * @return {number}The nearest intersection, < 0 if no intersection
     */
    Ray.prototype.planeIntersect = function(pt, normal) {
        // Assuming vectors are all normalized
        var denom = vec3.dot(normal, this.dir);
        var epsilon = 1e-6;
        if (Math.abs(denom) > epsilon) {
            var p0l0 = vec3.create();
            vec3.subtract(pt, this.orig, p0l0);
            var t = vec3.dot(p0l0, normal) / denom;
            return t;
        }
        return -1;
    };

    /**************************************************************************************************************/

    /**
     * Compute intersection between a sphere and ray
     * @function sphereIntersect
     * @memberof Ray.prototype
     * @param center
     * @param radius
     * @return the nearest intersection, < 0 if no intersection
     */
    Ray.prototype.sphereIntersect = function(center, radius) {
        // cf. http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection

        var rs = vec3.subtract(this.orig, center, vec3.create());
        // rayDirection is normalized so a = 1
        // var a = vec3.dot(rayDirection, rayDirection);
        var b = 2.0 * vec3.dot(this.dir, rs);
        var c = vec3.dot(rs, rs) - radius * radius;

        // as a == 1, discriminant = b^2 - (4*c)
        // var discr = (b*b) - (4*a*c);
        var discr = b * b - 4 * c;
        if (discr < 0) {
            return -1;
        }

        // t0 = (-b - sqrt(discr)) / 2a, t1 = (-b + sqrt(discr)) / 2a, a == 1
        discr = Math.sqrt(discr);
        var tNear = (-b - discr) / 2;
        var tFar = (-b + discr) / 2;
        if (tNear > tFar) {
            // Swap t values
            var tmp = tNear;
            tNear = tFar;
            tFar = tmp;
        }

        if (tFar < 0) {
            // Hit is beyond ray origin
            return -1;
        }

        return tNear < 0 ? tFar : tNear;
    };

    /**************************************************************************************************************/

    var EPS = 1e-15;
    /**
  * Ray triangle intersection optimized
  * @function triangleIntersectOptimized
  * @memberof Ray.prototype
  * @param verts
  * @param i0
  * @param i1
  * @param i2
  * @return the nearest intersection, null if no intersection

  */
    Ray.prototype.triangleIntersectOptimized = function(verts, i0, i1, i2) {
        var e1x = verts[i1] - verts[i0];
        var e1y = verts[i1 + 1] - verts[i0 + 1];
        var e1z = verts[i1 + 2] - verts[i0 + 2];

        var e2x = verts[i2] - verts[i0];
        var e2y = verts[i2 + 1] - verts[i0 + 1];
        var e2z = verts[i2 + 2] - verts[i0 + 2];

        var px = this.dir[1] * e2z - this.dir[2] * e2y;
        var py = this.dir[2] * e2x - this.dir[0] * e2z;
        var pz = this.dir[0] * e2y - this.dir[1] * e2x;

        var det = e1x * px + e1y * py + e1z * pz;

        if (det > -EPS && det < EPS) {
            return null;
        }

        var inv_det = 1.0 / det;

        var tx = this.orig[0] - verts[i0];
        var ty = this.orig[1] - verts[i0 + 1];
        var tz = this.orig[2] - verts[i0 + 2];

        var u = (tx * px + ty * py + tz * pz) * inv_det;
        if (u < 0.0 || u > 1.0) {
            return null;
        }

        var qx = ty * e1z - tz * e1y;
        var qy = tz * e1x - tx * e1z;
        var qz = tx * e1y - ty * e1x;

        var v =
            (this.dir[0] * qx + this.dir[1] * qy + this.dir[2] * qz) * inv_det;
        if (v < 0.0 || u + v > 1.0) {
            return null;
        }

        var t = (e2x * qx + e2y * qy + e2z * qz) * inv_det;
        if (t >= 0) {
            return new Ray.Intersection(t);
        } else {
            return null;
        }
    };

    /**************************************************************************************************************/

    /**
     * @function nodeIntersect
     * @memberof Ray.prototype
     * @param node
     * @param intersects
     * @return Intersects
     */
    Ray.prototype.nodeIntersect = function(node, intersects) {
        var i;
        intersects = intersects || [];

        for (i = 0; i < node.children.length; i++) {
            node.children[i].intersectWith(this, intersects);
        }

        for (i = 0; i < node.geometries.length; i++) {
            this.geometryIntersect(node.geometries[i], intersects);
        }

        intersects.sort(function(a, b) {
            return a.t - b.t;
        });
        return intersects;
    };

    /**
     * @function lodNodeIntersect
     * @memberof Ray.prototype
     * @param node
     * @param intersects
     * @return Intersects
     */
    Ray.prototype.lodNodeIntersect = function(node, intersects) {
        var i;
        intersects = intersects || [];

        if (this.sphereIntersect(node.center, node.radius) >= 0) {
            if (node.children.length > 0 && node.childToLoad === 0) {
                for (i = 0; i < node.children.length; i++) {
                    this.lodNodeIntersect(node.children[i], intersects);
                }
            } else {
                for (i = 0; i < node.geometries.length; i++) {
                    this.geometryIntersect(node.geometries[i], intersects);
                }
            }
        }

        return intersects;
    };

    /**
     * @function geometryIntersect
     * @memberof Ray.prototype
     * @param geometry
     * @param intersects
     * @return Intersects
     */
    Ray.prototype.geometryIntersect = function(geometry, intersects) {
        var indices = geometry.mesh.indices;
        for (var i = 0; i < indices.length; i += 3) {
            var intersect = this.triangleIntersectOptimized(
                geometry.mesh.vertices,
                geometry.mesh.numElements * indices[i],
                geometry.mesh.numElements * indices[i + 1],
                geometry.mesh.numElements * indices[i + 2]
            );

            if (intersect) {
                intersect.geometry = geometry;
                intersects.push(intersect);
            }
        }
    };

    return Ray;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to measure the distance between two points in planet mode
 */

define('gw/Services/MeasureToolPlanetCore',[
    "jquery",
    "underscore-min",
    "../Utils/Constants",
    "../Layer/VectorLayer",
    "../Renderer/Ray",
    "../Utils/Numeric",
    "../Renderer/FeatureStyle",
    "../Renderer/glMatrix"
], function($, _, Constants, VectorLayer, Ray, Numeric, FeatureStyle) {
    var navigation, mizarAPI, onselect, measureLayer, self, dragging;

    /**********************************************************************************************/

    /**
     * Get first Geo pick point in terms of cursor position
     * @param event
     * @returns {Array} geoPickPoint geo position on the planet
     */
    function _handleMouseDown(event) {
        event.preventDefault();
        if (!self.activated) {
            return;
        }

        navigation.stop();

        dragging = true;
        self.elevations = [];

        if (event.type.search("touch") >= 0) {
            self.pickPoint = [
                event.changedTouches[0].clientX,
                event.changedTouches[0].clientY
            ];
        } else {
            self.pickPoint = [event.layerX, event.layerY];
        }
        var geo = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(self.pickPoint[0], self.pickPoint[1]);
        if (geo !== null) {
            self.geoPickPoint = geo;
        } else {
            return null;
        }
        return self.geoPickPoint;
    }

    /**
     * Close the measure with the last point
     * @param event
     */
    function _handleMouseUp(event) {
        event.preventDefault();

        // Compute geo radius
        var stopPickPoint;
        if (event.type.search("touch") >= 0) {
            stopPickPoint = mizarAPI
                .getActivatedContext()
                .getLonLatFromPixel(
                    event.changedTouches[0].clientX,
                    event.changedTouches[0].clientY
                );
        } else {
            stopPickPoint = mizarAPI
                .getActivatedContext()
                .getLonLatFromPixel(event.layerX, event.layerY);
        }

        // No point found, picking was not on planet but sky
        if (!_.isEmpty(stopPickPoint)) {
            // Find angle between start and stop vectors which is in fact the radius
            var dotProduct = vec3.dot(
                vec3.normalize(mizarAPI.getCrs().get3DFromWorld(stopPickPoint)),
                vec3.normalize(
                    mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint)
                )
            );
            var theta = Math.acos(dotProduct);
            self.geoDistance = Numeric.toDegree(theta);

            if (onselect) {
                onselect();
            }
        }
        navigation.start();
        dragging = false;
    }

    /**
     * Update drawing and label in terms of current point
     * @param event
     */
    function _handleMouseMove(event) {
        event.preventDefault();
        if (!self.activated || !dragging) {
            return;
        }
        if (event.type.search("touch") >= 0) {
            self.secondPickPoint = [
                event.changedTouches[0].clientX,
                event.changedTouches[0].clientY
            ];
        } else {
            self.secondPickPoint = [event.layerX, event.layerY];
        }

        var geo = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(
                self.secondPickPoint[0],
                self.secondPickPoint[1]
            );
        if (geo !== null) {
            self.secondGeoPickPoint = mizarAPI
                .getActivatedContext()
                .getLonLatFromPixel(
                    self.secondPickPoint[0],
                    self.secondPickPoint[1]
                );
        } else {
            return;
        }
        //self.storeDistanceAndElevation(self.geoPickPoint, self.secondGeoPickPoint);

        // Update radius
        self.distance = Math.sqrt(
            Math.pow(self.secondPickPoint[0] - self.pickPoint[0], 2) +
                Math.pow(self.secondPickPoint[1] - self.pickPoint[1], 2)
        );
        var dotProduct;
        if (self.secondGeoPickPoint === undefined) {
            dotProduct = vec3.dot(
                vec3.normalize(
                    mizarAPI.getCrs().get3DFromWorld(self.secondPickPoint)
                ),
                vec3.normalize(
                    mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint)
                )
            );
        } else {
            dotProduct = vec3.dot(
                vec3.normalize(
                    mizarAPI.getCrs().get3DFromWorld(self.secondGeoPickPoint)
                ),
                vec3.normalize(
                    mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint)
                )
            );
        }
        var theta = Math.acos(dotProduct);
        self.geoDistance = Numeric.toDegree(theta);

        updateMeasure();
    }

    /**********************************************************************************************/

    function rotateVector2D(vec, theta) {
        theta = Numeric.toRadian(theta);
        var cs = Math.cos(theta);
        var sn = Math.sin(theta);

        return [vec[0] * cs - vec[1] * sn, vec[0] * sn + vec[1] * cs];
    }

    function normalize2D(vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var length = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
        dest[0] = vec[0] / length;
        dest[1] = vec[1] / length;
        return dest;
    }

    /**********************************************************************************************/

    /**
     * Computes the measure for the given pick point depending on the second point (used to draw)
     * @returns {Array} points to draw
     */
    function computeMeasure() {
        var geoDiff = [
            self.secondGeoPickPoint[0] - self.geoPickPoint[0],
            self.secondGeoPickPoint[1] - self.geoPickPoint[1],
            0
        ];
        var diff = vec3.create(geoDiff);
        var length = vec3.length(diff);
        vec3.normalize(diff);
        vec3.scale(diff, length * 0.001);

        // First arrow
        var arrow = rotateVector2D(diff, 30);
        var arrow2 = rotateVector2D(diff, -30);
        arrow = [
            self.geoPickPoint[0] + 10 * arrow[0],
            self.geoPickPoint[1] + 10 * arrow[1]
        ];
        arrow2 = [
            self.geoPickPoint[0] + 10 * arrow2[0],
            self.geoPickPoint[1] + 10 * arrow2[1]
        ];

        // Second arrow
        var diff2 = [-diff[0], -diff[1]];
        var arrow3 = rotateVector2D(diff2, 30);
        var arrow4 = rotateVector2D(diff2, -30);
        arrow3 = [
            self.secondGeoPickPoint[0] + 10 * arrow3[0],
            self.secondGeoPickPoint[1] + 10 * arrow3[1]
        ];
        arrow4 = [
            self.secondGeoPickPoint[0] + 10 * arrow4[0],
            self.secondGeoPickPoint[1] + 10 * arrow4[1]
        ];

        var points = [
            [arrow[0], arrow[1], null],
            [self.geoPickPoint[0], self.geoPickPoint[1], null],
            [arrow2[0], arrow2[1], null],
            [self.geoPickPoint[0], self.geoPickPoint[1], null],
            [self.secondGeoPickPoint[0], self.secondGeoPickPoint[1], null],
            [arrow3[0], arrow3[1], null],
            [self.secondGeoPickPoint[0], self.secondGeoPickPoint[1], null],
            [arrow4[0], arrow4[1], null]
        ];
        return points;
    }

    /**********************************************************************************************/

    function remove() {
        self.clear();
        mizarAPI.getPlanetContext().removeDraw(measureLayer);
    }

    function createGeoJsonMeasurement(coordinates) {
        return {
            geometry: {
                gid: "measureShape",
                coordinates: coordinates,
                type: Constants.GEOMETRY.LineString,
                crs: {
                    type: "name",
                    properties: {
                        name: mizarAPI.getCrs().getGeoideName()
                    }
                }
            },
            properties: {
                style: new FeatureStyle({
                    fillColor: [1, 0, 0, 1],
                    zIndex: Constants.DISPLAY.SERVICE_VECTOR
                })
            },
            type: "Feature"
        };
    }

    function createGeoJsonLabel(geoCenter, distance) {
        return {
            geometry: {
                type: Constants.GEOMETRY.Point,
                gid: "measureShape",
                coordinates: geoCenter,
                crs: {
                    type: "name",
                    properties: {
                        name: mizarAPI.getCrs().getGeoideName()
                    }
                }
            },
            properties: {
                style: new FeatureStyle({
                    label: distance + " km",
                    fillColor: [1, 1, 1, 1],
                    pointMaxSize: 600,
                    zIndex: Constants.DISPLAY.SERVICE_VECTOR
                })
            }
        };
    }

    /**
     *    Updates measure coordinates
     */
    function updateMeasure() {
        self.clear();

        // Create elevation
        var firstPoint = self.geoPickPoint;
        var secondPoint = self.secondGeoPickPoint;

        // Create measurement and  apply elevation to all point of displayed arrow
        var coordinates = self.computeMeasure();
        self.measureFeature = createGeoJsonMeasurement(coordinates);

        // Create measurement label
        var center = [
            (self.secondPickPoint[0] + self.pickPoint[0]) / 2,
            (self.secondPickPoint[1] + self.pickPoint[1]) / 2
        ];
        var geoCenter = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(center[0], center[1]);
        var distance = self.calculateDistanceElevation(
            self.geoPickPoint,
            self.secondGeoPickPoint
        );
        distance = Numeric.roundNumber(distance.toFixed(3), 2);
        self.measureLabel = createGeoJsonLabel(geoCenter, distance);

        // add measurement and label to the the GeoJson collection
        measureLayer.addFeature(self.measureFeature);
        measureLayer.addFeature(self.measureLabel);
    }

    /**************************************************************************************************************/

    /**
     *    Clear measureFeature and measureLabel
     */
    function clear() {
        if (self.measureFeature) {
            measureLayer.removeFeature(self.measureFeature);
        }
        if (self.measureLabel) {
            measureLayer.removeFeature(self.measureLabel);
        }
    }

    /**************************************************************************************************************/

    /**
     * Calculate intermediaries elevation points to increase drawing precision
     *
     * @param {Object} options
     *              <ul>
     *                  <li>nbPoints : number of intermediary points to compute</li>
     *              </ul>
     * @param {Array} firstPoint
     * @param {Array} secondPoint
     * @return {Array} intermediatePoints
     */
    function calculateIntermediateElevationPoint(
        options,
        firstPoint,
        secondPoint
    ) {
        var nbPoints = options.nbPoints | 50;
        var deltaX = firstPoint[0] - secondPoint[0];
        var intervalX;
        if (deltaX > 180.0) {
            deltaX = 360.0 - deltaX;
            intervalX = -deltaX / nbPoints;
        } else if (deltaX < -180.0) {
            deltaX = 360.0 + deltaX;
            intervalX = deltaX / nbPoints;
        } else {
            intervalX = deltaX / nbPoints;
        }
        var intervalY = (firstPoint[1] - secondPoint[1]) / nbPoints;

        var intermediatePoints = [];
        intermediatePoints[0] = firstPoint;
        for (var i = 1; i < nbPoints; i++) {
            var x = intermediatePoints[i - 1][0] - intervalX;
            if (x > 180.0) {
                x = x - 360;
            } else if (x < -180.0) {
                x = x + 360;
            }
            var y = intermediatePoints[i - 1][1] - intervalY;
            intermediatePoints[i] = [x, y];
        }
        intermediatePoints[nbPoints] = secondPoint;
        return intermediatePoints;
    }

    /**
     * Calculate distance elevation from a point
     *
     * url calcul distance : http://www.movable-type.co.uk/scripts/latlong.html
     *
     * @param {Array} firstPoint
     * @param {Array} secondPoint
     * @returns {number} distance elevation in kilometers
     */
    function calculateDistanceElevation(firstPoint, secondPoint) {
        var R = mizarAPI
            .getCrs()
            .getGeoide()
            .getRealPlanetRadius();
        var phi1 = Numeric.toRadian(firstPoint[1]);
        var phi2 = Numeric.toRadian(secondPoint[1]);
        var delta_phi = Numeric.toRadian(secondPoint[1] - firstPoint[1]);
        var delta_lambda = Numeric.toRadian(secondPoint[0] - firstPoint[0]);

        var a =
            Math.sin(delta_phi / 2) * Math.sin(delta_phi / 2) +
            Math.cos(phi1) *
                Math.cos(phi2) *
                Math.sin(delta_lambda / 2) *
                Math.sin(delta_lambda / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        var distance = R * c;

        return distance / 1000;
    }

    /**
     * Calculate distance and elevation for a given point and store it
     * @param {Array} firstPoint
     * @param {Array} secondPoint
     */
    function storeDistanceAndElevation(firstPoint, secondPoint) {
        var distance = self.calculateDistanceElevation(firstPoint, secondPoint);
        distance = Numeric.roundNumber(distance.toFixed(3), 2);

        var elevation = mizarAPI
            .getActivatedContext()
            .getElevation(secondPoint[0], secondPoint[1]);
        var scale = mizarAPI
            .getActivatedContext()
            .getBaseElevation()
            .getScale();
        elevation = Numeric.roundNumber(elevation / scale, 0);
        var pointElevation = [distance, elevation];

        self.elevations.push(pointElevation);
    }

    /**
     * Updates Mizar context
     * @param {Mizar} mizar
     * @fires Context#backgroundLayer:added
     * @fires Context#layer:added
     */
    function updateContext(mizar) {
        mizarAPI = mizar;
        navigation = mizarAPI.getActivatedContext().getNavigation();
        dragging = false;

        // Layer containing measure feature
        if (!measureLayer) {
            measureLayer = new VectorLayer();
        }
        mizarAPI.getPlanetContext().addDraw(measureLayer);

        this.activated = false;
        this.renderContext = mizarAPI.getRenderContext();

        this.elevations = [];
        this.measureFeature = null;
    }

    return {
        init: function(options) {
            mizarAPI = options.mizar;
            navigation = mizarAPI.getActivatedContext().getNavigation();
            onselect = options.onselect;
            self = this;
            dragging = false;

            // Layer containing measure feature
            measureLayer = mizarAPI.LayerFactory.create({
                type: Constants.LAYER.Vector,
                visible: true
            });
            mizarAPI.getPlanetContext().addDraw(measureLayer);

            this.activated = false;
            this.renderContext = mizarAPI.getRenderContext();

            this.elevations = [];
            this.measureFeature = null;
        },
        _handleMouseDown: _handleMouseDown,
        _handleMouseUp: _handleMouseUp,
        _handleMouseMove: _handleMouseMove,
        clear: clear,
        remove: remove,
        updateContext: updateContext,
        calculateIntermediateElevationPoint: calculateIntermediateElevationPoint,
        calculateDistanceElevation: calculateDistanceElevation,
        computeMeasure: computeMeasure,
        storeDistanceAndElevation: storeDistanceAndElevation
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to measure the distance between two points in planet mode
 */

define('gw/Services/MeasureToolSkyCore',[
    "jquery",
    "underscore-min",
    "../Utils/Numeric",
    "../Utils/Constants",
    "../Layer/VectorLayer",
    "../Renderer/Ray",
    "../Renderer/FeatureStyle",
    "../Renderer/glMatrix"
], function($, _, Numeric, Constants, VectorLayer, Ray, FeatureStyle) {
    var mizarAPI, navigation, onselect, measureLayer, self, dragging;

    /**********************************************************************************************/

    /**
     * Get first Geo pick point in terms of cursor position
     * @param event
     * @returns {Array} geoPickPoint geo position on the planet
     */
    function _handleMouseDown(event) {
        event.preventDefault();
        if (!self.activated) {
            return;
        }

        self.distance = 0;
        // Disable standard navigation events
        navigation.stop();

        dragging = true;
        self.elevations = [];

        if (event.type.search("touch") >= 0) {
            self.pickPoint = [
                event.changedTouches[0].clientX,
                event.changedTouches[0].clientY
            ];
        } else {
            self.pickPoint = [event.layerX, event.layerY];
        }
        self.geoPickPoint = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(self.pickPoint[0], self.pickPoint[1]);
    }

    /**
     * Close the measure with the last point
     * @param event
     */
    function _handleMouseUp(event) {
        event.preventDefault();
        if (!self.activated) {
            return;
        }

        // Compute geo radius
        var stopPickPoint;
        if (event.type.search("touch") >= 0) {
            stopPickPoint = mizarAPI
                .getActivatedContext()
                .getLonLatFromPixel(
                    event.changedTouches[0].clientX,
                    event.changedTouches[0].clientY
                );
        } else {
            stopPickPoint = mizarAPI
                .getActivatedContext()
                .getLonLatFromPixel(event.layerX, event.layerY);
        }

        // Find angle between start and stop vectors which is in fact the radius
        var dotProduct = vec3.dot(
            vec3.normalize(mizarAPI.getCrs().get3DFromWorld(stopPickPoint)),
            vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint))
        );
        var theta = Math.acos(dotProduct);
        self.geoDistance = Numeric.toDegree(theta);

        if (onselect) {
            onselect();
        }

        // Enable standard navigation events
        navigation.start();
        dragging = false;
    }

    /**
     * Update drawing and label in terms of current point
     * @param event
     */
    function _handleMouseMove(event) {
        event.preventDefault();
        if (!self.activated || !dragging) {
            return;
        }
        if (event.type.search("touch") >= 0) {
            self.secondPickPoint = [
                event.changedTouches[0].clientX,
                event.changedTouches[0].clientY
            ];
        } else {
            self.secondPickPoint = [event.layerX, event.layerY];
        }

        self.secondGeoPickPoint = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(
                self.secondPickPoint[0],
                self.secondPickPoint[1]
            );

        //self.storeDistanceAndElevation(self.geoPickPoint, self.secondGeoPickPoint);

        // Update radius
        self.distance = Math.sqrt(
            Math.pow(self.secondPickPoint[0] - self.pickPoint[0], 2) +
                Math.pow(self.secondPickPoint[1] - self.pickPoint[1], 2)
        );
        var dotProduct = vec3.dot(
            vec3.normalize(
                mizarAPI.getCrs().get3DFromWorld(self.secondGeoPickPoint)
            ),
            vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint))
        );

        var theta = Math.acos(dotProduct);
        self.geoDistance = Numeric.toDegree(theta);

        self.updateMeasure();
    }

    /**************************************************************************************************************/

    /**
     * Transform coordinates to the right world space dimension
     * @param points
     * @returns {Array} points  points transformed
     */
    function computeIntersection(points) {
        var rc = self.renderContext;
        var tmpMat = mat4.create();

        // Computes eye in world space
        mat4.inverse(rc.viewMatrix, tmpMat);
        var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];

        // Computes the inverse of view/proj matrix
        mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
        mat4.inverse(tmpMat);

        // Transforms the four corners of measured shape into world space
        // and then for each corner computes the intersection of ray starting from the eye to the sphere
        var worldCenter = [0, 0, 0];
        for (var i = 0; i < points.length; i++) {
            mat4.multiplyVec4(tmpMat, points[i]);
            vec3.scale(points[i], 1.0 / points[i][3]);
            vec3.subtract(points[i], eye, points[i]);
            vec3.normalize(points[i]);

            var ray = new Ray(eye, points[i]);
            var pos3d = ray.computePoint(
                ray.sphereIntersect(
                    worldCenter,
                    mizarAPI
                        .getCrs()
                        .getGeoide()
                        .getRadius()
                )
            );
            points[i] = mizarAPI.getCrs().getWorldFrom3D(pos3d);
        }

        return points;
    }

    /**********************************************************************************************/

    function rotateVector2D(vec, theta) {
        theta = (theta * Math.PI) / 180;
        var cs = Math.cos(theta);
        var sn = Math.sin(theta);

        return [vec[0] * cs - vec[1] * sn, vec[0] * sn + vec[1] * cs];
    }

    function normalize2D(vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var length = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
        dest[0] = vec[0] / length;
        dest[1] = vec[1] / length;
        return dest;
    }

    /**********************************************************************************************/

    /**
     * Computes the measure for the given pick point depending on the second point (used to draw)
     * @returns {Array} points to draw
     */
    function computeMeasure() {
        var rc = self.renderContext;
        // Scale to [-1,1]
        var widthScale = 2 / rc.canvas.width;
        var heightScale = 2 / rc.canvas.height;

        var diff = [
            self.secondPickPoint[0] - self.pickPoint[0],
            self.secondPickPoint[1] - self.pickPoint[1]
        ];
        normalize2D(diff);

        // First arrow
        var arrow = rotateVector2D(diff, 30);
        var arrow2 = rotateVector2D(diff, -30);
        arrow = [
            self.pickPoint[0] + 10 * arrow[0],
            self.pickPoint[1] + 10 * arrow[1]
        ];
        arrow2 = [
            self.pickPoint[0] + 10 * arrow2[0],
            self.pickPoint[1] + 10 * arrow2[1]
        ];

        var diff2 = [-diff[0], -diff[1]];
        var arrow3 = rotateVector2D(diff2, 30);
        var arrow4 = rotateVector2D(diff2, -30);
        arrow3 = [
            self.secondPickPoint[0] + 10 * arrow3[0],
            self.secondPickPoint[1] + 10 * arrow3[1]
        ];
        arrow4 = [
            self.secondPickPoint[0] + 10 * arrow4[0],
            self.secondPickPoint[1] + 10 * arrow4[1]
        ];

        var points = [
            [
                self.pickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.pickPoint[1]) * heightScale - 1,
                1,
                1
            ],
            [
                arrow[0] * widthScale - 1,
                (rc.canvas.height - arrow[1]) * heightScale - 1,
                1,
                1
            ],
            [
                self.pickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.pickPoint[1]) * heightScale - 1,
                1,
                1
            ],
            [
                arrow2[0] * widthScale - 1,
                (rc.canvas.height - arrow2[1]) * heightScale - 1,
                1,
                1
            ],
            [
                self.pickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.pickPoint[1]) * heightScale - 1,
                1,
                1
            ],
            [
                self.secondPickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.secondPickPoint[1]) * heightScale - 1,
                1,
                1
            ],
            [
                arrow3[0] * widthScale - 1,
                (rc.canvas.height - arrow3[1]) * heightScale - 1,
                1,
                1
            ],
            [
                self.secondPickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.secondPickPoint[1]) * heightScale - 1,
                1,
                1
            ],
            [
                arrow4[0] * widthScale - 1,
                (rc.canvas.height - arrow4[1]) * heightScale - 1,
                1,
                1
            ],
            [
                self.secondPickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.secondPickPoint[1]) * heightScale - 1,
                1,
                1
            ]
        ];

        this.computeIntersection(points);
        return points;
    }

    /**********************************************************************************************/

    /**
     *    Updates measure coordinates
     */
    function updateMeasure() {
        self.clear();

        var coordinates = self.computeMeasure();

        // Close the polygon
        coordinates.push(coordinates[0]);

        self.measureFeature = {
            geometry: {
                gid: "measureShape",
                coordinates: [coordinates],
                type: Constants.GEOMETRY.Polygon,
                crs: {
                    type: "name",
                    properties: {
                        name: mizarAPI.getCrs().getGeoideName()
                    }
                }
            },
            properties: {
                style: new FeatureStyle({
                    zIndex: Constants.DISPLAY.SERVICE_VECTOR,
                    fillColor: [1, 0, 0, 1]
                })
            },
            type: "Feature"
        };

        var center = [
            (self.secondPickPoint[0] + self.pickPoint[0]) / 2,
            (self.secondPickPoint[1] + self.pickPoint[1]) / 2
        ];
        var geoCenter = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(center[0], center[1]);
        self.measureLabel = {
            geometry: {
                type: Constants.GEOMETRY.Point,
                gid: "measureShape",
                coordinates: geoCenter,
                crs: {
                    type: "name",
                    properties: {
                        name: mizarAPI.getCrs().getGeoideName()
                    }
                }
            },
            properties: {
                style: new FeatureStyle({
                    label: mizarAPI.getCrs().fromDegreesToDMS(self.geoDistance),
                    fillColor: [1, 1, 1, 1],
                    zIndex: Constants.DISPLAY.SERVICE_VECTOR
                })
            }
        };
        var msg =
            "Distance :" +
            self.geoDistance +
            " at " +
            coordinates[0][0] +
            "," +
            coordinates[0][1] +
            "," +
            coordinates[0][2];
        measureLayer.addFeature(self.measureFeature);
        measureLayer.addFeature(self.measureLabel);
    }

    /**************************************************************************************************************/

    /**
     *    Clear measureFeature and measureLabel
     */
    function clear() {
        if (self.measureFeature) {
            measureLayer.removeFeature(self.measureFeature);
        }
        if (self.measureLabel) {
            measureLayer.removeFeature(self.measureLabel);
        }
    }

    function remove() {
        self.clear();
        mizarAPI.getSkyContext().removeDraw(measureLayer);
    }

    return {
        /**
         * @fires Context#backgroundLayer:added
         * @fires Context#layer:added
         */
        init: function(options) {
            mizarAPI = options.mizar;
            navigation = mizarAPI.getActivatedContext().getNavigation();
            onselect = options.onselect;
            self = this;
            dragging = false;

            // Layer containing measure feature
            measureLayer = mizarAPI.LayerFactory.create({
                type: Constants.LAYER.Vector,
                visible: true
            });
            mizarAPI.getSkyContext().addDraw(measureLayer);

            this.activated = false;
            this.renderContext = mizarAPI.getRenderContext();

            // Measure attributes
            /*this.pickPoint; // Window pick point
                this.secondPickPoint; // Window second pick point
                this.geoPickPoint; // Pick point in geographic reference
                this.secondGeoPickPoint; // Pick point in geographic reference
                this.measureLabel;
                */
            this.elevations = [];
            this.measureFeature = null;
        },
        _handleMouseDown: _handleMouseDown,
        _handleMouseUp: _handleMouseUp,
        _handleMouseMove: _handleMouseMove,
        updateMeasure: updateMeasure,
        clear: clear,
        remove: remove,
        computeMeasure: computeMeasure,
        computeIntersection: computeIntersection
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/MocLayer',[
    "jquery",
    "underscore-min",
    "./AbstractLayer",
    "../Utils/Constants",
    "../Renderer/FeatureStyle",
    "../Utils/Utils",
    "../Tiling/HEALPixBase",
    "./FitsLoader",
    "../Gui/dialog/ErrorDialog"
], function(
    $,
    _,
    AbstractLayer,
    Constants,
    FeatureStyle,
    Utils,
    HEALPixBase,
    FitsLoader,
    ErrorDialog
) {
    /**
     * MocLayer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.moc_configuration
     * @property {string} baseUrl - service URL
     * @property {int} [startOrder = 2] - Starting order of HEALPix tiling
     * @property {Object} [style] - See {@link FeatureStyle} description
     */
    /**
     * @name MocLayer
     * @class
     * This layer draws a MOC data
     * @augments AbstractLayer
     * @param {AbstractLayer.moc_configuration} options - Moc layer configuration
     * @memberof module:Layer
     * @see {@link http://www.ivoa.net/documents/MOC/20140602/index.html Moc}
     */
    var MocLayer = function(options) {
        options.dataType = Constants.GEOMETRY.LineString;
        AbstractLayer.prototype.constructor.call(
            this,
            Constants.LAYER.Moc,
            options
        );

        this.baseUrl = this.allowRequest(options.baseUrl);
        this.startOrder = options.startOrder || 2;

        if (options.coordinateSystem && options.coordinateSystem.geoideName) {
            this.crs = {
                properties: {
                    name: options.coordinateSystem.geoideName
                }
            };
        } else {
            this.crs = {
                properties: {
                    name: "Equatorial"
                }
            };
        }

        // Set style
        if (options && options.style) {
            this.style = new FeatureStyle(options.style);
        } else {
            this.style = new FeatureStyle();
        }

        this.featuresSet = null;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, MocLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof MocLayer#
     */
    MocLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.VECTOR;
    };

    /**
     * Attaches the layer to the planet
     * @function _attach
     * @memberof MocLayer#
     * @param g Planet
     * @protected
     */
    MocLayer.prototype._attach = function(g) {
        AbstractLayer.prototype._attach.call(this, g);

        var self = this;
        var i;

        try {
            FitsLoader.loadFits(self.baseUrl, function(fits) {
                var healpixMoc = {};
                var binaryTable = fits.getHDU(1).data;

                // setting startOrder with first order in dataTable
                //self.startOrder = uniq2hpix(binaryTable.getRow(0)[binaryTable.columns[0]])[0];

                for (i = 0; i < binaryTable.rows; i++) {
                    var uniq = binaryTable.getRow(i);
                    var hpix = HEALPixBase.uniq2hpix(
                        uniq[binaryTable.columns[0]]
                    );

                    var order = hpix[0];
                    if (healpixMoc[order] === undefined) {
                        healpixMoc[order] = [];
                    }
                    healpixMoc[order].push(hpix[1]);
                }
                // MIZAR CANNOT display MOC with order less than 3, convert the current moc to a moc starting a order 3
                if (
                    healpixMoc.hasOwnProperty("0") ||
                    healpixMoc.hasOwnProperty("1") ||
                    healpixMoc.hasOwnProperty("2")
                ) {
                    for (i = 0; i < 3; i++) {
                        if (healpixMoc.hasOwnProperty(i)) {
                            var pixels = healpixMoc[i];
                            _.each(pixels, function(pixel) {
                                var pix = HEALPixBase.getChildren(pixel);
                                if (!healpixMoc.hasOwnProperty(i + 1)) {
                                    healpixMoc[i + 1] = [];
                                }
                                healpixMoc[i + 1].push(pix[0]);
                                healpixMoc[i + 1].push(pix[1]);
                                healpixMoc[i + 1].push(pix[2]);
                                healpixMoc[i + 1].push(pix[3]);
                            });
                            delete healpixMoc[i];
                        }
                    }
                }
                self.moc = healpixMoc;
                self.handleDistribution(healpixMoc);
                fits = null;
                //delete fits;
            });
        } catch (e) {
            Utils.requestUrl(
                self.baseUrl,
                "json",
                "application/json",
                null,
                function(response) {
                    self.handleDistribution(response);
                },
                function(err) {
                    $("#addLayer_" + self.id)
                        .find("label")
                        .css("color", "red");
                    ErrorDialog.open(
                        Constants.LEVEL.ERROR,
                        "Failed ot request " + self.baseUrl,
                        err
                    );
                }
            );
        }

        // As post renderer, moc layer will regenerate data on tiles in case of base imagery change
        g.getTileManager().addPostRenderer(this);
    };

    /**************************************************************************************************************/

    /**
     * Generates moc data on tiles.
     * @function generate
     * @memberof MocLayer#
     * @param {Tile} tile Tile
     */
    MocLayer.prototype.generate = function(tile) {
        if (this.featuresSet && tile.order === this.startOrder) {
            var geometries = this.featuresSet[tile.pixelIndex];
            if (geometries) {
                for (var i = 0; i < geometries.length; i++) {
                    this.getGlobe()
                        .getRendererManager()
                        .addGeometryToTile(
                            this,
                            geometries[i],
                            this.style,
                            tile
                        );
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Renders
     * @function render
     * @memberof MocLayer#
     */
    MocLayer.prototype.render = function() {
        // No rendering
    };

    /**************************************************************************************************************/

    /**
     * Detaches the layer from the planet
     * @function _detach
     * @memberof MocLayer#
     * @private
     */
    MocLayer.prototype._detach = function() {
        for (var tileIndex in this.featuresSet) {
            if (this.featuresSet.hasOwnProperty(tileIndex)) {
                var tile = this.getGlobe().getTileManager().level0Tiles[
                    tileIndex
                ];
                for (var i = 0; i < this.featuresSet[tileIndex].length; i++) {
                    this.getGlobe()
                        .getRendererManager()
                        .removeGeometryFromTile(
                            this.featuresSet[tileIndex][i],
                            tile
                        );
                }
            }
        }
        this.featuresSet = null;
        this.getGlobe()
            .getTileManager()
            .removePostRenderer(this);

        AbstractLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    /**
     * Returns children indices of starting tiling order.
     * @function findChildIndices
     * @memberof MocLayer#
     * @param index Parent index
     * @param order Parent order
     */
    MocLayer.prototype.findChildIndices = function(index, order) {
        var childOrder = this.startOrder;
        var orderDepth = childOrder - order;
        var numSubTiles = Math.pow(4, orderDepth); // Number of subtiles depending on order
        var firstSubTileIndex = index * numSubTiles;
        var indices = [];
        for (
            var i = firstSubTileIndex;
            i < firstSubTileIndex + numSubTiles;
            i++
        ) {
            indices.push(i);
        }

        return indices;
    };

    /**************************************************************************************************************/

    /**
     * Returns index of parent of starting tiling order.
     * @function findParentIndex
     * @memberof MocLayer#
     * @param index Child index
     * @param order Child order
     */
    MocLayer.prototype.findParentIndex = function(index, order) {
        var parentOrder = this.startOrder;
        var orderDepth = order - parentOrder;
        return Math.floor(index / Math.pow(4, orderDepth));
    };

    /**************************************************************************************************************/

    /**
     * Handles MOC response.
     * @function handleDistribution
     * @memberof MocLayer#
     * @param response MOC response
     */
    MocLayer.prototype.handleDistribution = function(response) {
        var gl = this.getGlobe()
            .getTileManager()
            .getRenderContext().gl;
        this.featuresSet = {};
        var parentIndex;
        var i, u, v;
        // For each order, compute rectangles geometry depending on the pixel index
        for (var key in response) {
            if (response.hasOwnProperty(key)) {
                var order = parseInt(key, 10);
                for (i = 0; i < response[key].length; i++) {
                    var pixelIndex = response[key][i];

                    if (order > this.startOrder) {
                        parentIndex = this.findParentIndex(pixelIndex, order);
                    } else if (order === this.startOrder) {
                        parentIndex = pixelIndex;
                    } else {
                        // Handle low orders(< 3) by creating children polygons of order 3
                        var indices = this.findChildIndices(pixelIndex, order);
                        if (
                            response[this.startOrder.toString()] === undefined
                        ) {
                            response[
                                this.startOrder.toString()
                            ] = response[0].concat(indices);
                        } else {
                            response[this.startOrder.toString()] = response[
                                this.startOrder.toString()
                            ].concat(indices);
                        }
                        continue;
                    }

                    var geometry = {
                        type: Constants.GEOMETRY.Polygon,
                        gid: "moc" + this.id + "_" + order + "_" + pixelIndex,
                        crs: this.crs,
                        coordinates: [[]]
                    };

                    // Build the vertices
                    var size = 2; // TODO
                    var step = 1;

                    // Tesselate only low-order tiles
                    if (order < 5) {
                        size = 5;
                        step = 1.0 / (size - 1);
                    }

                    var nside = Math.pow(2, order);
                    var pix = pixelIndex & (nside * nside - 1);
                    var ix = HEALPixBase.compress_bits(pix);
                    var iy = HEALPixBase.compress_bits(pix >>> 1);
                    var face = pixelIndex >>> (2 * order);

                    var vertice, geo;

                    // Horizontal boudaries
                    for (u = 0; u < 2; u++) {
                        for (v = 0; v < size; v++) {
                            vertice = HEALPixBase.fxyf(
                                (ix + u * (size - 1) * step) / nside,
                                (iy + v * step) / nside,
                                face
                            );
                            geo = this.getGlobe()
                                .getCoordinateSystem()
                                .getWorldFrom3D(vertice);
                            if (u === 0) {
                                // Invert to clockwise sense
                                geometry.coordinates[0][
                                    2 * u * size + (size - 1) - v
                                ] = [geo[0], geo[1]];
                            } else {
                                geometry.coordinates[0][2 * u * size + v] = [
                                    geo[0],
                                    geo[1]
                                ];
                            }
                        }
                    }

                    // Vertical boundaries
                    for (v = 0; v < 2; v++) {
                        for (u = 0; u < size; u++) {
                            vertice = HEALPixBase.fxyf(
                                (ix + u * step) / nside,
                                (iy + v * (size - 1) * step) / nside,
                                face
                            );
                            geo = this.getGlobe()
                                .getCoordinateSystem()
                                .getWorldFrom3D(vertice);
                            if (v === 1) {
                                // Invert to clockwise sense
                                geometry.coordinates[0][
                                    size + 2 * v * size + (size - 1) - u
                                ] = [geo[0], geo[1]];
                            } else {
                                geometry.coordinates[0][
                                    size + 2 * v * size + u
                                ] = [geo[0], geo[1]];
                            }
                        }
                    }

                    var parentTile = this.getGlobe().getTileManager()
                        .level0Tiles[parentIndex];

                    if (!this.featuresSet[parentIndex]) {
                        this.featuresSet[parentIndex] = [];
                    }

                    this.featuresSet[parentIndex].push(geometry);
                    this.getGlobe()
                        .getRendererManager()
                        .addGeometryToTile(
                            this,
                            geometry,
                            this.style,
                            parentTile
                        );
                }
            }
        }
    };

    return MocLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 *    Moc base module
 */
define('gw/Services/MocBase',[
    "jquery",
    "../Renderer/FeatureStyle",
    "../Layer/MocLayer",
    "../Utils/Constants",
    "../Utils/Numeric"
], function($, FeatureStyle, MocLayer, Constants, Numeric) {
    var mizarAPI;
    var coverageServiceUrl;

    /**************************************************************************************************************/

    /**
     *    Create moc sublayer
     *
     *    @param layer Parent layer
     *    @fires Context#layer:add
     */
    function createMocSublayer(layer, successCallback, errorCallback) {
        var ID;
        if (layer.getBaseUrl()) {
            ID = handleMocLayer(layer, layer.getBaseUrl());
            var mocLayer = mizarAPI.getLayerByID(ID);
            if (layer.skyFraction) {
                mocLayer.coverage =
                    Numeric.roundNumber(
                        parseFloat(layer.skyFraction) * 100,
                        2
                    ) + "%";
            } else {
                mocLayer.coverage = "Not available";
            }
            successCallback(mocLayer);
        } else {
            errorCallback(layer);
        }
        return ID;
    }

    /**************************************************************************************************************/

    /**
     *    Handle moc layer as a sublayer
     *
     *    @param layer Parent layer
     *    @param mocServiceUrl Url to moc service
     *    @fires Context#backgroundLayer:added
     *    @fires Context#layer:added
     */
    function handleMocLayer(layer, mocServiceUrl) {
        var style;
        // checks if style is defined
        if (layer.getStyle()) {
            style = layer.getStyle();
            style.fill = true;
            if (style.hasOwnProperty("fillColor")) {
                // add transparency when fill color is defined
                style.fillColor[3] = 0.3;
            } else {
                // no predefined color, set one
                style.fillColor = [1.0, 0.0, 0.0, 0.3];
            }
        } else {
            // no style, create a new one.
            style = new FeatureStyle({
                rendererHint: "Basic",
                fill: true,
                fillColor: [1.0, 0.0, 0.0, 0.3]
            });
        }

        var ID = mizarAPI.addLayer({
            type: Constants.LAYER.Moc,
            baseUrl: mocServiceUrl,
            style: style,
            visible: false
        });
        return ID;
    }

    /**************************************************************************************************************/

    /**
     *    Search moc sublayer
     *    @return    Moc layer if found, null otherwise
     */
    function findMocSublayer(layerID) {
        return mizarAPI.getLayerByID(layerID);
    }

    /**************************************************************************************************************/

    /**
     *    Intersect layers
     */
    function intersectLayers(layersToIntersect) {
        // Construct url & layerNames
        var url = coverageServiceUrl;
        var layerNames = "";
        for (var i = 0; i < layersToIntersect.length; i++) {
            var layer = layersToIntersect[i];

            layerNames += layer.getName();
            url += layer.describeUrl;
            if (i !== layersToIntersect.length - 1) {
                url += ";";
                layerNames += " x ";
            }
        }

        // Create intersection MOC layer
        var intersectionLayer = new MocLayer({
            name: "Intersection( " + layerNames + " )",
            serviceUrl: url + "&media=json",
            style: new FeatureStyle({
                rendererHint: "Basic",
                fill: true,
                fillColor: [1.0, 0.0, 0.0, 0.3]
            }),
            visible: false
        });
        mizarAPI.getSkyContext().globe.addLayer(intersectionLayer);

        intersectionLayer.describeUrl = url;

        return intersectionLayer;
    }

    /**************************************************************************************************************/

    return {
        init: function(m, options) {
            mizarAPI = m;
            //coverageServiceUrl = "TODO must use AbstractLayer to get info";//options.coverageService.baseUrl;
            //TODO must use AbstractLayer to get this information
        },
        createMocSublayer: createMocSublayer,
        findMocSublayer: findMocSublayer,
        //getSkyCoverage: getSkyCoverage,
        //requestSkyCoverage: requestSkyCoverage,
        intersectLayers: intersectLayers
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Mollweider viewer module : Sky representation in mollweide coordinate system
 */
define('gw/Services/MollweideViewerCore',[
    "jquery",
    "../Utils/Numeric",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function($, Numeric, Ray) {
    var mizarAPI;
    var mizarBaseUrl;
    var navigation;
    var halfPaddingX;
    var halfPaddingY;
    var halfHeight;
    var halfWidth;
    var tesselation;
    var center3d;
    var canvas;
    var context;
    var self;
    var imageObj;

    /**
     *  Newton-Raphson method to find auxiliary theta needed for mollweide x/y computation
     *  @param lat latitude
     *  @see https://en.wikipedia.org/wiki/Mollweide_projection
     *  @return theta
     */
    function _findTheta(lat) {
        // Avoid divide by zero
        if (Math.abs(lat) === Math.PI / 2) {
            return lat;
        }

        var epsilon = 0.001;
        var thetaN; // n
        var thetaN1; // n+1

        do {
            thetaN = thetaN1;
            if (!thetaN) {
                thetaN = lat;
            }
            var twoThetaN = 2 * thetaN;
            thetaN1 =
                twoThetaN / 2 -
                (twoThetaN + Math.sin(twoThetaN) - Math.PI * Math.sin(lat)) /
                    (2 + 2 * Math.cos(twoThetaN));
        } while (Math.abs(thetaN1 - thetaN) >= epsilon);

        return thetaN1;
    }

    /**********************************************************************************************/

    /**
     *  Canvas 2D point
     *  @param {Object} options
     *      <ul>
     *          <li>options : x,y, color, size</li>
     */
    var Point = function(options) {
        this.x = options.x | 0;
        this.y = options.y | 0;
        this.color = options.color | "rgb(255,0,0)";
        this.size = options.size | 2;
        for (var x in options) {
            if (options.hasOwnProperty(x)) {
                this[x] = options[x];
            }
        }
    };

    /**********************************************************************************************/

    /**
     *  Compute mollweide position for given 3D position
     *  @param {Array} pos position
     *  @return {Array} x,y coordinates
     */
    function computeMollweidePosition(pos) {
        var coordinateSystem = mizarAPI.getCrs();
        var geoPos = coordinateSystem.getWorldFrom3D(pos);
        if (geoPos[0] > 180) geoPos[0] -= 360;
        //var geoPos = coordinateSystem.from3DToEquatorial(pos, null, false);
        //geoPos = coordinateSystem.convert(geoPos, Constants.CRS.Equatorial, coordinateSystem.getGeoideName());
        //geoPos = coordinateSystem.fromEquatorialToGeo(geoPos, null, false);

        var lambda = (geoPos[0] * Math.PI) / 180; // longitude
        var theta0 = (geoPos[1] * Math.PI) / 180; // latitude

        var auxTheta = _findTheta(theta0);

        // Transfrom to Mollweide coordinate system
        var mollX =
            ((2 * Math.sqrt(2)) / Math.PI) * lambda * Math.cos(auxTheta);
        var mollY = Math.sqrt(2) * Math.sin(auxTheta);

        // Transform to image space
        //    2.8: max x value in Mollweide projection
        //    1.38: max y value in Mollweide projection
        var x = (-mollX * halfWidth) / 2.8 + halfWidth + halfPaddingX;
        var y = (-mollY * halfHeight) / 1.38 + halfHeight + halfPaddingY;

        return [x, y];
    }

    /**********************************************************************************************/

    /**
     *  Update navigation eye for the given mouse coordinates
     *  @param {Array} moll
     */
    function updateNavigation(moll) {
        // Transform to Mollweide space
        center3d.x = (-(moll[0] - halfWidth - halfPaddingX) * 2.8) / halfWidth;
        center3d.y =
            (-(moll[1] - halfHeight - halfPaddingY) * 1.38) / halfHeight;

        // Transform to geographic coordinate system
        // http://mathworld.wolfram.com/MollweideProjection.html
        var auxTheta = Math.asin(center3d.y / Math.sqrt(2));

        var phi = Math.asin((2 * auxTheta + Math.sin(2 * auxTheta)) / Math.PI);
        var lambda =
            (Math.PI * center3d.x) / (2 * Math.sqrt(2) * Math.cos(auxTheta));

        var geo = [(lambda * 180) / Math.PI, (phi * 180) / Math.PI];

        // Update navigation
        mizarAPI.getCrs().get3DFromWorld(geo, navigation.center3d);

        navigation.computeViewMatrix();
    }

    /**********************************************************************************************/

    /**
     *  Function updating the position of center of camera on mollweide element
     */
    function updateMollweideFov() {
        // Reinit canvas
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(imageObj, 0, 0);

        // Draw fov
        context.fillStyle = "rgb(255,0,0)";
        var stepX =
            mizarAPI.getRenderContext().canvas.clientWidth / (tesselation - 1);
        var stepY =
            mizarAPI.getRenderContext().canvas.clientHeight / (tesselation - 1);

        var ray;
        var pos3d;
        var mPos;
        for (var i = 0; i < tesselation; i++) {
            // Width
            for (var j = 0; j < tesselation; j++) {
                // Height
                ray = Ray.createFromPixel(
                    mizarAPI.getRenderContext(),
                    i * stepX,
                    j * stepY
                );
                pos3d = ray.computePoint(
                    ray.sphereIntersect(
                        [0, 0, 0],
                        mizarAPI
                            .getCrs()
                            .getGeoide()
                            .getRadius()
                    )
                );

                mPos = computeMollweidePosition(pos3d);

                // Draw on canvas 2d
                context.fillRect(mPos[0], mPos[1], 2, 2);
            }
        }

        // Draw center
        context.fillStyle = center3d.color;
        mPos = computeMollweidePosition(navigation.center3d);
        center3d.x = mPos[0] - center3d.size / 2;
        center3d.y = mPos[1] - center3d.size / 2;

        // Draw on canvas 2d
        context.fillRect(
            mPos[0] - center3d.size / 2,
            mPos[1] - center3d.size / 2,
            center3d.size,
            center3d.size
        );

        // Update fov degrees
        var fov = navigation.getFov();
        var fovx = Numeric.roundNumber(fov[0], 2);
        fovx = mizarAPI.getCrs().fromDegreesToDMS(fovx);
        var fovy = Numeric.roundNumber(fov[1], 2);
        fovy = mizarAPI.getCrs().fromDegreesToDMS(fovy);
        $("#fov").html("Fov : " + fovx + " x " + fovy);
    }

    function updateGalaxyProjection(ctx) {
        $(self.getImageObj()).attr(
            "src",
            mizarBaseUrl +
                "css/images/MollweideSky_" +
                ctx.getCoordinateSystem().getGeoideName() +
                ".png"
        );
    }

    /**********************************************************************************************/

    return {
        init: function(options) {
            mizarAPI = options.mizar;
            mizarBaseUrl = options.mizarBaseUrl;

            // Init options
            navigation = mizarAPI.getActivatedContext().getNavigation();
            halfPaddingX = 16;
            halfPaddingY = 8;

            // Grid background dimensions
            halfHeight = 50;
            halfWidth = 100;

            // Level of tesselation to represent fov
            tesselation = 9; // Must be >= 2

            // Center of fov
            center3d = new Point({
                size: 5,
                color: "rgb(255,255,0)"
            });

            // Init image background
            canvas = document.getElementById("mollweideCanvas");
            context = canvas.getContext("2d");
            self = this;

            imageObj = new Image();
            imageObj.onload = function() {
                context.drawImage(imageObj, 0, 0);
                updateMollweideFov(imageObj);
            };
        },
        getImageObj: function() {
            return imageObj;
        },
        _findTheta: _findTheta,
        computeMollweidePosition: computeMollweidePosition,
        updateNavigation: updateNavigation,
        updateMollweideFov: updateMollweideFov,
        updateGalaxyProjection: updateGalaxyProjection
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/GeoBound',["../Utils/Constants"], function(Constants) {
    /**************************************************************************************************************/

    /**
     @name GeoBound
     @class
         Geo Bound
     @param {float} w West
     @param {float} s South
     @param {float} e East
     @param {float} n North
     @constructor
     */
    var GeoBound = function(w, s, e, n) {
        this.south = s;
        this.west = w;
        this.north = n;
        this.east = e;
    };

    /**
     Get geo center
     @function getCenter
     @memberof GeoBound.prototype
     @return {float[]} Geo center as array of 2 float
     */
    GeoBound.prototype.getCenter = function() {
        return [
            (this.east + this.west) * 0.5,
            (this.south + this.north) * 0.5,
            0.0
        ];
    };

    /**
     Get North
     @function getNorth
     @memberof GeoBound.prototype
     @return {float} North
     */
    GeoBound.prototype.getNorth = function() {
        return this.north;
    };

    /**
     Set North
     @function setNorth
     @memberof GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setNorth = function(val) {
        this.north = val;
    };

    /**
     Get South
     @function getSouth
     @memberof GeoBound.prototype
     @return {float} South
     */
    GeoBound.prototype.getSouth = function() {
        return this.south;
    };

    /**
     Set South
     @function setSouth
     @memberof GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setSouth = function(val) {
        this.south = val;
    };

    /**
     Get West
     @function getWest
     @memberof GeoBound.prototype
     @return {float} West
     */
    GeoBound.prototype.getWest = function() {
        return this.west;
    };

    /**
     Set West
     @function setWest
     @memberof GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setWest = function(val) {
        this.west = val;
    };

    /**
     Get East
     @function getEast
     @memberof GeoBound.prototype
     @return {float} East
     */
    GeoBound.prototype.getEast = function() {
        return this.east;
    };

    /**
     Set East
     @function setEast
     @memberof GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setEast = function(val) {
        this.east = val;
    };

    /**
     Compute the geo bound from coordinates
     @function computeFromCoordinates
     @memberof GeoBound.prototype
     @param {float[][]} coordinates Coordinates as bi-dimensionnal array of float
     */
    GeoBound.prototype.computeFromCoordinates = function(coordinates) {
        this.west = coordinates[0][0];
        this.east = coordinates[0][0];
        this.south = coordinates[0][1];
        this.north = coordinates[0][1];

        for (var i = 1; i < coordinates.length; i++) {
            this.west = Math.min(this.west, coordinates[i][0]);
            this.east = Math.max(this.east, coordinates[i][0]);
            this.south = Math.min(this.south, coordinates[i][1]);
            this.north = Math.max(this.north, coordinates[i][1]);
        }
    };

    function transformCoordinates(coordinates, crsID, globeCrs) {
        var len = coordinates.length,
            convertedCoord = new Array(len); // boost in Safari
        for (var i = 0; i < len; ++i) {
            convertedCoord[i] = coordinates[i].slice(0);
        }

        convertedCoord[0][0] = globeCrs.convert(
            coordinates[0][0],
            crsID,
            globeCrs.getGeoideName()
        );
        convertedCoord[0][1] = globeCrs.convert(
            coordinates[0][1],
            crsID,
            globeCrs.getGeoideName()
        );
        for (var j = 1; j < coordinates.length; j++) {
            convertedCoord[j][0] = globeCrs.convert(
                coordinates[j][0],
                crsID,
                globeCrs.getGeoideName()
            );
            convertedCoord[j][1] = globeCrs.convert(
                coordinates[j][1],
                crsID,
                globeCrs.getGeoideName()
            );
        }
        return convertedCoord;
    }

    GeoBound.prototype.computeFromCoordinatesInCrsTo = function(
        coordinates,
        crsID,
        globeCrs
    ) {
        var coords;
        if (crsID === globeCrs.getGeoideName()) {
            coords = coordinates;
        } else {
            coords = transformCoordinates(coordinates, crsID, globeCrs);
        }
        this.computeFromCoordinates(coords);
        return coords;
    };

    /**
     Check if a point is inside the given bound
     @function isPointInside
     @memberof GeoBound.prototype
     @param {Array} point The point
     @return {Boolean} return the test
     */
    GeoBound.prototype.isPointInside = function(point) {
        return (
            point[0] >= this.west &&
            point[0] <= this.east &&
            point[1] >= this.south &&
            point[1] <= this.north
        );
    };

    /**
     Intersects this geo bound with another one
     @function intersects
     @memberof GeoBound.prototype
     @param {GeoBound} geoBound Geo bound
     @return {Boolean} Intersects ?
     */
    GeoBound.prototype.intersects = function(geoBound) {
        if (this.west >= geoBound.east || this.east <= geoBound.west) {
            return false;
        }

        return !(this.south >= geoBound.north || this.north <= geoBound.south);
    };

    /**
     Intersects this geo bound with GeoJSON geometry
     @function intersectsGeometry
     @memberof GeoBound.prototype
     @param {JSON} geometry GeoJSON geometry
     @return {Boolean} Intersects ?
     */
    GeoBound.prototype.intersectsGeometry = function(geometry) {
        var isIntersected = false;
        var i, j;
        var geoBound = new GeoBound();
        var coords = geometry.coordinates;
        switch (geometry.type) {
        case Constants.GEOMETRY.LineString:
            geoBound.computeFromCoordinates(coords);
            isIntersected |= this.intersects(geoBound);
            break;
        case Constants.GEOMETRY.Polygon:
            // Don't take care about holes
            for (i = 0; i < coords.length && !isIntersected; i++) {
                geoBound.computeFromCoordinates(coords[i]);
                isIntersected |= this.intersects(geoBound);
            }
            break;
        case Constants.GEOMETRY.MultiLineString:
            for (i = 0; i < coords.length && !isIntersected; i++) {
                geoBound.computeFromCoordinates(coords[i]);
                isIntersected |= this.intersects(geoBound);
            }
            break;
        case Constants.GEOMETRY.MultiPolygon:
            for (i = 0; i < coords.length && !isIntersected; i++) {
                for (j = 0; j < coords[i].length && !isIntersected; j++) {
                    geoBound.computeFromCoordinates(coords[i][j]);
                    isIntersected |= this.intersects(geoBound);
                }
            }
            break;
        }
        return isIntersected;
    };

    /**************************************************************************************************************/

    return GeoBound;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/Program',["../Utils/Constants", "../Gui/dialog/ErrorDialog", "../Utils/Proxy"],function(Constants, ErrorDialog, Proxy) {
    /**************************************************************************************************************/

    /**
	 @name Program
	 @class
	   Program constructor
	 @param renderContext
	 @constructor
	 */
    var Program = function(renderContext) {
        this.renderContext = renderContext;
        this.glProgram = null;
        this.attributes = {};
        this.uniforms = {};
        this.numActiveAttribArray = 0;
    };

    /**************************************************************************************************************/

    /**
     * Creates a shader of the given type from the given source string
     * @function createShader
     * @memberof Program.prototype
     * @param type
     * @param source
     * @return Shader
     */
    Program.prototype.createShader = function(type, source) {
        var gl = this.renderContext.gl;
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "Program.js", "Shader compilation error: " + gl.getShaderInfoLog(shader));
            ErrorDialog.open(Constants.LEVEL.DEBUG, "Program.js", source);
            gl.deleteShader(shader);
            return null;
        }

        return shader;
    };

    /**************************************************************************************************************/

    /**
     * Create the program from source shaders
     * @function createFromSource
     * @memberof Program.prototype
     * @param vertexSource
     * @param fragmentSource
     * @return {Boolean}
     */
    Program.prototype.createFromSource = function(
        vertexSource,
        fragmentSource
    ) {
        var gl = this.renderContext.gl;

        //  Create the gl shaders from the source
        var vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
        var fragmentShader = this.createShader(
            gl.FRAGMENT_SHADER,
            fragmentSource
        );
        if (vertexShader === null || fragmentShader === null) {
            return false;
        }

        var i;

        // Create the program and attach the shaderss
        this.glProgram = gl.createProgram();
        gl.attachShader(this.glProgram, vertexShader);
        gl.attachShader(this.glProgram, fragmentShader);

        // Link and test the program is ok
        gl.linkProgram(this.glProgram);
        if (!gl.getProgramParameter(this.glProgram, gl.LINK_STATUS)) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "Program.js", "Program link error: " + gl.getProgramInfoLog(this.glProgram));
            gl.deleteShader(vertexShader);
            gl.deleteShader(fragmentShader);
            gl.deleteProgram(this.glProgram);
            this.glProgram = null;
            return false;
        }

        // Get vertex attributes used in the program, stored them in an attributes object
        var attributeCount = gl.getProgramParameter(
            this.glProgram,
            gl.ACTIVE_ATTRIBUTES
        );
        this.numActiveAttribArray = 0;
        for (i = 0; i < attributeCount; ++i) {
            var attribute = gl.getActiveAttrib(this.glProgram, i);
            var loc = gl.getAttribLocation(this.glProgram, attribute.name);
            this.attributes[attribute.name] = loc;

            if (loc + 1 > this.numActiveAttribArray) {
                this.numActiveAttribArray = loc + 1;
            }
        }

        // Get uniforms used in the program, stored them in an uniforms object
        var uniformCount = gl.getProgramParameter(
            this.glProgram,
            gl.ACTIVE_UNIFORMS
        );
        for (i = 0; i < uniformCount; ++i) {
            var uniform = gl.getActiveUniform(this.glProgram, i);
            this.uniforms[uniform.name] = gl.getUniformLocation(
                this.glProgram,
                uniform.name
            );
        }

        return true;
    };

    /**************************************************************************************************************/

    /**
     * Load from file (must be located on the server)
     * @function loadFromFile
     * @memberof Program.prototype
     * @param vertexFile
     * @param fragmentFile
     * @return {Boolean}
     */
    Program.prototype.loadFromFile = function(vertexFile, fragmentFile) {
        var xhr = new XMLHttpRequest();
        xhr.open("get", Proxy.proxify(this.renderContext.shadersPath + vertexFile), false);
        xhr.send(null);

        var vertexSource = xhr.responseText;
        xhr.open("get", Proxy.proxify(this.renderContext.shadersPath + fragmentFile), false);
        xhr.send(null);
        var fragmentSource = xhr.responseText;

        return this.createFromSource(vertexSource, fragmentSource);
    };

    /**************************************************************************************************************/

    /**
     * Apply the programs
     * @function apply
     * @memberof Program.prototype
     */
    Program.prototype.apply = function() {
        var rc = this.renderContext;
        var gl = rc.gl;
        var i;

        // Bind program
        gl.useProgram(this.glProgram);

        for (i = rc.numActiveAttribArray; i < this.numActiveAttribArray; i++) {
            gl.enableVertexAttribArray(i);
        }
        for (i = this.numActiveAttribArray; i < rc.numActiveAttribArray; i++) {
            gl.disableVertexAttribArray(i);
        }
        rc.numActiveAttribArray = this.numActiveAttribArray;
    };

    /**************************************************************************************************************/

    /**
     * Dispose the program
     * @function dispose
     * @memberof Program.prototype
     */
    Program.prototype.dispose = function() {
        this.renderContext.gl.deleteProgram(this.glProgram);
    };

    /**************************************************************************************************************/

    return Program;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/BoundingBox',[],function() {
    /**
	 @name BoundingBox
	 @class
	  Bounding Box
	 @param {float[]} min Min corner as 3D point (array of 3 float)
	 @param {float[]} max Max corner as 3D point (array of 3 float)
	 @constructor
	 */
    var BoundingBox = function(min, max) {
        if (min) {
            this.min = vec3.create(min);
        }
        if (max) {
            this.max = vec3.create(max);
        }
    };

    /**
	Extent the bounding box with the given point
	@function extend
	@memberof BoundingBox.prototype
	@param {float} x Coord x of extent point
	@param {float} y Coord y of extent point
	@param {float} z Coord z of extent point
*/
    BoundingBox.prototype.extend = function(x, y, z) {
        if (!this.min) {
            this.min = vec3.create();
            this.max = vec3.create();

            this.min[0] = x;
            this.min[1] = y;
            this.min[2] = z;
            this.max[0] = x;
            this.max[1] = y;
            this.max[2] = z;
        } else {
            if (x < this.min[0]) {
                this.min[0] = x;
            }
            if (y < this.min[1]) {
                this.min[1] = y;
            }
            if (z < this.min[2]) {
                this.min[2] = z;
            }
            if (x > this.max[0]) {
                this.max[0] = x;
            }
            if (y > this.max[1]) {
                this.max[1] = y;
            }
            if (z > this.max[2]) {
                this.max[2] = z;
            }
        }
    };
    /**
 	Compute the bounding box from an array of vertices
 	@function compute
 	@memberof BoundingBox.prototype
 	@param {float[]} vertices All coords as array of multiple of 3 float)
 	@param {float} length Vertices array length
 	@param {float} stride Stride (3 by default)
 */
    BoundingBox.prototype.compute = function(vertices, length, stride) {
        if (!this.min) {
            this.min = vec3.create();
            this.max = vec3.create();
        }

        this.min[0] = vertices[0];
        this.min[1] = vertices[1];
        this.min[2] = vertices[2];
        this.max[0] = vertices[0];
        this.max[1] = vertices[1];
        this.max[2] = vertices[2];

        var i, j;
        var st = stride || 3;
        var ll = length || vertices.length;

        for (i = st; i < ll; i += st) {
            for (j = 0; j < 3; j++) {
                if (vertices[i + j] < this.min[j]) {
                    this.min[j] = vertices[i + j];
                }
                if (vertices[i + j] > this.max[j]) {
                    this.max[j] = vertices[i + j];
                }
            }
        }
    };

    /**
 	Get the corner of a bounding box
 	@function getCorner
 	@memberof BoundingBox.prototype
 	@param {float} pos Position
 	@return {?} Corner
 */
    BoundingBox.prototype.getCorner = function(pos) {
        return [
            pos & 1 ? this.max[0] : this.min[0],
            pos & 2 ? this.max[1] : this.min[1],
            pos & 4 ? this.max[2] : this.min[2]
        ];
    };

    /**
 	Get the center of a bounding box
 	@function getCenter
 	@memberof BoundingBox.prototype
 	@return {?} Center
 */
    BoundingBox.prototype.getCenter = function() {
        return [
            (this.max[0] + this.min[0]) * 0.5,
            (this.max[1] + this.min[1]) * 0.5,
            (this.max[2] + this.min[2]) * 0.5
        ];
    };

    /**
 	Get the radius of a bounding box
 	@function getRadius
 	@memberof BoundingBox.prototype
 	@return {float} Radius
 */
    BoundingBox.prototype.getRadius = function() {
        var vec = vec3.create();
        vec3.subtract(this.max, this.min, vec);
        return 0.5 * vec3.length(vec);
    };

    /**************************************************************************************************************/

    return BoundingBox;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/Tile',[
    "../Renderer/BoundingBox",
    "../Renderer/Ray",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "../Renderer/glMatrix"
], function(BoundingBox, Ray, Constants, ErrorDialog) {
    /**************************************************************************************************************/

    /**
         Tile constructor
         @name Tile
         @constructor
         */
    var Tile = function() {
        // Parent/child relationship
        this.parent = null;
        this.parentIndex = -1;
        this.children = null;

        // Graphics data to render the tile
        this.vertices = null;
        this.texture = null;
        this.vertexBuffer = null;
        this.texTransform = [1.0, 1.0, 0.0, 0.0];

        // Tile spatial data
        this.matrix = null;
        this.inverseMatrix = null;
        this.bbox = new BoundingBox();

        // For culling
        this.radius = 0.0;
        this.distance = 0.0;
        this.closestPointToEye = [0.0, 0.0, 0.0];

        // Specific object to store extension from renderers
        this.extension = {};

        // For debug
        //this.color = [ Math.random(), Math.random(), Math.random() ];

        this.state = Tile.State.NONE;

        // Tile configuration given by tile manager : contains if the tile uses skirt, the tesselation, etc...
        this.config = null;
    };

    /**************************************************************************************************************/

    /**
     *    Tile state enumerations
     */
    Tile.State = {
        ERROR: -10,
        NONE: 0,
        REQUESTED: 1,
        LOADING: 2,
        LOADED: 3
    };

    /**************************************************************************************************************/

    /**
     * Compute position on the tile using normalized coordinate between [0,size-1]
     */
    Tile.prototype.computePosition = function(u, v) {
        var size = this.config.tesselation;
        u = Math.min(size - 1, Math.max(0, u));
        v = Math.min(size - 1, Math.max(0, v));

        var vFloor = Math.floor(v);
        var vFrac = v - vFloor;
        var uFloor = Math.floor(u);
        var uFrac = u - uFloor;
        var vertexSize = this.config.vertexSize;
        var vertexOffset = vertexSize * (vFloor * size + uFloor);
        var vec = [0.0, 0.0, 0.0];
        for (var i = 0; i < 3; i++) {
            vec[i] =
                (1.0 - vFrac) *
                    (1.0 - uFrac) *
                    this.vertices[vertexOffset + i] +
                vFrac *
                    (1.0 - uFrac) *
                    this.vertices[vertexOffset + vertexSize * size + i] +
                vFrac *
                    uFrac *
                    this.vertices[
                        vertexOffset + vertexSize * size + vertexSize + i
                    ] +
                (1.0 - vFrac) *
                    uFrac *
                    this.vertices[vertexOffset + vertexSize + i];
        }
        return vec;
    };

    /**************************************************************************************************************/

    /**
     *    Initialize the tile from its parent
     */
    Tile.prototype.initFromParent = function(parent, i, j) {
        this.parent = parent;
        this.parentIndex = j * 2 + i;
        this.matrix = parent.matrix;
        this.inverseMatrix = parent.inverseMatrix;
        this.texture = parent.texture;
        this.config = parent.config;

        this.vertexBuffer = parent.vertexBuffer;

        // Recompute the bounding box
        // Very fast and coarse version but it does not work with HEALPix tiling
        //var w = 0.5 * (parent.bbox.max[0] - parent.bbox.min[0]);
        //var h = -0.5 * (parent.bbox.max[1] - parent.bbox.min[1]);
        //var min = [  parent.bbox.min[0] + i * w, parent.bbox.max[1] + (j+1) * h, parent.bbox.min[2] ];
        //var max = [  parent.bbox.min[0] + (i+1) * w, parent.bbox.max[1] + j * h, parent.bbox.max[2] ];

        var size = this.config.tesselation;
        var halfTesselation = (size - 1) / 2;
        for (var n = 0; n <= halfTesselation; n++) {
            var offset =
                this.config.vertexSize *
                ((n + j * halfTesselation) * size + i * halfTesselation);
            for (var k = 0; k <= halfTesselation; k++) {
                this.bbox.extend(
                    parent.vertices[offset],
                    parent.vertices[offset + 1],
                    parent.vertices[offset + 2]
                );
                offset += this.config.vertexSize;
            }
        }

        // Compute the bounding box
        this.radius = this.bbox.getRadius();

        // Init extension
        for (var x in parent.extension) {
            if (parent.extension.hasOwnProperty(x)) {
                var e = parent.extension[x];
                if (e.initChild) {
                    e.initChild(this, i, j);
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     *    Test if the tile needs to be refined
     */
    Tile.prototype.needsToBeRefined = function(renderContext) {
        if (this.distance < this.radius) {
            return true;
        }
        // Approximate the radius of one texel : the radius of the tile divided by the image size
        // The radius is taken as the average of the bbox width and length, rather than the actual radius because at the pole, there is a large difference betwen width and length
        // and the radius (ie maximum width/length) is too pessimistic
        var radius =
            (0.25 *
                (this.bbox.max[0] -
                    this.bbox.min[0] +
                    (this.bbox.max[1] - this.bbox.min[1]))) /
            this.imageSize;
        // Transform the closest point from the eye in world coordinates
        var mat = this.matrix;
        var c = this.closestPointToEye;
        var px = mat[0] * c[0] + mat[4] * c[1] + mat[8] * c[2] + mat[12];
        var py = mat[1] * c[0] + mat[5] * c[1] + mat[9] * c[2] + mat[13];
        var pz = mat[2] * c[0] + mat[6] * c[1] + mat[10] * c[2] + mat[14];

        // Compute the pixel size of the radius texel
        var pixelSizeVector = renderContext.pixelSizeVector;
        var pixelSize =
            radius /
            (px * pixelSizeVector[0] +
                py * pixelSizeVector[1] +
                pz * pixelSizeVector[2] +
                pixelSizeVector[3]);
        // Check if pixel radius of a texel is superior to the treshold
        // The pixel size can be negative when the closest point is close to the near plane, so take absolute value
        return Math.abs(pixelSize) > renderContext.tileErrorTreshold;
    };

    /**************************************************************************************************************/

    /**
     *    Test if the tile is culled given the current view parameters
     */
    Tile.prototype.isCulled = function(renderContext) {
        // Compute the eye in tile local space
        var mat = this.inverseMatrix;
        var c = renderContext.eyePosition;
        if (!mat) {
            return false;
        }
        var ex = mat[0] * c[0] + mat[4] * c[1] + mat[8] * c[2] + mat[12];
        var ey = mat[1] * c[0] + mat[5] * c[1] + mat[9] * c[2] + mat[13];
        var ez = mat[2] * c[0] + mat[6] * c[1] + mat[10] * c[2] + mat[14];

        // If the eye is in the radius of the tile, consider the tile is not culled
        this.distance = Math.sqrt(ex * ex + ey * ey + ez * ez);
        if (this.distance < this.radius) {
            this.distance = 0.0;
            return false;
        } else {
            var pt = this.closestPointToEye;

            // Compute closest point to eye with the bbox of the tile
            pt[0] = Math.min(Math.max(ex, this.bbox.min[0]), this.bbox.max[0]);
            pt[1] = Math.min(Math.max(ey, this.bbox.min[1]), this.bbox.max[1]);
            pt[2] = Math.min(Math.max(ez, this.bbox.min[2]), this.bbox.max[2]);

            // Compute horizontal culling only if the eye is "behind" the tile
            // and the coordinate system is not a plane(no need to compute horizon culling on plane)
            if (ez < 0.0 && !this.config.coordinateSystem.isFlat()) {
                const eyeGeoAltitude = this.config.coordinateSystem.from3DToGeo(
                    c
                )[2];
                if (eyeGeoAltitude > 0) {
                    // Compute vertical at the closest point. The earth center is [0, 0, -radius] in tile local space.
                    var vx = pt[0];
                    var vy = pt[1];
                    var vz = pt[2] + this.config.coordinateSystem.geoide.radius;
                    var vl = Math.sqrt(vx * vx + vy * vy + vz * vz);
                    vx /= vl;
                    vy /= vl;
                    vz /= vl;

                    // Compute eye direction at the closest point (clampled on earth to avoid problem with mountains)
                    // The position clamp to earth is Vertical * Radius + EarthCenter. The EarthCenter being 0,0,-radius a lot of simplification is done.
                    var edx =
                        ex - vx * this.config.coordinateSystem.geoide.radius;
                    var edy =
                        ey - vy * this.config.coordinateSystem.geoide.radius;
                    var edz =
                        ez -
                        (vz - 1.0) * this.config.coordinateSystem.geoide.radius;

                    // Compute dot product between eye direction and the vertical at the point
                    var el = Math.sqrt(edx * edx + edy * edy + edz * edz);
                    var eDv = (edx * vx + edy * vy + edz * vz) / el;

                    eDv *= this.config.cullSign;

                    if (eDv < -0.05) {
                        return true;
                    }
                }
            }

            // Compute local frustum
            var localFrustum = renderContext.localFrustum;
            localFrustum.inverseTransform(
                renderContext.worldFrustum,
                this.matrix
            );

            // Check if the tile is inside the frustum
            return !localFrustum.containsBoundingBox(this.bbox);
        }
    };

    /**************************************************************************************************************/

    /**
     *    Dispose the tile
     */
    Tile.prototype.dispose = function(renderContext, tilePool) {
        // Dispose extension even if tile isn't loaded because it can be culled
        for (var x in this.extension) {
            if (this.extension[x].dispose) {
                this.extension[x].dispose(renderContext, tilePool);
            }
        }

        if (this.state === Tile.State.LOADED) {
            tilePool.disposeGLBuffer(this.vertexBuffer);
            if (this.texture) {
                tilePool.disposeGLTexture(this.texture);
            }

            this.vertexBuffer = null;
            this.texture = null;
            this.parent = null;

            this.state = Tile.State.NONE;
        }
    };

    /**************************************************************************************************************/

    /**
     *    Delete the children
     */
    Tile.prototype.deleteChildren = function(renderContext, tilePool) {
        if (this.children) {
            for (var i = 0; i < 4; i++) {
                // Recursively delete its children
                this.children[i].deleteChildren(renderContext, tilePool);
                // Dispose its ressources (WebGL)
                this.children[i].dispose(renderContext, tilePool);
            }

            // Cleanup the tile
            this.children = null;
        }
    };

    /**************************************************************************************************************/

    /**
     *    Build skirt vertices
     */
    Tile.prototype.buildSkirtVertices = function(
        center,
        srcOffset,
        srcStep,
        dstOffset
    ) {
        var vertices = this.vertices;
        var skirtHeight = this.radius * 0.05;

        var size = this.config.tesselation;
        for (var i = 0; i < size; i++) {
            /*		//Not optimized version of skirt computation
                 var srcPos = [ vertices[srcOffset], vertices[srcOffset+1], vertices[srcOffset+2] ];
                 var dir = vec3.subtract( srcPos, center, vec3.create() );
                 vec3.normalize(dir);
                 vec3.scale( dir, skirtHeight );
                 vec3.subtract( srcPos, dir );*/

            // Optimized version of skirt computation
            var x = vertices[srcOffset] - center[0];
            var y = vertices[srcOffset + 1] - center[1];
            var z = vertices[srcOffset + 2] - center[2];
            var scale = skirtHeight / Math.sqrt(x * x + y * y + z * z);
            x *= scale;
            y *= scale;
            z *= scale;

            vertices[dstOffset] = vertices[srcOffset] - x;
            vertices[dstOffset + 1] = vertices[srcOffset + 1] - y;
            vertices[dstOffset + 2] = vertices[srcOffset + 2] - z;

            for (var n = 3; n < this.config.vertexSize; n++) {
                vertices[dstOffset + n] = vertices[srcOffset + n];
            }

            dstOffset += this.config.vertexSize;
            srcOffset += srcStep;
        }
    };

    /**************************************************************************************************************/

    /**
     *    Generate normals for a tile
     */
    Tile.prototype.generateNormals = function() {
        var size = this.config.tesselation;
        var vertexSize = this.config.vertexSize;
        var lineSize = vertexSize * size;

        var vo = 0;
        for (var j = 0; j < size; j++) {
            var vp1 = j === size - 1 ? 0 : lineSize;
            var vm1 = j === 0 ? 0 : -lineSize;
            for (var i = 0; i < size; i++) {
                var up1 = i === size - 1 ? 0 : vertexSize;
                var um1 = i === 0 ? 0 : -vertexSize;
                var u = [
                    this.vertices[vo + up1] - this.vertices[vo + um1],
                    this.vertices[vo + up1 + 1] - this.vertices[vo + um1 + 1],
                    this.vertices[vo + up1 + 2] - this.vertices[vo + um1 + 2]
                ];
                var v = [
                    this.vertices[vo + vp1] - this.vertices[vo + vm1],
                    this.vertices[vo + vp1 + 1] - this.vertices[vo + vm1 + 1],
                    this.vertices[vo + vp1 + 2] - this.vertices[vo + vm1 + 2]
                ];

                var normal = vec3.cross(u, v, []);
                vec3.normalize(normal);
                this.vertices[vo + 3] = normal[0];
                this.vertices[vo + 4] = normal[1];
                this.vertices[vo + 5] = normal[2];

                vo += vertexSize;
            }
        }
    };

    /**************************************************************************************************************/

    /**
     *    Generate the tile
     */
    Tile.prototype.generate = function(tilePool, image, elevations) {
        // Generate the vertices
        this.vertices = this.generateVertices(elevations);
        if(this.vertices === null) {
            console.log("vertice is null");
        }

        // Compute the bounding box
        var size = this.config.tesselation;
        var vertexSize = this.config.vertexSize;
        this.bbox.compute(this.vertices, vertexSize * size * size, vertexSize);
        this.radius = this.bbox.getRadius();

        // Compute normals if needed
        if (this.config.normals) {
            this.generateNormals();
        }
        // Compute skirt from vertices
        if (this.config.skirt) {
            // Compute local earth center, used to generate skirts
            var localEarthCenter = [0.0, 0.0, 0.0];
            mat4.multiplyVec3(this.inverseMatrix, localEarthCenter);

            // Skirts
            var dstOffset = vertexSize * (size * size); // TOP
            this.buildSkirtVertices(localEarthCenter, 0, vertexSize, dstOffset);
            dstOffset += vertexSize * size; // BOTTOM
            this.buildSkirtVertices(
                localEarthCenter,
                vertexSize * (size * (size - 1)),
                vertexSize,
                dstOffset
            );
            dstOffset += vertexSize * size; // LEFT
            this.buildSkirtVertices(
                localEarthCenter,
                0,
                vertexSize * size,
                dstOffset
            );
            dstOffset += vertexSize * size; // RIGHT
            this.buildSkirtVertices(
                localEarthCenter,
                vertexSize * (size - 1),
                vertexSize * size,
                dstOffset
            );

            // These skirts are only used by children tile
            dstOffset += vertexSize * size; // CENTER
            this.buildSkirtVertices(
                localEarthCenter,
                vertexSize * ((size * (size - 1)) / 2),
                vertexSize,
                dstOffset
            );
            dstOffset += vertexSize * size; // MIDDLE
            this.buildSkirtVertices(
                localEarthCenter,
                vertexSize * ((size - 1) / 2),
                vertexSize * size,
                dstOffset
            );
        }

        // Avoid double creation of vertex buffer for level0Tiles generation
        if (this.vertexBuffer !== null && this.parent === null) {
            tilePool.disposeGLBuffer(this.vertexBuffer);
        }
        this.vertexBuffer = tilePool.createGLBuffer(this.vertices);

        // Create texture
        if (image) {
            this.texture = tilePool.createGLTexture(image);
            this.imageSize = this.config.imageSize;
        }

        this.state = Tile.State.LOADED;
    };

    /**************************************************************************************************************/

    Tile.prototype.intersect = function(ray, indices, rc) {
        if (this.isCulled(rc)) {
            return -1;
        }

        // We intersect, check the children recursively for a finer result
        var minChildrenIntersection;

        if (this.children) {
            for (var i = 0; i < this.children.length; ++i) {
                const child = this.children[i];
                if (child.vertices) {
                    const intersection = child.intersect(ray, indices, rc);
                    if (
                        intersection >= 0 &&
                        (!minChildrenIntersection ||
                            intersection < minChildrenIntersection)
                    ) {
                        minChildrenIntersection = intersection;
                    }
                }
            }
        }

        // Children will be more fine-grained
        var final_t;
        if (minChildrenIntersection && minChildrenIntersection >= 0) {
            final_t = minChildrenIntersection;
        } else if (this.vertices == null) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "Tile.js", "vertices is null");
        } else {
            var intersection = null;

            for (var j = 0; indices && j < indices.length / 3; ++j) {
                const i0 = indices[j * 3 + 0] * 3;
                const i1 = indices[j * 3 + 1] * 3;
                const i2 = indices[j * 3 + 2] * 3;

                var v0 = [
                    this.vertices[i0 + 0],
                    this.vertices[i0 + 1],
                    this.vertices[i0 + 2]
                ];
                var v1 = [
                    this.vertices[i1 + 0],
                    this.vertices[i1 + 1],
                    this.vertices[i1 + 2]
                ];
                var v2 = [
                    this.vertices[i2 + 0],
                    this.vertices[i2 + 1],
                    this.vertices[i2 + 2]
                ];

                v0 = mat4.multiplyVec3(this.matrix, v0);
                v1 = mat4.multiplyVec3(this.matrix, v1);
                v2 = mat4.multiplyVec3(this.matrix, v2);

                var verts = [
                    v0[0],
                    v0[1],
                    v0[2],
                    v1[0],
                    v1[1],
                    v1[2],
                    v2[0],
                    v2[1],
                    v2[2]
                ];

                const tmp_i = ray.triangleIntersectOptimized(verts, 0, 3, 6);
                if (tmp_i) {
                    if (!intersection || tmp_i.t < intersection.t) {
                        intersection = tmp_i;
                    }
                }
            }

            if (intersection) {
                final_t = intersection.t;
            }
        }

        if (!final_t) {
            return -1;
        }

        const result = final_t;
        return result;
    };

    return Tile;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/GroundOverlayRenderer',["./Program", "../Tiling/Tile"], function(Program, Tile) {
    //*************************************************************************

    /**
	@name GroundOverlayRenderer
	@class
	 GroundOverlayRenderer constructor
	@param {TileManager} tileManager Tile manager
	@constructor
	*/
    var GroundOverlayRenderer = function(tileManager) {
        this.enabled = true;

        this.renderContext = tileManager.renderContext;
        this.tileManager = tileManager;

        var vertexShader = "attribute vec3 vertex;\n";
        vertexShader += "attribute vec2 tcoord;\n";
        vertexShader += "uniform mat4 modelViewMatrix;\n";
        vertexShader += "uniform mat4 projectionMatrix;\n";
        vertexShader += "uniform vec4 extent; \n";
        vertexShader += "varying vec2 texCoord;\n";
        vertexShader += "void main(void) \n";
        vertexShader += "{\n";
        vertexShader +=
            "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
        vertexShader +=
            "	texCoord.x = tcoord.x * (extent[1] - extent[0]) + extent[0];\n";
        vertexShader +=
            "	texCoord.y = tcoord.y * (extent[3] - extent[2]) + extent[2];\n";
        vertexShader += "}\n";

        var fragmentShader = "#ifdef GL_ES\n";
        fragmentShader += "precision highp float;\n";
        fragmentShader += "#endif\n";
        fragmentShader += "\n";
        fragmentShader += "varying vec2 texCoord;\n";
        fragmentShader += "uniform sampler2D overlayTexture;\n";
        fragmentShader += "uniform mat3 transform;\n";
        fragmentShader += "uniform float opacity; \n";
        fragmentShader += "\n";
        fragmentShader += "void main(void)\n";
        fragmentShader += "{\n";
        fragmentShader += "	vec3 tc = transform * vec3(texCoord,1.0); \n";
        fragmentShader += "	tc.xy /= tc.z; \n";
        fragmentShader +=
            "	gl_FragColor.rgba = texture2D(overlayTexture, tc.xy); \n";
        fragmentShader +=
            "	gl_FragColor.a = (tc.x >= 0.0 && tc.x <= 1.0 && tc.y >= 0.0 && tc.y <= 1.0) ? opacity * gl_FragColor.a  : 0.0; \n";
        fragmentShader += "}\n";

        this.program = new Program(this.renderContext);
        this.program.createFromSource(vertexShader, fragmentShader);

        this.groundOverlays = [];
    };

    //*************************************************************************

    /*
	Render the ground overlays above the tiles in parameter
 */
    GroundOverlayRenderer.prototype.render = function(tiles) {
        if (this.enabled === false) {
            // Disabled, so no rendering
            return;
        }

        var gl = this.renderContext.gl;

        // Setup program
        this.program.apply();

        var attributes = this.program.attributes;

        gl.uniformMatrix4fv(
            this.program.uniforms.projectionMatrix,
            false,
            this.renderContext.projectionMatrix
        );
        gl.uniform1i(this.program.uniforms.overlayTexture, 0);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        gl.depthMask(false);

        var modelViewMatrix = mat4.create();

        var currentIB = null;

        for (var j = 0; j < this.groundOverlays.length; j++) {
            var go = this.groundOverlays[j];

            // Image is not loaded, nothing to be done
            if (!go.image.complete) {
                continue;
            }

            if (!go.texture) {
                go.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(
                    go.image,
                    go.flipY
                );
            }

            var initialized = false;

            for (var i = 0; i < tiles.length; i++) {
                var tile = tiles[i];
                if (go.geoBound.intersects(tile.geoBound)) {
                    if (!initialized) {
                        gl.uniformMatrix3fv(
                            this.program.uniforms.transform,
                            false,
                            go.inverseTransform
                        );
                        gl.uniform1f(
                            this.program.uniforms.opacity,
                            go.getOpacity()
                        );

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, go.texture);

                        gl.bindBuffer(
                            gl.ARRAY_BUFFER,
                            this.tileManager.tcoordBuffer
                        );
                        gl.vertexAttribPointer(
                            attributes.tcoord,
                            2,
                            gl.FLOAT,
                            false,
                            0,
                            0
                        );

                        initialized = true;
                    }

                    var extent =
                        tile.state === Tile.State.LOADED
                            ? tile.bound
                            : tile.parent.bound;

                    gl.uniform4f(
                        this.program.uniforms.extent,
                        extent.west,
                        extent.east,
                        extent.north,
                        extent.south
                    );
                    mat4.multiply(
                        this.renderContext.viewMatrix,
                        tile.matrix,
                        modelViewMatrix
                    );
                    gl.uniformMatrix4fv(
                        this.program.uniforms.modelViewMatrix,
                        false,
                        modelViewMatrix
                    );

                    // Bind the vertex buffer
                    gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
                    gl.vertexAttribPointer(
                        attributes.vertex,
                        3,
                        gl.FLOAT,
                        false,
                        0,
                        0
                    );

                    // Bind the index buffer only if different (index buffer is shared between tiles)
                    var indexBuffer =
                        tile.state === Tile.State.LOADED
                            ? this.tileManager.tileIndexBuffer.getSolid()
                            : this.tileManager.tileIndexBuffer.getSubSolid(
                                tile.parentIndex
                            );
                    if (currentIB !== indexBuffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                        currentIB = indexBuffer;
                    }

                    // Finally draw the tiles
                    gl.drawElements(
                        gl.TRIANGLES,
                        indexBuffer.numIndices,
                        gl.UNSIGNED_SHORT,
                        0
                    );
                }
            }
        }

        gl.disable(gl.BLEND);
        gl.depthMask(true);
    };

    //*************************************************************************

    return GroundOverlayRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/GroundOverlayLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "../Utils/Constants",
    "../Renderer/GeoBound",
    "../Renderer/GroundOverlayRenderer",
    "../Utils/Proxy"
], function(Utils, AbstractLayer, Constants, GeoBound, GroundOverlayRenderer, Proxy) {
    /**
     * GroundOverlay Layer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.groundOverlay_configuration
     * @param {float[]} quad  - An array of 4 points to define the area on the terrain to drape the image
     * @param {Object|String} image - the image to drape on the terrain, can be an Image element or a string (url of the image)
     * @param {boolean} [flipY=true] - flip or not the image
     */

    /**
     * @name GroundOverlayLayer
     * @class
     * This layer draws an image overlay draped onto the terrain
     * @augments AbstractLayer
     * @param {AbstractLayer.groundOverlay_configuration} options - Ground overlay configuration
     * @constructor
     * @memberof module:Layer
     */
    var GroundOverlayLayer = function(options) {
        options.zIndex = options.zIndex || Constants.DISPLAY.DEFAULT_RASTER;
        AbstractLayer.prototype.constructor.call(
            this,
            Constants.LAYER.GroundOverlay,
            options
        );

        this.geoBound = null;
        this.image = null;
        this.globe = null;
        this.flipY = null;

        this.quad = options.quad;
        if (typeof options.flipY === "undefined") {
            this.flipY = true;
        } else {
            this.flipY = options.flipY;
        }

        if (this.quad !== null && typeof this.quad !== "undefined") {
            // Compute the geo bound of the ground overlay
            this.geoBound = new GeoBound();
            this.geoBound.computeFromCoordinates(this.quad);
        }

        if (typeof options.image === "string") {
            this.image = new Image();
            this.image.crossOrigin = "";
            this.image.src = Proxy.proxify(options.image);
        } else if (options.image instanceof HTMLImageElement) {
            this.image = options.image;
        }
        this.image.layer = this;

        this.image.onload = function() {
            this.layer.getGlobe().refresh();
        };
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, GroundOverlayLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof GroundOverlayLayer#
     */
    GroundOverlayLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.RASTER;
    };

    /**
     * Loads a global overview if available. Only use for sky rendering currently
     * @function loadOverview
     * @memberof GroundOverlayLayer#
     */
    GroundOverlayLayer.prototype.loadOverview = function() {};

    /**
     * Attaches layer to the globe.
     * @function _attach
     * @memberof GroundOverlayLayer#
     * @param {AbstractGlobe} planet - Globe to attach
     * @private
     */
    GroundOverlayLayer.prototype._attach = function(planet) {
        // Add layer to ground overlay renderer, create one if needed
        var renderer = planet.groundOverlayRenderer;
        if (!renderer) {
            renderer = new GroundOverlayRenderer(planet.getTileManager());
            planet.getTileManager().addPostRenderer(renderer);
            planet.groundOverlayRenderer = renderer;
        }
        renderer.groundOverlays.push(this);

        this.globe = planet;

        this.computeTransform();
    };

    //*************************************************************************

    /**
     * Update
     * @function update
     * @memberof GroundOverlayLayer#
     * @param {JSon} quad Quad coordinates
     * @param {string} url Url of image
     */
    GroundOverlayLayer.prototype.update = function(quad, url) {
        this.getGlobe().groundOverlayRenderer.enabled = true;

        this.geoBound = null;
        this.geoBound = new GeoBound();

        this.geoBound.computeFromCoordinates(this.quad);

        this.image = null;
        this.image = new Image();

        this.image.crossOrigin = "";
        this.image.src = Proxy.proxify(url);
        this.image.layer = this;

        this.computeTransform();

        this.image.onload = function() {
            this.layer.getGlobe().refresh();
        };
    };

    //*************************************************************************

    /**
     * Detaches layer from the globe.
     * @function _detach
     * @memberof GroundOverlayLayer#
     * @param {AbstractGlobe} globe - globe to detach
     * @private
     */
    GroundOverlayLayer.prototype._detach = function(planet) {
        // Remove layer from the planet renderer for ground overlay
        var prevRenderer = this.getGlobe().groundOverlayRenderer;
        if (prevRenderer) {
            var index = prevRenderer.groundOverlays.indexOf(this);
            if (index !== -1) {
                prevRenderer.groundOverlays.splice(index, 1);

                if (prevRenderer.groundOverlays.length === 0) {
                    this.getGlobe()
                        .getTileManager()
                        .removePostRenderer(prevRenderer);
                    this.getGlobe().groundOverlayRenderer = null;
                }
            }
        }
    };

    //*************************************************************************

    /**
     * Computes the inverse transform from unit square to geo position
     * Code taken from QTransform
     * @function computeInverse
     * @memberof GroundOverlayLayer#
     */
    GroundOverlayLayer.prototype.computeInverse = function() {
        var det =
            this.transform[0] *
                (this.transform[8] * this.transform[4] -
                    this.transform[5] * this.transform[7]) -
            this.transform[3] *
                (this.transform[8] * this.transform[1] - this.transform[7]) *
                this.transform[3] +
            this.transform[6] *
                (this.transform[5] * this.transform[1] -
                    this.transform[4] * this.transform[2]);

        var h11, h12, h13, h21, h22, h23, h31, h32, h33;
        h11 =
            this.transform[4] * this.transform[8] -
            this.transform[5] * this.transform[7];
        h21 =
            this.transform[5] * this.transform[6] -
            this.transform[3] * this.transform[8];
        h31 =
            this.transform[3] * this.transform[7] -
            this.transform[4] * this.transform[6];
        h12 =
            this.transform[2] * this.transform[7] -
            this.transform[1] * this.transform[8];
        h22 =
            this.transform[0] * this.transform[8] -
            this.transform[2] * this.transform[6];
        h32 =
            this.transform[1] * this.transform[6] -
            this.transform[0] * this.transform[7];
        h13 =
            this.transform[1] * this.transform[5] -
            this.transform[2] * this.transform[4];
        h23 =
            this.transform[2] * this.transform[3] -
            this.transform[0] * this.transform[5];
        h33 =
            this.transform[0] * this.transform[4] -
            this.transform[1] * this.transform[3];

        this.inverseTransform = [
            h11 / det,
            h12 / det,
            h13 / det,
            h21 / det,
            h22 / det,
            h23 / det,
            h31 / det,
            h32 / det,
            h33 / det
        ];
    };

    //*************************************************************************

    /**
     * Computes the transform from geo position to unit square
     * Code taken from QTransform
     * @function computeTransform
     * @memberof GroundOverlayLayer#
     */
    GroundOverlayLayer.prototype.computeTransform = function() {
        if (this.quad === null) {
            // Sleeping mode, no compute
            return;
        }

        var q1 = this.quad[0];
        var q2 = this.quad[1];
        var q3 = this.quad[2];
        var q4 = this.quad[3];

        var tileConfig = this.getGlobe().getTileManager().tileConfig;
        if (tileConfig.srs !== "CRS:84") {
            q1 = tileConfig.project(q1);
            q2 = tileConfig.project(q2);
            q3 = tileConfig.project(q3);
            q4 = tileConfig.project(q4);
        }

        var dx0 = q1[0];
        var dx1 = q2[0];
        var dx2 = q3[0];
        var dx3 = q4[0];

        var dy0 = q1[1];
        var dy1 = q2[1];
        var dy2 = q3[1];
        var dy3 = q4[1];

        var ax = dx0 - dx1 + dx2 - dx3;
        var ay = dy0 - dy1 + dy2 - dy3;

        if (!ax && !ay) {
            //afine transform
            this.transform = [
                dx1 - dx0,
                dy1 - dy0,
                0,
                dx2 - dx1,
                dy2 - dy1,
                0,
                dx0,
                dy0,
                1
            ];
        } else {
            var ax1 = dx1 - dx2;
            var ax2 = dx3 - dx2;
            var ay1 = dy1 - dy2;
            var ay2 = dy3 - dy2;

            /*determinants */
            var gtop = ax * ay2 - ax2 * ay;
            var htop = ax1 * ay - ax * ay1;
            var bottom = ax1 * ay2 - ax2 * ay1;

            var a, b, c, d, e, f, g, h;
            /*i is always 1*/

            if (!bottom) {
                return;
            }

            g = gtop / bottom;
            h = htop / bottom;

            a = dx1 - dx0 + g * dx1;
            b = dx3 - dx0 + h * dx3;
            c = dx0;
            d = dy1 - dy0 + g * dy1;
            e = dy3 - dy0 + h * dy3;
            f = dy0;

            this.transform = [a, d, g, b, e, h, c, f, 1.0];
        }

        this.computeInverse();
    };

    //*************************************************************************

    return GroundOverlayLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Layer/OpenSearch/OpenSearchUtils',["jquery"],function($) {
    var OpenSearchUtils = {};

    OpenSearchUtils.getArrayBoundKey = function(tiles) {
        var key = "";
        if (tiles == null) {
            return "";
        }
        for (var i = 0; i < tiles.length; i++) {
            key += tiles[i].getKey();
        }
        return key;
    };
    /*************************************************************************************************************/
    /**
     * @function getAttributeValue
     * @memberof OpenSearchUtils#
     * @param {Object} object Object describing the parameter
     * @param {string} name Name of the parameter
     * @return {string} Value
     */
    OpenSearchUtils.getAttributeValue = function(object, name) {
        var reconstructedName = "_attr" + name;
        if (typeof object[reconstructedName] !== "undefined") {
            if (typeof object[reconstructedName]._value != "undefined") {
                return object[reconstructedName]._value;
            }
        }
        return null;
    };

    /*************************************************************************************************************/

    /**
     * Get the value
     * @function getValue
     * @memberof OpenSearchUtils#
     * @param {Object} object Object describing the parameter
     * @param {string} name Name of the parameter
     * @return {string} Value
     */
    OpenSearchUtils.getValue = function(object, name) {
        if (typeof object[name] !== "undefined") {
            if (typeof object[name]._text !== "undefined") {
                return object[name]._text;
            }
        }
        return null;
    };

    /*************************************************************************************************************/

    /**
     * Set the current value of a parameter
     * @function setCurrentValueToParam
     * @memberof OpenSearchUtils#
     * @param {OpenSearchForm} form Form
     * @param {string} name Name of the parameter
     * @param {string} value Value to set
     */
    OpenSearchUtils.setCurrentValueToParam = function(form, name, value) {
        var param; // param managed
        for (var i = 0; i < form.parameters.length; i++) {
            param = form.parameters[i];
            if (param.value === "{"+name+"}") {
                param.currentValue = value;
                $("#p_" + name).val(value);
                break;
            }
        }
    };

    /*************************************************************************************************************/

    /**
     * Get the current value of a parameter
     * @function getCurrentValue
     * @memberof OpenSearchUtils#
     * @param {OpenSearchForm} form Form
     * @param {string} name Name of the parameter
     * @return {string} Current value
     */
    OpenSearchUtils.getCurrentValue = function(form, name) {
        var param; // param managed
        for (var i = 0; i < form.parameters.length; i++) {
            param = form.parameters[i];
            if (param.value === "{"+name+"}") {
                return param.currentValue;
            }
        }
    };

    /*************************************************************************************************************/

    /**
     * Init navigation values
     * @function initNavigationValues
     * @memberof OpenSearchUtils#
     * @param {OpenSearchForm} form Form
     */
    OpenSearchUtils.initNavigationValues = function(form) {
        var param; // param managed
        for (var i = 0; i < form.parameters.length; i++) {
            param = form.parameters[i];
            if (param.value === "{count}") {
                param.currentValue = Math.ceil(param.maxInclusive * 0.2);
                //param.currentValue = Math.ceil(param.maxInclusive * 1);
                //param.currentValue = 20;
            } else if (param.value === "{startPage}") {
                param.currentValue = 1;
            } else {
                //console.log(param.name,param);
            }
        }
    };

    /*************************************************************************************************************/

    return OpenSearchUtils;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Layer/OpenSearch/OpenSearchCache',["underscore-min","../../Utils/Constants", "../../Gui/dialog/ErrorDialog"], function(_, Constants, ErrorDialog) {
    /**
     * @name OpenSearchCache
     * @class
     * Manage the OpenSearch cache
     * @memberof module:Layer
     */

    var OpenSearchCache = function() {
        this.maxTiles = 120;
        this.tileArray = [];
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchCache", "[New] " + this.getCacheStatus());
    };

    /**************************************************************************************************************/

    /**
     * Get cache status
     * @function getCacheStatus
     * @memberof OpenSearchCache#
     * @return {string} Status
     */

    OpenSearchCache.prototype.getCacheStatus = function() {
        var message = "";
        message +=
            "Cache : " +
            this.tileArray.length +
            "/" +
            this.maxTiles +
            " (size:" +
            this.getSize() +
            ")";
        return message;
    };


    /*************************************************************************************************************/

    /**
     * Get tile cache size (in term of number of features)
     * @function getTileSize
     * @memberof OpenSearchCache#
     * @param {Tile} tile Tile
     * @return {Integer} Number of features associated to the tile
     */

    OpenSearchCache.prototype.getTileSize = function(tile) {
        return tile.features.length;
    };

    /*************************************************************************************************************/

    /**
     * Get cache size (in term of number of features)
     * @function getSize
     * @memberof OpenSearchCache#
     * @return {Integer} Number of features associated to the cache
     */

    OpenSearchCache.prototype.getSize = function() {
        var nb = 0;
        for (var i = 0; i < this.tileArray.length; i++) {
            nb += this.getTileSize(this.tileArray[i]);
        }
        return nb;
    };


    OpenSearchCache.prototype.storeInCache = function(url, features, total) {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchCache", "[addTile]" + this.getCacheStatus());

        var myTile = {
            key: url,
            features: features.slice(),
            total: total
        };
        // If cache is full, remove first element
        if (this.tileArray.length === this.maxTiles) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchCache", "Cache full, remove oldest");
            this.tileArray.splice(0, 1);
        }
        this.tileArray.push(myTile);
    };

    OpenSearchCache.prototype.getCacheFromKey = function(url){
        var result =_.find(this.tileArray, function(tile) {
            return tile.key === url;
        });
        return (result === undefined) ? null: Object.assign({}, result);
    };


    /*************************************************************************************************************/

    /**
     * Reset the cache
     * @function reset
     * @memberof OpenSearchCache#
     */

    OpenSearchCache.prototype.reset = function() {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchCache", "[reset]");
        this.tileArray.length = 0;
    };

    /*************************************************************************************************************/

    return OpenSearchCache;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
define('gw/Layer/OpenSearchLayer',[
    "underscore-min",
    "../Renderer/FeatureStyle",
    "../Utils/Utils",
    "../Utils/UtilsIntersection",
    "./AbstractLayer",
    "./GroundOverlayLayer",
    "../Tiling/Tile",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "./OpenSearch/OpenSearchUtils",
    "./OpenSearch/OpenSearchCache",
    "moment"
], function(
    _,
    FeatureStyle,
    Utils,
    UtilsIntersection,
    AbstractLayer,
    GroundOverlayLayer,
    Tile,
    Constants,
    ErrorDialog,
    OpenSearchUtils,
    OpenSearchCache,
    Moment
) {
    /**
     * Update status attribute.<br/>
     * Called with pagination
     * @event OpenSearchLayer#updateStatsAttribute
     * @type {OpenSearchLayer~pagination|OpenSearchLayer~result}
     */

    /**
     * Toggle WMS<br/>
     * Called to display/undisplay the WMS related to the opensearch record
     * @event OpenSearchLayer#toggleWMS
     * @type {object}
     * @property {string} layer_name Name of the layer to make visible
     * @property {boolean} visible display/undisplay the layer related to the opensearch record
     */

    /**
     * Opensearch pagination.
     * @typedef {object} OpenSearchLayer~pagination
     * @property {string} shortName of the opensearch layer
     * @property {int} current page in the query
     */

    /**
     * Opensearch result.
     * @typedef {object} OpenSearchLayer~result
     * @property {string} shortName of the opensearch layer
     * @property {int} nb_loaded number of loaded records
     * @property {int} nb_total total number of records
     */

    /**
     * The time object.
     * @typedef {object} TimeTravelParams~details
     * @property {date|moment} date - the current time.
     * @property {string} display - the current date as string for display.
     * @property {object} [period] - time period.
     * @property {moment} [period.from] - start date.
     * @property {moment} [period.to] - stop date.
     */
    /**
     * @name OpenSearchLayer
     * @class
     * This layer draws an OpenSearch dynamic layer
     * @augments AbstractLayer
     * @param {Object} options Configuration properties for the layer. See {@link AbstractLayer} for base properties
     * @param {string} options.serviceUrl Url of OpenSearch description XML file
     * @param {int} [options.minOrder=5] Starting order for OpenSearch requests
     * @param {Boolean} [options.coordSystemRequired=true]
     * @param {FeatureStyle} [options.style=new FeatureStyle()]
     * @param {int} [options.heatmapMinFeatureCount=100] The minimum feature count to not display the heatmap anymore
     * @param {int} [options.heatmapMaxLevel=5] The maximum level where the heatmap can be displayed
     * @memberof module:Layer
     */
    var OpenSearchLayer = function(options) {
        options.zIndex = options.zIndex || Constants.DISPLAY.DEFAULT_VECTOR;
        AbstractLayer.prototype.constructor.call(this, Constants.LAYER.OpenSearch, options);

        this.minLevel = options.minLevel || 5;
        this.coordSystemRequired = options.hasOwnProperty("coordSystemRequired")? options.coordSystemRequired: true;


        this.previousKey = null;
        this.previousTileId = null;
        this.previousDistance = null;

        // Keep trace of all features loaded (TODO: make object more light, just keep geometry and style ?)
        this.features = [];
        // Keep all tiles associated to a feature id to add / remove them more efficiently
        this.featuresSet = {};

        // Keep trace of all tiles loaded (bound, key and features id associated)
        this.tilesLoaded = [];

        this.nbFeaturesTotal = 0;

        // last datetime for removing outside
        this.lastRemovingDateTime = null;
        this.removingDeltaSeconds = options.hasOwnProperty("removingDeltaSeconds")? options.removingDeltaSeconds: 1;

        this.nbFeaturesTotal = 0;


        // Pool for request management (manage outside to be sharable between multiple opensearch layers)
        this.pool = options.openSearchRequestPool;

        // Cache for data management
        this.cache = new OpenSearchCache();

        // Force Refresh
        this.forceRefresh = false;

        // Layer created on-the-fly to display quickook over openSearch layer
        // TODO: optimisation : created only once and reused ?
        this.currentQuicklookLayer = null;
        // Id of current feature displayed
        this.currentIdDisplayed = null;

        this.featuresAddedToNotLoadedTiles = {};

        this.heatmapMaxLevel = options.heatmapMaxLevel || 5;
        this.heatmapMinFeatureCount = options.heatmapMinFeatureCount || 100;

        this.colormap = [
            { pct: 0.00, color: [0.0, 0.0, 0.3] },
            { pct: 0.01, color: [0.0, 0.0, 1.0] },
            { pct: 0.05, color: [0.0, 1.0, 1.0] },
            { pct: 0.10, color: [0.0, 1.0, 0.0] },
            { pct: 0.25, color: [1.0, 1.0, 0.0] },
            { pct: 0.50, color: [1.0, 0.0, 0.0] },
            { pct: 1.00, color: [0.3, 0.0, 0.0] },
        ];

        this.heatmapTiles = {};
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, OpenSearchLayer);

    /**************************************************************************************************************/

    OpenSearchLayer.TileState = {
        LOADING: 0,
        LOADED: 1,
        NOT_LOADED: 2
    };

    function _fixCrossLine(features) {
        var len = features.length;
        while (len--) {
            var currentFeature = features[len];

            if (currentFeature.geometry) {
                switch (currentFeature.geometry.type) {
                case Constants.GEOMETRY.Point:
                    // Convert to geographic to simplify picking
                    if (currentFeature.geometry.coordinates[0] > 180) {
                        currentFeature.geometry.coordinates[0] -= 360;
                    }
                    break;
                case Constants.GEOMETRY.Polygon:
                    var ring = currentFeature.geometry.coordinates[0];
                    for (var j = 0; j < ring.length; j++) {
                        // Convert to geographic to simplify picking
                        if (ring[j][0] > 180) {
                            ring[j][0] -= 360;
                        }
                    }
                    break;
                default:
                    break;
                }
            }
        }
    }

    function _isAlreadyAdded(featureId, features) {
        var isFound = _.find(features, function (feature) { return feature.id === featureId; });
        return isFound !== undefined;
    }

    function _isAlreadyAddedInTile(featureId, tile) {
        if (typeof tile.associatedFeaturesId.length === "undefined") {
            return false;
        }
        var num = tile.associatedFeaturesId.indexOf(featureId);
        return num >= 0;
    }

    function _getColorForPercentage(pct, colormap) {
        var colors = colormap.slice(0);
        colors.sort(function(c0, c1) { return c0.pct - c1.pct; });

        const length = colors.length;

        // Find the pct bounds
        var color;
        // Pct is outside colormap bounds
        if (colors[0].pct > pct) {
            color = colors[0].color;
        } else if (colors[length - 1].pct < pct) {
            color = colors[length - 1].color;
        } else {
            for (var i = 0; i < length - 1; ++i) {
                const p0 = colors[i].pct;
                const p1 = colors[i + 1].pct;

                if (p0 <= pct && p1 >= pct) {
                    const p = (pct - p0) / (p1 - p0);
                    const c0 = colors[i].color;
                    const c1 = colors[i + 1].color;

                    color = [
                        (1.0 - p) * c0[0] + p * c1[0],
                        (1.0 - p) * c0[1] + p * c1[1],
                        (1.0 - p) * c0[2] + p * c1[2],
                    ];
                }
            }
        }

        return color;
    }

    /**
     * Internal function to sort tiles
     * @function _sortTilesByDistance
     * @param {Tile} t1 First tile
     * @param {Tile} t2 Second tile
     * @private
     */
    function _sortTilesByDistance(t1, t2) {
        return t1.distance - t2.distance;
    }

    function _computeGeometryExtent(geometry) {
        var result = {
            east: -180,
            west: +180,
            north: -90,
            south: +90
        };
        for (var i = 0; i < geometry.coordinates[0].length; i++) {
            var coord = geometry.coordinates[0][i];
            result.south = coord[1] < result.south ? coord[1] : result.south;
            result.north = coord[1] > result.north ? coord[1] : result.north;
            result.east = coord[0] > result.east ? coord[0] : result.east;
            result.west = coord[0] < result.west ? coord[0] : result.west;
        }
        return result;
    }

    function _removeFeature(layer, featureId, tile) {
        const featureData = layer.featuresSet[featureId];
        if (!featureData) return;

        const index = featureData.tiles.findIndex(function(element) {
            return element.key === tile.key;
        });

        if (index === -1) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchLayer.js:298", "Tile not found when removing feature");
        } else {
            const feature = layer.features[featureData.index];
            layer.getGlobe().getRendererManager().removeGeometryFromTile(feature.geometry, tile);

            featureData.tiles.splice(index, 1);
        }

        if (featureData.tiles.length === 0) {
            // No more tiles attached to this feature, remove it from the dataset
            delete layer.featuresSet[featureId];

            // And from the features list
            const lastFeature = layer.features.pop();
            if (featureData.index < layer.features.length) {
                // The poped feature is not the one we are removing, swap them
                layer.features[featureData.index] = lastFeature;

                // And update the index
                layer.featuresSet[lastFeature.id].index = featureData.index;
            }
        }
    }

    function _removeFeatures(layer) {
        for (const id in layer.featuresSet) {
            for (var tileIndex = layer.featuresSet[id].tiles.length - 1; tileIndex >= 0; --tileIndex) {
                _removeFeature(layer, id, layer.featuresSet[id].tiles[tileIndex]);
            }
        }

        layer.featuresSet = {};

        for (var i = 0; i < layer.tilesLoaded.length; i++) {
            layer.tilesLoaded[i].tile.osState[layer.getID()] = OpenSearchLayer.TileState.NOT_LOADED;
        }
        layer.tilesLoaded = [];

        layer.getGlobe().getRenderContext().requestFrame();
    }

    function _removeTile(layer, tile) {
        // If there is no features for this tile, there will be no associatedFeaturesId
        if (tile.associatedFeaturesId) {
            // Remove each feature associated with the tile
            for (const id in tile.associatedFeaturesId) {
                const featureId = tile.associatedFeaturesId[id];
                _removeFeature(layer, featureId, tile);
            }
            tile.associatedFeaturesId = [];
        }

        // Remove the tile
        const index = layer.tilesLoaded.findIndex(function(element) {
            return element.tile.key === tile.key;
        });

        if (index !== -1) {
            layer.tilesLoaded.splice(index, 1);
        }

        tile.osState[layer.getID()] = OpenSearchLayer.TileState.NOT_LOADED;

        delete layer.heatmapTiles[tile.level][tile.key];
        layer.buildHeatmap();
    }

    function _removeFeaturesOutside(layer, tiles) {
        var maxLevel = 0;
        for (var t of tiles) {
            if (maxLevel < t.level) {
                maxLevel = t.level;
            }
        }

        for (var i = 0; i < layer.tilesLoaded.length; i++) {
            var tile = layer.tilesLoaded[i].tile;

            var remove = (tile.level > maxLevel);

            if (!remove) {
                remove = !UtilsIntersection.tileIntersects(tile,tiles);
            }

            if (remove) {
                _removeTile(layer, tile);
            }
        }
    }

    function _addFeatureToRenderers(layer, feature, tile) {
        var geometry = feature.geometry;

        // Manage style, if undefined try with properties, otherwise use defaultStyle
        var style = layer.style;
        var props = feature.properties;
        if (props && props.style) {
            style = props.style;
        }

        // Manage geometry collection
        if (geometry.type === "GeometryCollection") {
            var geoms = geometry.geometries;
            for (var i = 0; i < geoms.length; i++) {
                layer.getGlobe().getRendererManager().addGeometryToTile(layer, geoms[i], style, tile);
            }
        } else {
            // Add geometry to renderers
            layer.getGlobe().getRendererManager().addGeometryToTile(layer, geometry, style, tile);
        }
    }

    function _addFeature(layer, feature, tile) {
        var featureData;

        var style = feature.properties.style ? feature.properties.style : layer.style;
        style.opacity = layer.getOpacity();


        // fix geometry gid
        feature.geometry.gid = feature.id;

        // fix feature ID
        if (!feature.hasOwnProperty("id")) {
            feature.id = feature.properties.identifier;
        }

        // fix style
        if (!feature.properties.hasOwnProperty("style")) {
            feature.properties.style = style;
        }

        if (!layer.featuresSet.hasOwnProperty(feature.id)) {
            layer.features.push(feature);
            featureData = {
                index: layer.features.length - 1,
                tiles: [tile],
            };
            layer.featuresSet[feature.id] = featureData;
        } else {
            featureData = layer.featuresSet[feature.id];

            // Store the tile
            featureData.tiles.push(tile);

            // Always use the base feature to manager geometry indices
            feature = layer.features[featureData.index];
        }

        if (!tile.associatedFeaturesId) tile.associatedFeaturesId = [];

        tile.associatedFeaturesId.push(feature.id);

        if (feature.geometry.type === "GeometryCollection") {
            var geoms = feature.geometry.geometries;
            for (var i = 0; i < geoms.length; i++) {
                layer.getGlobe().getRendererManager().addGeometryToTile(layer, geoms[i], style, tile);
            }
        } else {
            // Add geometry to renderers
            layer.getGlobe().getRendererManager().addGeometryToTile(layer, feature.geometry, style, tile);
        }

        if (tile.state !== Tile.State.LOADED) {
            if (!layer.featuresAddedToNotLoadedTiles[tile.key]) {
                layer.featuresAddedToNotLoadedTiles[tile.key] = [];
            }

            if (feature.geometry.type === "Point") {
                layer.featuresAddedToNotLoadedTiles[tile.key].length = 0;
            }

            layer.featuresAddedToNotLoadedTiles[tile.key].push(feature);
        }
    }

    function _cleanCache(layer) {
        layer.cache.reset();
        layer.previousViewKey = null;
    }

    function _prepareParameters(layer, tile) {
        var param; // param managed
        var code; // param code
        for (var i = 0; i < layer.getServices().queryForm.parameters.length; i++) {
            param = layer.getServices().queryForm.parameters[i];
            code = param.value;
            code = code.replace("?}", "}");
            if (code === "{geo:box}" && (tile.type === Constants.TILE.GEO_TILE || tile.type === Constants.TILE.MERCATOR_TILE)) {
                // set bbox
                param.currentValue =
                    tile.geoBound.west +
                    "," +
                    tile.geoBound.south +
                    "," +
                    tile.geoBound.east +
                    "," +
                    tile.geoBound.north;
            } else if (code === "{geo:geometry}" && tile.type === Constants.TILE.HEALPIX_TILE) {
                var corners = tile.getCorners();
                param.currentValue = "POLYGON(("+corners[0][0]+" "+corners[0][1]
                +","+corners[1][0]+" "+corners[1][1]
                +","+corners[2][0]+" "+corners[2][1]
                +","+corners[3][0]+" "+corners[3][1]
                +","+corners[0][0]+" "+corners[0][1]+"))";
            }
        }
    }

    function _addFeatureToRenderersCurrentLevel(layer, feature) {
        var geometry = feature.geometry;

        // Manage style, if undefined try with properties, otherwise use defaultStyle
        var style = layer.style;
        var props = feature.properties;
        if (props && props.style) {
            style = props.style;
        }

        // Manage geometry collection
        if (geometry.type === "GeometryCollection") {
            var geoms = geometry.geometries;
            for (var i = 0; i < geoms.length; i++) {
                layer.getGlobe().getRendererManager().addGeometryCurrentLevel(layer, geoms[i], style);
            }
        } else {
            // Add geometry to renderers
            layer.getGlobe().getRendererManager().addGeometryCurrentLevel(layer, geometry, style);
        }
    }

    function _removeFeatureFromRenderersCurrentLevel(layer, feature) {
        return layer.getGlobe().getRendererManager().removeGeometryCurrentLevel(feature.geometry, layer);
    }

    function _buildUrl(layer, tile, count) {
        //var url = this.serviceUrl + "/search?order=" + tile.order + "&healpix=" + tile.pixelIndex;
        if (!layer.getServices().hasOwnProperty("queryForm")) {
            return null;
        }
        var url = layer.getServices().queryForm.template;

        // Prepare parameters for this tile
        _prepareParameters(layer, tile);

        // Check each parameter
        var param; // param managed
        var currentValue; // value set
        for (
            var i = 0;
            i < layer.getServices().queryForm.parameters.length;
            i++
        ) {
            param = layer.getServices().queryForm.parameters[i];
            if (param.name === "maxRecords" && count) {
                currentValue = count;
            } else {
                currentValue = param.currentValueTransformed();
            }

            if (currentValue === null) {
                // Remove parameter if not mandatory (with a ?)
                url = url.replace(
                    "&" + param.name + "=" + param.value.replace("}", "?}"),
                    ""
                );
                url = url.replace(
                    param.name + "=" + param.value.replace("}", "?}"),
                    ""
                );
                // Set blank if parameter is mandatory
                url = url.replace(param.value, "");
            } else {
                // replace value
                url = url.replace(param.value, currentValue);
                // replace optional value
                url = url.replace(param.value.replace("}", "?}"), currentValue);
            }
        }
        return url;
    }

    function _isTileLoaded(tilesLoaded, key) {
        const index = tilesLoaded.findIndex(function(element) { return element.key === key; });
        return index !== -1;
    }

    function _removeFeaturesExternalFov(layer, tiles) {
        var doRemove = false;
        if (layer.lastRemovingDateTime === null) {
            doRemove = true;
        } else {
            doRemove = Date.now() - layer.lastRemovingDateTime >= layer.removingDeltaSeconds * 1000;
        }
        if (doRemove) {
            layer.lastRemovingDateTime = Date.now();
            _removeFeaturesOutside(layer, tiles);
        }
    }

    function _initOsState(layer, tile) {
        if (typeof tile.key === "undefined") {
            tile.key = tile.getKey();
        }
        // If no state defined...
        if (tile.osState == null) {
            //...set it to NOT_LOADED
            tile.osState = {};
        }
        if (tile.osState[layer.getID()] == null) {
            tile.osState[layer.getID()] = OpenSearchLayer.TileState.NOT_LOADED;
        }
    }

    function _mustBeRefreshed(previousKey, currentKey, forceRefreshed) {
        var needRefresh;
        if (previousKey === null || forceRefreshed === true) {
            needRefresh = true;
        } else {
            needRefresh = previousKey !== currentKey;
        }
        return needRefresh;
    }

    function _computeStats(layer) {
        var nb = 0;
        for(var i=0; i<layer.tilesLoaded.length; i++) {
            var tileLoaded = layer.tilesLoaded[i].tile;
            if(tileLoaded.associatedFeaturesId) {
                nb = nb + tileLoaded.associatedFeaturesId.length;
            }
        }
        console.log("features in tileLoaded :"+nb);
        console.log("nb features :"+layer.features.length);
    }

    function _requestTile(layer, tile, count) {
        var url = _buildUrl(layer, tile, count);
        if (url !== null) {
            var cachedTile = layer.cache.getCacheFromKey(url);
            if(cachedTile == null) {
                // cache
                tile.osState[layer.getID()] =  OpenSearchLayer.TileState.LOADING;
                layer.pool.addQuery(url, tile, layer);
            } else {
                // If no state defined...
                if (cachedTile.osState == null) {
                    //...set it to NOT_LOADED
                    cachedTile.osState = {};
                }
                cachedTile.osState[layer.getID()] =  OpenSearchLayer.TileState.LOADING;
                layer.computeFeaturesResponse(cachedTile.features, cachedTile, cachedTile.total);
            }
            _computeStats(layer);
        }
    }

    function _setTileLoaded(tile, id) {
        // Only if tile was LOADING...
        if (tile.osState[id] === OpenSearchLayer.TileState.LOADING) {
            // ...set to LOADED
            tile.osState[id] = OpenSearchLayer.TileState.LOADED;
        }
    }

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof OpenSearchLayer#
     */
    OpenSearchLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.VECTOR;
    };

    /**
     * @function setTime
     * @memberof OpenSearchLayer#
     * @param {Time.configuration} time Time configuration
     */
    OpenSearchLayer.prototype.setTime = function(time) {
        AbstractLayer.prototype.setTime(time);
        this.setParameter.call(this, "mizar:time", time);
    };

    /**
     * @function setParameter
     * @memberof OpenSearchLayer#
     * @param {string} paramName Name of parameter
     * @param {Time.configuration} value Time configuration
     */
    OpenSearchLayer.prototype.setParameter = function(paramName, value) {
        if (paramName === "mizar:time") {
            value.period.from = Moment(value.period.from).format("YYYY-MM-DD HH:mm");
            value.period.to = Moment(value.period.to).format("YYYY-MM-DD HH:mm");

            OpenSearchUtils.setCurrentValueToParam(this.getServices().queryForm,"time:start",value.period.from);
            OpenSearchUtils.setCurrentValueToParam(this.getServices().queryForm,"time:end",value.period.to);
        } else {
            OpenSearchUtils.setCurrentValueToParam(this.getServices().queryForm,paramName,value
            );
        }
        this.resetAll();
    };

    /**
     * Go to next page
     * @function nextPage
     * @memberof OpenSearchLayer#
     * @fires OpenSearchLayer#updateStatsAttribute
     */
    OpenSearchLayer.prototype.nextPage = function() {
        var num = OpenSearchUtils.getCurrentValue(this.getServices().queryForm,"startPage");
        // If not specified, set default to 1
        if (num === null || typeof num === "undefined") {
            num = 1;
        } else {
            num = parseInt(num);
        }
        OpenSearchUtils.setCurrentValueToParam(this.getServices().queryForm,"startPage",num + 1);

        // update labels
        this.callbackContext.publish(
            Constants.EVENT_MSG.LAYER_UPDATE_STATS_ATTRIBUTES,
            {
                shortName: this.getShortName(),
                page: num + 1
            }
        );

        this.forceRefresh = true;
        for (var i = 0; i < this.tilesLoaded.length; i++) {
            this.tilesLoaded[i].tile.osState[this.getID()] = OpenSearchLayer.TileState.NOT_LOADED;
        }
        this.getGlobe().getRenderContext().requestFrame();
    };

    /**************************************************************************************************************/

    /**
     * Attaches the layer to the globe
     * @function _attach
     * @memberof OpenSearchLayer#
     * @param g The globe
     * @private
     */
    OpenSearchLayer.prototype._attach = function(g) {
        AbstractLayer.prototype._attach.call(this, g);
        g.getTileManager().addPostRenderer(this);
    };

    /**************************************************************************************************************/

    /**
     * Detach the layer from the globe
     * @function _detach
     * @memberof OpenSearchLayer#
     * @private
     */
    OpenSearchLayer.prototype._detach = function() {
        this.getGlobe().getTileManager().removePostRenderer(this);
        AbstractLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    OpenSearchLayer.prototype.modifyFeatureStyle = function(feature, style, useFeatureStyle) {
        if (useFeatureStyle && feature.properties.style) {
            for (var key in feature.properties.style) {
                if (!feature.properties.style.hasOwnProperty(key)) continue;

                style[key] = feature.properties.style[key];
            }
        }

        const rm = this.getGlobe().getRendererManager();
        if (this.featuresSet[feature.id]) {
            for (var tile of this.featuresSet[feature.id].tiles) {
                try {
                    rm.removeGeometryFromTile(feature.geometry, tile);
                    rm.addGeometryToTile(this, feature.geometry, style, tile);
                } catch (error) { /* e */ }
            }
        }
    };

    /**
     * Load quicklook
     * @function loadQuicklook
     * @memberof OpenSearchLayer#
     * @param {Feature} feature Feature
     * @param {string} url Url of image
     */
    OpenSearchLayer.prototype.loadQuicklook = function(feature, url) {
        // Save coordinates
        this.currentIdDisplayed = feature.id;

        // Get quad coordinates
        var coordinates = feature.geometry.coordinates[0];
        var quad = [];
        for (var i = 0; i < 4; i++) {
            quad[i] = coordinates[i];
        }

        if (this.currentQuicklookLayer === null) {
            // Creation first time
            this.currentQuicklookLayer = new GroundOverlayLayer({quad: quad,image: url});
            this.currentQuicklookLayer._attach(this.globe);
        } else {
            this.currentQuicklookLayer.update(quad, url);
        }
        //TODO : Does not work because it is not added to the renderer but postRenderer
        //TODO : Test : load OSM + S1. Click on S1, load quicklook
        this.currentQuicklookLayer.setOnTheTop();
        this.getGlobe().refresh();
    };

    /**************************************************************************************************************/

    /**
     * Indicate if quicklook is currently displayed
     * @function isQuicklookDisplayed
     * @memberof OpenSearchLayer#
     * @return {Boolean} Is quicklook currently displayed ?
     */
    OpenSearchLayer.prototype.isQuicklookDisplayed = function() {
        // Trivial case
        return this.currentQuicklookLayer !== null;
    };

    /**************************************************************************************************************/

    /**removeGeometry
     * Remove quicklook
     * @function removeQuicklook
     * @memberof OpenSearchLayer#
     */
    OpenSearchLayer.prototype.removeQuicklook = function() {
        if (this.currentQuicklookLayer === null) {
            return;
        }

        this.currentQuicklookLayer._detach();
        this.currentQuicklookLayer = null;
    };

    /**************************************************************************************************************/

    /**
     * Highlight feature
     * @function highlight
     * @memberof OpenSearchLayer#
     * @param {Feature} feature Feature
     * @param {FeatureStyle} style Style
     */
    OpenSearchLayer.prototype.highlight = function(feature, style) {
        feature.properties.style = style;
        _addFeatureToRenderersCurrentLevel(this, feature);
    };

    /**
     * Unhighlight feature
     * @function unhighlight
     * @memberof OpenSearchLayer#
     * @param {Feature} feature Feature
     * @param {FeatureStyle} style Style
     */
    OpenSearchLayer.prototype.unhighlight = function(feature, style) {
        _removeFeatureFromRenderersCurrentLevel(this, feature);
    };

    /**
     * Render function
     * @function render
     * @memberof OpenSearchLayer#
     * @param {Tile[]} tiles The array of tiles to render
     * @fires Context#startLoad
     * @fires Context#endLoad
     * @fires Context#features:added
     */
    OpenSearchLayer.prototype.render = function(tiles) {
        if (!this.isVisible() || tiles.length === 0) {
            return;
        }

        // Check if we have features that might be missing
        if (Object.keys(this.featuresAddedToNotLoadedTiles).length > 0) {
            for (var tile of tiles) {
                if (tile.state === Tile.State.LOADED && this.featuresAddedToNotLoadedTiles[tile.key]) {
                    for (var feature of this.featuresAddedToNotLoadedTiles[tile.key]) {
                        _addFeature(this, feature, tile);
                    }
                    delete this.featuresAddedToNotLoadedTiles[tile.key];
                }
            }
        }

        this.currentKey = OpenSearchUtils.getArrayBoundKey(tiles);

        // if (_mustBeRefreshed(this.previousKey, this.currentKey, this.forceRefresh)) {
        if (this.forceRefresh === true) {
            // Remove cache, in order to reload new features
            _cleanCache(this);
            this.forceRefresh = false;
        }

        var localTiles = tiles.slice(0);

        // Sort tiles in order to load the first tiles closed to the camera
        localTiles.sort(_sortTilesByDistance);

        this.currentLevel = localTiles[0].level;
        this.ctx = this.callbackContext;

        this.isZoomLevelChanged = this.currentLevel !== this.previousLevel;

        if (this.isZoomLevelChanged) {
            // Go to page 1
            OpenSearchUtils.setCurrentValueToParam(
                this.getServices().queryForm,
                "startPage",
                1
            );
            // update labels
            this.callbackContext.publish(
                Constants.EVENT_MSG.LAYER_UPDATE_STATS_ATTRIBUTES,
                {
                    shortName: this.getShortName(),
                    page: 1
                }
            );

            if (this.previousLevel !== undefined && this.previousLevel !== null) {
                if (this.heatmapTiles && this.heatmapTiles[this.previousLevel]) {
                    const oldKeys = Object.keys(this.heatmapTiles[this.previousLevel]);
                    for (var i = oldKeys.length - 1; i >= 0; --i)  {
                        const key = oldKeys[i];
                        const heatmapData = this.heatmapTiles[this.previousLevel][key];
                        if (heatmapData.feature) _removeFeature(this, heatmapData.feature.id, heatmapData.tile);

                        heatmapData.tile.osState[this.getID()] = OpenSearchLayer.TileState.NOT_LOADED;

                        delete this.heatmapTiles[this.previousLevel][key];
                    }
                }
            }
        }

        this.nbFeaturesTotal = 0;

        // =========================================================================
        // Check each tile
        // =========================================================================

        this.previousLevel = this.currentLevel;
        this.previousKey = this.currentKey;
        for (var j = 0; j < localTiles.length; j++) {
            var currentTile = localTiles[j];

            _initOsState(this, currentTile);
            switch (currentTile.osState[this.getID()]) {
            case OpenSearchLayer.TileState.NOT_LOADED:
                // First load the least possible amount of data
                _requestTile(this, currentTile, 1);
                break;
            case OpenSearchLayer.TileState.LOADED:
                //console.log("tile still loaded !!!");
                break;
            case OpenSearchLayer.TileState.LOADING:
                //console.log("tile loading...");
                break;
            default:
                break;
            }
        }

        // Remove all feature outside view of tiles
        _removeFeaturesExternalFov(this, localTiles);
        // }
    };

    /**************************************************************************************************************/

    /**
     * setRequestProperties OpenSearch form from a submit
     * @function setRequestProperties
     * @memberof OpenSearchLayer#
     * @param {Object} properties query parameters from query form
     */
    OpenSearchLayer.prototype.setRequestProperties = function(properties) {
        this.getServices().queryForm.setParametersValueFrom(properties);
        this.getServices().queryForm.updateFromGUI();
        this.resetAll();
        this.forceRefresh = true;
    };

    /**************************************************************************************************************/

    /**
     * @function setVisible
     * @memberof OpenSearchLayer#
     * @throws {TypeError} - The parameter of setVisible should be a boolean
     */
    OpenSearchLayer.prototype.setVisible = function(arg) {
        if (typeof arg === "boolean") {
            // Change for current layer
            if (this.visible !== arg && this.getGlobe().attributionHandler) {
                this.getGlobe().attributionHandler.toggleAttribution(this);
            }
            this.visible = arg;

            var linkedLayers = this.callbackContext.getLinkedLayers(this.ID);
            // Change for wms linked layers
            for (var i = 0; i < linkedLayers.length; i++) {
                linkedLayers[i].setVisible(arg);
            }

            if (
                typeof this.currentQuicklookLayer !== "undefined" &&
                this.currentQuicklookLayer !== null
            ) {
                //this.currentQuicklookLayer.setVisible(this.visible);
                if (this.visible === false) {
                    this.removeQuicklook();
                }
            }

            if (this.getGlobe()) {
                this.getGlobe()
                    .getRenderContext()
                    .requestFrame();
            }
            this.publish(Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED, this);
        } else {
            throw new TypeError(
                "the parameter of setVisible should be a boolean",
                "AbstractLayer.js"
            );
        }
    };

    /**************************************************************************************************************/
    /**
     * @function setOpacity
     * @memberof OpenSearchLayer#
     * @throws {RangeError} opacity - opacity value should be a value in [0..1]
     */
    OpenSearchLayer.prototype.setOpacity = function(arg) {
        if (typeof arg === "number" && arg >= 0.0 && arg <= 1.0) {
            var targetStyle = new FeatureStyle(this.getStyle());
            targetStyle.setOpacity(arg);

            for (var i = 0; i < this.features.length; i++) {
                this.modifyFeatureStyle(this.features[i], targetStyle, true);
            }

            var linkedLayers = this.callbackContext.getLinkedLayers(
                this.getID()
            );
            // Change for wms linked layers
            for (i = 0; i < linkedLayers.length; i++) {
                linkedLayers[i].getStyle().setOpacity(arg);
            }

            AbstractLayer.prototype.setOpacity.call(this, arg);
        } else {
            throw new RangeError(
                "opacity value should be a value in [0..1]",
                "AbstractLayer.js"
            );
        }
    };

    /**************************************************************************************************************/

    /**
     * Reset pool, cache and all OpenSearch data loaded
     * @function resetAll
     * @memberof OpenSearchLayer#
     */
    OpenSearchLayer.prototype.resetAll = function() {
        // Reset pool
        this.pool.resetPool();
        // Reset cache
        _cleanCache(this);
        // Remove all features
        _removeFeatures(this);
    };


    /**
     * Load WMS layer
     * @function loadWMS
     * @memberof OpenSearchLayer#
     * @param {Json} selectedData Selected data
     * @fires OpenSearchLayer#toggleWMS
     * @fires Context#backgroundLayer:added
     * @fires Context#layer:added
     */
    OpenSearchLayer.prototype.loadWMS = function(selectedData) {
        var extent = _computeGeometryExtent(selectedData.feature.geometry);
        var endpoint = selectedData.feature.properties.services.browse.layer.url;
        var name = selectedData.layer.name + " (WMS)";
        var layerDescription = {
            type: "WMS",
            name: name,
            baseUrl: endpoint,
            onlyFirst: true,
            format: "image/png",
            visible: true,
            restrictTo: extent,
            background: false,
            linkedTo: selectedData.layer.ID
        };
        var self = this;
        selectedData.layer.callbackContext.addLayer(layerDescription, function(layerID) {
            // Add feature id of wms into list a current WMS displayed
            self.addServicesRunningOnRecord(selectedData.feature.id, layerID);

            var layer = self.callbackContext.getLayerByID(layerID);
            layer.setOnTheTop();

            if (typeof self.callbackContext !== "undefined") {
                self.callbackContext.publish(
                    Constants.EVENT_MSG.LAYER_TOGGLE_WMS,
                    {
                        layer_name: selectedData.layer.getShortName(),
                        visible: true
                    }
                );
            }
        });
    };

    /**************************************************************************************************************/

    /**
     * Unload all WMS layer
     * @function unloadAllWMS
     * @memberof OpenSearchLayer#
     * @fires OpenSearchLayer#toggleWMS
     */
    OpenSearchLayer.prototype.unloadAllWMS = function(selectedData) {
        this.removeServicesRunningOnRecords();
        this.removeServicesRunningOnCollection();

        this.callbackContext.refresh();

        if (typeof this.callbackContext !== "undefined") {
            if (typeof selectedData !== "undefined") {
                this.callbackContext.publish(
                    Constants.EVENT_MSG.LAYER_TOGGLE_WMS,
                    {
                        layer_name: selectedData.layer.getShortName(),
                        visible: false
                    }
                );
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Unload WMS layer
     * @function unloadWMS
     * @memberof OpenSearchLayer#
     * @param {Json} selectedData Selected data
     * @fires OpenSearchLayer#toggleWMS
     */
    OpenSearchLayer.prototype.unloadWMS = function(selectedData) {
        // Remove feature id
        this.removeServicesRunningOnRecord(selectedData.feature.id);

        selectedData.layer.callbackContext.refresh();

        if (typeof this.callbackContext !== "undefined") {
            this.callbackContext.publish(Constants.EVENT_MSG.LAYER_TOGGLE_WMS, {
                layer_name: selectedData.layer.getShortName(),
                visible: false
            });
        }
    };

    /**************************************************************************************************************/
    /**
     * Compute a response to OpenSearch query
     * @function computeFeaturesResponse
     * @memberof OpenSearchLayer#
     * @param {Array} features Array of features loaded
     * @param {Tile} tile Tile
     * @param {int} nbFeaturesTotalPerTile Total number of features found over all pages for a given tile
     * @fires OpenSearchLayer#updateStatsAttribute
     */
    OpenSearchLayer.prototype.computeFeaturesResponse = function(features, tile, nbFeaturesTotalPerTile) {
        var ableToContinue = true;

        const { level, key } = tile;

        if (!this.heatmapTiles[level]) {
            this.heatmapTiles[level] = {};
        }

        this.heatmapTiles[level][key] = {
            tile: tile,
            nbFeatures: nbFeaturesTotalPerTile
        };

        if (nbFeaturesTotalPerTile > this.heatmapMinFeatureCount && level <= this.heatmapMaxLevel) {
            ableToContinue = false;

            this.heatmapTiles[level][key].shouldBeDrawn = true;
        }
        else if (features.length === 1) {
            ableToContinue = false;
            // Set 10 times more than the parsed value because the features total
            // number is approximative
            // TODO Iterate on each page until there is no feature to parse
            _requestTile(this, tile, this.heatmapMinFeatureCount);
        }

        this.buildHeatmap();

        if (!ableToContinue) {
            return;
        }

        _fixCrossLine(features);

        // compute the total number of available features on the server in the FOV
        this.nbFeaturesTotal += nbFeaturesTotalPerTile;

        // For each feature...
        for (var feature of features) {
            try {
                _addFeature(this, feature, tile);
            } catch (error) { /* error */ }
            // Add features to renderer if this is attached to planet
        }

        if (typeof this.callbackContext !== "undefined") {
            this.callbackContext.publish(
                Constants.EVENT_MSG.LAYER_UPDATE_STATS_ATTRIBUTES,
                {
                    shortName: this.getShortName(),
                    nb_loaded: this.features.length,
                    nb_total: this.nbFeaturesTotal
                }
            );
        }

        _setTileLoaded(tile, this.getID());

        this.getGlobe().refresh();

        if (!_isTileLoaded(this.tilesLoaded, tile.key)) {
            this.tilesLoaded.push({
                key: key,
                tile: tile
            });
        }

        // Publish event that layer have received new features
        this.getGlobe()
            .publishEvent(Constants.EVENT_MSG.FEATURED_ADDED, {
                layer: this,
                features: this.features
            });
    };

    /**************************************************************************************************************/
    /**
     * Build a heatmap showing the amount of OS data per tile currently displayed on screen
     * @function buildHeatmap
     * @memberof OpenSearchLayer#
     */
    OpenSearchLayer.prototype.buildHeatmap = function() {
        var total = 0;

        const heatmapData = this.heatmapTiles[this.currentLevel];

        for (const key in heatmapData) {
            total += heatmapData[key].nbFeatures;
        }

        for (const key in heatmapData) {
            const entry = heatmapData[key];
            if (entry.shouldBeDrawn) {
                const pct = entry.nbFeatures / total;
                const { tile } = entry;

                const center = [
                    (tile.geoBound.east + tile.geoBound.west) / 2.0,
                    (tile.geoBound.north + tile.geoBound.south) / 2.0
                ];

                const color = _getColorForPercentage(pct, this.colormap);

                const textFeature = {
                    type: "Feature",
                    id: `${this.ID}_${key}_text`,
                    geometry: {
                        type: "Point",
                        coordinates: center,
                        crs: {
                            type: "name",
                            properties: {
                                name: tile.config.srs
                            }
                        }
                    },
                    properties: {
                        "Feature count": `${entry.nbFeatures}`,
                        "Percentage": `${(pct * 100).toFixed(2).toString()}%`,
                        style: {
                            label: `${(pct * 100).toFixed(2).toString()}%`,
                            fillColor: color,
                            strokeColor: color,
                            textColor: color,
                            opacity: 1,
                            pointMaxSize: 500,

                            extrusionScale: 1,
                            fill: false,
                            fillShader: null,
                            fillTexture: null,
                            fillTextureUrl: null,
                            icon: null,
                            iconUrl: null,
                            onTerrain: true,
                            strokeWidth: 1,
                            zIndex: 0
                        }
                    },
                };

                if (entry.feature) {
                    if (entry.feature.pickData && entry.feature.pickData.picked) {
                        entry.feature.pickData.pickSelection[entry.feature.pickData.index].feature = textFeature;
                        textFeature.pickData = entry.feature.pickData;
                    }
                    _removeFeature(this, entry.feature.id, tile);
                }

                entry.feature = textFeature;

                _addFeature(this, textFeature, tile);

                if (this.tilesLoaded.findIndex(function(element) { return element.key === tile.key; }) === -1) {
                    this.tilesLoaded.push({
                        key: tile.key,
                        tile: tile
                    });
                }

                _setTileLoaded(tile, this.getID());
            }
        }
    };

    /*************************************************************************************************************/

    return OpenSearchLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Services/PickingManagerCore',[
    "../Renderer/FeatureStyle",
    "../Layer/OpenSearchLayer",
    "../Utils/Utils",
    "../Utils/UtilsIntersection",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function(
    FeatureStyle,
    OpenSearchLayer,
    Utils,
    UtilsIntersection,
    Constants,
    ErrorDialog
) {
    const DEFAULT_SIZE_MULTIPLICATOR = 1;

    var ctx;
    var globe;

    var pickableLayers = [];
    var selection = [];
    var stackSelectionIndex = -1;

    var selectedStyle = new FeatureStyle({
        strokeColor: [1.0, 0.0, 0.0, 1.0],
        fillColor: [1.0, 1.0, 0.0, 1.0],
        zIndex: Constants.DISPLAY.SELECTED_VECTOR
    });

    var highlightedSelectedStyle = new FeatureStyle({
        strokeColor: [0.0, 0.0, 1.0, 1.0],
        fillColor: [0.0, 0.0, 1.0, 1.0],
        zIndex: Constants.DISPLAY.HIGHLIGHTED_VECTOR
    });    

    /**************************************************************************************************************/

    /**
     *    Add pickable layer to the pickableLayers list
     *    @function addPickableLayer
     *    @param {AbstractLayer} layer
     */
    function addPickableLayer(layer) {
        if (pickableLayers.indexOf(layer) === -1) {
            pickableLayers.push(layer);
        } else {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "PickingManagerCore.js", layer.name + " has been already added");
        }
    }

    /**************************************************************************************************************/

    /**
     *    Remove pickable layers
     *    @param {AbstractLayer} layer
     */
    function removePickableLayer(layer) {
        for (var i = 0; i < pickableLayers.length; i++) {
            if (layer.id === pickableLayers[i].id) {
                pickableLayers.splice(i, 1);
            }
        }
    }

    /**************************************************************************************************************/

    /**
     * Get the list of pickable layers
     * @returns {Array} pickableLayers
     */
    function getPickableLayers() {
        return pickableLayers;
    }

    /**************************************************************************************************************/

    /**
     *    Revert style of selected feature
     */
    function blurSelectedFeature() {
        var selectedData = this.getSelection()[this.stackSelectionIndex];
        if (selectedData) {
            var style = new FeatureStyle(selectedData.feature.properties.style);
            switch (selectedData.feature.geometry.type) {
            case Constants.GEOMETRY.LineString:
            case Constants.GEOMETRY.MultiLineString:
            case Constants.GEOMETRY.Polygon:
            case Constants.GEOMETRY.MultiPolygon:
                style.strokeColor = this.selectedStyle.strokeColor;
                break;
            case Constants.GEOMETRY.Point:
                // Use stroke color while reverting
                style.fillColor = this.selectedStyle.fillColor;
                break;
            default:
                break;
            }
            style.zIndex = selectedStyle.zIndex;
            selectedData.layer.modifyFeatureStyle(
                selectedData.feature,
                style
            );       
        }
    }

    /**************************************************************************************************************/

    /**
     *    Apply selected style to the feature by the given index in selection array
     *
     *    @param index Index of feature in selection array
     *    @param options
     *        <li>isExclusive : Boolean indicating if the focus is exclusive</li>
     *        <li>color : Highlight color</li>
     */
    function focusFeatureByIndex(index, options) {
        if (options && options.isExclusive) {
            blurSelection();
        }

        // Update highlight color
        var strokeColor = options.color
            ? FeatureStyle.fromStringToColor(options.color)
            : this.highlightedSelectedStyle.strokeColor;
        var fillColor = options.color
            ? FeatureStyle.fromStringToColor(options.color)
            : this.highlightedSelectedStyle.fillColor;

        var selectedData = this.getSelection()[index];
        if (selectedData) {
            this.stackSelectionIndex = index;
            var style = new FeatureStyle(selectedData.feature.properties.style);
            switch (selectedData.feature.geometry.type) {
            case Constants.GEOMETRY.LineString:
            case Constants.GEOMETRY.MultiLineString:
            case Constants.GEOMETRY.Polygon:
            case Constants.GEOMETRY.MultiPolygon:
                style.strokeColor = strokeColor;
                style.strokeWidth = style.strokeWidth + 2;                
                break;
            case Constants.GEOMETRY.Point:
                style.fillColor = fillColor;
                break;
            default:
                break;
            }
            style.zIndex = this.highlightedSelectedStyle.zIndex;
            selectedData.layer.modifyFeatureStyle(
                selectedData.feature,
                style
            );            
        }
        globe.refresh();
    }

    /**************************************************************************************************************/

    /**
     * Get the current selection
     * @returns {Array}
     */
    function getSelection() {
        return selection;
    }

    /**************************************************************************************************************/

    /**
     *    Revert style of selection
     */
    function blurSelection() {
        for (var i = 0; i < this.getSelection().length; i++) {
            var selectedData = this.getSelection()[i];
            var style = new FeatureStyle(selectedData.feature.properties.style);
            switch (selectedData.feature.geometry.type) {
            case Constants.GEOMETRY.LineString:
            case Constants.GEOMETRY.MultiLineString:
            case Constants.GEOMETRY.Polygon:
            case Constants.GEOMETRY.MultiPolygon:
                style.strokeColor = selectedData.layer.getStyle().strokeColor;
                style.strokeWidth = selectedData.layer.getStyle().strokeWidth;
                break;
            case Constants.GEOMETRY.Point:
                // Use stroke color while reverting
                style.fillColor = selectedData.feature.properties.style.strokeColor;
                break;
            default:
                break;
            }
            style.zIndex = selectedData.layer.getStyle().zIndex;

            if (selectedData.layer.getGlobe()) {
                // Layer is still attached to globe
                selectedData.layer.modifyFeatureStyle(
                    selectedData.feature,
                    style
                );                
            }

            if (selectedData.feature.pickData) {
                delete selectedData.feature.pickData;
            }
        }
    }

    /**************************************************************************************************************/

    /**
     *    Apply style to selection
     *    @param {Array} newSelection selection of data
     */
    function focusSelection(newSelection) {
        var style;
        var startTime;
        var endTime;
        var focusLayers = {};
        for (var i = 0; i < newSelection.length; i++) {
            var selectedData = newSelection[i];
            if (selectedData.feature.properties.style) {
                style = new FeatureStyle(selectedData.feature.properties.style);
            } else {
                style = new FeatureStyle(selectedData.layer.getStyle());
            }
            switch (selectedData.feature.geometry.type) {
            case Constants.GEOMETRY.LineString:
            case Constants.GEOMETRY.MultiLineString:
            case Constants.GEOMETRY.Polygon:
            case Constants.GEOMETRY.MultiPolygon:
                style.strokeColor = this.selectedStyle.strokeColor;
                style.strokeWidth = style.strokeWidth + 1;
                break;
            case Constants.GEOMETRY.Point:
                style.fillColor = this.selectedStyle.fillColor;
                break;
            default:
                break;
            }
            style.zIndex = this.selectedStyle.zIndex;
            selectedData.layer.modifyFeatureStyle(
                selectedData.feature,
                style
            );
        }
        /*            for (var layerID in focusLayers) {
                currentLayer = focusLayers[layerID];
                currentLayer.layer.modifyFeatureStyles(
                    currentLayer.focusFeatures,
                    currentLayer.focusStyles
                );
            }
        */
    }

    /**************************************************************************************************************/

    /**
     *    Clear selection
     */
    function clearSelection() {
        this.blurSelection();
        this.setSelection([]);
    }

    /**************************************************************************************************************/

    /**
     * Check if a geometry crosses the date line
     * @param {Array} pickPoint
     * @param {Array}coords
     * @returns {Array} coords
     */
    function fixDateLine(pickPoint, coords) {
        var crossDateLine = false;
        var startLon = coords[0][0];
        for (var i = 1; i < coords.length && !crossDateLine; i++) {
            var deltaLon = Math.abs(coords[i][0] - startLon);
            if (deltaLon > 180) {
                // DateLine!
                crossDateLine = true;
            }
        }
        var n;
        if (crossDateLine) {
            var fixCoords = [];

            if (pickPoint[0] < 0.0) {
                // Ensure coordinates are always negative
                for (n = 0; n < coords.length; n++) {
                    if (coords[n][0] > 0) {
                        fixCoords[n] = [coords[n][0] - 360, coords[n][1]];
                    } else {
                        fixCoords[n] = [coords[n][0], coords[n][1]];
                    }
                }
            } else {
                // Ensure coordinates are always positive
                for (n = 0; n < coords.length; n++) {
                    if (coords[n][0] < 0) {
                        fixCoords[n] = [coords[n][0] + 360, coords[n][1]];
                    } else {
                        fixCoords[n] = [coords[n][0], coords[n][1]];
                    }
                }
            }

            return fixCoords;
        } else {
            return coords;
        }
    }

    /**************************************************************************************************************/

    /**
     * Picking test for feature depending on its geometry type
     * @param {Object} feature
     * @param {Array} pickPoint
     * @returns {Boolean} isPicked
     */
    function featureIsPicked(feature, pickPoint, pickingNoDEM, options) {
        var i, j, p;
        var feat, featNext, ring, isMobile;
        var sizeMultiplicator =
            options && options.sizeMultiplicator
                ? options.sizeMultiplicator
                : DEFAULT_SIZE_MULTIPLICATOR;
        switch (feature.geometry.type) {
        case Constants.GEOMETRY.LineString:
            if (!pickPoint) { return false; }
            for (i = 0; i < feature.geometry.coordinates.length - 1; i++) {
                feat = feature.geometry.coordinates[i];
                featNext = feature.geometry.coordinates[i + 1];
                if (
                    UtilsIntersection.pointInLine(pickPoint, feat, featNext)
                ) {
                    return true;
                }
            }
            //var ring = this.fixDateLine(pickPoint, feature['geometry']['coordinates'][0]);
            break;
        case Constants.GEOMETRY.MultiLineString:
            if (!pickPoint) { return false; }
            for (i = 0; i < feature.geometry.coordinates.length; i++) {
                for (
                    j = 0;
                    j < feature.geometry.coordinates[i].length - 1;
                    j++
                ) {
                    feat = feature.geometry.coordinates[i][j];
                    featNext = feature.geometry.coordinates[i][j + 1];
                    if (
                        UtilsIntersection.pointInLine(
                            pickPoint,
                            feat,
                            featNext
                        )
                    ) {
                        return true;
                    }
                }
            }
            break;
        case Constants.GEOMETRY.Polygon:
            if (!pickPoint) { return false; }
            ring = this.fixDateLine(
                pickPoint,
                feature.geometry.coordinates[0]
            );
            return UtilsIntersection.pointInRing(pickPoint, ring);
        case Constants.GEOMETRY.MultiPolygon:
            if (!pickPoint) { return false; }
            for (p = 0; p < feature.geometry.coordinates.length; p++) {
                ring = this.fixDateLine(
                    pickPoint,
                    feature.geometry.coordinates[p][0]
                );
                if (UtilsIntersection.pointInRing(pickPoint, ring)) {
                    return true;
                }
            }
            return false;
        case Constants.GEOMETRY.Point:
            // Do not pick the labeled features
            var isLabel = !options.allowLabelPicking && feature && feature.properties && feature.properties.style && feature.properties.style.label;
            if (isLabel) return false;

            if (feature.properties && feature.properties.style &&
                feature.properties.style.useMeterSize && feature.properties.style.meterSize) {
                return UtilsIntersection.isInBillboard(pickPoint, feature.geometry, feature.properties.style.meterSize, options.eventPos);
            } else {
                if (!pickPoint) { return false; }
                var point = feature.geometry.coordinates;

                var pt = [pickPoint[0], pickPoint[1], pickPoint[2]];
                if (pickingNoDEM === true) {
                    pt[2] = 0;
                }
                return UtilsIntersection.pointInSphere(ctx, pt, point, feature.geometry._bucket.textureHeight * sizeMultiplicator);
            }
        default:
            ErrorDialog.open(Constants.LEVEL.DEBUG, "PickingManagerCore.js", "Picking for " + feature.geometry.type + " is not yet");
            return false;
        }
    }

    /**************************************************************************************************************/

    /**
     * @deprecated Please use computePickSelection
     */
    function computeFilterPickSelection(pickPoint, options) {
        ErrorDialog.open(Constants.LEVEL.WARNING, "PickingManagerCore", "computeFilterPickSelection: This function is deprecated. Please use computePickSelection instead.");
        var selection = this.computePickSelection(pickPoint, options);
        var returnedSelection = [];
        for (var i = 0; i < selection.length; i++) {
            returnedSelection.push(selection[i]);
        }
        return returnedSelection;
    }

    /**
     * Compute the selection at the picking point
     * @param {Array} pickPoint
     * @return {Array} newSelection
     */
    function computePickSelection(pickPoint, options) {
        var i, j, feature;
        var newSelection = [];

        var selectedTile = pickPoint
            ? globe.tileManager.getVisibleTile(pickPoint[0], pickPoint[1])
            : undefined;

        const tileData = selectedTile ? selectedTile.extension.renderer : null;

        for (i = 0; i < this.getPickableLayers().length; i++) {
            var pickableLayer = this.getPickableLayers()[i];
            if (pickableLayer.isVisible() && pickableLayer.globe === globe) {
                if (pickableLayer instanceof OpenSearchLayer) {
                    if (!pickPoint) {
                        return [];
                    }

                    // Extension using layer
                    // Search for features in each tile
                    if (!selectedTile) {
                        ErrorDialog.open(Constants.LEVEL.DEBUG, "PickingManagerCore.js", "no tile found");
                        continue;
                    }

                    if (!tileData) {
                        ErrorDialog.open(Constants.LEVEL.DEBUG, "PickingManagerCore.js", "no tile data");
                        continue;
                    }

                    //[pickableLayer.extId];
                    /*if (!tileData || tileData.state !== OpenSearchLayer.TileState.LOADED) {
                            while (tile.parent && (!tileData || tileData.state !== OpenSearchLayer.TileState.LOADED)) {
                                tile = tile.parent;
                                tileData = tile.extension[pickableLayer.extId];
                            }
                        }*/

                    //for (j = 0; j < tileData.featureIds.length; j++) {
                    for (j = 0; j < pickableLayer.features.length; j++) {
                        //feature = pickableLayer.features[pickableLayer.featuresSet[tileData.featureIds[j]].index];
                        feature = pickableLayer.features[j];

                        // Allow label picking for opensearch texts
                        var localOptions = JSON.parse(JSON.stringify(options));
                        if (feature && feature.properties && feature.properties.style && feature.properties.style.label) {
                            localOptions.allowLabelPicking = true;
                            if (!localOptions.sizeMultiplicator) {
                                localOptions.sizeMultiplicator = 3;
                            }
                        }

                        if (
                            this.featureIsPicked(
                                feature,
                                pickPoint,
                                pickableLayer.pickingNoDEM,
                                localOptions
                            )
                        ) {
                            feature.pickData = {
                                picked: true,
                                index: newSelection.length,
                                pickSelection: newSelection
                            };

                            newSelection.push({
                                feature: feature,
                                layer: pickableLayer
                            });
                        }
                    }
                } else {
                    // Vector layer
                    // Search for picked features
                    for (j = 0; j < pickableLayer.features.length; j++) {
                        feature = pickableLayer.features[j];
                        if (
                            this.featureIsPicked(
                                feature,
                                pickPoint,
                                pickableLayer.pickingNoDEM,
                                options
                            )
                        ) {
                            newSelection.push({
                                feature: feature,
                                layer: pickableLayer
                            });
                        }
                    }
                }
            }
        }

        // Add selected tile to selection to be able to make the requests by tile
        // (actually used for asteroids search)
        newSelection.selectedTile = selectedTile;

        return newSelection;
    }

    /**************************************************************************************************************/

    /**
     * Set selection list with passed selection
     * @param {Array} sel selection
     */
    function setSelection(sel) {
        selection = sel;
        return selection;
    }

    /**************************************************************************************************************/

    /**
     *    Highlight the given feature
     *
     *    @param featureData
     *        Feature data is an object composed by feature and its layer
     *    @param options
     *        Focus feature options(isExclusive and color)
     *
     *    // TODO : maybe it's more intelligent to store layer reference on feature ?
     */
    function highlightObservation(featureData, options) {
        selection.push(featureData);
        focusFeatureByIndex(selection - 1, options);
    }

    function updateContext(context) {
        ctx = context;
        globe = context.globe;
    }

    /**************************************************************************************************************/

    return {
        selectedStyle: selectedStyle,
        highlightedSelectedStyle: highlightedSelectedStyle,
        stackSelectionIndex: stackSelectionIndex,
        init: function(context) {
            ctx = context;
            globe = context.globe;
        },
        addPickableLayer: addPickableLayer,
        removePickableLayer: removePickableLayer,
        getPickableLayers: getPickableLayers,
        blurSelectedFeature: blurSelectedFeature,
        focusFeatureByIndex: focusFeatureByIndex,
        getSelection: getSelection,
        blurSelection: blurSelection,
        focusSelection: focusSelection,
        clearSelection: clearSelection,
        fixDateLine: fixDateLine,
        featureIsPicked: featureIsPicked,
        computePickSelection: computePickSelection,
        computeFilterPickSelection: computeFilterPickSelection,
        setSelection: setSelection,
        highlightObservation: highlightObservation,
        updateContext: updateContext
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/HEALPixTiling',[
    "./Tile",
    "./HEALPixBase",
    "../Renderer/GeoBound",
    "../Utils/Numeric",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function(Tile, HEALPixBase, GeoBound, Numeric, Constants, ErrorDialog) {
    /**
         Tile constructor

         Quadrilateral which composes one tile of HEALPix sphere

         nside : 2^order
         order : log2(nside);
         pix : pixel index number
         face : face number = [0..11]
         @constructor
         */
    var HEALPixTile = function(order, pix, face) {
        // Call ancestor constructor
        Tile.prototype.constructor.call(this);

        this.level = this.order = order;        
        this.nside = Math.pow(2, this.order);
        this.pixelIndex = pix;
        this.face = face;

        this.key = this.level+"#"+this.pixelIndex;
        this.type = Constants.TILE.HEALPIX_TILE; 

        // Compute texture transform
        /*	var width = 1728/64;
             var height = 1856/64;
             this.texTransform = [64/1728, 64/1856, ((this.pixelIndex % width))/width, ((Math.floor(this.pixelIndex/width))/height)];*/

        this.geoBound = null;
    };

    /**************************************************************************************************************/

    /** inherits from Tile */
    HEALPixTile.prototype = new Tile();

    /**************************************************************************************************************/

    HEALPixTile.prototype.getKey = function() {
        return this.key;
    };

    /**
         Create the children
         */
    HEALPixTile.prototype.createChildren = function() {
        // Create the children

        var child00 = new HEALPixTile(
            this.order + 1,
            this.pixelIndex * 4,
            this.face
        );
        var child10 = new HEALPixTile(
            this.order + 1,
            this.pixelIndex * 4 + 2,
            this.face
        );
        var child01 = new HEALPixTile(
            this.order + 1,
            this.pixelIndex * 4 + 1,
            this.face
        );
        var child11 = new HEALPixTile(
            this.order + 1,
            this.pixelIndex * 4 + 3,
            this.face
        );

        child00.initFromParent(this, 0, 0);
        child10.initFromParent(this, 1, 0);
        child01.initFromParent(this, 0, 1);
        child11.initFromParent(this, 1, 1);

        this.children = [child00, child10, child01, child11];
    };

    /**************************************************************************************************************/

    /**
         Compute the local matrix for the tile
         */
    HEALPixTile.prototype.computeLocalMatrix = function(vertices) {
        var matrix = mat4.create();

        var east = vec3.create();
        var north = vec3.create();
        var up = vec3.create();

        var mx = 0;
        var my = 0;
        var mz = 0;
        for (var i = 0; i < vertices.length; i++) {
            mx += vertices[i][0];
            my += vertices[i][1];
            mz += vertices[i][2];
        }
        var barycenter = vec3.create([
            mx / vertices.length,
            my / vertices.length,
            mz / vertices.length
        ]);

        vec3.set(barycenter, up);
        vec3.normalize(up);

        vec3.subtract(vertices[0], vertices[3], north);

        vec3.cross(up, north, east);
        vec3.normalize(east);
        vec3.cross(up, east, north);
        vec3.normalize(north);

        matrix[0] = east[0];
        matrix[1] = east[1];
        matrix[2] = east[2];
        matrix[3] = 0.0;

        matrix[4] = north[0];
        matrix[5] = north[1];
        matrix[6] = north[2];
        matrix[7] = 0.0;

        matrix[8] = up[0];
        matrix[9] = up[1];
        matrix[10] = up[2];
        matrix[11] = 0.0;

        matrix[12] = barycenter[0];
        matrix[13] = barycenter[1];
        matrix[14] = barycenter[2];
        matrix[15] = 1.0;

        return matrix;
    };

    /**************************************************************************************************************/

    function _computeWorldSpaceVertices(config, nside, pixelIndex, face) {
        // Build the vertices
        var size = config.tesselation;
        var worldSpaceVertices = [];
        var step = 1.0 / (size - 1);

        // xyf calculation
        var pix = pixelIndex & (nside * nside - 1);
        var ix = HEALPixBase.compress_bits(pix);
        var iy = HEALPixBase.compress_bits(pix >>> 1);
        // Compute array of worldspace coordinates
        for (var u = 0; u < size; u++) {
            for (var v = 0; v < size; v++) {
                var vertice = HEALPixBase.fxyf(
                    (ix + u * step) / nside,
                    (iy + v * step) / nside,
                    face
                );

                // Take sphere radius into account
                vertice[0] *= config.coordinateSystem.getGeoide().getRadius();
                vertice[1] *= config.coordinateSystem.getGeoide().getRadius();
                vertice[2] *= config.coordinateSystem.getGeoide().getRadius();
                //TODO a modifier
                if (config.coordinateSystem.getGeoideName() !== Constants.CRS.Equatorial) {
                    var geo = config.coordinateSystem.getWorldFrom3D(vertice);
                    var eq = config.coordinateSystem.convert(
                        geo,
                        config.coordinateSystem.getGeoideName(),
                        Constants.CRS.Equatorial
                    );
                    worldSpaceVertices[u * size + v] = config.coordinateSystem.get3DFromWorld(eq);
                } else {
                    worldSpaceVertices[u * size + v] = vertice;
                }
            }
        }  
        return worldSpaceVertices;      
    }

    function _computeCorners(config, worldSpaceVertices) {
        var corners = [];
        var size = config.tesselation;
        corners.push(config.coordinateSystem.getWorldFrom3D(worldSpaceVertices[0]));
        corners.push(config.coordinateSystem.getWorldFrom3D(worldSpaceVertices[size - 1]));
        corners.push(config.coordinateSystem.getWorldFrom3D(worldSpaceVertices[size * (size - 1)]));
        corners.push(config.coordinateSystem.getWorldFrom3D(worldSpaceVertices[size * size - 1]));
        return corners;
    }

    HEALPixTile.prototype.getCorners = function() {
        var worldSpaceVertices = _computeWorldSpaceVertices(this.config, this.nside, this.pixelIndex, this.face);
        var corners = _computeCorners(this.config, worldSpaceVertices);
        return corners;
    }; 

    /**
         Generate vertices for tile
         */
    HEALPixTile.prototype.generateVertices = function() {
        var size = this.config.tesselation;
        var worldSpaceVertices = _computeWorldSpaceVertices(this.config, this.nside, this.pixelIndex, this.face);
        var corners = _computeCorners(this.config, worldSpaceVertices);
        // Compute geoBound using corners of tile
        this.geoBound = new GeoBound();
        this.geoBound.computeFromCoordinates(corners);

        // Compute tile matrix
        this.matrix = this.computeLocalMatrix(worldSpaceVertices);
        var invMatrix = mat4.create();
        mat4.inverse(this.matrix, invMatrix);
        this.inverseMatrix = invMatrix;

        // Compute tile matrix
        /*var center = HEALPixBase.fxyf((ix+0.5)/this.nside, (iy+0.5)/this.nside, face);
             var geoCenter = coordinateSystem.getWorldFrom3D(center);
             this.matrix = coordinateSystem.getLHVTransform( geoCenter );
             var invMatrix = mat4.create();
             mat4.inverse( this.matrix, invMatrix );
             this.inverseMatrix = invMatrix;*/

        // Build the vertices
        var vertices = new Float32Array(3 * size * size);

        // Vertex coordinates in local space
        var vertexOffset = 0;
        for (var i = 0; i < worldSpaceVertices.length; i++) {
            vertices[vertexOffset] =
                invMatrix[0] * worldSpaceVertices[i][0] +
                invMatrix[4] * worldSpaceVertices[i][1] +
                invMatrix[8] * worldSpaceVertices[i][2] +
                invMatrix[12];
            vertices[vertexOffset + 1] =
                invMatrix[1] * worldSpaceVertices[i][0] +
                invMatrix[5] * worldSpaceVertices[i][1] +
                invMatrix[9] * worldSpaceVertices[i][2] +
                invMatrix[13];
            vertices[vertexOffset + 2] =
                invMatrix[2] * worldSpaceVertices[i][0] +
                invMatrix[6] * worldSpaceVertices[i][1] +
                invMatrix[10] * worldSpaceVertices[i][2] +
                invMatrix[14];
            vertexOffset += 3;
        }

        return vertices;
    };

    /**************************************************************************************************************/

    /**
     *    HEALPixTiling constructor
     *    @name HEALPixTiling
     *
     *    @param order Starting tiling order
     *    @param options Options
     *        <ul>
     *            <li>coordSystem: Coordinate system of the given tiling</li>
     *        </ul>
     *    @constructor
     */
    var HEALPixTiling = function(order, options) {
        this.order = order;
        this.nside = Math.pow(2, this.order);
        this.coordinateSystem = options.coordinateSystem;
        // TODO undefined coord system
    };

    /**************************************************************************************************************/

    /**
         Generate the tiles for level zero
         */
    HEALPixTiling.prototype.generateLevelZeroTiles = function(
        config,
        tilePool
    ) {
        config.skirt = false;
        config.cullSign = -1;
        config.tesselation = 5;
        // TODO : change name to avoid ambiguity
        config.coordinateSystem = this.coordinateSystem;
        this.coordinateSystem = config.coordinateSystem;
        var level0Tiles = [];

        var qpf = Math.pow(this.nside, 2); // quad per face
        var nFaces = 12;
        var nQuads = nFaces * qpf;

        for (var i = 0; i < nQuads; i++) {
            var face = Math.floor(i / qpf);
            var tile = new HEALPixTile(this.order, i, face);
            tile.config = config;
            level0Tiles.push(tile);
        }

        return level0Tiles;
    };

    // Get all the coordinates of a geometry
    var _getGeometryCoordinates = function(geometry) {
        var coords, n;
        switch (geometry.type) {
        case Constants.GEOMETRY.Point:
            coords = [];
            coords.push(geometry.coordinates);
            break;
        case Constants.GEOMETRY.MultiPoint:
        case Constants.GEOMETRY.LineString:
            coords = geometry.coordinates;
            break;
        case Constants.GEOMETRY.MultiLineString:
            coords = [];
            for (n = 0; n < geometry.coordinates.length; n++) {
                coords = coords.concat(geometry.coordinates[n]);
            }
            break;
        case Constants.GEOMETRY.Polygon:
            coords = geometry.coordinates[0];
            break;
        case Constants.GEOMETRY.MultiPolygon:
            coords = [];
            for (n = 0; n < geometry.coordinates.length; n++) {
                coords = coords.concat(geometry.coordinates[n][0]);
            }
            break;
        case Constants.GEOMETRY.GeometryCollection:
            coords = [];
            for (n = 0; n < geometry.geometries.length; n++) {
                coords = coords.concat(
                    _getGeometryCoordinates(geometry.geometries[n])
                );
            }
            break;
        }
        return coords;
    };

    /**************************************************************************************************************/

    /**
         Get the level zero tiles that overlaps the given geometry
         */
    HEALPixTiling.prototype.getOverlappedLevelZeroTiles = function(geometry) {
        var tileIndices = [];

        var coords = _getGeometryCoordinates(geometry);
        if (!coords) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "HEALPixTiling.js", "Invalid geometry type or not supported.");
            return tileIndices;
        }

        var indexMap = {};
        for (var i = 0; i < coords.length; i++) {
            var index = this.lonlat2LevelZeroIndex(coords[i][0], coords[i][1]);
            if (!indexMap[index]) {
                indexMap[index] = true;
                tileIndices.push(index);
            }
        }

        return tileIndices;
    };

    /**************************************************************************************************************/

    /**
         Locate a level zero tile
         */
    HEALPixTiling.prototype.lonlat2LevelZeroIndex = function(lon, lat) {
        //var geo = this.coordinateSystem.convert([lon, lat], Constants.CRS.Equatorial, this.coordinateSystem.getGeoideName());
        //lon = geo[0];
        //lat = geo[1];
        return HEALPixBase.lonLat2pix(this.order, lon, lat);
    };

    /**************************************************************************************************************/

    /**
         Return tile of given longitude/latitude from tiles array if exists, null otherwise
         */
    HEALPixTiling.prototype.findInsideTile = function(lon, lat, tiles) {
        //var geo = this.coordinateSystem.convert([lon, lat], Constants.CRS.Equatorial, this.coordinateSystem.getGeoideName());
        //lon = geo[0];
        //lat = geo[1];
        for (var i = 0; i < tiles.length; i++) {
            var tile = tiles[i];
            var index = HEALPixBase.lonLat2pix(tile.order, lon, lat);
            if (index === tile.pixelIndex) {
                return tile;
            }
        }
        return null;
    };

    /**************************************************************************************************************/

    /**************************************************************************************************************/

    return HEALPixTiling;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Utils/ImageRequest',["./Proxy"], function(Proxy) {
    /**
     *    @constructor
     *    ImageRequest constructor
     */
    var ImageRequest = function(options) {
        this.successCallback = options.successCallback;
        this.failCallback = options.failCallback;
        this.abortCallback = options.abortCallback;
        this.image = null;
    };

    /**************************************************************************************************************/

    /**
     *    Send image request
     */
    ImageRequest.prototype.send = function(url, crossOrigin) {
        this.image = new Image();
        this.image.crossOrigin = crossOrigin;
        this.image.dataType = "byte";

        var self = this;
        this.image.onload = function() {
            var isComplete =
                self.image.naturalWidth !== 0 && self.image.complete;
            if (isComplete) {
                self.successCallback(self);
            }
        };
        this.image.onerror = this.failCallback.bind(this);
        this.image.src = Proxy.proxify(url);
    };

    /**************************************************************************************************************/

    /**
     *    Abort image request
     */
    ImageRequest.prototype.abort = function() {
        if (this.abortCallback) {
            this.abortCallback(this);
        }
        this.image.src = "";
    };

    /**************************************************************************************************************/

    return ImageRequest;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/RendererTileData',[],function() {
    /**************************************************************************************************************/
    /**
  @name RendererTileData
  @class
	  RendererTileData constructor
    Contains a list of renderables for the tiles
  @param manager
  @constructor
  */
    var RendererTileData = function(manager) {
        this.manager = manager;
        this.renderables = [];
    };

    /**************************************************************************************************************/

    /**
     * Initialize a child tile
     * @function initChild
     * @memberof RendererTileData.prototype
     * @param childTile
     * @param i
     * @param j
     */
    RendererTileData.prototype.initChild = function(childTile, i, j) {
        var childData;
        for (var n = 0; n < this.renderables.length; n++) {
            if (this.renderables[n].initChild) {
                var r = this.renderables[n].initChild(i, j, childTile);
                if (r) {
                    if (!childData) {
                        childData = childTile.extension.renderer = new RendererTileData(
                            this.manager
                        );
                    }
                    childData.renderables.push(r);
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Traverse the renderer data
     * @function traverse
     * @memberof RendererTileData.prototype
     * @param {Tile} tile Tile
     * @param isLeaf
     */
    RendererTileData.prototype.traverse = function(tile, isLeaf) {
        for (var i = 0; i < this.renderables.length; i++) {
            var renderable = this.renderables[i];
            var bucket = renderable.bucket;
            if (bucket.layer.isVisible() && bucket.layer.getOpacity() > 0) {
                if (renderable.traverse) {
                    renderable.traverse(this.manager, tile, isLeaf);
                } else {
                    if (renderable.hasChildren && !isLeaf) {
                        continue;
                    }

                    this.manager.renderables.push(renderable);
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Get a renderable from the tile, given the bucket
     * @function getRenderable
     * @memberof RendererTileData.prototype
     * @param {Bucket} bucket Bucket
     * @return Renderable
     */
    RendererTileData.prototype.getRenderable = function(bucket) {
        for (var i = 0; i < this.renderables.length; i++) {
            if (bucket === this.renderables[i].bucket) {
                return this.renderables[i];
            }
        }
        return null;
    };

    /**************************************************************************************************************/

    /**
     * Dispose renderable data from tile
     * @function dispose
     * @memberof RendererTileData.prototype
     * @param renderContext
     * @param tilePool
     */
    RendererTileData.prototype.dispose = function(renderContext, tilePool) {
        for (var i = 0; i < this.renderables.length; i++) {
            this.renderables[i].dispose(renderContext, tilePool);
        }
        this.renderables.length = 0;
    };

    /**************************************************************************************************************/

    return RendererTileData;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/RasterOverlayRenderer',[
    "./Program",
    "../Tiling/Tile",
    "../Utils/ImageRequest",
    "./RendererTileData",
    "../Utils/Constants"
], function(Program, Tile, ImageRequest, RendererTileData, Constants) {
    /**************************************************************************************************************/

    /**
         @name RasterOverlayRenderer
         @class
             RasterOverlayRenderer constructor
         @param {AbstractGlobe} globe AbstractGLobe
         @constructor
         */

    var RasterOverlayRenderer = function(globe) {
        this.vertexShader = "attribute vec3 vertex;\n";
        this.vertexShader += "attribute vec2 tcoord;\n";
        this.vertexShader += "uniform mat4 modelViewMatrix;\n";
        this.vertexShader += "uniform mat4 projectionMatrix;\n";
        this.vertexShader += "uniform vec4 textureTransform; \n";
        this.vertexShader += "varying vec2 texCoord;\n";
        this.vertexShader += "void main(void) \n";
        this.vertexShader += "{\n";
        this.vertexShader +=
            "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
        this.vertexShader +=
            "	texCoord = tcoord * textureTransform.xy + textureTransform.zw;\n";
        this.vertexShader += "}\n";

        this.fragmentShader = "precision lowp float;\n";
        this.fragmentShader += "varying vec2 texCoord;\n";
        this.fragmentShader += "uniform sampler2D overlayTexture;\n";
        this.fragmentShader += "uniform float opacity; \n";
        this.fragmentShader += "uniform vec3 levelColRow;\n";
        this.fragmentShader += "void main(void)\n";
        this.fragmentShader += "{\n";
        this.fragmentShader +=
            "	gl_FragColor.rgba = texture2D(overlayTexture, texCoord.xy); \n";
        this.fragmentShader += "	gl_FragColor.a *= opacity; \n";
        // this.fragmentShader += "    gl_FragColor.rgb = levelColRow / vec3(16.0);\n";
        // this.fragmentShader += "    gl_FragColor.a = min(gl_FragColor.a + 0.8, 1.0);\n";
        this.fragmentShader += "}\n";

        this.lerpFragmentShader =
            `precision lowp float;

            varying vec2 texCoord;
            uniform sampler2D fromOverlayTexture;
            uniform sampler2D toOverlayTexture;
            uniform float time;
            uniform float totalTime;
            uniform float opacity;

            void main() {
                vec4 fromColor = texture2D(fromOverlayTexture, texCoord.xy);
                vec4 toColor = texture2D(toOverlayTexture, texCoord.xy);
                gl_FragColor = mix(fromColor, toColor, time / totalTime);
                gl_FragColor.a *= opacity;
                // gl_FragColor.rgba = vec4(0, 1, 0, opacity);
            }`;

        this.rendererManager = globe.getRendererManager();
        this.tileManager = globe.tileManager;

        this.programs = [];
        this.program = this.createProgram({
            vertexCode: this.vertexShader,
            fragmentCode: this.fragmentShader,
            updateUniforms: null
        });

        this.lerpProgram = this.createProgram({
            vertexCode: this.vertexShader,
            fragmentCode: this.lerpFragmentShader,
            updateUniforms: null
        });

        this.buckets = [];
        this.imageRequests = [];
        this.frameNumber = 0;


        this.oldRenderables = {};

        var self = this;
        for (var i = 0; i < 4; i++) {
            var imageRequest = new ImageRequest({
                successCallback: function() {
                    if (this.renderable) {
                        if (this.renderable.bucket.layer.handleImage) {
                            this.renderable.bucket.layer.handleImage(this);
                        }

                        this.renderable.ownTexture = self.tileManager.tilePool.createGLTexture(
                            this.image
                        );
                        this.renderable.texture = this.renderable.ownTexture;
                        this.renderable.uvScale = 1.0;
                        this.renderable.uTrans = 0.0;
                        this.renderable.vTrans = 0.0;
                        this.renderable.updateChildrenTexture();
                        this.renderable.onRequestFinished(true);

                        const { level, x, y } = this.renderable.tile;
                        try {
                            const oldRenderable = self.oldRenderables[level][x][y];
                            if (oldRenderable && oldRenderable.ownTexture) {
                                this.renderable.oldRenderable = oldRenderable;
                                this.renderable.needsLerp = true;
                                this.renderable.time = 0.0;
                            }
                        } catch (error) {
                            // Nothing to do
                        }

                        this.renderable = null;
                        self.tileManager.renderContext.requestFrame();
                    }
                },
                failCallback: function() {
                    if (this.renderable) {
                        this.renderable.onRequestFinished(true);
                        this.renderable = null;
                    }
                },
                abortCallback: function() {
                    //console.log("Raster overlay request abort.");
                    if (this.renderable) {
                        this.renderable.onRequestFinished(false);
                        this.renderable = null;
                    }
                }
            });

            this.imageRequests.push(imageRequest);
        }
    };

    /**************************************************************************************************************/

    /**
         @name RasterOverlayRenderable
         @class
             Create a renderable for the overlay.
         There is one renderable per overlay and per tile.
         @param {Bucket} bucket Bucket
         @constructor
         */
    var RasterOverlayRenderable = function(bucket) {
        this.bucket = bucket;
        this.bucket.renderables.push(this);
        this.ownTexture = null;
        this.texture = null;
        this.oldRenderable = null;
        this.needsLerp = false;
        this.time = 0.0;
        this.request = null;
        this.requestFinished = false;
        this.tile = null;
        this.uvScale = 1.0;
        this.uTrans = 0.0;
        this.vTrans = 0.0;
    };

    /**************************************************************************************************************/

    /**
     * Called when a request is started
     * @function onRequestStarted
     * @memberof RasterOverlayRenderable.prototype
     * @param {string}request Request
     * @fires Context#startLoad
     */
    RasterOverlayRenderable.prototype.onRequestStarted = function(request) {
        this.request = request;
        this.requestFinished = false;
        var layer = this.bucket.layer;
        if (layer._numRequests === 0) {
            layer.globe.publishEvent(
                Constants.EVENT_MSG.LAYER_START_LOAD,
                layer
            );
        }
        layer._numRequests++;
    };

    /**************************************************************************************************************/

    /**
     * Called when a request is finished
     * @function onRequestFinished
     * @memberof RasterOverlayRenderable.prototype
     * @param completed
     * @fires Context#endLoad
     */
    RasterOverlayRenderable.prototype.onRequestFinished = function(completed) {
        this.request = null;
        this.requestFinished = completed;
        var layer = this.bucket.layer;
        layer._numRequests--;
        if (layer.getGlobe() && layer._numRequests === 0) {
            layer
                .getGlobe()
                .publishEvent(Constants.EVENT_MSG.LAYER_END_LOAD, layer);
        }
    };

    /**************************************************************************************************************/

    /**
     * Initialize a child renderable
     * @function initChild
     * @memberof RasterOverlayRenderable.prototype
     * @param i
     * @param j
     * @param childTile
     */
    RasterOverlayRenderable.prototype.initChild = function(i, j, childTile) {
        // Request finished and no texture  : no init needed for children
        /*	// TODO : does not work because sometimes level 0 cannot be loaded
             if (this.requestFinished && !this.ownTexture)
             return null;*/

        var renderable = this.bucket.createRenderable();
        renderable.tile = childTile;
        if (this.texture) {
            renderable.texture = this.texture;
            renderable.uvScale = this.uvScale;
            renderable.uTrans = this.uTrans;
            renderable.vTrans = this.vTrans;
        }

        return renderable;
    };

    /**************************************************************************************************************/

    /**
     * Generate child renderable
     * @function generateChild
     * @memberof RasterOverlayRenderable.prototype
     * @param {Tile} tile Tile
     */
    RasterOverlayRenderable.prototype.generateChild = function(tile) {
        // Request finished and no texture  : no generate needed for children
        /*	// TODO : does not work because sometimes level 0 cannot be loaded
             if (this.requestFinished && !this.ownTexture)
             return;*/

        var r = this.bucket.renderer;
        r.addOverlayToTile(tile, this.bucket, this);
    };

    /**************************************************************************************************************/

    /**
     * Update the children texture
     * @function updateChildrenTexture
     * @memberof RasterOverlayRenderable.prototype
     */
    RasterOverlayRenderable.prototype.updateChildrenTexture = function() {
        if (this.tile.children) {
            for (var i = 0; i < 4; i++) {
                var rd = this.tile.children[i].extension.renderer;
                if (rd) {
                    var cr = rd.getRenderable(this.bucket);
                    if (cr && !cr.ownTexture) {
                        cr.updateTextureFromParent(this);
                        cr.updateChildrenTexture();
                    }
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Update texture from its parent
     * @function updateTextureFromParent
     * @memberof RasterOverlayRenderable.prototype
     * @param parent
     */
    RasterOverlayRenderable.prototype.updateTextureFromParent = function(
        parent
    ) {
        if (this.tile.state === Tile.State.LOADED) {
            this.texture = parent.texture;
            this.uvScale = parent.uvScale * 0.5;
            this.uTrans = parent.uTrans;
            this.vTrans = parent.vTrans;

            this.uTrans += this.tile.parentIndex & 1 ? this.uvScale : 0;
            this.vTrans += this.tile.parentIndex & 2 ? this.uvScale : 0;
        } else {
            this.texture = parent.texture;
            this.uvScale = parent.uvScale;
            this.uTrans = parent.uTrans;
            this.vTrans = parent.vTrans;
        }
    };

    /**************************************************************************************************************/

    /**
         * Traverse renderable : add it to renderables list if there is a texture
         Request the texture
         * @function traverse
         * @memberof RasterOverlayRenderable.prototype
         * @param manager
         * @param {Tile} tile Tile
         * @param {Boolean} isLeaf
         */
    RasterOverlayRenderable.prototype.traverse = function(
        manager,
        tile,
        isLeaf
    ) {
        if (isLeaf && this.texture) {
            manager.renderables.push(this);
        } else if (isLeaf) {
            const oldRenderables = this.bucket.renderer.oldRenderables;
            try {
                const oldRenderable = oldRenderables[tile.level][tile.x][tile.y];
                if (oldRenderable && oldRenderable.ownTexture) {
                    const renderable = Object.assign({}, this);
                    renderable.texture = oldRenderable.ownTexture;
                    manager.renderables.push(renderable);
                }
            } catch (error) {
                // do nothing
            }
        }

        if (!this.requestFinished && this.tile.state === Tile.State.LOADED) {
            this.bucket.renderer.requestOverlayTextureForTile(this);
        }
    };

    /**************************************************************************************************************/

    /**
     * Dispose the renderable
     * @function dispose
     * @memberof RasterOverlayRenderable.prototype
     * @param renderContext
     * @param tilePool
     */
    RasterOverlayRenderable.prototype.dispose = function(
        renderContext,
        tilePool
    ) {
        if (this.ownTexture) {
            tilePool.disposeGLTexture(this.ownTexture);
            this.ownTexture = null;
        }
    };

    /**************************************************************************************************************/

    /**
         @name Bucket
         @class
             Bucket constructor for RasterOverlay
         @param layer
         @constructor
         */
    var Bucket = function(layer) {
        this.layer = layer;
        this.renderer = null;
        this.style = layer.style;
        this.renderables = [];
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof Bucket.prototype
     * @return {RasterOverlayRenderable} Renderable
     */
    Bucket.prototype.createRenderable = function() {
        return new RasterOverlayRenderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Add an overlay into the renderer.
     * The overlay is added to all loaded tiles.
     * @function addOverlay
     * @memberof RasterOverlayRenderer.prototype
     * @param overlay
     */
    RasterOverlayRenderer.prototype.addOverlay = function(overlay) {
        // Initialize num requests to 0
        overlay._numRequests = 0;

        var bucket = new Bucket(overlay);
        bucket.renderer = this;
        bucket.id = this.rendererManager.bucketId++;
        this.buckets.push(bucket);

        overlay._bucket = bucket;

        for (var i = 0; i < this.tileManager.level0Tiles.length; i++) {
            var tile = this.tileManager.level0Tiles[i];
            if (tile.state === Tile.State.LOADED) {
                this.addOverlayToTile(tile, bucket);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove an overlay
     * The overlay is removed from all loaded tiles.
     * @function removeOverlay
     * @memberof RasterOverlayRenderer.prototype
     * @param overlay
     */
    RasterOverlayRenderer.prototype.removeOverlay = function(overlay, noDispose) {
        var index = this.buckets.indexOf(overlay._bucket);
        this.buckets.splice(index, 1);

        var rc = this.tileManager.renderContext;
        var tp = this.tileManager.tilePool;
        this.tileManager.visitTiles(function(tile) {
            var rs = tile.extension.renderer;
            var renderable = rs ? rs.getRenderable(overlay._bucket) : null;
            if (renderable) {
                // Remove the renderable
                var index = rs.renderables.indexOf(renderable);
                rs.renderables.splice(index, 1);

                if (!noDispose) {
                    // Dispose its data
                    renderable.dispose(rc, tp);
                }

                // Remove tile data if not needed anymore
                if (rs.renderables.length === 0) {
                    delete tile.extension.renderer;
                }
            }
        });
    };

    /**************************************************************************************************************/

    RasterOverlayRenderer.prototype.updateOverlay = function(overlay) {
        var oldBucket = overlay._bucket;

        var rc = this.tileManager.renderContext;
        var tp = this.tileManager.tilePool;

        if (oldBucket) {
            for (var j = 0; j < oldBucket.renderables.length; ++j) {
                const renderable = oldBucket.renderables[j];
                if (renderable.ownTexture) {
                    const { level, x, y } = renderable.tile;

                    // If there is already old data, dispose it
                    try {
                        const oldRenderable = this.oldRenderables[level][x][y];
                        oldRenderable.dispose(rc, tp);
                    } catch (e) {
                        // No-op
                    }

                    if (!this.oldRenderables[level]) this.oldRenderables[level] = {};
                    if (!this.oldRenderables[level][x]) this.oldRenderables[level][x] = {};
                    this.oldRenderables[level][x][y] = renderable;
                }
            }
        }

        this.removeOverlay(overlay, true);
        this.addOverlay(overlay);
    };

    /**************************************************************************************************************/

    /**
     * Add an overlay into a tile.
     * Create tile data if needed, and create the renderable for the overlay.
     * @function addOverlayToTile
     * @memberof RasterOverlayRenderer.prototype
     * @param tile
     * @param bucket
     * @param parentRenderable
     */
    RasterOverlayRenderer.prototype.addOverlayToTile = function(
        tile,
        bucket,
        parentRenderable
    ) {
        if (!this.overlayIntersects(tile.geoBound, bucket.layer)) {
            return;
        }

        if (!tile.extension.renderer) {
            tile.extension.renderer = new RendererTileData(
                this.rendererManager
            );
        }

        var renderable = bucket.createRenderable();
        renderable.tile = tile;
        tile.extension.renderer.renderables.push(renderable);

        if (parentRenderable && parentRenderable.texture) {
            renderable.updateTextureFromParent(parentRenderable);
        }

        if (tile.children) {
            // Add the overlay to loaded children
            for (var i = 0; i < 4; i++) {
                if (tile.children[i].state === Tile.State.LOADED) {
                    this.addOverlayToTile(tile.children[i], bucket, renderable);
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Create an interpolated for polygon clipping
     */
    var _createInterpolatedVertex = function(t, p1, p2) {
        return [p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1])];
    };

    /**************************************************************************************************************/

    /**
     * Clip polygon to a side (used by bound-overlay intersection)
     * @function clipPolygonToSide
     * @memberof RasterOverlayRenderer.prototype
     * @param coord
     * @param sign
     * @param value
     * @param polygon
     */
    RasterOverlayRenderer.prototype.clipPolygonToSide = function(
        coord,
        sign,
        value,
        polygon
    ) {
        var clippedPolygon = [];
        var t, newPoint;
        // iterate through vertices
        for (var i = 0; i < polygon.length; i++) {
            var p1 = polygon[i];
            var p2 = polygon[(i + 1) % polygon.length];
            var val1 = p1[coord];
            var val2 = p2[coord];

            // test containement
            var firstInside = (val1 - value) * sign >= 0.0;
            var secondInside = (val2 - value) * sign >= 0.0;

            // output vertices for inside polygon
            if (!firstInside && secondInside) {
                t = (value - val1) / (val2 - val1);
                newPoint = _createInterpolatedVertex(t, p1, p2);
                clippedPolygon.push(newPoint);
                clippedPolygon.push(p2);
            } else if (firstInside && secondInside) {
                clippedPolygon.push(p2);
            } else if (firstInside && !secondInside) {
                t = (value - val1) / (val2 - val1);
                newPoint = _createInterpolatedVertex(t, p1, p2);
                clippedPolygon.push(newPoint);
            }
        }

        return clippedPolygon;
    };

    /**************************************************************************************************************/

    /**
     * Check the intersection between a geo bound and an overlay
     * @function overlayIntersects
     * @memberof RasterOverlayRenderer.prototype
     * @param bound
     * @param overlay
     * @return {Boolean} Is intersects ?
     */
    RasterOverlayRenderer.prototype.overlayIntersects = function(
        bound,
        overlay
    ) {
        if (overlay.coordinates) {
            var c;
            c = this.clipPolygonToSide(0, 1, bound.west, overlay.coordinates);
            c = this.clipPolygonToSide(0, -1, bound.east, c);
            c = this.clipPolygonToSide(1, 1, bound.south, c);
            c = this.clipPolygonToSide(1, -1, bound.north, c);
            return c.length > 0;
        } else if (overlay.geoBound) {
            return overlay.geoBound.intersects(bound);
        }

        // No geobound or coordinates : always return true
        return true;
    };

    /**************************************************************************************************************/

    /**
     * Generate Raster overlay data on the tile.
     * The method is called by TileManager when a new tile has been generated.
     * @function generateLevelZero
     * @memberof RasterOverlayRenderer.prototype
     * @param {Tile} tile Tile
     */
    RasterOverlayRenderer.prototype.generateLevelZero = function(tile) {
        // Traverse all overlays
        for (var i = 0; i < this.buckets.length; i++) {
            this.addOverlayToTile(tile, this.buckets[i]);
        }
    };

    /**************************************************************************************************************/

    /**
     * Request the overlay texture for a tile
     * @function requestOverlayTextureForTile
     * @memberof RasterOverlayRenderer.prototype
     * @param renderable
     */
    RasterOverlayRenderer.prototype.requestOverlayTextureForTile = function(
        renderable
    ) {
        if (!renderable.request) {
            var imageRequest;
            for (var i = 0; i < this.imageRequests.length; i++) {
                if (!this.imageRequests[i].renderable) {
                    imageRequest = this.imageRequests[i];
                    break;
                }
            }

            if (imageRequest) {
                var url = renderable.bucket.layer.getUrl(renderable.tile);
                if (url !== null) {
                    renderable.onRequestStarted(imageRequest);
                    imageRequest.renderable = renderable;
                    imageRequest.frameNumber = this.frameNumber;
                    imageRequest.send(
                        renderable.bucket.layer.getUrl(renderable.tile),
                        renderable.bucket.layer.crossOrigin
                    );
                }
            }
        } else {
            renderable.request.frameNumber = this.frameNumber;
        }
    };

    /**************************************************************************************************************/

    /**
     * Create program from customShader object
     * @function createProgram
     * @memberof RasterOverlayRenderer.prototype
     * @param customShader
     * @return {Program} Program
     */
    RasterOverlayRenderer.prototype.createProgram = function(customShader) {
        var program = new Program(this.tileManager.renderContext);
        program.createFromSource(this.vertexShader, customShader.fragmentCode);

        // Add program
        program.id = this.programs.length;
        this.programs.push({
            fragmentCode: customShader.fragmentCode,
            program: program
        });
        return program;
    };

    /**************************************************************************************************************/

    /**
     * Get program if known by renderer, create otherwise
     * @function getProgram
     * @memberof RasterOverlayRenderer.prototype
     * @param customShader
     * @return {Program} Program
     */
    RasterOverlayRenderer.prototype.getProgram = function(customShader) {
        var program;

        for (var id = 0; id < this.programs.length; id++) {
            if (this.programs[id].fragmentCode === customShader.fragmentCode) {
                program = this.programs[id].program;
            }
        }

        if (!program) {
            program = this.createProgram(customShader);
        }
        return program;
    };

    /**************************************************************************************************************/

    /**
     *    Render the raster overlays for the given tiles
     * @function render
     * @memberof RasterOverlayRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    RasterOverlayRenderer.prototype.render = function(renderables, start, end) {
        var rc = this.tileManager.renderContext;
        var gl = rc.gl;

        // Update gl states
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);

        var modelViewMatrix = mat4.create();

        var currentTile = null;
        var currentIB = null;
        var currentProgram = null;

        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            var bucket = renderable.bucket;
            var layer = bucket.layer;

            var updateUniforms;
            var program;
            if (layer.customShader) {
                program = this.getProgram(layer.customShader);
                updateUniforms = layer.customShader.updateUniforms;
            } else if (renderable.needsLerp) {
                program = this.getProgram({
                    vertexCode: this.vertexShader,
                    fragmentCode: this.lerpFragmentShader,
                    updateUniforms: null
                });
            } else {
                program = this.getProgram({
                    vertexCode: this.vertexShader,
                    fragmentCode: this.fragmentShader,
                    updateUniforms: null
                });
            }

            // Apply program if changed
            if (program !== currentProgram) {
                currentProgram = program;
                program.apply();

                gl.uniformMatrix4fv(
                    program.uniforms.projectionMatrix,
                    false,
                    rc.projectionMatrix
                );

                if (renderable.needsLerp) {
                    gl.uniform1i(program.uniforms.fromOverlayTexture, 0);
                    gl.uniform1i(program.uniforms.toOverlayTexture, 1);
                } else {
                    gl.uniform1i(program.uniforms.overlayTexture, 0);
                }

                // Bind tcoord buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, this.tileManager.tcoordBuffer);
                gl.vertexAttribPointer(
                    program.attributes.tcoord,
                    2,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
            }

            if (updateUniforms) {
                updateUniforms(gl, program);
            }

            // Bind the vertex buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tile.vertexBuffer);
            gl.vertexAttribPointer(
                program.attributes.vertex,
                3,
                gl.FLOAT,
                false,
                4 * renderable.tile.config.vertexSize,
                0
            );

            // Bind the index buffer only if different (index buffer is shared between tiles)
            var indexBuffer =
                renderable.tile.state === Tile.State.LOADED
                    ? this.tileManager.tileIndexBuffer.getSolid()
                    : this.tileManager.tileIndexBuffer.getSubSolid(
                        renderable.tile.parentIndex
                    );
            if (currentIB !== indexBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                currentIB = indexBuffer;
            }

            // Bind the tile tile matrix
            mat4.multiply(
                rc.viewMatrix,
                renderable.tile.matrix,
                modelViewMatrix
            );
            gl.uniformMatrix4fv(
                program.uniforms.modelViewMatrix,
                false,
                modelViewMatrix
            );

            gl.uniform1f(program.uniforms.opacity, layer.getOpacity());
            gl.uniform4f(
                program.uniforms.textureTransform,
                renderable.uvScale,
                renderable.uvScale,
                renderable.uTrans,
                renderable.vTrans
            );

            gl.uniform3f(
                program.uniforms.levelColRow,
                renderable.tile.level,
                renderable.tile.x,
                renderable.tile.y
            );

            if (renderable.needsLerp) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, renderable.oldRenderable.texture);

                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, renderable.texture);

                gl.uniform1f(program.uniforms.time, renderable.time);
                gl.uniform1f(program.uniforms.totalTime, 500);
            } else {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, renderable.texture || renderable.oldRenderable.texture);
            }

            if (renderable.needsLerp) {
                renderable.time += rc.deltaTime;
                if (renderable.time > 500) {
                    renderable.needsLerp = false;
                    renderable.oldRenderable = null;
                }
            }

            // Finally draw the tiles
            gl.drawElements(
                gl.TRIANGLES,
                currentIB.numIndices,
                gl.UNSIGNED_SHORT,
                0
            );
        }

        // reset gl states
        gl.disable(gl.BLEND);
        //gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.depthFunc(gl.LESS);
    };

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof RasterOverlayRenderer.prototype
     * @param type
     * @param style
     * @return {Boolean} Can apply ?
     */
    RasterOverlayRenderer.prototype.canApply = function(type, style) {
        return false;
    };

    /**************************************************************************************************************/

    return RasterOverlayRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Utils/Cache',[],function() {
    /**
     *    Cache storing <AbstractRasterLayer> tile requests in browser's local storage
     *    Due to performance reasons, it's recommended to use it only for tiles of level 0
     *    @param options
     *        <ul>
     *            <li>layer: Layer which will contain the given cache(required)</li>
     *            <li>cacheLevel: the maximum level of tiles to be cached</li>
     *        </ul>
     */
    var Cache = function(options) {
        this.layer = options.layer;

        this.cacheLevel = options.hasOwnProperty("cacheLevel")
            ? options.cacheLevel
            : 1;

        if (!localStorage.getItem(this.layer.getName())) {
            // Create cache space in local storage named after layer
            localStorage.setItem(this.layer.getName(), JSON.stringify({}));
        }

        this._cacheMap = JSON.parse(localStorage.getItem(this.layer.getName()));

        this.imgCanvas = document.createElement("canvas");
        // Make sure canvas is as big as layer requests
        this.imgCanvas.width = options.tilePixelSize || 256;
        this.imgCanvas.height = options.tilePixelSize || 256;

        this.imgContext = this.imgCanvas.getContext("2d");
    };

    /**************************************************************************************************************/

    /**
     *    Get tile request from cache for the given tile
     *    @returns The image(TODO: handle elevations) corresponding to the given tile, null if doesn't exist in cache
     */
    Cache.prototype.getFromCache = function(tile) {
        var cachedTileRequest = null;
        if (this.cacheLevel >= tile.level) {
            var tileId = this.layer.getUrl(tile);
            var tileInfo = this._cacheMap[tileId];
            if (tileInfo) {
                // Update access info
                tileInfo.lastAccess = Date.now();

                var image = new Image();
                image.src = tileInfo.dataUrl;
                image.dataType = "byte";
                cachedTileRequest = {
                    image: image,
                    elevations: tileInfo.elevations
                };
            }
        }
        return cachedTileRequest;
    };

    /**************************************************************************************************************/

    /**
     *    Internal method to generate data url from HTML image object
     */
    Cache.prototype._createDataURL = function(image) {
        // Draw image into canvas element
        this.imgContext.drawImage(image, 0, 0, image.width, image.height);

        // Save image as a data URL
        return this.imgCanvas.toDataURL("image/png");
    };

    /**************************************************************************************************************/

    /**
     *    Store tile request in cache
     */
    Cache.prototype.storeInCache = function(tileRequest) {
        var tile = tileRequest.tile;
        if (this.cacheLevel >= tile.level) {
            var tileId = this.layer.getUrl(tile);
            this._cacheMap[tileId] = {
                dataUrl: this._createDataURL(tileRequest.image),
                elevations: tileRequest.elevations,
                lastAccess: Date.now()
            };

            // Update local storage with new cache
            localStorage.setItem(
                this.layer.getName(),
                JSON.stringify(this._cacheMap)
            );
        }
    };

    return Cache;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/AbstractRasterLayer',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./AbstractLayer",
    "../Renderer/RasterOverlayRenderer",
    "../Utils/Cache"
], function(Utils, Constants, AbstractLayer, RasterOverlayRenderer, Cache) {
    /**
     * AbstractRasterLayer configuration
     * @typedef {AbstractLayer.configuration} AbstractRasterLayer.configuration
     * @property {int} tilePixelSize - the image size of a tile in pixels
     * @property tiling - Tiling
     * @property {int} numberOfLevels - number of levels in the pyramidal tiles
     * @property [geoBound=null] - geography boundary
     * @property [coordinates=null]
     * @property {int} [zIndex=0]
     * @property {string} [crossOrigin="anonymous"]
     * @property {string} baseUrl
     * @property cache
     */

    /**
     * @name AbstractRasterLayer
     * @class
     *     Base class for raster layer
     * @augments AbstractLayer
     * @param {LAYER} type - the type of the layer
     * @param {AbstractRasterLayer.configuration} options -Configuration properties for the AbstractRasterLayer.
     * @constructor
     * @implements {RasterLayer}
     */
    var AbstractRasterLayer = function(type, options) {
        options.zIndex = options.zIndex || Constants.DISPLAY.DEFAULT_RASTER;
        AbstractLayer.prototype.constructor.call(this, type, options);

        // Base properties
        this.tilePixelSize = options.tilePixelSize;
        this.tiling = options.tiling;
        this.numberOfLevels = options.numberOfLevels || 21;
        this.minLevel = options.minLevel;
        this.maxLevel = options.maxLevel;
        this.geoBound = options.geoBound || null;
        this.coordinates = options.coordinates || null;
        this.crossOrigin = options.crossOrigin || "anonymous";

        // Init cache if defined
        if (options.cache) {
            options.cache.layer = this;
            this.cache = new Cache(options.cache);
        }

        // Internal
        this._ready = true; // Ready is use by TileManager
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, AbstractRasterLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof AbstractRasterLayer#
     */
    AbstractRasterLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.RASTER;
    };

    /**
     * Loads a global overview if available.
     * Only use for sky rendering currently
     * @function loadOverview
     * @memberof AbstractRasterLayer#
     */
    AbstractRasterLayer.prototype.loadOverview = function() {};

    /**
     * Returns the URL to query the raster.
     * @param {Tile} tile for which the URL is created
     * @returns {string} the URL
     * @memberof AbstractRasterLayer#
     */
    AbstractRasterLayer.prototype.getUrl = function(tile) {
        throw new SyntaxError(
            "getUrl() not implemented",
            "AbstractRasterLayer.js"
        );
    };

    /**
     * Returns the Url when the tile level is between [minLevel, maxLevel]
     * @param url url
     * @returns {Boolean} the proxified Url when the tile level is between [minLevel, maxLevel]
     * @function allowRequest
     * @memberof AbstractRasterLayer#
     */
    AbstractRasterLayer.prototype.allowRequest = function(url, level) {
        var request;
        if (this.isBetweenMinMaxLevel(level)) {
            request = url;
        } else {
            request = null;
        }
        return request;
    };

    /**
     * Returns true when the tile is defined between [minLevel,maxLevel] otherwise false.
     * @param level level of the tile
     * @returns {Boolean} true when the tile level is defined between [minLevel,maxLevel] otherwise false.
     * @memberof AbstractRasterLayer#
     */
    AbstractRasterLayer.prototype.isBetweenMinMaxLevel = function(level) {
        var isInside;
        if (this.minLevel != null && this.maxLevel != null) {
            isInside = this.minLevel <= level && level <= this.maxLevel;
        } else if (this.minLevel != null) {
            isInside = level >= this.minLevel;
        } else if (this.maxLevel != null) {
            isInside = level <= this.maxLevel;
        } else {
            isInside = true;
        }

        return isInside;
    };

    /**
     * Attach the raster layer to the planet
     * @function _attach
     * @memberof AbstractRasterLayer#
     * @param {Globe} g - globe
     * @private
     */
    AbstractRasterLayer.prototype._attach = function(g) {
        if (this.isBackground()) {
            // Override id of background layer because of unicity of background not overlayed layer
            //TODO : check if it is still needed
            this.id = 0;
        }

        AbstractLayer.prototype._attach.call(this, g);
        if (!this.isBackground()) {
            // Create the renderer if needed
            if (!g.rasterOverlayRenderer) {
                var renderer = new RasterOverlayRenderer(g);
                g.getRendererManager().renderers.push(renderer);
                g.rasterOverlayRenderer = renderer;
            }
            g.rasterOverlayRenderer.addOverlay(this);
        }
    };

    /**************************************************************************************************************/

    /**
     * Detach the raster layer from the planet
     * @function _detach
     * @memberof AbstractRasterLayer#
     * @private
     */
    AbstractRasterLayer.prototype._detach = function() {
        // Remove raster from overlay renderer if needed
        if (!this.isBackground() && this.getGlobe().rasterOverlayRenderer) {
            this.getGlobe().rasterOverlayRenderer.removeOverlay(this);
        }

        AbstractLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    return AbstractRasterLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Crs/Geoide',[], function() {
    /**
     * Geoide configuration
     * @typedef {Object} AbstractCrs.geoide_configuration
     * @property {float} radius - internal radius in vector length
     * @property {float} realPlanetRadius - real planet radius in meter
     */

    /**
     * @name Geoide
     * @class
     * Geodetic datum is a set of parameters that define the position of the origin, the scale, and the orientation of a
     * coordinate system in relationship with the planet.
     * @param {AbstractCrs.geoide_configuration} options - Options for Geoide
     * @constructor
     * @throws {ReferenceError} Will throw an error when options.realPlanetRadius or options.radius are not defined
     * @memberof module:Crs
     * @todo add flattening parameter
     */
    var Geoide = function(options) {
        this.radius =
            options && options.hasOwnProperty("radius") ? options.radius : null;
        this.realPlanetRadius =
            options && options.hasOwnProperty("realPlanetRadius")
                ? options.realPlanetRadius
                : null;
        if (this.radius === null || this.realPlanetRadius === null) {
            throw new ReferenceError(
                "Radius and realPlanetRadius must be set to define a geoide",
                "Geoide.js"
            );
        }
        this.heightScale = this.radius / this.realPlanetRadius;
    };

    /**
     * Get real planet radius in meter
     * @function getRealPlanetRadius
     * @memberof Geoide#
     * @return {float} Real planet radius
     */
    Geoide.prototype.getRealPlanetRadius = function() {
        return this.realPlanetRadius;
    };

    /**
     * Get radius in vector length
     * @function getRadius
     * @memberof Geoide#
     * @return {float} Radius
     */
    Geoide.prototype.getRadius = function() {
        return this.radius;
    };

    /**
     * Get height scale = 1/realPlanetRadius
     * @function getHeightScale
     * @memberof Geoide#
     * @return {float} Height scale
     */
    Geoide.prototype.getHeightScale = function() {
        return this.heightScale;
    };
    /**************************************************************************************************************/

    return Geoide;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Crs/AstroCoordTransform',[],function() {
    /**************************************************************************************************************/

    /** The Constant twoPi. */
    var twoPi = 2.0 * Math.PI;

    /** The Constant fourPi. */
    var fourPi = 4.0 * Math.PI;

    /** The Constant degToRad. */
    var degToRad = 180.0 / Math.PI;

    /** The Constant psi. */
    var psi = [
        [0.57595865315, 4.9261918136, 0.0, 0.0, 0.11129056012, 4.7005372834],
        [0.574770433, 4.9368292465, 0.0, 0.0, 0.11142137093, 4.71279419371]
    ];

    /** The Constant stheta. */
    var stheta = [
        [
            0.88781538514,
            -0.88781538514,
            0.39788119938,
            -0.39788119938,
            0.86766174755,
            -0.86766174755
        ],
        [
            0.88998808748,
            -0.88998808748,
            0.39777715593,
            -0.39777715593,
            0.86766622025,
            -0.86766622025
        ]
    ];

    /** The Constant ctheta. */
    var ctheta = [
        [
            0.46019978478,
            0.46019978478,
            0.9174369467,
            0.9174369467,
            0.49715499774,
            0.49715499774
        ],
        [
            0.45598377618,
            0.45598377618,
            0.91748206207,
            0.91748206207,
            0.49714719172,
            0.49714719172
        ]
    ];

    /** The Constant phi. */
    var phi = [
        [4.9261918136, 0.57595865315, 0.0, 0.0, 4.7005372834, 0.11129056012],
        [4.9368292465, 0.574770433, 0.0, 0.0, 4.71279419371, 0.11142137093]
    ];

    var AstroCoordTransform = {
        /**Transforms an angular position in radians in a given coordinate system to a position
         in an other coordinate system, also in radians. RA-Dec position are intended in
         Equinox J2000

         @param {float[]} pos Angular position [phi, theta]
         @param trType Transform type
         */
        transform: function(pos, trType) {
            var ao, bo, a, b, sb, cb, cbsa;
            var J2000 = 1;
            //by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

            a = pos[0] - phi[J2000][trType];
            b = pos[1];
            sb = Math.sin(b);
            cb = Math.cos(b);
            cbsa = cb * Math.sin(a);
            b = -stheta[J2000][trType] * cbsa + ctheta[J2000][trType] * sb;
            b = Math.max(-1.0, Math.min(b, 1.0));
            bo = Math.asin(b);

            a = Math.atan2(
                ctheta[J2000][trType] * cbsa + stheta[J2000][trType] * sb,
                cb * Math.cos(a)
            );
            ao = (a + psi[J2000][trType] + fourPi) % twoPi;

            return [ao, bo]; // phi, theta
        },

        /**Transforms an angular position in degrees in a given coordinate system to a position
         in an other coordinate systems, also in degrees. RA-Dec position are intended in
         Equinox J2000

         @param {float[]} pos Angular position [phi, theta]
         @param trType Transform type
         */
        transformInDeg: function(pos, trType) {
            var ao, bo, a, b, sb, cb, cbsa;
            var J2000 = 1;
            //by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

            a = pos[0] / degToRad - phi[J2000][trType];
            b = pos[1] / degToRad;
            sb = Math.sin(b);
            cb = Math.cos(b);
            cbsa = cb * Math.sin(a);
            b = -stheta[J2000][trType] * cbsa + ctheta[J2000][trType] * sb;
            b = Math.max(-1.0, Math.min(b, 1.0));
            bo = Math.asin(b) * degToRad;

            a = Math.atan2(
                ctheta[J2000][trType] * cbsa + stheta[J2000][trType] * sb,
                cb * Math.cos(a)
            );
            ao = ((a + psi[J2000][trType] + fourPi) % twoPi) * degToRad;

            return [ao, bo];
        }
    };

    /**
     *    Transform type enumerations
     */
    AstroCoordTransform.Type = {
        EQ2GAL: 0, //RA-Dec (2000) -> Galactic
        GAL2EQ: 1, //Galactic      -> RA-Dec
        EQ2ECL: 2, //RA-Dec        -> Ecliptic
        ECL2EQ: 3, //Ecliptic      -> RA-Dec
        ECL2GAL: 4, //Ecliptic      -> Galactic
        GAL2ECL: 5 //Galactic      -> Ecliptic
    };

    /**************************************************************************************************************/

    return AstroCoordTransform;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/Crs/AbstractCrs',[
    "../Utils/Numeric",
    "./Geoide",
    "../Utils/Constants",
    "./AstroCoordTransform",
    "../Gui/dialog/ErrorDialog",
    "../Renderer/glMatrix"
], function(Numeric, Geoide, Constants, AstroCoordTransform, ErrorDialog) {
    /**
     * Abstract coordinate reference system configuration
     * @typedef {AbstractCrs.geoide_configuration} AbstractCrs.configuration
     * @property {CRS} geoideName - name of the coordinate reference system
     * @property {CONTEXT} type - Type of the CRS
     * @property {GeoBound} geoBound - Geographical bounding box
     */

    /**
     * @name AbstractCrs
     * @class
     * Creates an coordinate reference system for a globe and data.
     *
     * A coordinate reference system is a coordinate system that is related to an object
     * by a {@link Geoide geodetic datum}.
     *
     * A coordinate system is a set of mathematical rules for specifying how coordinates are to be assigned to points
     * @param {AbstractCrs.configuration} options - Options for the coordinate reference system.
     * @throws {ReferenceError} Will throw when option.geoideName, options.geoBound and options.type are not defined
     * @implements {Crs}
     */
    var AbstractCrs = function(options) {
        this.flat = false;
        this.geoide = null;
        this.type = null;
        this.geoBound = null;

        // If geoideName is specified, use it
        if (options && options.geoideName && options.type && options.geoBound) {
            this.geoide = new Geoide(options);
            this.geoideName = options.geoideName;
            this.type = options.type;
            this.geoBound = options.geoBound;
        } else {
            throw new ReferenceError(
                "The geoide's parameters, the geoBound and the type of context must be defined",
                AbstractCrs.js
            );
        }
    };

    /**
     * @function isFlat
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.isFlat = function() {
        return this.flat;
    };

    /**
     * @function getVerticalAt3D
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getVerticalAt3D = function(pos, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        if (this.isFlat()) {
            dest[0] = 0.0;
            dest[1] = 0.0;
            dest[2] = 1.0;
        } else {
            vec3.normalize(pos, dest);
        }
        return dest;
    };

    /**
     * @function fromGeoTo3D
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.fromGeoTo3D = function(geo, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        if (!geo || geo.length < 2) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "AbstractCrs.js", "geo is 2D or does not exist");
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        }
        var longInRad = Numeric.toRadian(geo[0]);
        var latInRad = Numeric.toRadian(geo[1]);
        var cosLat = Math.cos(latInRad);

        // Take height into account
        var height = geo.length > 2 ? this.geoide.getHeightScale() * geo[2] : 0;
        var radius = this.geoide.getRadius() + height;

        dest[0] = radius * Math.cos(longInRad) * cosLat;
        dest[1] = radius * Math.sin(longInRad) * cosLat;
        dest[2] = radius * Math.sin(latInRad);

        return dest;
    };

    /**
     * @function from3DToGeo
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.from3DToGeo = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var r = Math.sqrt(
            position3d[0] * position3d[0] +
                position3d[1] * position3d[1] +
                position3d[2] * position3d[2]
        );
        var lon = Math.atan2(position3d[1] / r, position3d[0] / r);
        var lat = Math.asin(position3d[2] / r);
        dest[0] = Numeric.toDegree(lon);
        dest[1] = Numeric.toDegree(lat);
        dest[2] =
            this.geoide.getRealPlanetRadius() * (r - this.geoide.getRadius());
        return dest;
    };

    /**
     * @function getLocalTransform
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getLocalTransform = function(geo, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        var longitude = (geo[0] * Math.PI) / 180.0;
        var latitude = (geo[1] * Math.PI) / 180.0;

        var up = [
            Math.cos(longitude) * Math.cos(latitude),
            Math.sin(longitude) * Math.cos(latitude),
            Math.sin(latitude)
        ];
        var east = [-Math.sin(longitude), Math.cos(longitude), 0];
        var north = vec3.create();
        vec3.cross(up, east, north);

        dest[0] = east[0];
        dest[1] = east[1];
        dest[2] = east[2];
        dest[3] = 0.0;

        dest[4] = north[0];
        dest[5] = north[1];
        dest[6] = north[2];
        dest[7] = 0.0;

        dest[8] = up[0];
        dest[9] = up[1];
        dest[10] = up[2];
        dest[11] = 0.0;

        dest[12] = 0.0;
        dest[13] = 0.0;
        dest[14] = 0.0;
        dest[15] = 1.0;

        return dest;
    };

    /**
     * @function getLHVTransform
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getLHVTransform = function(geo, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        var longitude = (geo[0] * Math.PI) / 180.0;
        var latitude = (geo[1] * Math.PI) / 180.0;

        var up = [
            Math.cos(longitude) * Math.cos(latitude),
            Math.sin(longitude) * Math.cos(latitude),
            Math.sin(latitude)
        ];
        var east = [-Math.sin(longitude), Math.cos(longitude), 0];
        var north = vec3.create();
        vec3.cross(up, east, north);

        var pt = this.get3DFromWorld(geo);

        dest[0] = east[0];
        dest[1] = east[1];
        dest[2] = east[2];
        dest[3] = 0.0;

        dest[4] = north[0];
        dest[5] = north[1];
        dest[6] = north[2];
        dest[7] = 0.0;

        dest[8] = up[0];
        dest[9] = up[1];
        dest[10] = up[2];
        dest[11] = 0.0;

        dest[12] = pt[0];
        dest[13] = pt[1];
        dest[14] = pt[2];
        dest[15] = 1.0;

        return dest;
    };

    /**
     * @function getSideVector
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getSideVector = function(matrix, v) {
        v[0] = matrix[0];
        v[1] = matrix[1];
        v[2] = matrix[2];
        return v;
    };

    /**
     * @function getFrontVector
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getFrontVector = function(matrix, v) {
        v[0] = matrix[4];
        v[1] = matrix[5];
        v[2] = matrix[6];

        return v;
    };

    /**
     * @function getUpVector
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getUpVector = function(matrix, v) {
        v[0] = matrix[8];
        v[1] = matrix[9];
        v[2] = matrix[10];

        return v;
    };

    /**
     * @function formatCoordinates
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype.formatCoordinates = function(geo) {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function getGeoide
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getGeoide = function() {
        return this.geoide;
    };

    /**
     * @function getGeoideName
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getGeoideName = function() {
        return this.geoideName;
    };

    /**
     * @function getType
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getType = function() {
        return this.type;
    };

    /**
     * @function getElevation
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getElevation = function(globe, geoPos) {
        return globe.getElevation(geoPos.coordinates[0], geoPos.coordinates[1]);
    };

    /**
     * @function getWorldFrom3D
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getWorldFrom3D = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        var geoPos = this.from3DToGeo(position3d);
        this._setupPosAfterTrans(geoPos);
        dest[0] = geoPos[0];
        dest[1] = geoPos[1];
        dest[2] = geoPos.length > 2 ? geoPos[2] : 0;
        return dest;
    };

    /**
     * @function get3DFromWorld
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.get3DFromWorld = function(posWorld, dest) {
        if (!dest) {
            dest = vec3.create();
        }
        var pos = posWorld.slice(0);
        this._setupPosBeforeTrans(pos);
        this.fromGeoTo3D(pos, dest);
        return dest;
    };

    /**
     * @function get3DFromWorldInCrs
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.get3DFromWorldInCrs = function(
        posWorld,
        posCrsID,
        dest
    ) {
        if (!dest) {
            dest = vec3.create();
        }
        var posWorldInCurrentCrs = this.convert(
            posWorld,
            posCrsID,
            this.getGeoideName()
        );
        this.get3DFromWorld(posWorldInCurrentCrs, dest);
        return dest;
    };

    /**
     * @function getSexagesimalFromDeg
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getSexagesimalFromDeg = function(degPos, dest) {
        dest = dest || [];

        var deg = degPos[0];
        // RA
        if (deg < 0) {
            deg += 360;
        }

        dest[0] = this.fromDegreesToHMS(deg);
        dest[1] = this.fromDegreesToDMS(degPos[1]);

        return dest;
    };

    /**
     * @function getDecimalDegFromSexagesimal
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getDecimalDegFromSexagesimal = function(
        sexagesimalPos,
        dest
    ) {
        dest = dest || [];

        // we use string because : parseFloat("-0") returns 0..
        function sign(stringDegree) {
            return stringDegree[0] === "-" ? -1 : 1;
        }

        var longitude = sexagesimalPos[0].split(" ");
        // long
        var deg = parseFloat(longitude[0]);
        var min = parseFloat(longitude[1]);
        var sec = parseFloat(longitude[2]);

        dest[0] = (deg + min / 60 + sec / 3600) * 15.0;

        var latitude = sexagesimalPos[1].split(" ");
        // lat
        deg = parseFloat(latitude[0]);
        min = parseFloat(latitude[1]);
        sec = parseFloat(latitude[2]);

        dest[1] = sign(latitude[0]) * (Math.abs(deg) + min / 60 + sec / 3600);

        return dest;
    };

    /**
     * @function convert
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.convert = function(geo, from, to) {
        // No conversion needed
        if (from === to) {
            return geo;
        }

        var convertedGeo = null;
        var convertType = null;
        switch (from + "2" + to) {
        case Constants.CRS.Galactic + "2" + Constants.CRS.Equatorial:
            convertType = AstroCoordTransform.Type.GAL2EQ;
            convertedGeo = AstroCoordTransform.transformInDeg(
                geo,
                convertType
            );
            break;
        case Constants.CRS.Equatorial + "2" + Constants.CRS.Galactic:
            convertType = AstroCoordTransform.Type.EQ2GAL;
            convertedGeo = AstroCoordTransform.transformInDeg(
                geo,
                convertType
            );
            if (convertedGeo[0] < 0) {
                // TODO : Check if convertedGeo can be negative
                ErrorDialog.open(Constants.LEVEL.DEBUG, "AbstractCRs.js", "EQ2GAL transformation returned negative value");
                convertedGeo[0] += 360;
            }
            break;
        case Constants.CRS.Mars_2000 + "2" + Constants.CRS.Mars_2000_old:
        case Constants.CRS.Mars_2000_old + "2" + Constants.CRS.Mars_2000:
            convertedGeo = geo;
            break;
        case Constants.CRS.Moon_2000 + "2" + Constants.CRS.Moon_2000_old:
        case Constants.CRS.Moon_2000_old + "2" + Constants.CRS.Moon_2000:
            convertedGeo = geo;
            break;
        default:
            throw new RangeError(
                "Conversion " + from + " to " + to + " is not implemented",
                "AbstractCrs.js"
            );
        }

        return convertedGeo;
    };

    /**
     * Adds a zero before the number < 10
     * @function _pad2Digits
     * @param number number to format
     * @returns {string}
     * @private
     */
    AbstractCrs.prototype._pad2Digits = function(number) {
        return number < 10 ? "0" + number : number;
    };

    /**
     * @function fromDegreesToHMS
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.fromDegreesToHMS = function(degree) {
        var localDegree = degree / 15;

        var absLon = Math.abs(localDegree);
        var hours = Math.floor(absLon);
        var decimal = (absLon - hours) * 60;
        var min = Math.floor(decimal);
        var sec = (decimal - min) * 60;

        return (
            this._pad2Digits(hours) +
            "h " +
            this._pad2Digits(min) +
            "m " +
            this._pad2Digits(Numeric.roundNumber(sec, 2)) +
            "s"
        );
    };

    /**
     * @function fromDegreesToDMS
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.fromDegreesToDMS = function(degree) {
        function stringSign(val) {
            return val >= 0 ? "+" : "-";
        }

        var absLat = Math.abs(degree);
        var deg = Math.floor(absLat);
        var decimal = (absLat - deg) * 60;
        var min = Math.floor(decimal);
        var sec = (decimal - min) * 60;

        return (
            stringSign(degree) +
            this._pad2Digits(deg) +
            String.fromCharCode(176) +
            " " +
            this._pad2Digits(min) +
            "' " +
            this._pad2Digits(Numeric.roundNumber(sec, 2)) +
            "\""
        );
    };

    /**
     * @function _setupPosBeforeTrans
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype._setupPosBeforeTrans = function(posWorld) {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function _setupPosAfterTrans
     * @memberof AbstractCrs#
     * @bastract
     */
    AbstractCrs.prototype._setupPosAfterTrans = function(posWorld) {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function getGeoBound
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getGeoBound = function() {
        return this.geoBound;
    };

    /**
     * @function getName
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype.getName = function() {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function getDescription
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype.getDescription = function() {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function getLongitudeLabel
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype.getLongitudeLabel = function() {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function getLatitudeLabel
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype.getLatitudeLabel = function() {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function isProjected
     * @memberof AbstractCrs#
     * @return {boolean} true when the Crs is projected in 2D otherwise false.
     */
    AbstractCrs.prototype.isProjected = function() {
        return false;
    };

    /**
     * @function destroy
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.destroy = function() {
        this.flat = null;
        this.geoide = null;
        this.type = null;
        this.geoBound = null;
        this.projected = null;
    };

    /**************************************************************************************************************/
    return AbstractCrs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Crs/WGS84Crs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    const DESCRIPTION =
        "WGS84 coordinate Reference System is a coordinate system using the Earth geoide in which " +
        "the geographic longitude increases to the east. The geographic latitude is measured in degrees north or south " +
        "of the Earth equator. In Mizar, the latitudes are projected on a sphere";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "Long";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "Lat";

    /**
     * @name WGS84Crs
     * @class
     * WGS84 coordinate Reference System is a coordinate system using the Earth geoide in which the
     * geographic longitude increases to the east. The geographic latitude is measured in degrees north or south
     * of the Earth equator.
     * <br/>
     * <img src="../doc/images/earth.jpg" width="200px"/>
     * <br/>
     * WGS84Crs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = CRS:84</li>
     *     <li>radius = 1</li>
     *     <li>realPlanetRadius = 6378137 meters</li>
     *     <li>type = Planet</li>
     *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - No option to give.
     * @constructor
     * @memberof module:Crs
     */
    var WGS84Crs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.WGS84,
            radius: 1.0,
            realPlanetRadius: 6378137,
            type: Constants.CONTEXT.Planet,
            geoBound: new GeoBound(-180, -90, 180, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, WGS84Crs);

    /**************************************************************************************************************/

    /**
     * Formats the coordinates (longitude, latitude) as (x.xxx&deg, y.yyy&deg).
     * @function formatCoordinates
     * @memberof WGS84Crs#
     * @param {float[]} geo the spatial position in degree
     * @return {string[]} the formatted chain
     */
    WGS84Crs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        var longitude = Numeric.roundNumber(geo[0], 3);
        var latitude = Numeric.roundNumber(geo[1], 3);
        astro[0] = this.getLatitudeLabel() + " = ";
        astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
        astro[1] = this.getLongitudeLabel() + " = ";
        astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof WGS84Crs#
     */
    WGS84Crs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof WGS84Crs#
     */
    WGS84Crs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * @function _setupPosAfterTrans
     * @memberof WGS84Crs#
     * Do nothing
     * @param posWorld
     * @private
     */
    WGS84Crs.prototype._setupPosAfterTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * Do nothing
     * @function _setupPosBeforeTrans
     * @memberof WGS84Crs#
     * @param posWorld
     * @private
     */
    WGS84Crs.prototype._setupPosBeforeTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * @function getName
     * @memberof WGS84Crs#
     */
    WGS84Crs.prototype.getName = function() {
        return Constants.CRS.WGS84;
    };

    /**
     * @function getDescription
     * @memberof WGS84Crs#
     */
    WGS84Crs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return WGS84Crs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Crs/Mars2000Crs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "Mars 2000 coordinate Reference System is a coordinate system using the Mars sphere and in " +
        "which the planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees " +
        "north or south of the Mars equator.";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "Long";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "Lat";

    /**
     * @name Mars2000Crs
     * @class
     * Mars 2000 coordinate Reference System is a coordinate system using the Mars sphere and in which the
     * planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees north or south
     * of the Mars equator.
     * <br/>
     * Mars2000Crs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = IAU2000:49901</li>
     *     <li>radius = 1.0</li>
     *     <li>realPlanetRadius = 3396190</li>
     *     <li>type = Planet</li>
     *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - No option to give.
     * @constructor
     * @memberof module:Crs
     */
    var Mars2000Crs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.Mars_2000,
            radius: 1.0,
            realPlanetRadius: 3396190,
            type: Constants.CONTEXT.Planet,
            geoBound: new GeoBound(-180, -90, 180, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, Mars2000Crs);

    /**************************************************************************************************************/

    /**
     * Formats coordinates as (x.xxx N, y.yyy E).
     * @function formatCoordinates
     * @memberof Mars2000Crs
     * @param {float[]} geo the spatial position in degree
     * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
     */
    Mars2000Crs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        var longitude = Numeric.roundNumber(geo[0], 3);
        var latitude = Numeric.roundNumber(geo[1], 3);
        astro[0] = this.getLatitudeLabel() + " = ";
        astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
        astro[1] = this.getLongitudeLabel() + " = ";
        astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof Mars2000Crs#
     */
    Mars2000Crs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof Mars2000Crs#
     */
    Mars2000Crs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * Do nothing
     * @function _setupPosAfterTrans
     * @memberof Mars2000Crs
     * @private
     */
    Mars2000Crs.prototype._setupPosAfterTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * Do nothing
     * @function _setupPosBeforeTrans
     * @memberof Mars2000Crs
     * @private
     */
    Mars2000Crs.prototype._setupPosBeforeTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * @function getName
     * @memberof Mars2000Crs#
     */
    Mars2000Crs.prototype.getName = function() {
        return Constants.CRS.Mars_2000;
    };

    /**
     * @function getDescription
     * @memberof Mars2000Crs#
     */
    Mars2000Crs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return Mars2000Crs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Crs/Moon2000Crs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "Moon 2000 coordinate Reference System is a coordinate system using the Moon sphere and in " +
        "which the planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees " +
        "north or south of the Moon equator.";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "Long";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "Lat";

    /**
     * @name Moon2000Crs
     * @class
     * Moon 2000 coordinate Reference System is a coordinate system using the Moon sphere and in which the
     * planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees north or south
     * of the Moon equator.
     * <br/>
     * Moon2000Crs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = IAU2000:30101</li>
     *     <li>radius = 1.0</li>
     *     <li>realPlanetRadius = 1737400</li>
     *     <li>type = Planet</li>
     *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - No option to give.
     * @constructor
     * @memberof module:Crs
     */
    var Moon2000Crs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.Moon_2000,
            radius: 1.0,
            realPlanetRadius: 1737400,
            type: Constants.CONTEXT.Planet,
            geoBound: new GeoBound(-180, -90, 180, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, Moon2000Crs);

    /**************************************************************************************************************/

    /**
     * Formats coordinates as (x.xxx N, y.yyy E).
     * @function formatCoordinates
     * @memberof Moon2000Crs
     * @param {float[]} geo the spatial position in degree
     * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
     */
    Moon2000Crs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        var longitude = Numeric.roundNumber(geo[0], 3);
        var latitude = Numeric.roundNumber(geo[1], 3);
        astro[0] = this.getLatitudeLabel() + " = ";
        astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
        astro[1] = this.getLongitudeLabel() + " = ";
        astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof Moon2000Crs#
     */
    Moon2000Crs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof Moon2000Crs#
     */
    Moon2000Crs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * Do nothing
     * @function _setupPosAfterTrans
     * @memberof Moon2000Crs
     * @private
     */
    Moon2000Crs.prototype._setupPosAfterTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * Do nothing
     * @function _setupPosBeforeTrans
     * @memberof Moon2000Crs
     * @private
     */
    Moon2000Crs.prototype._setupPosBeforeTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * @function getName
     * @memberof Moon2000Crs#
     */
    Moon2000Crs.prototype.getName = function() {
        return Constants.CRS.Moon_2000;
    };

    /**
     * @function getDescription
     * @memberof Moon2000Crs#
     */
    Moon2000Crs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return Moon2000Crs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * A coordinate reference system is a coordinate system that is related to an object
 * by a {@link module:Crs.Geoide geodetic datum}.
 * Mizar currently supports the following coordinates reference systems :
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/equatorial.png" width="200px"/></td>
 *         <td>{@link module:Crs.EquatorialCrs EquatorialCrs}</td>
 *         <td>Provides an equatorial coordinate reference system</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/galactic.png" width="200px"/></td>
 *         <td>{@link module:Crs.GalacticCrs GalacticCrs}</td>
 *         <td>Provides a galactic coordinate reference system</td>
 *     </tr>
 *     <tr>
 *         <td></td>
 *         <td>{@link module:Crs.Mars2000Crs Mars2000Crs}</td>
 *         <td>Provides a coordinate reference system base on the Mars geoide</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/earth.jpg" width="200px"/></td>
 *         <td>{@link module:Crs.WGS84Crs WGS84Crs}</td>
 *         <td>Provides a coordinate reference system base on the Earth geoide</td>
 *     </tr>
 *     <tr>
 *         <td></td>
 *         <td>{@link module:Crs.ProjectedCrs ProjectedCrs}</td>
 *         <td>Provides a projected coordinate reference system on a map</td>
 *     </tr>
 * </table>
 * <br/>
 * In addition to the classes, a {@link module:Crs.CoordinateSystemFactory factory} is available to help for creating
 * coordinate reference system. Once the coordinate reference system is created, the client can handle it by the use of its
 * {@link Crs interface}.
 *
 * @module Crs
 * @implements {Crs}
 */
define('gw/Crs/EquatorialCrs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractCrs, GeoBound, Utils, Constants) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "System in which a celestial object's position on the celestial " +
        "sphere is described in terms of its declination and right ascension, measured with respect to the celestial " +
        "equator. Declination and right ascension correspond directly to geographic latitude and longitude as " +
        "projected outward onto the celestial sphere. Declination is measured in degrees north or south of the " +
        "celestial equator but right ascension  is measured in hours, minutes, and seconds eastward along the " +
        "celestial equator from the point of the vernal equinox. Because the celestial equator moves among the fixed " +
        "stars with the precession of the Earth's poles, an object's declination and right ascension change " +
        "gradually over time, and coordinates in the equatorial system must be specified for particular years. By " +
        "Default J2000 is used";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "&alpha;";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "&delta;";

    /**
     * @name EquatorialCrs
     * @class
     * System in which a celestial object's position on the celestial
     * sphere is described in terms of its declination and right ascension, measured with respect to the celestial equator.
     * Declination and right ascension correspond directly to geographic latitude and longitude as projected outward onto
     * the celestial sphere. Declination is measured in degrees north or south of the celestial equator but right ascension
     * is measured in hours, minutes, and seconds eastward along the celestial equator from the point of the vernal equinox.
     * Because the celestial equator moves among the fixed stars with the precession of the Earth's poles, an object's
     * declination and right ascension change gradually over time, and coordinates in the equatorial system must be
     * specified for particular years.
     * <br/>
     * <i>source : equatorial coordinate system. Dictionary.com. The American Heritage Science Dictionary.
     * Houghton Mifflin Company. http://www.dictionary.com/browse/equatorial-coordinate-system (accessed: March 5, 2017).</i>
     * <br/>
     * <img src="../doc/images/equatorial.png"/>
     * <br/>
     * EquatorialCrs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = Equatorial</li>
     *     <li>radius = 10.0</li>
     *     <li>realPlanetRadius = 1.0</li>
     *     <li>type = Sky</li>
     *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param {Object} options - No option to give
     * @constructor
     * @see {@link https://en.wikipedia.org/wiki/Equatorial_coordinate_system Wikipedia}
     * @memberof module:Crs
     */
    var EquatorialCrs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.Equatorial,
            radius: 10.0,
            realPlanetRadius: 1.0,
            type: Constants.CONTEXT.Sky,
            geoBound: new GeoBound(0, -90, 360, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, EquatorialCrs);

    /**************************************************************************************************************/

    /**
     * @function transformVec
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.transformVec = function(vec) {
        var transformMatrix = this.computeTransformMatrix();
        var res = [];
        mat4.multiplyVec3(transformMatrix, vec, res);
        return res;
    };

    /**
     * @function computeTransformMatrix
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.computeTransformMatrix = function() {
        var transformMatrix = [];

        var galNorth = this.convert(
            [0, 90],
            Constants.CRS.Galactic,
            Constants.CRS.Equatorial
        );
        var gal3DNorth = this.fromGeoTo3D(galNorth);

        var galCenter = this.convert(
            [0, 0],
            Constants.CRS.Galactic,
            Constants.CRS.Equatorial
        );
        var gal3DCenter = this.fromGeoTo3D(galCenter);

        var galEast = this.convert(
            [90, 0],
            Constants.CRS.Galactic,
            Constants.CRS.Equatorial
        );
        var gal3DEast = this.fromGeoTo3D(galEast);

        transformMatrix[0] = gal3DCenter[0];
        transformMatrix[1] = gal3DCenter[1];
        transformMatrix[2] = gal3DCenter[2];
        transformMatrix[3] = 0.0;
        transformMatrix[4] = gal3DEast[0];
        transformMatrix[5] = gal3DEast[1];
        transformMatrix[6] = gal3DEast[2];
        transformMatrix[7] = 0.0;
        transformMatrix[8] = gal3DNorth[0];
        transformMatrix[9] = gal3DNorth[1];
        transformMatrix[10] = gal3DNorth[2];
        transformMatrix[11] = 0.0;
        transformMatrix[12] = 0.0;
        transformMatrix[13] = 0.0;
        transformMatrix[14] = 0.0;
        transformMatrix[15] = 1.0;

        return transformMatrix;
    };

    /**
     * @function formatCoordinates
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.formatCoordinates = function(geo) {
        var sexa = this.getSexagesimalFromDeg(geo);
        var dest = [];
        dest[0] = this.getLongitudeLabel() + " = " + sexa[0];
        dest[1] = this.getLatitudeLabel() + " = " + sexa[1];
        return dest;
    };

    /**
     * @function getLongitudeLabel
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * @function _setupPosAfterTrans
     * @memberof EquatorialCrs#
     * @private
     */
    EquatorialCrs.prototype._setupPosAfterTrans = function(posWorld) {
        if (posWorld[0] < 0) {
            posWorld[0] += 360.0;
        }
    };

    /**
     * @function _setupPosBeforeTrans
     * @memberof EquatorialCrs#
     * @private
     */
    EquatorialCrs.prototype._setupPosBeforeTrans = function(posWorld) {
        if (posWorld[0] > 180) {
            posWorld[0] -= 360.0;
        }
    };

    /**
     * @function getName
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.getName = function() {
        return Constants.CRS.Equatorial;
    };

    /**
     * @function getDescription
     * @memberof EquatorialCrs#
     * @abstract
     */
    EquatorialCrs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    /**************************************************************************************************************/

    return EquatorialCrs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Crs/GalacticCrs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "System in which a celestial object's position on the celestial sphere is described in " +
        "relation to the structure of the Milky Way galaxy. An object's galactic longitude is measured along the " +
        "galactic equator, a great circle on the celestial sphere that follows the band of the Milky Way. The " +
        "galactic equator, also called the galactic circle, is inclined at an angle of approximately 62 to the " +
        "celestial equator; distances are measured along it beginning at a point in the constellation Sagittarius lying in " +
        "the direction of the Milky Way's nucleus. The galactic poles are the two points where a perpendicular line " +
        "through the middle of the plane of the galactic equator intersect the celestial sphere. An object's galactic " +
        "latitude is measured in degrees north or south of the galactic equator toward the galactic poles.";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "l";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "b";

    /**
     * @name GalacticCrs
     * @class
     * System in which a celestial object's position on the celestial
     * sphere is described in relation to the structure of the Milky Way galaxy. An object's galactic longitude is measured
     * along the galactic equator, a great circle on the celestial sphere that follows the band of the Milky Way.
     * The galactic equator, also called the galactic circle, is inclined at an angle of approximately 62 to the
     * celestial equator; distances are measured along it beginning at a point in the constellation Sagittarius lying in
     * the direction of the Milky Way's nucleus. The galactic poles are the two points where a perpendicular line through
     * the middle of the plane of the galactic equator intersect the celestial sphere. An object's galactic latitude is
     * measured in degrees north or south of the galactic equator toward the galactic poles.
     * <br/>
     * <i>source : galactic coordinate system. Dictionary.com. The American Heritage Science Dictionary.
     * Houghton Mifflin Company. http://www.dictionary.com/browse/galactic-coordinate-system (accessed: March 5, 2017).</i>
     * <br/>
     * <img src="../doc/images/galactic.png"/>
     * <br/>
     * GalacticCrs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = Galactic</li>
     *     <li>radius = 10.0</li>
     *     <li>realPlanetRadius = 1.0</li>
     *     <li>type = Sky</li>
     *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - no option to give.
     * @constructor
     * @see {@link https://en.wikipedia.org/wiki/Galactic_coordinate_system Wikipedia}
     * @memberof module:Crs
     */
    var GalacticCrs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.Galactic,
            radius: 10.0,
            realPlanetRadius: 1.0,
            type: Constants.CONTEXT.Sky,
            geoBound: new GeoBound(0, -90, 360, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, GalacticCrs);

    /**************************************************************************************************************/

    /**
     * @function formatCoordinates
     * @memberof GalacticCrs#
     */
    GalacticCrs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        astro[0] =
            this.getLongitudeLabel() + " = " + Numeric.roundNumber(geo[0], 3);
        astro[0] += "&deg;";
        astro[1] =
            this.getLatitudeLabel() + " = " + Numeric.roundNumber(geo[1], 3);
        astro[1] += "&deg;";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof GalacticCrs#
     */
    GalacticCrs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof GalacticCrs#
     */
    GalacticCrs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * @function _setupPosAfterTrans
     * @memberof GalacticCrs#
     * @private
     */
    GalacticCrs.prototype._setupPosAfterTrans = function(posWorld) {
        if (posWorld[0] < 0) {
            posWorld[0] += 360.0;
        }
        posWorld = this.convert(
            posWorld,
            Constants.CRS.Equatorial,
            Constants.CRS.Galactic
        );
    };

    /**
     * @function _setupPosBeforeTrans
     * @memberof GalacticCrs#
     * @rpivate
     */
    GalacticCrs.prototype._setupPosBeforeTrans = function(posWorld) {
        posWorld = this.convert(
            posWorld,
            Constants.CRS.Galactic,
            Constants.CRS.Equatorial
        );
        if (posWorld[0] > 180) {
            posWorld[0] -= 360.0;
        }
    };

    /**
     * @function getName
     * @memberof GalacticCrs#
     */
    GalacticCrs.prototype.getName = function() {
        return Constants.CRS.Galactic;
    };

    /**
     * @function getName
     * @memberof GalacticCrs#
     */
    GalacticCrs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return GalacticCrs;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Projection/AbstractProjection',["../Renderer/GeoBound"], function(GeoBound) {
    /**
     * Base projection configuration
     * @typedef {Object} AbstractProjection.configuration
     * @property {PROJECTION} projectionName - Name of the projection
     */

    /**
     * @name AbstractProjection
     * @class
     *   Abstract class for projections.
     * A map projection is one of many methods used to represent the 3-dimensional surface of the earth or other round body
     * on a 2-dimensional plane in cartography. The creation of a map projection involves two steps :
     * <ul>
     *     <li>selection of a model for the shape of the body (choosing between a sphere or ellipsoid),</li>
     *     <li>transform planetographic coordinates to plane coordinates.</li>
     * </ul>
     * @param {float[]} projectionCenter - the projection center as (longitude, latitude)
     * @param {float[]} geoBound - Geo boundary as [minLongitude, minLatitude, maxLongitude, maxLatitude]
     * @param {AbstractProjection.configuration} options - Not used currently
     * @constructor
     * @implements {Projection}
     */
    var AbstractProjection = function(projectionCenter, geoBound, options) {
        this.geoBound = new GeoBound(
            geoBound[0],
            geoBound[1],
            geoBound[2],
            geoBound[3]
        );
        this.projectionCenter = projectionCenter;
        this.options = options || {};
    };

    /**
     * @function getProjectionCenter
     * @memberof AbstractProjection#
     */
    AbstractProjection.prototype.getProjectionCenter = function() {
        return this.projectionCenter;
    };

    /**
     * @function getGeoBound
     * @memberof AbstractProjection#
     */
    AbstractProjection.prototype.getGeoBound = function() {
        return this.geoBound;
    };

    /**
     * @function unProject
     * @memberof AbstractProjection#
     * @abstract
     */
    AbstractProjection.prototype.unProject = function(position3d, dest) {
        throw new SyntaxError(
            "unProject not implemented",
            "AbstractProjection.js"
        );
    };

    /**
     * @function project
     * @memberof AbstractProjection#
     * @abstract
     */
    AbstractProjection.prototype.project = function(geoPos, dest) {
        throw new SyntaxError(
            "project not implemented",
            "AbstractProjection.js"
        );
    };

    /**
     * @function getName
     * @memberof AbstractProjection#
     * @abstract
     */
    AbstractProjection.prototype.getName = function() {
        throw new SyntaxError(
            "getName not implemented",
            "AbstractProjection.js"
        );
    };

    /**************************************************************************************************************/

    return AbstractProjection;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
/**
 * Mizar owns different types of projection, which is used to represent a planet on a 2D map.
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/aitoff.png" width="200px"/></td>
 *         <td>{@link module:Projection.AitoffProjection AitoffProjection}</td>
 *         <td>Provides a AITOFF projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/august.png" width="200px"/></td>
 *         <td>{@link module:Projection.AugustProjection AugustProjection}</td>
 *         <td>Provides an august projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/azimuth.png" width="200px"/></td>
 *         <td>{@link module:Projection.AzimuthProjection AzimuthProjection}</td>
 *         <td>Provides an azimuth projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/mercator.png" width="200px"/></td>
 *         <td>{@link module:Projection.MercatorProjection MercatorProjection}</td>
 *         <td>Provides a mercator projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/mollweide.png" width="200px"/></td>
 *         <td>{@link module:Projection.MollweideProjection MollweideProjection}</td>
 *         <td>Provides a mollweide projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/platecarr.png" width="200px"/></td>
 *         <td>{@link module:Projection.PlateProjection PlateProjection}</td>
 *         <td>Provides a plate carre projection</td>
 *     </tr>
 * </table>
 *
 * The projection is automatically instantiated by the {@link module:Crs.ProjectedCrs ProjectedCrs} class.
 * @module Projection
 * @implements {Projection}
 */
define('gw/Projection/AitoffProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * @name AitoffProjection
     * @class
     *    The Aitoff coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     *  <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
     *  <li>a projection : the Aitoff projection.</li>
     * </ul>
     *
     * The Aitoff projection is a modified azimuthal map projection first proposed by David A. Aitoff in 1889.
     * Based on the equatorial form of the azimuthal equidistant projection, Aitoff halved longitudes from the central
     * meridian, projected by the azimuthal equidistant, and then stretched the result horizontally into a 2:1 ellipse.
     * <img src="../doc/images/aitoff.png" width="200px"/>
     *
     *
     * @see {@link https://en.wikipedia.org/wiki/Aitoff_projection}
     * @augments AbstractProjection
     * @param {AbstractProjection.configuration} [options] - Aitoff projection configuration.
     * @constructor
     * @memberof module:Projection
     */
    var AitoffProjection = function(options) {
        AbstractProjection.prototype.constructor.call(
            this,
            [0, 0],
            [-180, -90, 180, 90],
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, AitoffProjection);

    /**************************************************************************************************************/

    /**
     *    Inverse sampling function(sinc)
     */
    var _sinci = function(x) {
        return x ? x / Math.sin(x) : 1;
    };

    /**
     * @function unProject
     * @memberof AitoffProjection#
     */
    AitoffProjection.prototype.unProject = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var epsilon = 0.005;
        var deltaLambda;
        var deltaPhi;
        // Abort if [x, y] is not within an ellipse centered at [0, 0] with
        // semi-major axis pi and semi-minor axis pi/2.
        if (
            position3d[0] * position3d[0] + 4 * position3d[1] * position3d[1] >
            Math.PI * Math.PI + epsilon
        ) {
            return;
        }

        var lambda = position3d[0],
            phi = position3d[1],
            i = 25;

        do {
            var sinLambda = Math.sin(lambda),
                sinLambda_2 = Math.sin(lambda / 2),
                cosLambda_2 = Math.cos(lambda / 2),
                sinPhi = Math.sin(phi),
                cosPhi = Math.cos(phi),
                sin_2phi = Math.sin(2 * phi),
                sin2phi = sinPhi * sinPhi,
                cos2phi = cosPhi * cosPhi,
                sin2lambda_2 = sinLambda_2 * sinLambda_2,
                F,
                C = 1 - cos2phi * cosLambda_2 * cosLambda_2,
                E = C
                    ? Math.acos(cosPhi * cosLambda_2) * Math.sqrt((F = 1 / C))
                    : (F = 0),
                fx = 2 * E * cosPhi * sinLambda_2 - position3d[0],
                fy = E * sinPhi - position3d[1],
                deltaXLambda =
                    F *
                    (cos2phi * sin2lambda_2 +
                        E * cosPhi * cosLambda_2 * sin2phi),
                deltaXPhi =
                    F *
                    (0.5 * sinLambda * sin_2phi - E * 2 * sinPhi * sinLambda_2),
                deltaYLambda =
                    F *
                    0.25 *
                    (sin_2phi * sinLambda_2 - E * sinPhi * cos2phi * sinLambda),
                deltaYPhi =
                    F * (sin2phi * cosLambda_2 + E * sin2lambda_2 * cosPhi),
                denominator =
                    deltaXPhi * deltaYLambda - deltaYPhi * deltaXLambda;
            if (!denominator) {
                break;
            }
            deltaLambda = (fy * deltaXPhi - fx * deltaYPhi) / denominator;
            deltaPhi = (fx * deltaYLambda - fy * deltaXLambda) / denominator;
            lambda -= deltaLambda;
            phi -= deltaPhi;
        } while (
            (Math.abs(deltaLambda) > epsilon || Math.abs(deltaPhi) > epsilon) &&
            --i > 0
        );

        dest[0] = (lambda * 180) / Math.PI;
        dest[1] = (phi * 180) / Math.PI;
        dest[2] = position3d[2];
        return dest;
    };

    /**
     * @function project
     * @memberof AitoffProjection#
     */
    AitoffProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var lambda = (geoPos[0] * Math.PI) / 180; // longitude
        var phi = (geoPos[1] * Math.PI) / 180; // latitude

        var cosPhi = Math.cos(phi);
        var sinciAlpha = _sinci(Math.acos(cosPhi * Math.cos((lambda /= 2))));

        dest[0] = 2 * cosPhi * Math.sin(lambda) * sinciAlpha;
        dest[1] = Math.sin(phi) * sinciAlpha;
        dest[2] = geoPos[2];

        // Triple winkel: mode
        // TODO: inverse
        // dest[0] = (dest[0] + lambda / Math.PI/2) / 2;
        // dest[1] = (dest[1] + phi) / 2;

        return dest;
    };

    /**
     * @function getName
     * @memberof AitoffProjection#
     */
    AitoffProjection.prototype.getName = function() {
        return Constants.PROJECTION.Aitoff;
    };

    /**************************************************************************************************************/

    return AitoffProjection;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Projection/AugustProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * @name AugustProjection
     * @class
     *    The August coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
     * <li>a projection : the August projection.</li>
     * </ul>
     * <img src="../doc/images/august.png" width="200px">
     * @augments AbstractProjection
     * @param {AbstractProjection.configuration} [options] - August projection configuration.
     * @constructor
     * @memberof module:Projection
     */
    var AugustProjection = function(options) {
        AbstractProjection.prototype.constructor.call(
            this,
            [0, 0],
            [-180, -90, 180, 90],
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, AugustProjection);

    /**************************************************************************************************************/

    /**
     * @function unProject
     * @memberof AugustProjection#
     * @throws "must be implemented"
     */
    AugustProjection.prototype.unProject = function(position3d, dest) {
        throw new SyntaxError("must be implemented");
    };

    /**
     * @function project
     * @memberof AugustProjection#
     */
    AugustProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var lambda = (geoPos[0] * Math.PI) / 180; // longitude
        var phi = (geoPos[1] * Math.PI) / 180; // latitude

        var tanPhi = Math.tan(phi / 2),
            k = Math.sqrt(1 - tanPhi * tanPhi),
            c = 1 + k * Math.cos((lambda /= 2)),
            x = (Math.sin(lambda) * k) / c,
            y = tanPhi / c,
            x2 = x * x,
            y2 = y * y;

        dest[0] = (4 / 3) * x * (3 + x2 - 3 * y2);
        dest[1] = (4 / 3) * y * (3 + 3 * x2 - y2);
        dest[2] = geoPos[2];
        return dest;
    };

    /**
     * @function getName
     * @memberof AugustProjection#
     */
    AugustProjection.prototype.getName = function() {
        return Constants.PROJECTION.August;
    };

    /**************************************************************************************************************/

    return AugustProjection;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Projection/MercatorProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * Mercator projection configuration
     * @typedef {AbstractProjection.configuration} AbstractProjection.mercator_configuration
     * @property {float} [lambda0 = 0.0] - the longitude of an arbitrary central meridian usually(but not always) Greenwich, in degrees
     * (default value is 0)
     */

    /**
     * @name MercatorProjection
     * @class
     *    The Mercator coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     * <li>a reference frame : the reference geoide, which is set as parameter of the options object,</li>
     * <li>a projection : the Mercator projection.</li>
     * </ul>
     * The Mercator projection is a cylindrical map projection presented by the Flemish geographer and cartographer
     * Gerardus Mercator in 1569. It became the standard map projection for nautical purposes because of its ability to
     * represent lines of constant course<br/>
     * <img src="../doc/images/mercator.png" width="200px"/>
     * @augments AbstractProjection
     * @param {AbstractProjection.mercator_configuration} [options] - Mercator projection configuration.
     * @see {@link https://en.wikipedia.org/wiki/Mercator_projection}
     * @constructor
     * @memberof module:Projection
     */
    var MercatorProjection = function(options) {
        AbstractProjection.prototype.constructor.call(
            this,
            [0, 0],
            [-180, -80, 180, 84],
            options
        );
        this.lambda0 = options && options.lambda0 ? options.lambda0 : 0.0; // Greenwich (i.e., zero)
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, MercatorProjection);

    /**************************************************************************************************************/

    /**
     *  Hyperbolic sine
     */
    var _sinh = function(x) {
        var expY = Math.exp(x);
        return (expY - 1 / expY) / 2;
    };

    /**
     * @function unProject
     * @memberof MercatorProjection#
     */
    MercatorProjection.prototype.unProject = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        dest[0] = this.lambda0 + (position3d[0] * 180) / Math.PI;
        dest[1] = (Math.atan(_sinh(position3d[1])) * 180) / Math.PI;
        dest[2] = position3d[2];

        if (Math.abs(dest[1]) > 85.05) return null;

        return dest;
    };

    /**
     * @function project
     * @memberof MercatorProjection#
     */
    MercatorProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        // Clamp latitude values, since mercator converges to infinity at poles
        if (geoPos[1] > 85.05) {
            geoPos[1] = 85.05;
        }
        if (geoPos[1] < -85.05) {
            geoPos[1] = -85.05;
        }

        var longInRad = (geoPos[0] * Math.PI) / 180; // longitude
        var latInRad = (geoPos[1] * Math.PI) / 180; // latitude

        var x = longInRad - (this.lambda0 * Math.PI) / 180;
        var y = Math.log(Math.tan(latInRad) + 1 / Math.cos(latInRad));

        dest[0] = x;
        dest[1] = y;
        dest[2] = geoPos[2];
        return dest;
    };

    /**
     * @function getName
     * @memberof MercatorProjection#
     */
    MercatorProjection.prototype.getName = function() {
        return Constants.PROJECTION.Mercator;
    };

    /**************************************************************************************************************/

    return MercatorProjection;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Projection/MollweideProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * @name MollweideProjection
     * @class
     *    The Mollweide coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
     * <li>a projection : the Mollweide projection.</li>
     * </ul>
     * The Mollweide projection is an equal-area, pseudocylindrical map projection generally used for global maps of
     * the world or night sky.<br/>
     * <img src="../doc/images/mollweide.png" width="200px"/>
     * @augments AbstractProjection
     * @param {AbstractProjection.configuration} [options] - No options.
     * @constructor
     * @see {@link https://en.wikipedia.org/wiki/Mollweide_projection}
     * @memberof module:Projection
     */
    var MollweideProjection = function(options) {
        AbstractProjection.prototype.constructor.call(
            this,
            [0, 0],
            [-180, -90, 180, 90],
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, MollweideProjection);

    /**************************************************************************************************************/

    /**
     *  Newton-Raphson method to find auxiliary theta needed for mollweide x/y computation
     *  @see https://en.wikipedia.org/wiki/Mollweide_projection
     */
    function _findTheta(lat) {
        // Avoid divide by zero
        if (Math.abs(lat) === Math.PI / 2) {
            return lat;
        }

        var epsilon = 0.001;
        var thetaN = lat; // n
        var thetaN1; // n+1

        do {
            var twoThetaN = 2 * thetaN;
            thetaN = thetaN1;
            if (!thetaN) {
                thetaN = lat;
            }
            thetaN1 =
                twoThetaN / 2 -
                (twoThetaN + Math.sin(twoThetaN) - Math.PI * Math.sin(lat)) /
                    (2 + 2 * Math.cos(twoThetaN));
        } while (Math.abs(thetaN1 - thetaN) >= epsilon);

        return thetaN1;
    }

    /**
     * @function unProject
     * @memberof MollweideProjection#
     */
    MollweideProjection.prototype.unProject = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var auxTheta = Math.asin(position3d[1] / Math.sqrt(2));
        var phi = Math.asin((2 * auxTheta + Math.sin(2 * auxTheta)) / Math.PI);
        var lambda =
            (Math.PI * position3d[0]) / (2 * Math.sqrt(2) * Math.cos(auxTheta));

        dest[0] = (lambda * 180) / Math.PI;
        dest[1] = (phi * 180) / Math.PI;
        dest[2] = position3d[2];
        return dest;
    };

    /**
     * @function project
     * @memberof MollweideProjection#
     */
    MollweideProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var lambda = (geoPos[0] * Math.PI) / 180; // longitude
        var theta0 = (geoPos[1] * Math.PI) / 180; // latitude
        var auxTheta = _findTheta(theta0);

        // Transfrom to Mollweide coordinate system
        var mollX =
            ((2 * Math.sqrt(2)) / Math.PI) * lambda * Math.cos(auxTheta);
        var mollY = Math.sqrt(2) * Math.sin(auxTheta);

        dest[0] = mollX;
        dest[1] = mollY;
        dest[2] = geoPos[2];
        return dest;
    };

    /**
     * @function getName
     * @memberof MollweideProjection#
     */
    MollweideProjection.prototype.getName = function() {
        return Constants.PROJECTION.Mollweide;
    };

    /**************************************************************************************************************/

    return MollweideProjection;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Projection/PlateProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * @name PlateProjection
     * @class
     *    The Plate coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
     * <li>a projection : the Plate carre projection.</li>
     * </ul>
     * <img src="../doc/images/platecarr.png" width="200px"/>
     * @augments AbstractProjection
     * @param {AbstractProjection.configuration} [options] - No options.
     * @constructor
     * @see {@link https://en.wikipedia.org/wiki/Mollweide_projection}
     * @memberof module:Projection
     */
    var PlateProjection = function(options) {
        AbstractProjection.prototype.constructor.call(
            this,
            [0, 0],
            [-180, -90, 180, 90],
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, PlateProjection);

    /**************************************************************************************************************/

    /**
     * @function unProject
     * @memberof PlateProjection#
     */
    PlateProjection.prototype.unProject = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        dest[0] = (position3d[0] * 180) / Math.PI;
        dest[1] = (position3d[1] * 180) / Math.PI;
        dest[2] = position3d[2];

        return dest;
    };

    /**
     * @function project
     * @memberof PlateProjection#
     */
    PlateProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        dest[0] = (geoPos[0] * Math.PI) / 180;
        dest[1] = (geoPos[1] * Math.PI) / 180;
        dest[2] = geoPos[2];
        return dest;
    };

    /**
     * @function getName
     * @memberof PlateProjection#
     */
    PlateProjection.prototype.getName = function() {
        return Constants.PROJECTION.Plate;
    };

    /**************************************************************************************************************/

    return PlateProjection;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/Projection/AzimuthProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * Azimuthal projection configuration
     * @typedef {AbstractProjection.configuration} AbstractProjection.azimuth_configuration
     * @property {string} [pole = "north"] - Projection center. It can be "north" or "south"
     */

    /**
     * @name AzimuthProjection
     * @class
     *    The Azimuth coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
     * <li>a projection : the Azimuth projection.</li>
     * </ul>
     * <img src="../doc/images/azimuth.png" width="200px"/>
     *
     * @see {@link https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection}
     * @augments AbstractProjection
     * @param {AbstractProjection.azimuth_configuration} [options] - Azimuthal projection configuration.
     * @constructor
     * @memberof module:Projection
     */
    var AzimuthProjection = function(options) {
        this.pole = (options && options.pole) || "north";
        var geoBound;
        var projectionCenter;
        if (this.pole === "south") {
            geoBound = [-180, -90, 180, 0];
            projectionCenter = [0, -90];
        } else {
            geoBound = [-180, 0, 180, 90];
            projectionCenter = [0, 90];
            this.pole = "north";
        }
        AbstractProjection.prototype.constructor.call(
            this,
            projectionCenter,
            geoBound,
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, AzimuthProjection);

    /**************************************************************************************************************/

    /**
     * @function unProject
     * @memberof AzimuthProjection#
     */
    AzimuthProjection.prototype.unProject = function(position3d, dest) {
        var p = Math.sqrt(
            position3d[0] * position3d[0] + position3d[1] * position3d[1]
        );
        var o = Math.atan2(position3d[0], -position3d[1]);

        p = (p * 180) / Math.PI;
        o = (o * 180) / Math.PI;

        o *= this.pole === "south" ? -1 : 1;

        if (p > 90) return null;

        if (!dest) {
            dest = new Array(3);
        }
        dest[0] = o;
        dest[1] = this.pole === "south" ? p - 90 : 90 - p;
        dest[2] = position3d[2];
        return dest;
    };

    /**
     * @function project
     * @memberof AzimuthProjection#
     */
    AzimuthProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        var p = this.pole === "south" ? 90 + geoPos[1] : 90 - geoPos[1];
        p = (p * Math.PI) / 180;

        var o = (geoPos[0] * Math.PI) / 180;
        o *= this.pole === "south" ? -1 : 1;
        dest[0] = p * Math.sin(o);
        dest[1] = -p * Math.cos(o);
        dest[2] = geoPos[2];
        return dest;
    };

    /**
     * @function getName
     * @memberof AzimuthProjection#
     */
    AzimuthProjection.prototype.getName = function() {
        return Constants.PROJECTION.Azimuth;
    };

    /**************************************************************************************************************/

    return AzimuthProjection;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name ProjectionFactory
 * @class
 * Factory to create a projection
 * @memberof module:Projection
 */
define('gw/Projection/ProjectionFactory',[
    "../Utils/Constants",
    "./AitoffProjection",
    "./AugustProjection",
    "./MercatorProjection",
    "./MollweideProjection",
    "./PlateProjection",
    "./AzimuthProjection"
], function(
    Constants,
    AitoffProjection,
    AugustProjection,
    MercatorProjection,
    MollweideProjection,
    PlateProjection,
    AzimuthProjection
) {
    /**
     * Creates a projection based on the name of the projection and its options.
     * @param {PROJECTION} projectionName - Name of the projection
     * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - Options for the projection
     * @returns {Projection} projection
     * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
     * @private
     */
    function _createProjection(projectionName, options) {
        var cs;
        switch (projectionName) {
        case Constants.PROJECTION.Aitoff:
            cs = new AitoffProjection(options);
            break;
        case Constants.PROJECTION.August:
            cs = new AugustProjection(options);
            break;
        case Constants.PROJECTION.Azimuth:
            cs = new AzimuthProjection(options);
            break;
        case Constants.PROJECTION.Mercator:
            cs = new MercatorProjection(options);
            break;
        case Constants.PROJECTION.Mollweide:
            cs = new MollweideProjection(options);
            break;
        case Constants.PROJECTION.Plate:
            cs = new PlateProjection(options);
            break;
        default:
            throw new RangeError(
                "Unable to create the projection " + options.projectionName,
                "ProjectionFactory.js"
            );
        }
        return cs;
    }

    return {
        /**
         * Create a projection
         * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - Options.
         * @return {Projection}
         * @throws {ReferenceError} Will throw when options.projectionName is not defined
         * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
         * @alias module:Projection.ProjectionFactory.create
         */
        create: function(options) {
            var cs;

            if (options && options.projectionName) {
                cs = _createProjection(options.projectionName, options);
            } else {
                throw new ReferenceError(
                    "Unable to get options.projectionName",
                    "ProjectionFactory.js"
                );
            }

            return cs;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Crs/ProjectedCrs',[
    "./AbstractCrs",
    "../Utils/Utils",
    "../Projection/ProjectionFactory",
    "../Renderer/glMatrix"
], function(AbstractCrs, Utils, ProjectionFactory) {
    /**
     * ProjectedCrs configuration
     * @typedef {AbstractCrs.geoide_configuration} AbstractCrs.configuration
     * @property {CRS} geoideName - name of the coordinate reference system
     * @property {CONTEXT} type - Type of the CRS
     * @property {GeoBound} geoBound - Geographical bounding box
     */

    /**
     * @name ProjectedCrs
     * @class
     * A coordinate reference system projected on a 2D map.
     * @augments AbstractCrs
     * @param {Crs} cs - coordinate reference system
     * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - projection configuration
     * @constructor
     * @memberof module:Crs
     * @throws {ReferenceError} Will throw when options.projectionName is not defined
     * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
     */
    var ProjectedCrs = function(cs, options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: cs.getGeoideName(),
            radius: cs.getGeoide().getRadius(),
            realPlanetRadius: cs.getGeoide().getRealPlanetRadius(),
            type: cs.getType(),
            geoBound: cs.getGeoBound()
        });
        this.cs = cs;
        this.projection = ProjectionFactory.create(options);
        this.geoBound.setWest(this.projection.getGeoBound().getWest());
        this.geoBound.setSouth(this.projection.getGeoBound().getSouth());
        this.geoBound.setEast(this.projection.getGeoBound().getEast());
        this.geoBound.setNorth(this.projection.getGeoBound().getNorth());
        this.flat = true;
    };
    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, ProjectedCrs);

    /**************************************************************************************************************/

    /**
     * Formats the coordinates
     * @function formatCoordinates
     * @memberof ProjectedCrs
     * @param geo the spatial position in degrees
     * @return {string[]} the format coordinates of the geoide given in parameter
     */
    ProjectedCrs.prototype.formatCoordinates = function(geo) {
        return this.cs.formatCoordinates(geo);
    };

    /**
     * @function getLongitudeLabel
     * @memberof ProjectedCrs#
     */
    ProjectedCrs.prototype.getLongitudeLabel = function() {
        return this.cs.getLongitudeLabel();
    };

    /**
     * @function getLatitudeLabel
     * @memberof ProjectedCrs#
     */
    ProjectedCrs.prototype.getLatitudeLabel = function() {
        return this.cs.getLatitudeLabel();
    };

    /**
     * Returns the physical position in degrees.
     * @function getWorldFrom3D
     * @memberof ProjectedCrs
     * @param position3d the position in 3D
     * @param {float[]} dest the physical position
     * @return {float[]} the physical position
     */
    ProjectedCrs.prototype.getWorldFrom3D = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        this.projection.unProject(position3d, dest);
        this.cs._setupPosAfterTrans(dest);
        dest[2] = dest[2] / this.geoide.getHeightScale();
        return dest;
    };

    /**
     * Returns the 3D position from physical position
     * @param posWorld physical position
     * @param {float[]}dest the 3D position
     * @return {float[]} the 3D position
     */
    ProjectedCrs.prototype.get3DFromWorld = function(posWorld, dest) {
        if (!dest) {
            dest = vec3.create();
        }
        var pos = posWorld.slice(0);
        this.cs._setupPosBeforeTrans(pos);
        this.projection.project(pos, dest);
        dest[2] = dest[2] ? dest[2] * this.geoide.getHeightScale() : 0.0;
        return dest;
    };

    /**
     * Returns the local transformation
     * @function getLocalTransform
     * @memberof ProjectedCrs#
     * @param {Array} geo
     * @param {Array} dest
     * @return {Array} dest Matrix as 16 values
     */
    ProjectedCrs.prototype.getLocalTransform = function(geo, dest) {
        if (!dest) {
            dest = mat4.create();
        }
        mat4.identity(dest);
        return dest;
    };

    /**************************************************************************************************************/

    /**
     * Returns the LHV transformation
     * @function getLHVTransform
     * @memberof ProjectedCrs
     * @param {Array} geo
     * @param {Array} dest
     * @return {Array} dest Matrix as 16 values
     */
    ProjectedCrs.prototype.getLHVTransform = function(geo, dest) {
        if (!dest) {
            dest = mat4.create();
        }
        var pt = this.projection.project(geo);
        mat4.identity(dest);
        dest[12] = pt[0];
        dest[13] = pt[1];
        dest[14] = pt[2] ? pt[2] * this.geoide.getHeightScale() : 0.0;
        dest[15] = 1.0;
        return dest;
    };

    /**
     * Returns the projection.
     * @function getProjection
     * @memberof ProjectedCrs
     * @returns {AbstractProjection} the used projection
     */
    ProjectedCrs.prototype.getProjection = function() {
        return this.projection;
    };

    /**
     * @function getName
     * @memberof ProjectedCrs#
     */
    ProjectedCrs.prototype.getName = function() {
        return this.cs.getName();
    };

    /**
     * @function getDescription
     * @memberof ProjectedCrs#
     */
    ProjectedCrs.prototype.getDescription = function() {
        return this.cs.getDescription();
    };

    /**
     * @function isProjected
     * @memberof ProjectedCrs#
     * @return {boolean} true.
     */
    ProjectedCrs.prototype.isProjected = function() {
        return true;
    };

    return ProjectedCrs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Crs/HorizontalLocalCrs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "System in which an local object's position is described in the observer's local horizon." +
        "It is expressed in terms of altitude (or elevation) angle and azimuth. The elevation is measured for -90 " +
        "(nadir) to 90 (zenith) but azimuth is measured in degrees eastward along the horizon from the North";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "Az";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "Alt";

    /**
     * @name HorizontalLocalCrs
     * @class
     * System in which an local object's position is described in the observer's local horizon. It is expressed in
     * terms of altitude (or elevation) angle and azimuth. The elevation is measured for -90 (nadir) to 90 (zenith)
     * but azimuth is measured in degrees eastward along the horizon from the North.
     * <br/>
     * HorizontalLocalCrs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = HorizontalLocal</li>
     *     <li>radius = 1.0</li>
     *     <li>realPlanetRadius = 1</li>
     *     <li>type = Planet</li>
     *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - No option to give.
     * @constructor
     * @memberof module:Crs
     */
    var HorizontalLocalCrs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.HorizontalLocal,
            radius: 1.0,
            realPlanetRadius: 1,
            type: Constants.CONTEXT.Ground,
            geoBound: new GeoBound(0, -90, 360, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, HorizontalLocalCrs);

    /**************************************************************************************************************/

    /**
     * Formats coordinates as (x.xxx N, y.yyy E).
     * @function formatCoordinates
     * @memberof HorizontalLocalCrs
     * @param {float[]} geo the spatial position in degree
     * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
     */
    HorizontalLocalCrs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        var azimuth = Numeric.roundNumber(geo[0], 3);
        var altitude = Numeric.roundNumber(geo[1], 3);
        astro[0] = this.getLongitudeLabel() + " = " + azimuth;
        astro[0] += "&deg;";
        astro[1] = this.getLatitudeLabel() + " = " + altitude;
        astro[1] += "&deg;";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof HorizontalLocalCrs#
     */
    HorizontalLocalCrs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof HorizontalLocalCrs#
     */
    HorizontalLocalCrs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * Do nothing
     * @function _setupPosAfterTrans
     * @memberof HorizontalLocalCrs
     * @private
     */
    HorizontalLocalCrs.prototype._setupPosAfterTrans = function(posWorld) {
        if (posWorld[0] < 0) {
            posWorld[0] = -1 * posWorld[0];
        } else {
            posWorld[0] = 360 - posWorld[0];
        }
    };

    /**
     * Do nothing
     * @function _setupPosBeforeTrans
     * @memberof HorizontalLocalCrs
     * @private
     */
    HorizontalLocalCrs.prototype._setupPosBeforeTrans = function(posWorld) {
        if (posWorld[0] < 180) {
            posWorld[0] = -1 * posWorld[0];
        } else {
            posWorld[0] = 360 - posWorld[0];
        }
    };

    /**
     * @function getName
     * @memberof HorizontalLocalCrs#
     */
    HorizontalLocalCrs.prototype.getName = function() {
        return Constants.CRS.HorizontalLocal;
    };

    /**
     * @function getDescription
     * @memberof HorizontalLocalCrs#
     */
    HorizontalLocalCrs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return HorizontalLocalCrs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Crs/SunCrs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "Sun coordinate Reference System is a coordinate system using the Sun sphere and in " +
        "which the heliocentric longitude increases to the east. The heliocentric latitude is measured in degrees " +
        "north or south of the Sun equator.";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "Long";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "Lat";

    /**
     * @name SunCrs
     * @class
     * Sun  coordinate Reference System is a coordinate system using the Sun sphere and in which the
     * heliocentric longitude increases to the east. The heliocentric latitude is measured in degrees north or south
     * of the Sun equator.
     * <br/>
     * SunCrs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = IAU:Sun</li>
     *     <li>radius = 1.0</li>
     *     <li>realPlanetRadius = 696342000</li>
     *     <li>type = Planet</li>
     *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - No option to give.
     * @constructor
     * @memberof module:Crs
     */
    var SunCrs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.Sun,
            radius: 1.0,
            realPlanetRadius: 696342000,
            type: Constants.CONTEXT.Planet,
            geoBound: new GeoBound(-180, -90, 180, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, SunCrs);

    /**************************************************************************************************************/

    /**
     * Formats coordinates as (x.xxx N, y.yyy E).
     * @function formatCoordinates
     * @memberof SunCrs
     * @param {float[]} geo the spatial position in degree
     * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
     */
    SunCrs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        var longitude = Numeric.roundNumber(geo[0], 3);
        var latitude = Numeric.roundNumber(geo[1], 3);
        astro[0] = this.getLatitudeLabel() + " = ";
        astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
        astro[1] = this.getLongitudeLabel() + " = ";
        astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof SunCrs#
     */
    SunCrs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof SunCrs#
     */
    SunCrs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * Do nothing
     * @function _setupPosAfterTrans
     * @memberof SunCrs#
     * @private
     */
    SunCrs.prototype._setupPosAfterTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * Do nothing
     * @function _setupPosBeforeTrans
     * @memberof SunCrs#
     * @private
     */
    SunCrs.prototype._setupPosBeforeTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * @function getName
     * @memberof SunCrs#
     */
    SunCrs.prototype.getName = function() {
        return Constants.CRS.Sun;
    };

    /**
     * @function getDescription
     * @memberof SunCrs#
     */
    SunCrs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return SunCrs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name CoordinateSystemFactory
 * @class
 * Factory to create a coordinate reference system
 * @memberof module:Crs
 */
define('gw/Crs/CoordinateSystemFactory',[
    "../Utils/Constants",
    "./WGS84Crs",
    "./Mars2000Crs",
    "./Moon2000Crs",
    "./EquatorialCrs",
    "./GalacticCrs",
    "./ProjectedCrs",
    "./HorizontalLocalCrs",
    "./SunCrs"
], function(
    Constants,
    WGS84Crs,
    Mars2000Crs,
    Moon2000Crs,
    EquatorialCrs,
    GalacticCrs,
    ProjectedCrs,
    HorizontalLocalCrs,
    SunCrs
) {
    /**
     * Creates a coordinate reference system based on its geoide name and its options.
     * @param {CRS} geoideName
     * @param {AbstractCrs.crsFactory} options - options to create a coordinate reference system
     * @returns {Crs} the created coordinate reference system
     * @throws {RangeError} Will throw an error when geoideName  is not part of {@link CRS}
     * @private
     */
    function _createCrs(geoideName, options) {
        var cs;
        switch (geoideName) {
        case Constants.CRS.Equatorial:
            cs = new EquatorialCrs(options);
            break;
        case Constants.CRS.Galactic:
            cs = new GalacticCrs(options);
            break;
            // For Earth
        case Constants.CRS.WGS84:
            cs = new WGS84Crs(options);
            break;
            // For Mars
        case Constants.CRS.Mars_2000_old:
        case Constants.CRS.Mars_2000:
            cs = new Mars2000Crs(options);
            break;
            // For Moon
        case Constants.CRS.Moon_2000_old:
        case Constants.CRS.Moon_2000:
            cs = new Moon2000Crs(options);
            break;
            // For Ground
        case Constants.CRS.HorizontalLocal:
            cs = new HorizontalLocalCrs(options);
            break;
            // For Sun
        case Constants.CRS.Sun:
            cs = new SunCrs(options);
            break;
            // Unknown geoide name
        default:
            throw new RangeError(
                "Datum " + geoideName + " not implemented",
                "CoordinateSystemFactory.js"
            );
        }
        return cs;
    }

    return {
        /**
         * Data model to create a coordinate reference system through the factory
         * @typedef {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} AbstractCrs.crsFactory
         * @property {CRS} options.geoideName - name of the geoide
         */
        /**
         * Factory for CRS.
         * @param {AbstractCrs.crsFactory} options - Options to create a coordinate reference system
         * @return {Crs} Object to handle CRS
         * @alias module:Crs.CoordinateSystemFactory.create
         * @throws {ReferenceError} Will throw an error when options.geoideName is not defined
         * @throws {RangeError} Will throw an error when options.geoideName  is not part of {@link CRS}
         * @throws {RangeError} Will throw an error when options.projectionName is not part of {@link PROJECTION}
         */
        create: function(options) {
            var cs;
            if (options && options.geoideName) {
                cs = _createCrs(options.geoideName, options);
            } else {
                throw new ReferenceError(
                    "geoideName not defined in " + JSON.stringify(options),
                    "CoordinateSystemFactory.js"
                );
            }

            if (options && options.projectionName) {
                cs = new ProjectedCrs(cs, options);
            }
            return cs;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/Layer/HipsMetadata',["jquery", "../Utils/Constants", "../Gui/dialog/ErrorDialog", "../Utils/Proxy"], function(
    $,
    Constants,
    ErrorDialog,
    Proxy
) {
    /**
     * @namespace
     * GENERAL_WAVELENGTH
     * @property {string} Radio - Radio
     * @property {string} Millimeter - Millimeter
     * @property {string} Infrared - Infrared
     * @property {string} Optical - Optical
     * @property {string} UV - UV
     * @property {string} EUV - EUV
     * @property {string} X-ray - X-ray
     * @property {string} Gamma-ray - Gamma-ray
     */
    var GENERAL_WAVELENGTH = {
        Radio: "Radio",
        Millimeter: "Millimeter",
        Infrared: "Infrared",
        Optical: "Optical",
        UV: "UV",
        EUV: "EUV",
        "X-ray": "X-ray",
        "Gamma-ray": "Gamma-ray"
    };

    /**
     * @namespace
     * HIPS_FRAME
     * @property {string} equatorial - equatorial
     * @property {string} galactic - galactic
     * @property {string} ecliptic - ecliptic
     * @property {string} horizontalLocal - horizontalLocal
     */
    var HIPS_FRAME = {
        equatorial: Constants.CRS.Equatorial,
        galactic: Constants.CRS.Galactic,
        ecliptic: "ecliptic",
        horizontalLocal: Constants.CRS.HorizontalLocal
    };

    /**
     * @namespace
     * HIPS_TILE_FORMAT
     * @property {string} jpeg - jpeg
     * @property {string} png - png
     * @property {string} fits - fits
     * @property {string} tsv - tsv
     */
    var HIPS_TILE_FORMAT = {
        jpeg: "jpeg",
        png: "png",
        fits: "fits",
        tsv: "tsv"
    };

    /**
     * @namespace
     * SAMPLING
     * @property {string} none - none
     * @property {string} nearest - nearest
     * @property {string} bilinear - bilinear
     */
    var SAMPLING = {
        none: "non",
        nearest: "nearest",
        bilinear: "bilinear"
    };

    /**
     * @namespace
     * PIXEL_OVERLAY
     * @property {string} add - add
     * @property {string} mean - mean
     * @property {string} first - first
     * @property {string} border_fading - border_fading
     * @property {string} custom - custom
     */
    var PIXEL_OVERLAY = {
        add: "add",
        mean: "mean",
        first: "first",
        border_fading: "border_fading",
        custom: "custom"
    };

    /**
     * @namespace
     * SKY_VAL
     * @property {string} none - none
     * @property {string} hips_estimation - hips_estimation
     * @property {string} fits_keyword - fits_keyword
     */
    var SKY_VAL = {
        none: "none",
        hips_estimation: "hips_estimation",
        fits_keyword: "fits_keyword"
    };

    /**
     * @namespace
     * DATA_PRODUCT_TYPE
     * @property {string} image - image
     * @property {string} cube - cube
     * @property {string} catalog - catalog
     * @property {string} meta - meta
     */
    var DATA_PRODUCT_TYPE = {
        image: "image",
        cube: "cube",
        catalog: "catalog",
        meta: "meta"
    };

    /**
     * @namespace
     * SUB_TYPE_DATA
     * @property {string} color - color
     * @property {string} live - live
     */
    var SUB_TYPE_DATA = {
        color: "color",
        live: "live"
    };

    /**
     * Hips data model
     * Mandatory, description, isMultiple, default value, distinctvalue, isArray
     * @namespace
     * HIPS_METADATA
     * @property {string} creator_did - Unique ID of the HiPS - Format: IVOID - Ex : ivo://CDS/P/2MASS/J
     * @property {string} [publisher_id] - Unique ID of the HiPS publisher  Format: IVOID - Ex : ivo://CDS
     * @property {string} [obs_collection] - Short name of original data set  Format: one word  Ex : 2MASS
     * @property {string} obs_title - Data set title  Format: free text, one line  Ex : HST F110W observations
     * @property {string} [obs_description] - Data set description  Format: free text, longer free text description of the dataset
     * @property {string} [obs_ack] - Acknowledgment mention"
     * @property {string} [prov_progenitor] - Provenance of the original data  Format: free text
     * @property {string} [bib_reference] - Bibliographic reference
     * @property {string} [bib_reference_url] - URL to bibliographic reference
     * @property {string} [obs_copyright] - Copyright mention  Format: free text
     * @property {string} [obs_copyright_url] - URL to a copyright mention
     * @property {GENERAL_WAVELENGTH} [obs_regime] - General wavelength
     * @property {string} [data_ucd] - UCD describing data contents
     * @property {string} hips_version="1.4" - Number of HiPS version  Format: number
     * @property {string} [hips_builder] - Name and version of the tool used for building the HiPS  Format: free text
     * @property {string} [hips_publisher] - Institute or person who built the HiPS  Format: free text  Ex : CDS (T.Boch)
     * @property {string} [hips_creation_date] - HiPS first creation date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ
     * @property {string} hips_release_date - Last HiPS update date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ
     * @property {string} [hips_service_url] - HiPS access url  Format: URL
     * @property {string} hips_status - HiPS status
     * @property {string} [hips_estsize] - HiPS size estimation  Format: positive integer  Unit : KB
     * @property {HIPS_FRAME} hips_frame - Coordinate frame reference
     * @property {int} hips_order - Deepest HiPS order  Format: positive integer
     * @property {int} [hips_tile_width=512] - Tiles width in pixels  Format: positive integer
     * @property {HIPS_TILE_FORMAT} hips_tile_format - List of available tile formats
     * @property {string} [hips_pixel_cut] - Suggested pixel display cut range (physical values)  Format: min max
     * @property {string} [hips_data_range] - Pixel data range taken into account during the HiPS generation (physical values)  Format: min max  Ex : -18.5 510.5
     * @property {SAMPLING} [hips_sampling] - Sampling applied for the HiPS generation
     * @property {PIXEL_OVERLAY} [hips_overlay] - Pixel composition method applied on the image overlay region during HiPS generation
     * @property {SKY_VAL} [hips_skyval] - Sky background subtraction method applied during HiPS generation
     * @property {string} [hips_pixel_bitpix] - Fits tile BITPIX code
     * @property {string} [data_pixel_bitpix] - Original data BITPIX code
     * @property {DATA_PRODUCT_TYPE} dataproduct_type - Type of data
     * @property {SUB_TYPE_DATA} [dataproduct_subtype] - Subtype of data
     * @property {string} [hips_progenitor_url] - URL to an associated progenitor HiPS
     * @property {int} [hips_cat_nrows] -  Number of rows of the HiPS catalog
     * @property {int} [hips_cube_depth] - Number of frames of the HiPS cube
     * @property {int} [hips_cube_firstframe=0] - Initial first index frame to display for a HiPS cube
     * @property {float} [data_cube_crpix3] - Coef for computing physical channel value
     * @property {float} [data_cube_crval3] - Coef for computing physical channel value
     * @property {float} [data_cube_cdelt3] - Coef for computing physical channel value
     * @property {string} [data_cube_bunit3] - Third axis unit
     * @property {float} [hips_initial_ra] - Default RA display position (ICRS frame)  Unit : degrees
     * @property {float} [hips_initial_dec] - Default DEC display position (ICRS frame)  Unit : degrees
     * @property {float} [hips_initial_fov] - Default display size  Unit : degrees
     * @property {float} [hips_pixel_scale] - HiPS pixel angular resolution at the highest order  Unit : degrees
     * @property {float} [s_pixel_scale] - Best pixel angular resolution of the original images  Unit : degrees
     * @property {float} [t_min] - Start time of the observations - Representation: MJD
     * @property {float} [t_max] - Stop time of the observations - Representation: MJD
     * @property {float} [em_min] - Start in spectral coordinates  Unit: meters
     * @property {float} [em_max] - Stop in spectral coordinates  Unit: meters
     * @property {string} [client_category] - / separated keywords suggesting a display hierarchy to the client  Ex : Image/InfraRed
     * @property {string} [client_sort_key] - Sort key suggesting a display order to the client inside a client_category  Sort : alphanumeric
     * @property {string} [addendum_did] - In case of live HiPS, creator_did of the added HiPS
     * @property {float} [moc_sky_fraction] - Fraction of the sky covers by the MOC associated to the HiPS  Format: real between 0 and 1
     */
    var HipsVersion_1_4 = {
        creator_did: [
            "R",
            "Unique ID of the HiPS - Format: IVOID - Ex : ivo://CDS/P/2MASS/J",
            false,
            null,
            null,
            false
        ],
        publisher_id: [
            null,
            "Unique ID of the HiPS publisher  Format: IVOID - Ex : ivo://CDS",
            false,
            null,
            null,
            false
        ],
        obs_collection: [
            null,
            "Short name of original data set  Format: one word  Ex : 2MASS",
            false,
            null,
            null,
            false
        ],
        obs_title: [
            "R",
            "Data set title  Format: free text, one line  Ex : HST F110W observations",
            false,
            null,
            null,
            false
        ],
        obs_description: [
            "S",
            "Data set description  Format: free text, longer free text description of the dataset",
            false,
            null,
            null,
            false
        ],
        obs_ack: [null, "Acknowledgment mention", false, null, null, false],
        prov_progenitor: [
            "S",
            "Provenance of the original data  Format: free text",
            true,
            null,
            null,
            false
        ],
        bib_reference: [
            null,
            "Bibliographic reference",
            true,
            null,
            null,
            false
        ],
        bib_reference_url: [
            null,
            "URL to bibliographic reference",
            true,
            null,
            null,
            false
        ],
        obs_copyright: [
            null,
            "Copyright mention  Format: free text",
            false,
            null,
            null,
            false
        ],
        obs_copyright_url: [
            null,
            "URL to a copyright mention",
            false,
            null,
            null,
            false
        ],
        obs_regime: [
            "S",
            "General wavelength  Format: word",
            true,
            null,
            GENERAL_WAVELENGTH,
            false
        ],
        data_ucd: [
            null,
            "UCD describing data contents",
            true,
            null,
            null,
            false
        ],
        hips_version: [
            "R",
            "Number of HiPS version  Format: number",
            false,
            "1.4",
            null,
            false
        ],
        hips_builder: [
            null,
            "Name and version of the tool used for building the HiPS  Format: free text",
            false,
            null,
            null,
            false
        ],
        hips_publisher: [
            null,
            "Institute or person who built the HiPS  Format: free text  Ex : CDS (T.Boch)",
            false,
            null,
            null,
            false
        ],
        hips_creation_date: [
            "S",
            "HiPS first creation date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ",
            false,
            null,
            null,
            false
        ],
        hips_release_date: [
            "R",
            "Last HiPS update date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ",
            false,
            null,
            null,
            false
        ],
        hips_service_url: [
            null,
            "HiPS access url  Format: URL",
            false,
            null,
            null,
            false
        ],
        hips_status: [
            "R",
            "HiPS status",
            false,
            "public master clonableOnce",
            null,
            true
        ],
        hips_estsize: [
            null,
            "HiPS size estimation  Format: positive integer  Unit : KB",
            false,
            null,
            null,
            false
        ],
        hips_frame: [
            "R",
            "Coordinate frame reference",
            false,
            null,
            HIPS_FRAME,
            false
        ],
        hips_order: [
            "R",
            "Deepest HiPS order  Format: positive integer",
            false,
            null,
            null,
            false
        ],
        hips_tile_width: [
            null,
            "Tiles width in pixels  Format: positive integer",
            false,
            512,
            null,
            false
        ],
        hips_tile_format: [
            "R",
            "List of available tile formats. The first one is the default suggested to the client",
            false,
            null,
            HIPS_TILE_FORMAT,
            true
        ],
        hips_pixel_cut: [
            null,
            "Suggested pixel display cut range (physical values)  Format: min max",
            null,
            null,
            null,
            true
        ],
        hips_data_range: [
            null,
            "Pixel data range taken into account during the HiPS generation (physical values)  Format: min max  Ex : -18.5 510.5",
            false,
            null,
            null,
            true
        ],
        hips_sampling: [
            null,
            "Sampling applied for the HiPS generation",
            false,
            null,
            SAMPLING,
            false
        ],
        hips_overlay: [
            null,
            "Pixel composition method applied on the image overlay region during HiPS generation",
            false,
            null,
            PIXEL_OVERLAY,
            false
        ],
        hips_skyval: [
            null,
            "Sky background subtraction method applied during HiPS generation",
            false,
            null,
            SKY_VAL,
            false
        ],
        hips_pixel_bitpix: [
            null,
            "Fits tile BITPIX code",
            false,
            null,
            null,
            false
        ],
        data_pixel_bitpix: [
            null,
            "Original data BITPIX code",
            false,
            null,
            null
        ],
        dataproduct_type: [
            "R",
            "Type of data",
            false,
            null,
            DATA_PRODUCT_TYPE,
            false
        ],
        dataproduct_subtype: [
            "RD",
            "Subtype of data",
            false,
            null,
            SUB_TYPE_DATA,
            false
        ],
        hips_progenitor_url: [
            null,
            "URL to an associated progenitor HiPS",
            false,
            null,
            null,
            false
        ],
        hips_cat_nrows: [
            "S",
            "Number of rows of the HiPS catalog",
            false,
            null,
            null,
            false
        ],
        hips_cube_depth: [
            "RD",
            "Number of frames of the HiPS cube",
            false,
            null,
            null,
            false
        ],
        hips_cube_firstframe: [
            null,
            "Initial first index frame to display for a HiPS cube",
            false,
            0,
            null,
            false
        ],
        data_cube_crpix3: [
            null,
            "Coef for computing physical channel value (see FITS doc)",
            false,
            null,
            null,
            false
        ],
        data_cube_crval3: [
            null,
            "Coef for computing physical channel value (see FITS doc)",
            false,
            null,
            null,
            false
        ],
        data_cube_cdelt3: [
            null,
            "Coef for computing physical channel value (see FITS doc)",
            false,
            null,
            null,
            false
        ],
        data_cube_bunit3: [
            null,
            "Third axis unit (see FITS doc)",
            false,
            null,
            null,
            false
        ],
        hips_initial_ra: [
            "S",
            "Default RA display position (ICRS frame)  Unit : degrees",
            false,
            null,
            null,
            false
        ],
        hips_initial_dec: [
            "S",
            "Default DEC display position (ICRS frame)  Unit : degrees",
            false,
            null,
            null,
            false
        ],
        hips_initial_fov: [
            "S",
            "Default display size  Unit : degrees",
            false,
            null,
            null,
            false
        ],
        hips_pixel_scale: [
            null,
            "HiPS pixel angular resolution at the highest order  Unit : degrees",
            false,
            null,
            null,
            false
        ],
        s_pixel_scale: [
            null,
            "Best pixel angular resolution of the original images  Unit : degrees",
            false,
            null,
            null,
            false
        ],
        t_min: [
            "S",
            "Start time of the observations - Representation: MJD",
            false,
            null,
            null,
            false
        ],
        t_max: [
            "S",
            "Stop time of the observations - Representation: MJD",
            false,
            null,
            null,
            false
        ],
        em_min: [
            "S",
            "Start in spectral coordinates  Unit: meters",
            false,
            null,
            null,
            false
        ],
        em_max: [
            "S",
            "Stop in spectral coordinates  Unit: meters",
            false,
            null,
            null,
            false
        ],
        client_category: [
            null,
            "/ separated keywords suggesting a display hierarchy to the client  Ex : Image/InfraRed",
            false,
            null,
            null,
            false
        ],
        client_sort_key: [
            null,
            "Sort key suggesting a display order to the client inside a client_category  Sort : alphanumeric",
            false,
            null,
            null,
            false
        ],
        addendum_did: [
            null,
            "In case of live HiPS, creator_did of the added HiPS",
            true,
            null,
            null,
            false
        ],
        moc_sky_fraction: [
            null,
            "Fraction of the sky covers by the MOC associated to the HiPS  Format: real between 0 and 1",
            false,
            null,
            null,
            false
        ]
    };

    /**
     * Checks if the required attribute is stored in hipsMetadata.<br>
     * when the attribute is not stored, then store this information in requiredKeywordNotFound.
     * @param {HIPS_METADATA} hipsMetadata
     * @param {string} mandatory - "R" is a required parameter
     * @param {string} key - attribute to check
     * @param {string} description Key's description
     * @param requiredKeywordNotFound - Array or required information not found
     * @private
     */
    function _checkRequiredParameters(
        hipsMetadata,
        mandatory,
        key,
        description,
        requiredKeywordNotFound
    ) {
        if (mandatory === "R" && !hipsMetadata.hasOwnProperty(key)) {
            //Fix for version=1.2
            if (key === "creator_did" && hipsMetadata.hips_version === "1.2") {
                hipsMetadata.creator_did = hipsMetadata.publisher_did;
                ErrorDialog.open(
                    Constants.LEVEL.WARNING,
                    "Deprecated Hips version <b>1.2</b> for " +
                        hipsMetadata.obs_title,
                    "please update it - <i>use creator_did=publisher_did</i>"
                );
            }
            //Fix for version=1.3
            else if (
                key === "creator_did" &&
                hipsMetadata.hips_version === "1.3"
            ) {
                hipsMetadata.creator_did = hipsMetadata.publisher_did;
                ErrorDialog.open(
                    Constants.LEVEL.WARNING,
                    "Deprecated Hips version <b>1.3</b> for " +
                        hipsMetadata.obs_title,
                    "please update it - <i>use creator_did=publisher_did</i>"
                );
            } else if (
                key === "obs_title" &&
                hipsMetadata.hips_version === "1.3"
            ) {
                hipsMetadata.obs_title = hipsMetadata.obs_collection;
                ErrorDialog.open(
                    Constants.LEVEL.WARNING,
                    "Deprecated Hips version <b>1.3</b> for " +
                        hipsMetadata.obs_title,
                    "please update it - <i>use obs_title=obs_collection</i>"
                );
            }
            //Fox for version 1.4
            else if (
                key === "obs_title" &&
                hipsMetadata.hips_version === "1.4"
            ) {
                hipsMetadata.obs_title = hipsMetadata.obs_collection;
                ErrorDialog.open(
                    Constants.LEVEL.WARNING,
                    "obs_title not found in v1.4 for " + hipsMetadata.obs_title,
                    "use obs_title, please fix it"
                );
            } else if (
                key === "creator_did" &&
                hipsMetadata.hips_version === "1.4"
            ) {
                hipsMetadata.creator_did = hipsMetadata.publisher_did;
                ErrorDialog.open(
                    Constants.LEVEL.WARNING,
                    "creator_did not found in v1.4 for " +
                        hipsMetadata.obs_title,
                    "use creator_did, please fix it"
                );
            }
            /// very old version
            else if (
                key === "hips_version" &&
                !hipsMetadata.hasOwnProperty("hips_version")
            ) {
                hipsMetadata.hips_version = "very old one";
                ErrorDialog.open(
                    Constants.LEVEL.WARNING,
                    "Deprecated Hips version <b>unknown</b> for " +
                        hipsMetadata.obs_title,
                    "please update it - <i>use a version in your metadata</i>"
                );
            } else if (
                key === "creator_did" &&
                !hipsMetadata.hasOwnProperty("hips_version")
            ) {
                hipsMetadata.creator_did = hipsMetadata.publisher_did;
                ErrorDialog.open(
                    Constants.LEVEL.WARNING,
                    "Deprecated Hips version <b>unknown</b> for " +
                        hipsMetadata.obs_title,
                    "please update it - <i>use creator_did = pulisher_did</i>"
                );
            }
            //Error
            else {
                requiredKeywordNotFound.push(
                    key + " (" + description + ") is not present. "
                );
            }
        }
    }

    /**
     *
     * @param {boolean} valueArray - is an Array
     * @param {string} key - attribute
     * @param {HIPS_METADATA} hipsMetadata
     * @private
     */
    function _transformAStringToArray(valueArray, key, hipsMetadata) {
        if (valueArray && hipsMetadata.hasOwnProperty(key)) {
            hipsMetadata[key] = hipsMetadata[key].split(/\s+/);
        }
    }

    /**
     * Checks a value is among an enumerated list
     * @param {string} key - key to test
     * @param {string} description - key's description
     * @param distinctValue - enumeration
     * @param hipsMetadata - hipsMetadata
     * @param valueNotRight - Wrong value
     * @private
     */
    function _checkValueAmongEnumeratedList(
        key,
        valueArray,
        description,
        distinctValue,
        hipsMetadata,
        valueNotRight
    ) {
        if (distinctValue !== null && hipsMetadata.hasOwnProperty(key)) {
            if (valueArray) {
                for (var val in hipsMetadata[key]) {
                    if (hipsMetadata[key].hasOwnProperty(val)) {
                        var format = hipsMetadata[key][val];
                        if (!distinctValue.hasOwnProperty(format)) {
                            valueNotRight.push(
                                "The value \"" +
                                    hipsMetadata[key] +
                                    "\" of " +
                                    key +
                                    " (" +
                                    description +
                                    ") is not correct. "
                            );
                            break;
                        }
                    }
                }
            } else {
                if (!distinctValue.hasOwnProperty(hipsMetadata[key])) {
                    valueNotRight.push(
                        "The value \"" +
                            hipsMetadata[key] +
                            "\" of " +
                            key +
                            " (" +
                            description +
                            ") is not correct. "
                    );
                }
            }
        }
    }

    /**
     * fills hipsMetadata with the default value when the key is not present
     * @param {string} key - key
     * @param {string} defaultValue - default value
     * @param {HIPS_METADATA} hipsMetadata
     * @private
     */
    function _fillWithDefaultValue(key, defaultValue, hipsMetadata) {
        if (defaultValue !== null && !hipsMetadata.hasOwnProperty(key)) {
            hipsMetadata[key] = defaultValue;
        }
    }

    /**
     * Validates and fixes metadata
     * @param {HIPS_METADATA} hipsMetadata
     * @throws RangeError - "unvalid hips metadata"
     */
    function _validateAndFixHips(hipsMetadata) {
        var requiredKeywordNotFound = [];
        var valueNotRight = [];
        var values,
            mandatory,
            description,
            isMutiple,
            defaultValue,
            distinctValue,
            valueArray;
        for (var key in HipsVersion_1_4) {
            if (HipsVersion_1_4.hasOwnProperty(key)) {
                values = HipsVersion_1_4[key];
                mandatory = values[0];
                description = values[1];
                defaultValue = values[3];
                distinctValue = values[4];
                valueArray = values[5];

                // checking the required parameter is here
                _checkRequiredParameters.call(
                    this,
                    hipsMetadata,
                    mandatory,
                    key,
                    description,
                    requiredKeywordNotFound
                );

                // Transforms a key's value into an array when it is necessary and store the result in hipsMetadata
                _transformAStringToArray.call(
                    this,
                    valueArray,
                    key,
                    hipsMetadata
                );

                // checking the value of the parameter among a list of values
                //_checkValueAmongEnumeratedList.call(this, key, valueArray, description, distinctValue, hipsMetadata, valueNotRight);

                // checking the key is here when a default value exists
                _fillWithDefaultValue.call(
                    this,
                    key,
                    defaultValue,
                    hipsMetadata
                );
            }
        }
        if (requiredKeywordNotFound.length > 0 || valueNotRight.length > 0) {
            var name = hipsMetadata.obs_title
                ? hipsMetadata.obs_title
                : hipsMetadata.obs_collection;
            var url = hipsMetadata.hips_service_url
                ? hipsMetadata.hips_service_url
                : this.baseUrl;
            throw new RangeError(
                "unvalid hips metadata for " +
                    name +
                    " (" +
                    url +
                    "): \n" +
                    requiredKeywordNotFound.toString() +
                    "\n" +
                    valueNotRight.toString(),
                "HipsMetadata.js"
            );
        }
    }

    /**
     * Loads Hips properties
     * @param baseUrl
     * @throws ReferenceError - Unable to load the Hips
     * @return {*}
     */
    function _loadHipsProperties(baseUrl) {
        var url = baseUrl + "/properties";
        var properties = $.ajax({
            type: "GET",
            datatype : "text",
            url: Proxy.proxify(baseUrl + "/properties"),
            async: false,
            beforeSend:function(xhr) {
                xhr.setRequestHeader("Accept", "text/plain");
            }
        }).responseText;
        if (typeof properties === "undefined") {
            throw new ReferenceError(
                "Unable to load the Hips at " + baseUrl,
                "HipsMetadata.js"
            );
        }
        var hipsProperties = _parseProperties.call(this, properties);
        _validateAndFixHips.call(this, hipsProperties);
        return hipsProperties;
    }

    /**
     * Parses properties
     * @param propertiestext
     * @return {{}}
     */
    function _parseProperties(propertiestext) {
        var propertyMap = {};
        var lines = propertiestext.split(/\r?\n/);
        var currentLine = "";
        $.each(lines, function(i, value) {
            //check if it is a comment line
            if (!/^\s*(#|!|$)/.test(value)) {
                // line is whitespace or first non-whitespace character is '#' or '!'
                value = value.replace(/^\s*/, ""); // remove space at start of line
                currentLine += value;
                if (/(\\\\)*\\$/.test(currentLine)) {
                    // line ends with an odd number of '\' (backslash)
                    //line ends with continuation character, remember it and don't process further
                    currentLine = currentLine.replace(/\\$/, "");
                } else {
                    /^\s*((?:[^\s:=\\]|\\.)+)\s*[:=\s]\s*(.*)$/.test(
                        currentLine
                    ); // sub-matches pick out key and value
                    var nkey = RegExp.$1;
                    var nvalue = RegExp.$2;
                    if (propertyMap.hasOwnProperty(nkey)) {
                        propertyMap[nkey] = propertyMap[nkey].isPrototypeOf(
                            Array
                        )
                            ? propertyMap[nkey].push(nvalue)
                            : [propertyMap[nkey], nvalue];
                    } else {
                        propertyMap[nkey] = nvalue;
                    }

                    currentLine = "";
                }
            }
        });
        return propertyMap;
    }

    /**
     * @name HipsMetadata
     * @class
     * Creates the Hips data model. When baseUrl is an URL, then the Hips properties is loaded by requesting
     * the properties file.
     * When the baseURl is the Hips description coming from registry, then the description is validated and fixed if needed.
     * @param baseUrl
     * @constructor
     */
    var HipsMetadata = function(baseUrl) {
        if (baseUrl == null) {
            // nothing to do
        } else if (typeof baseUrl === "string") {
            this.baseUrl = baseUrl;
            this.hipsMetadata = _loadHipsProperties.call(this, baseUrl);
        } else {
            this.hipsMetadata = baseUrl;
            // In hips registry, each record must provide at least creator_did, hips_release_date, hips_service_url, hips_status
            try {
                _validateAndFixHips.call(this, this.hipsMetadata);
            } catch (e) {
                this.baseUrl = this.hipsMetadata.hips_service_url;
                this.hipsMetadata = _loadHipsProperties.call(
                    this,
                    this.baseUrl
                );
            }
        }
    };

    /**
     * @name setMetadata
     * @param metadata
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.setMetadata = function(metadata) {
        this.hipsMetadata = metadata;
        this.baseUrl = metadata.hips_service_url;
    };

    /**
     * Supported {@link GENERAL_WAVELENGTH wavelength}
     * @name GeneralWavelength
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.GeneralWavelength = GENERAL_WAVELENGTH;

    /**
     * Supported {@link HIPS_FRAME Hips frame}
     * @name HipsFrame
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.HipsFrame = HIPS_FRAME;

    /**
     * Supported {@link HIPS_TILE_FORMAT Hips tile format}
     * @name HipsTileFormat
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.HipsTileFormat = HIPS_TILE_FORMAT;

    /**
     * Supported {@link SAMPLING Sampling}
     * @name Sampling
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.Sampling = SAMPLING;

    /**
     * Supported {@link PIXEL_OVERLAY pixel overlay}
     * @name PixelOverlay
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.PixelOverlay = PIXEL_OVERLAY;

    /**
     * Supported {@link SKY_VAL SkyVal}
     * @name SkyVal
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.SkyVal = SKY_VAL;

    /**
     * Supported {@link DATA_PRODUCT_TYPE DataProductType}
     * @name DataProductType
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.DataProductType = DATA_PRODUCT_TYPE;

    /**
     * Supported {@link SUB_TYPE_DATA SubTypeData}
     * @name SubTypeData
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.SubTypeData = SUB_TYPE_DATA;

    /**
     * Returns the Hips metadata.
     * @function getHipsMetadata
     * @returns {HIPS_METADATA}
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.getHipsMetadata = function() {
        return this.hipsMetadata;
    };

    /**
     * Returns base URL
     * @function getBaseUrl
     * @returns {string} the URL of the Hips
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.getBaseUrl = function() {
        return this.baseUrl;
    };

    return HipsMetadata;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Layer/AbstractHipsLayer',[
    "underscore-min",
    "./AbstractRasterLayer",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Tiling/HEALPixTiling",
    "../Crs/CoordinateSystemFactory",
    "./HipsMetadata"
], function(
    _,
    AbstractRasterLayer,
    Utils,
    Constants,
    HEALPixTiling,
    CoordinateSystemFactory,
    HipsMetadata
) {
    /**
     * AbstractHipsLayer configuration
     * @typedef {AbstractLayer.configuration} AbstractHipsLayer.configuration
     * @property {Crs} [coordinateSystem = CoordinateSystemFactory.create({geoideName: Constants.MappingCrsHips2Mizar[this.hipsMetadata.hips_frame]})] - Coordinate reference system
     * @property {int} [tilePixelSize = hipsMetadata['hips_tile_width'] - Tiles width in pixels
     * @property {int} [baseLevel = 2] - min HiPS order
     * @property {HEALPixTiling} [tiling = new HEALPixTiling(options.baseLevel, {coordinateSystem: options.coordinateSystem})] - Tiling
     * @property {int} [numberOfLevels = hipsMetadata['hips_order']] - Deepest order min
     * @property {string} [name = hipsMetadata['obs_title']] - Data set title
     * @property {string} [attribution = <a href=\"" + this.hipsMetadata['obs_copyright_url'] + "\" target=\"_blank\">" + this.hipsMetadata['obs_copyright'] + "</a>"] - URL to a copyright mention
     * @property {string} [ack = hipsMetadata['obs_ack']] - Acknowledgment mention
     * @property {string} [icon = ""] - icon used as metadata representation on the map
     * @property {string} [description = hipsMetadata['obs_description']] - Data set description
     * @property {boolean} [visible = false] visibility by default on the map
     * @property {Object} properties - other metadata
     * @property {float} [properties.initialRa = undefined] - Initial RA
     * @property {float} [properties.initialDec = undefined] - Initial DEC
     * @property {float} [properties.initialFov = undefined] - Initial field of view
     * @property {float} [properties.mocCoverage = undefined] - Sky fraction coverage
     * @property {boolean} [pickable = false] - Pickable layer
     * @property {Array} [availableServices = {}] - List of services related to the layer
     * @property {Array} [format = hipsMetadata['hips_tile_format']] - List of available tile formats
     * @property {string} [baseUrl =  hipsMetadata['hips_service_url']] - Endpoint service
     * @property {string} [category = Image] - Default category
     * @property {boolean} background - Tell if the layer is set as background
     */

    /**
     * @name AbstractHipsLayer
     * @class
     * Abstract class for HIPS
     * @augments AbstractRasterLayer
     * @param {HipsMetadata} hipsMetadata
     * @param {AbstractHipsLayer.configuration} options - AbstractHipsLayer configuration
     * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
     * @throws ReferenceError - Some required parameters are missing
     * @constructor
     */
    var AbstractHipsLayer = function(hipsMetadata, options) {
        _checkAndSetDefaultOptions.call(this, options);
        this.hipsMetadata = _createMetadata.call(
            this,
            hipsMetadata,
            options.baseUrl
        );
        _overloadHipsMetataByConfiguration.call(
            this,
            options,
            this.hipsMetadata
        );

        options.tiling = new HEALPixTiling(options.baseLevel || 2, {
            coordinateSystem: options.coordinateSystem
        });
        options.icon = options.hasOwnProperty("icon")
            ? options.icon
            : options.mizarBaseUrl
                ? options.mizarBaseUrl + "css/images/star.png"
                : "";
        options.visible = options.hasOwnProperty("visible")
            ? options.visible
            : false;
        options.properties = options.hasOwnProperty("properties")
            ? options.properties
            : {};
        options.pickable = options.hasOwnProperty("pickable")
            ? options.pickable
            : false;
        options.services = options.hasOwnProperty("services")
            ? options.services
            : {};

        options.category = options.hasOwnProperty("category")
            ? options.category
            : "Image"; //this.hipsMetadata.client_category;

        if (this.hipsMetadata.hasOwnProperty("moc_access_url")) {
            options.services.Moc = {
                baseUrl: this.hipsMetadata.moc_access_url,
                skyFraction: this.hipsMetadata.moc_sky_fraction
            };
        }

        //Hack : set Galactic layer as background because only background owns two grids (equetorial and galactic)
        if (
            options.coordinateSystem.getGeoideName() === Constants.CRS.Galactic
        ) {
            options.background = true;
        }

        AbstractRasterLayer.prototype.constructor.call(
            this,
            Constants.LAYER.Hips,
            options
        );

        this.fitsSupported = _.contains(
            this.hipsMetadata.hips_tile_format,
            "fits"
        );
    };

    /**
     * Check options.
     * @param options
     * @throws ReferenceError - Some required parameters are missing
     * @private
     */
    function _checkAndSetDefaultOptions(options) {
        if (!options) {
            throw new ReferenceError(
                "Some required parameters are missing",
                "AbstractHipsLayer.js"
            );
        } else {
            options.category = options.category || "Image";
            options.pickable = options.pickable || false;
        }
    }

    /**
     * Creates metadata.
     * @param hipsMetadata
     * @param baseUrl
     * @returns {*}
     * @private
     */
    function _createMetadata(hipsMetadata, baseUrl) {
        var metadata = hipsMetadata;
        if (typeof metadata === "undefined") {
            var hipsProperties = new HipsMetadata(baseUrl);
            metadata = hipsProperties.getHipsMetadata();
        }
        return metadata;
    }

    /**
     *
     * @param options
     * @param hipsMetadata
     * @private
     */
    function _overloadHipsMetataByConfiguration(options, hipsMetadata) {
        options.coordinateSystem = options.hasOwnProperty("coordinateSystem")
            ? CoordinateSystemFactory.create(options.coordinateSystem)
            : CoordinateSystemFactory.create({
                geoideName:
                      Constants.MappingCrsHips2Mizar[hipsMetadata.hips_frame]
            });
        options.tilePixelSize = options.hasOwnProperty("tilePixelSize")
            ? options.tilePixelSize
            : hipsMetadata.hips_tile_width;
        options.baseLevel = options.hasOwnProperty("baseLevel")
            ? options.baseLevel
            : hipsMetadata.hasOwnProperty("hips_order_min")
                ? hipsMetadata.hips_order_min
                : 2;
        options.numberOfLevels = options.hasOwnProperty("numberOfLevels")
            ? options.numberOfLevels
            : hipsMetadata.hips_order;
        options.name = options.hasOwnProperty("name")
            ? options.name
            : hipsMetadata.obs_title;
        options.attribution = options.hasOwnProperty("attribution")
            ? options.attribution
            : "<a href=\"" +
              hipsMetadata.obs_copyright_url +
              "\" target=\"_blank\">" +
              hipsMetadata.obs_copyright +
              "</a>";
        options.copyrightUrl = options.hasOwnProperty("copyrightUrl")
            ? options.copyrightUrl
            : hipsMetadata.obs_copyright_url;
        options.ack = options.hasOwnProperty("ack")
            ? options.ack
            : hipsMetadata.obs_ack;
        options.description = options.hasOwnProperty("description")
            ? options.description
            : hipsMetadata.obs_description;
        options.format = options.hasOwnProperty("format")
            ? options.format
            : hipsMetadata.hips_tile_format;
        options.baseUrl = options.hasOwnProperty("baseUrl")
            ? options.baseUrl
            : hipsMetadata.hips_service_url;
        options.properties = options.hasOwnProperty("properties")
            ? options.properties
            : {};
        if (hipsMetadata.hasOwnProperty("obs_initial_ra")) {
            options.properties.initialRa = parseFloat(
                hipsMetadata.obs_initial_ra
            );
        }
        if (hipsMetadata.hasOwnProperty("obs_initial_dec")) {
            options.properties.initialDec = parseFloat(
                hipsMetadata.obs_initial_dec
            );
        }
        if (hipsMetadata.hasOwnProperty("obs_initial_fov")) {
            options.properties.initialFov = parseFloat(
                hipsMetadata.obs_initial_fov
            );
        }
        if (hipsMetadata.hasOwnProperty("moc_sky_fraction")) {
            options.properties.moc_sky_fraction = parseFloat(
                hipsMetadata.moc_sky_fraction
            );
        }
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractRasterLayer, AbstractHipsLayer);

    /**************************************************************************************************************/

    /**
     * Returns the Metadata related to Hips protocol.
     * @return {Object}
     * @memberof AbstractHipsLayer#
     */
    AbstractHipsLayer.prototype.getHipsMetadata = function() {
        return this.hipsMetadata;
    };

    return AbstractHipsLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/HipsGraphicLayer',[
    "../Utils/Utils",
    "../Tiling/HEALPixTiling",
    "./AbstractHipsLayer",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function(Utils, HEALPixTiling, AbstractHipsLayer, Constants, ErrorDialog) {
    /**************************************************************************************************************/

    /**
     * HipsFits configuration
     * @typedef {AbstractHipsLayer.configuration} AbstractHipsLayer.graphic_configuration
     * @property {Function} onready - Callback function
     */

    /**
     * @name HipsGraphicLayer
     * @class
     * This layer draws an Hips Image
     * @augments AbstractHipsLayer
     * @param {HipsMetadata} hipsMetadata
     * @param {AbstractHipsLayer.graphic_configuration} options - HipsGraphic configuration
     * @memberof module:Layer
     * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
     * @fires Context#baseLayersError
     */
    var HipsGraphicLayer = function(hipsMetadata, options) {
        //options.format = options.format || "jpg";
        AbstractHipsLayer.prototype.constructor.call(
            this,
            hipsMetadata,
            options
        );

        this._ready = false;

        // allsky
        this.levelZeroImage = new Image();
        var self = this;
        this.levelZeroImage.crossOrigin = "";
        this.levelZeroImage.onload = function() {
            self._ready = true;

            // Call callback if set
            if (options.onready && options.onready instanceof Function) {
                options.onready(self);
            }

            // Request a frame
            if (self.globe) {
                self.globe.getRenderContext().requestFrame();
            }
        };
        this.levelZeroImage.onerror = function(event) {
            var error = self.getHipsMetadata();
            error.message = "Cannot load " + self.levelZeroImage.src;
            self.globe.publishEvent(
                Constants.EVENT_MSG.BASE_LAYERS_ERROR,
                error
            );
            self._ready = false;
            ErrorDialog.open(Constants.LEVEL.WARNING, "Cannot load " + self.levelZeroImage.src);
        };
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractHipsLayer, HipsGraphicLayer);

    /**************************************************************************************************************/

    /**
     * Attaches the raster layer to the planet.
     * @function _attach
     * @memberof HipsGraphicLayer#
     * @param g Globe
     * @private
     */
    HipsGraphicLayer.prototype._attach = function(g) {
        AbstractHipsLayer.prototype._attach.call(this, g);

        // Load level zero image now, only for background
        this.loadOverview();
    };

    /**
     * Loads image overview
     * @function loadOverview
     * @memberof HipsGraphicLayer
     */
    HipsGraphicLayer.prototype.loadOverview = function() {
        if (this.isBackground()) {
            this.levelZeroImage.src =
                this.allowRequest(this.baseUrl) + "/Norder3/Allsky." + this.format;
        }
    };

    /**************************************************************************************************************/

    /**
     * Returns an url from a given tile.
     * @function getUrl
     * @memberof HipsGraphicLayer#
     * @param {Tile} tile Tile
     * @return {string} Url
     */
    HipsGraphicLayer.prototype.getUrl = function(tile) {
        var url = this.allowRequest(this.baseUrl);

        url += "/Norder";
        url += tile.order;

        url += "/Dir";
        var indexDirectory = Math.floor(tile.pixelIndex / 10000.0) * 10000.0;
        url += indexDirectory;

        url += "/Npix";
        url += tile.pixelIndex;
        url += "." + this.format;

        return this.allowRequest(url);
    };

    /**************************************************************************************************************/

    /**
     * Generates the level0 texture for the tiles.
     * @function generateLevel0Textures
     * @memberof HipsGraphicLayer
     * @param {Tile} tiles
     * @param {TilePool} tilePool
     */
    HipsGraphicLayer.prototype.generateLevel0Textures = function(
        tiles,
        tilePool
    ) {
        // Create a canvas to build the texture
        var canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        var i, pi, sx, sy, tile;
        var context = canvas.getContext("2d");

        for (i = 0; i < tiles.length; i++) {
            tile = tiles[i];

            // Top left
            pi = tile.pixelIndex * 4;
            sx = (pi % 27) * 64;
            sy = Math.floor(pi / 27) * 64;
            context.drawImage(
                this.levelZeroImage,
                sx,
                sy,
                64,
                64,
                0,
                0,
                64,
                64
            );

            // Top right
            pi = tile.pixelIndex * 4 + 2;
            sx = (pi % 27) * 64;
            sy = Math.floor(pi / 27) * 64;
            context.drawImage(
                this.levelZeroImage,
                sx,
                sy,
                64,
                64,
                64,
                0,
                64,
                64
            );

            // Bottom left
            pi = tile.pixelIndex * 4 + 1;
            sx = (pi % 27) * 64;
            sy = Math.floor(pi / 27) * 64;
            context.drawImage(
                this.levelZeroImage,
                sx,
                sy,
                64,
                64,
                0,
                64,
                64,
                64
            );

            // Bottom right
            pi = tile.pixelIndex * 4 + 3;
            sx = (pi % 27) * 64;
            sy = Math.floor(pi / 27) * 64;
            context.drawImage(
                this.levelZeroImage,
                sx,
                sy,
                64,
                64,
                64,
                64,
                64,
                64
            );

            var imgData = context.getImageData(0, 0, 128, 128);
            imgData.dataType = "byte";

            tile.texture = tilePool.createGLTexture(imgData);
            tile.imageSize = 128;
        }
    };

    /**************************************************************************************************************/

    return HipsGraphicLayer;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

/**
 *    JSON processor module
 *
 *    Module processing feature collection
 *
 */
define('gw/Parser/JsonProcessor',[
    "../Layer/HipsGraphicLayer",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "../Crs/CoordinateSystemFactory"
], function(HipsLayer, Constants, ErrorDialog, CoordinateSystemFactory) {
    var gid = 0;

    /**
     * Handle services of feature
     * @fires Context#layer:add
     */
    function handleServices(gwLayer, feature) {
        for (var x in feature.services) {
            var service = feature.services[x];
            if (!gwLayer.subLayers) {
                gwLayer.subLayers = [];
            }
            switch (service.type) {
            case Constants.LAYER.Hips:
                service.layer = new HipsLayer({
                    format: service.format,
                    baseUrl: service.url,
                    name: service.name,
                    visible: false,
                    coordinates: feature.geometry.coordinates[0]
                });
                gwLayer.subLayers.push(service.layer);
                if (gwLayer.planet && gwLayer.visible()) {
                    // Add sublayer to engine
                    gwLayer.planet.addLayer(service.layer);
                }
                break;
            default:
                break;
            }
        }
    }

    return {
        /**
         *    Handles feature collection
         *    Recompute geometry from equatorial coordinates to geo for each feature
         *    Handle feature services
         *    Add gid
         *
         *    @param gwLayer Layer of feature
         *    @param featureCollection GeoJSON FeatureCollection
         *    @fires Context#layer:add
         *
         */
        handleFeatureCollection: function(gwLayer, featureCollection) {
            // Default CRS according to GeoJSON specification
            var defaultCrs = {
                type: "name",
                properties: {
                    name: Constants.CRS.WGS84
                }
            };

            if (featureCollection === null || featureCollection === undefined) {
                throw new ReferenceError(
                    "Error, featureCollection is null",
                    "JsonProcessor.js"
                );
            }

            //check if crs is global at the featureCollection
            var crs = featureCollection.crs
                ? featureCollection.crs
                : defaultCrs;

            gwLayer.coordinateSystem = CoordinateSystemFactory.create({
                geoideName: crs.properties.name
            });

            var features = featureCollection.features;
            if (features === null || features === undefined) {
                ErrorDialog.open(Constants.LEVEL.ERROR, "Error, no feature in featureCollection : ", featureCollection);
                return;
            }
            var i, j, r;

            for (i = 0; i < features.length; i++) {
                var currentFeature = features[i];

                switch (currentFeature.geometry.type) {
                case Constants.GEOMETRY.Point:
                    if (!gwLayer.dataType) {
                        gwLayer.dataType = "point";
                    } else {
                        if (gwLayer.dataType !== "point") {
                            gwLayer.dataType = "none";
                        }
                    }
                    break;
                case Constants.GEOMETRY.Polygon:
                case Constants.GEOMETRY.MultiPolygon:
                    if (!gwLayer.dataType) {
                        gwLayer.dataType = "line";
                    } else {
                        if (gwLayer.dataType !== "line") {
                            gwLayer.dataType = "none";
                        }
                    }

                    if (currentFeature.properties._imageCoordinates) {
                        // Set _imageCoordinates as geometry's property (may be modified later)
                        currentFeature.geometry._imageCoordinates =
                                currentFeature.properties._imageCoordinates;
                    }

                    break;
                default:
                    break;
                }
                if (!currentFeature.geometry.crs) {
                    currentFeature.geometry.crs = crs;
                }
                currentFeature.geometry.gid = "jsonProc_" + gid;
                gid++;

                if (currentFeature.services) {
                    handleServices(gwLayer, currentFeature);
                }
            }
        }
    };
});

// samp
// ----
// Provides capabilities for using the SAMP Web Profile from JavaScript.
// Exported tokens are in the samp.* namespace.
// Inline documentation is somewhat patchy (partly because I don't know
// what javascript documentation is supposed to look like) - it is
// suggested to use it conjunction with the provided examples,
// currently visible at http://astrojs.github.com/sampjs/
// (gh-pages branch of github sources).

var samp = (function() {

    // Constants defining well-known location of SAMP Web Profile hub etc.
    var WEBSAMP_PORT = 21012;
    var WEBSAMP_PATH = "/";
    var WEBSAMP_PREFIX = "samp.webhub.";
    var WEBSAMP_CLIENT_PREFIX = "";

    // Tokens representing permissible types in a SAMP object (e.g. a message)
    TYPE_STRING = "string";
    TYPE_LIST = "list";
    TYPE_MAP = "map";

    var heir = function(proto) {
        function F() {};
        F.prototype = proto;
        return new F();
    };

    // Utility functions for navigating DOM etc.
    // -----------------------------------------

    var getSampType = function(obj) {
        if (typeof obj === "string") {
            return TYPE_STRING;
        }
        else if (obj instanceof Array) {
            return TYPE_LIST;
        }
        else if (obj instanceof Object && obj !== null) {
            return TYPE_MAP;
        }
        else {
            throw new Error("Not legal SAMP object type: " + obj);
        }
    };
    var getChildElements = function(el, childTagName) {
        var children = el.childNodes;
        var child;
        var childEls = [];
        var i;
        for (i = 0; i < children.length; i++) {
            child = children[i];
            if (child.nodeType === 1) {  // Element
                if (childTagName && (child.tagName !== childTagName)) {
                    throw new Error("Child <" + children[i].tagName + ">"
                                  + " of <" + el.tagName + ">"
                                  + " is not a <" + childTagName + ">");
                }
                childEls.push(child);
            }
        }
        return childEls;
    };
    var getSoleChild = function(el, childTagName) {
        var children = getChildElements(el, childTagName);
        if (children.length === 1 ) {
            return children[0];
        }
        else {
            throw new Error("No sole child of <" + el.tagName + ">");
        }
    };
    var getTextContent = function(el) {
        var txt = "";
        var i;
        var child;
        for (i = 0; i < el.childNodes.length; i++ ) {
            child = el.childNodes[i];
            if (child.nodeType === 1) {           // Element 
                throw new Error("Element found in text content");
            }
            else if (child.nodeType === 3 ||      // Text
                     child.nodeType === 4 ) {     // CDATASection
                txt += child.nodeValue;
            }
        }
        return txt;
    };
    var stringify = function(obj) {
        return typeof JSON === "undefined" ? "..." : JSON.stringify(obj);
    };

    // XmlRpc class:
    // Utilities for packing and unpacking XML-RPC messages.
    // See xml-rpc.com.

    var XmlRpc = {};

    // Takes text and turns it into something suitable for use as the content
    // of an XML-RPC string - special characters are escaped.
    XmlRpc.escapeXml = function(s) {
        return s.replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
    };

    // Asserts that the elements of paramList match the types given by typeList.
    // TypeList must be an array containing only TYPE_STRING, TYPE_LIST
    // and TYPE_MAP objects in some combination.  paramList must be the
    // same length.
    // In case of mismatch an error is thrown.
    XmlRpc.checkParams = function(paramList, typeList) {
        var i;
        for (i = 0; i < typeList.length; i++) {
            if (typeList[i] !== TYPE_STRING &&
                typeList[i] !== TYPE_LIST &&
                typeList[i] !== TYPE_MAP) {
                throw new Error("Unknown type " + typeList[i]
                              + " in check list");
            }
        }
        var npar = paramList.length;
        var actualTypeList = [];
        var ok = true;
        for (i = 0; i < npar; i++) {
            actualTypeList.push(getSampType(paramList[i]));
        }
        ok = ok && (typeList.length === npar);
        for (i = 0; ok && i < npar; i++ ) {
            ok = ok && typeList[i] === actualTypeList[i];
        }
        if (!ok) {
            throw new Error("Param type list mismatch: " 
                          + "[" + typeList + "] != "
                          + "[" + actualTypeList + "]");
        }
    };

    // Turns a SAMP object (structure of strings, lists, maps) into an
    // XML string suitable for use with XML-RPC.
    XmlRpc.valueToXml = function v2x(obj, prefix) {
        prefix = prefix || "";
        var a;
        var i;
        var result;
        var type = getSampType(obj);
        if (type === TYPE_STRING) {
            return prefix
                 + "<value><string>"
                 + XmlRpc.escapeXml(obj)
                 + "</string></value>";
        }
        else if (type === TYPE_LIST) {
            result = [];
            result.push(prefix + "<value>",
                        prefix + "  <array>",
                        prefix + "    <data>");
            for (i = 0; i < obj.length; i++) {
                result.push(v2x(obj[i], prefix + "      "));
            }
            result.push(prefix + "    </data>",
                        prefix + "  </array>",
                        prefix + "</value>");
          
            return result.join("\n");
        }
        else if (type === TYPE_MAP) {
            result = [];
            result.push(prefix + "<value>");
            result.push(prefix + "  <struct>");
            for (i in obj) {
                result.push(prefix + "    <member>");
                result.push(prefix + "      <name>"
                          + XmlRpc.escapeXml(i)
                          + "</name>");
                result.push(v2x(obj[i], prefix + "      "));
                result.push(prefix + "    </member>");
            }
            result.push(prefix + "  </struct>");
            result.push(prefix + "</value>");
            return result.join("\n");
        }
        else {
            throw new Error("bad type");  // shouldn't get here
        }
    };

    // Turns an XML string from and XML-RPC message into a SAMP object
    // (structure of strings, lists, maps).
    XmlRpc.xmlToValue = function x2v(valueEl, allowInt) {
        var childEls = getChildElements(valueEl);
        var i;
        var j;
        var txt;
        var node;
        var childEl;
        var elName;
        if (childEls.length === 0) {
            return getTextContent(valueEl);
        }
        else if (childEls.length === 1) {
            childEl = childEls[0];
            elName = childEl.tagName;
            if (elName === "string") {
                return getTextContent(childEl);
            }
            else if (elName === "array") {
                var valueEls =
                    getChildElements(getSoleChild(childEl, "data"), "value");
                var list = [];
                for (i = 0; i < valueEls.length; i++) {
                    list.push(x2v(valueEls[i], allowInt));
                }
                return list;
            }
            else if (elName === "struct") {
                var memberEls = getChildElements(childEl, "member");
                var map = {};
                var s_name;
                var s_value;
                var jc;
                for (i = 0; i < memberEls.length; i++) {
                    s_name = undefined;
                    s_value = undefined;
                    for (j = 0; j < memberEls[i].childNodes.length; j++) {
                        jc = memberEls[i].childNodes[j];
                        if (jc.nodeType == 1) {
                            if (jc.tagName === "name") {
                                s_name = getTextContent(jc);
                            }
                            else if (jc.tagName === "value") {
                                s_value = x2v(jc, allowInt);
                            }
                        }
                    }
                    if (s_name !== undefined && s_value !== undefined) {
                        map[s_name] = s_value;
                    }
                    else {
                        throw new Error("No <name> and/or <value> "
                                      + "in <member>?");
                    }
                }
                return map;
            }
            else if (allowInt && (elName === "int" || elName === "i4")) {
                return getTextContent(childEl);
            }
            else {
                throw new Error("Non SAMP-friendly value content: "
                              + "<" + elName + ">");
            }
        }
        else {
            throw new Error("Bad XML-RPC <value> content - multiple elements");
        }
    };

    // Turns the content of an XML-RPC <params> element into an array of
    // SAMP objects.
    XmlRpc.decodeParams = function(paramsEl) {
        var paramEls = getChildElements(paramsEl, "param");
        var i;
        var results = [];
        for (i = 0; i < paramEls.length; i++) {
            results.push(XmlRpc.xmlToValue(getSoleChild(paramEls[i], "value")));
        }
        return results;
    };

    // Turns the content of an XML-RPC <fault> element into an XmlRpc.Fault
    // object.
    XmlRpc.decodeFault = function(faultEl) {
        var faultObj = XmlRpc.xmlToValue(getSoleChild(faultEl, "value"), true);
        return new XmlRpc.Fault(faultObj.faultString, faultObj.faultCode);
    };

    // Turns an XML-RPC response element (should be <methodResponse>) into
    // either a SAMP response object or an XmlRpc.Fault object.
    // Note that a fault response does not throw an error, so check for
    // the type of the result if you want to know whether a fault occurred.
    // An error will however be thrown if the supplied XML does not
    // correspond to a legal XML-RPC response.
    XmlRpc.decodeResponse = function(xml) {
        var mrEl = xml.documentElement;
        if (mrEl.tagName !== "methodResponse") {
            throw new Error("Response element is not <methodResponse>");
        }
        var contentEl = getSoleChild(mrEl);
        if (contentEl.tagName === "fault") {
            return XmlRpc.decodeFault(contentEl);
        }
        else if (contentEl.tagName === "params") {
            return XmlRpc.decodeParams(contentEl)[0];
        }
        else {
            throw new Error("Bad XML-RPC response - unknown element"
                          + " <" + contentEl.tagName + ">");
        }
    };

    // XmlRpc.Fault class:
    // Represents an XML-RPC Fault response.
    XmlRpc.Fault = function(faultString, faultCode) {
        this.faultString = faultString;
        this.faultCode = faultCode;
    };
    XmlRpc.Fault.prototype.toString = function() {
        return "XML-RPC Fault (" + this.faultCode + "): " + this.faultString;
    };

    // XmlRpcRequest class:
    // Represents an call which can be sent to an XML-RPC server.
    var XmlRpcRequest = function(methodName, params) {
        this.methodName = methodName;
        this.params = params || [];
    }
    XmlRpcRequest.prototype.toString = function() {
        return this.methodName + "(" + stringify(this.params) + ")";
    };
    XmlRpcRequest.prototype.addParam = function(param) {
        this.params.push(param);
        return this;
    };
    XmlRpcRequest.prototype.addParams = function(params) {
        var i;
        for (i = 0; i < params.length; i++) {
            this.params.push(params[i]);
        }
        return this;
    };
    XmlRpcRequest.prototype.checkParams = function(typeList) {
        XmlRpc.checkParams(this.params, typeList);
    };
    XmlRpcRequest.prototype.toXml = function() {
        var lines = [];
        lines.push(
           "<?xml version='1.0'?>",
           "<methodCall>",
           "  <methodName>" + this.methodName + "</methodName>",
           "  <params>");
        for (var i = 0; i < this.params.length; i++) {
            lines.push("    <param>",
                       XmlRpc.valueToXml(this.params[i], "      "),
                       "    </param>");
        }
        lines.push(
           "  </params>",
           "</methodCall>");
        return lines.join("\n");
    };

    // XmlRpcClient class:
    // Object capable of sending XML-RPC calls to an XML-RPC server.
    // That server will typically reside on the host on which the
    // javascript is running; it is not likely to reside on the host
    // which served the javascript.  That means that sandboxing restrictions
    // will be in effect.  Much of the work done here is therefore to
    // do the client-side work required to potentially escape the sandbox.
    // The endpoint parameter, if supplied, is the URL of the XML-RPC server.
    // If absent, the default SAMP Web Profile server is used.
    var XmlRpcClient = function(endpoint) {
        this.endpoint = endpoint ||
                        "http://localhost:" + WEBSAMP_PORT + WEBSAMP_PATH;
    };

    // Creates an XHR facade - an object that presents an interface
    // resembling that of an XMLHttpRequest Level 2.
    // This facade may be based on an actual XMLHttpRequest Level 2 object
    // (on browsers that support it), or it may fake one using other
    // available technology.
    //
    // The created facade in any case presents the following interface:
    //
    //    open(method, url)
    //    send(body)
    //    abort()
    //    setContentType()
    //    responseText
    //    responseXML
    //    onload
    //    onerror(err)  - includes timeout; abort is ignored
    //
    // See the documentation at http://www.w3.org/TR/XMLHttpRequest/
    // for semantics.
    //
    // XMLHttpRequest Level 2 supports Cross-Origin Resource Sharing (CORS)
    // which makes sandbox evasion possible.  Faked XHRL2s returned by
    // this method may use CORS or some other technology to evade the
    // sandbox.  The SAMP hub itself may selectively allow some of these
    // technologies and not others, according to configuration.
    XmlRpcClient.createXHR = function() {

        // Creates an XHR facade based on a genuine XMLHttpRequest Level 2.
        var XhrL2 = function(xhr) {
            this.xhr = xhr;
            xhr.onreadystatechange = (function(l2) {
                return function() {
                    if (xhr.readyState !== 4) {
                        return;
                    }
                    else if (!l2.completed) {
                        if (+xhr.status === 200) {
                            l2.completed = true;
                            l2.responseText = xhr.responseText;
                            l2.responseXML = xhr.responseXML;
                            if (l2.onload) {
                                l2.onload();
                            }
                        }
                    }
                };
            })(this);
            xhr.onerror = (function(l2) {
                return function(event) {
                    if (!l2.completed) {
                        l2.completed = true;
                        if (l2.onerror) {
                            if (event) {
                                event.toString = function() {return "No hub?";};
                            }
                            else {
                                event = "No hub?";
                            }
                            l2.onerror(event);
                        }
                    }
                };
            })(this);
            xhr.ontimeout = (function(l2) {
                return function(event) {
                    if (!l2.completed) {
                        l2.completed = true;
                        if (l2.onerror) {
                            l2.onerror("timeout");
                        }
                    }
                };
            })(this);
        };
        XhrL2.prototype.open = function(method, url) {
            this.xhr.open(method, url);
        };
        XhrL2.prototype.send = function(body) {
            this.xhr.send(body);
        };
        XhrL2.prototype.abort = function() {
            this.xhr.abort();
        }
        XhrL2.prototype.setContentType = function(mimeType) {
            if ("setRequestHeader" in this.xhr) {
                this.xhr.setRequestHeader("Content-Type", mimeType);
            }
        }

        // Creates an XHR facade based on an XDomainRequest (IE8+ only).
        var XdrL2 = function(xdr) {
            this.xdr = xdr;
            xdr.onload = (function(l2) {
                return function() {
                    var e;
                    l2.responseText = xdr.responseText;
                    if (xdr.contentType === "text/xml" ||
                        xdr.contentType === "application/xml" ||
                        /\/x-/.test(xdr.contentType)) {
                        try {
                            var xdoc = new ActiveXObject("Microsoft.XMLDOM");
                            xdoc.loadXML(xdr.responseText);
                            l2.responseXML = xdoc;
                        }
                        catch (e) {
                            l2.responseXML = e;
                        }
                    }
                    if (l2.onload) {
                        l2.onload();
                    }
                };
            })(this);
            xdr.onerror = (function(l2) {
                return function(event) {
                    if (l2.onerror) {
                        l2.onerror(event);
                    }
                };
            })(this);
            xdr.ontimeout = (function(l2) {
                return function(event) {
                    if (l2.onerror) {
                        l2.onerror(event);
                    }
                };
            })(this);
        };
        XdrL2.prototype.open = function(method, url) {
            this.xdr.open(method, url);
        };
        XdrL2.prototype.send = function(body) {
            this.xdr.send(body);
        };
        XdrL2.prototype.abort = function() {
            this.xdr.abort();
        };
        XdrL2.prototype.setContentType = function(mimeType) {
            // can't do it.
        };

        // Creates an XHR Facade based on available XMLHttpRequest-type
        // capabilibities.
        // If an actual XMLHttpRequest Level 2 is available, use that.
        if (typeof XMLHttpRequest !== "undefined") {
            var xhr = new XMLHttpRequest();
            if ("withCredentials" in xhr) {
                return new XhrL2(xhr);
            }
        }

        // Else if an XDomainRequest is available, use that.
        if (typeof XDomainRequest !== "undefined") {
            return new XdrL2(new XDomainRequest());
        }

        // Else fake an XMLHttpRequest using Flash/flXHR, if available
        // and use that.
        if (typeof flensed.flXHR !== "undefined") {
            return new XhrL2(new flensed.flXHR({instancePooling: true}));
        }

        // No luck.
        throw new Error("no cross-origin mechanism available");
    };

    // Executes a request by passing it to the XML-RPC server.
    // On success, the result is passed to the resultHandler.
    // On failure, the errHandler is called with one of two possible
    // arguments: an XmlRpc.Fault object, or an Error object.
    XmlRpcClient.prototype.execute = function(req, resultHandler, errHandler) {
        (function(xClient) {
            var xhr;
            var e;
            try {
                xhr = XmlRpcClient.createXHR();
                xhr.open("POST", xClient.endpoint);
                xhr.setContentType("text/xml");
            }
            catch (e) {
                errHandler(e);
                throw e;
            }
            xhr.onload = function() {
                var xml = xhr.responseXML;
                var result;
                var e;
                if (xml) {
                    try {
                        result = XmlRpc.decodeResponse(xml);
                    }
                    catch (e) {
                        if (errHandler) {
                            errHandler(e);
                        }
                        return;
                    }
                }
                else {
                    if (errHandler) {
                        errHandler("no XML response");
                    }
                    return;
                }
                if (result instanceof XmlRpc.Fault) {
                    if (errHandler) {
                        errHandler(result);
                    }
                }
                else {
                    if (resultHandler) {
                        resultHandler(result);
                    }
                }
            };
            xhr.onerror = function(event) {
                if (event) {
                    event.toString = function() {return "No hub?";}
                }
                else {
                    event = "No hub";
                }
                if (errHandler) {
                    errHandler(event);
                }
            };
            xhr.send(req.toXml());
            return xhr;
        })(this);
    };

    // Message class:
    // Aggregates an MType string and a params map.
    var Message = function(mtype, params) {
        this["samp.mtype"] = mtype;
        this["samp.params"] = params;
    };

    // Connection class:
    // this is what clients use to communicate with the hub.
    //
    // All the methods from the Hub Abstract API as described in the
    // SAMP standard are available as methods of a Connection object.
    // The initial private-key argument required by the Web Profile is
    // handled internally by this object - you do not need to supply it
    // when calling one of the methods.
    //
    // All these calls have the same form:
    //
    //    connection.method([method-args], resultHandler, errorHandler)
    //
    // the first argument is an array of the arguments (as per the SAMP
    // abstract hub API), the second argument is a function which is
    // called on successful completion with the result of the SAMP call
    // as its argument, and the third argument is a function which is
    // called on unsuccessful completion with an error object as its
    // argument.  The resultHandler and errorHandler arguments are optional.
    //
    // So for instance if you have a Connection object conn,
    // you can send a notify message to all other clients by doing, e.g.:
    //
    //    conn.notifyAll([new samp.Message(mtype, params)])
    //
    // Connection has other methods as well as the hub API ones
    // as documented below.
    var Connection = function(regInfo) {
        this.regInfo = regInfo;
        this.privateKey = regInfo["samp.private-key"];
        if (! typeof(this.privateKey) === "string") {
            throw new Error("Bad registration object");
        }
        this.xClient = new XmlRpcClient();
    };
    (function() {
        var connMethods = {
            call: [TYPE_STRING, TYPE_STRING, TYPE_MAP],
            callAll: [TYPE_STRING, TYPE_MAP],
            callAndWait: [TYPE_STRING, TYPE_MAP, TYPE_STRING],
            declareMetadata: [TYPE_MAP],
            declareSubscriptions: [TYPE_MAP],
            getMetadata: [TYPE_STRING],
            getRegisteredClients: [],
            getSubscribedClients: [TYPE_STRING],
            getSubscriptions: [TYPE_STRING],
            notify: [TYPE_STRING, TYPE_MAP],
            notifyAll: [TYPE_MAP],
            ping: [],
            reply: [TYPE_STRING, TYPE_MAP]
        };
        var fn;
        var types;
        for (fn in connMethods) {
            (function(fname, types) {
                // errHandler may be passed an XmlRpc.Fault or a thrown Error.
                Connection.prototype[fname] =
                        function(sampArgs, resultHandler, errHandler) {
                    var closer =
                        (function(c) {return function() {c.close()}})(this);
                    errHandler = errHandler || closer
                    XmlRpc.checkParams(sampArgs, types);
                    var request = new XmlRpcRequest(WEBSAMP_PREFIX + fname);
                    request.addParam(this.privateKey);
                    request.addParams(sampArgs);
                    return this.xClient.
                           execute(request, resultHandler, errHandler);
                };
            })(fn, connMethods[fn]);
        }
    })();
    Connection.prototype.unregister = function() {
        var e;
        if (this.callbackRequest) {
            try {
                this.callbackRequest.abort();
            }
            catch (e) {
            }
        }
        var request = new XmlRpcRequest(WEBSAMP_PREFIX + "unregister");
        request.addParam(this.privateKey);
        try {
            this.xClient.execute(request);
        }
        catch (e) {
            // log unregister failed
        }
        delete this.regInfo;
        delete this.privateKey;
    };

    // Closes this connection.  It unregisters from the hub if still
    // registered, but may harmlessly be called multiple times.
    Connection.prototype.close = function() {
        var e;
        if (this.closed) {
            return;
        }
        this.closed = true;
        try {
            if (this.regInfo) {
                this.unregister();
            }
        }
        catch (e) {
        }
        if (this.onclose) {
            oc = this.onclose;
            delete this.onclose;
            try {
                oc();
            }
            catch (e) {
            }
        }
    };

    // Arranges for this connection to receive callbacks.
    //
    // The callableClient argument must be an object implementing the
    // SAMP callable client API, i.e. it must have the following methods:
    //
    //     receiveNotification(string sender-id, map message)
    //     receiveCall(string sender-id, string msg-id, map message)
    //     receiveResponse(string responder-id, string msg-tag, map response)
    // 
    // The successHandler argument will be called with no arguments if the
    // allowCallbacks hub method completes successfully - it is a suitable
    // hook to use for declaring subscriptions.
    //
    // The CallableClient class provides a suitable implementation, see below.
    Connection.prototype.setCallable = function(callableClient,
                                                successHandler) {
        var e;
        if (this.callbackRequest) {
            try {
                this.callbackRequest.abort();
            }
            catch (e) {
            }
            finally {
                delete this.callbackRequest;
            }
        }
        if (!callableClient && !this.regInfo) {
            return;
        }
        var request =
            new XmlRpcRequest(WEBSAMP_PREFIX + "allowReverseCallbacks");
        request.addParam(this.privateKey);
        request.addParam(callableClient ? "1" : "0");
        var closer = (function(c) {return function() {c.close()}})(this);
        if (callableClient) {
            (function(connection) {
                var invokeCallback = function(callback) {
                    var methodName = callback["samp.methodName"];
                    var methodParams = callback["samp.params"];
                    var handlerFunc = undefined;
                    if (methodName === WEBSAMP_CLIENT_PREFIX
                                     + "receiveNotification") {
                        handlerFunc = callableClient.receiveNotification;
                    }
                    else if (methodName === WEBSAMP_CLIENT_PREFIX
                                          + "receiveCall") {
                        handlerFunc = callableClient.receiveCall;
                    }
                    else if (methodName === WEBSAMP_CLIENT_PREFIX
                                          + "receiveResponse") {
                        handlerFunc = callableClient.receiveResponse;
                    }
                    else {
                        // unknown callback??
                    }
                    if (handlerFunc) {
                        handlerFunc.apply(callableClient, methodParams);
                    }
                };
                var startTime;
                var resultHandler = function(result) {
                    if (getSampType(result) != TYPE_LIST) {
                        errHandler(new Error("pullCallbacks result not List"));
                        return;
                    }
                    var i;
                    var e;
                    for (i = 0; i < result.length; i++) {
                        try {
                            invokeCallback(result[i]);
                        }
                        catch (e) {
                            // log here?
                        }
                    }
                    callWaiter();
                };
                var errHandler = function(error) {
                    var elapsed = new Date().getTime() - startTime;
                    if (elapsed < 1000) {
                        connection.close()
                    }
                    else {
                        // probably a timeout
                        callWaiter();
                    }
                };
                var callWaiter = function() {
                    if (!connection.regInfo) {
                        return;
                    }
                    var request =
                        new XmlRpcRequest(WEBSAMP_PREFIX + "pullCallbacks");
                    request.addParam(connection.privateKey);
                    request.addParam("600");
                    startTime = new Date().getTime();
                    connection.callbackRequest =
                        connection.xClient.
                                   execute(request, resultHandler, errHandler);
                };
                var sHandler = function() {
                    callWaiter();
                    successHandler();
                };
                connection.xClient.execute(request, sHandler, closer);
            })(this);
        }
        else {
            this.xClient.execute(request, successHandler, closer);
        }
    };

    // Takes a public URL and returns a URL that can be used from within
    // this javascript context.  Some translation may be required, since
    // a URL sent by an external application may be cross-domain, in which
    // case browser sandboxing would typically disallow access to it.
    Connection.prototype.translateUrl = function(url) {
        var translator = this.regInfo["samp.url-translator"] || "";
        return translator + url;
    };
    Connection.Action = function(actName, actArgs, resultKey) {
        this.actName = actName;
        this.actArgs = actArgs;
        this.resultKey = resultKey;
    };

    // Suitable implementation for a callable client object which can
    // be supplied to Connection.setCallable().
    // Its callHandler and replyHandler members are string->function maps
    // which can be used to provide handler functions for MTypes and
    // message tags respectively.
    //
    // In more detail:
    // The callHandler member maps a string representing an MType to
    // a function with arguments (senderId, message, isCall).
    // The replyHandler member maps a string representing a message tag to
    // a function with arguments (responderId, msgTag, response).
    var CallableClient = function(connection) {
        this.callHandler = {};
        this.replyHandler = {};
    };
    CallableClient.prototype.init = function(connection) {
    };
    CallableClient.prototype.receiveNotification = function(senderId, message) {
        var mtype = message["samp.mtype"];
        var handled = false;
        var e;
        if (mtype in this.callHandler) {
            try {
                this.callHandler[mtype](senderId, message, false);
            }
            catch (e) {
            }
            handled = true;
        }
        return handled;
    };
    CallableClient.prototype.receiveCall = function(senderId, msgId, message) {
        var mtype = message["samp.mtype"];
        var handled = false;
        var response;
        var result;
        var e;
        if (mtype in this.callHandler) {
            try {
                result = this.callHandler[mtype](senderId, message, true) || {};
                response = {"samp.status": "samp.ok",
                            "samp.result": result};
                handled = true;
            }
            catch (e) {
                response = {"samp.status": "samp.error",
                            "samp.error": {"samp.errortxt": e.toString()}};
            }
        }
        else {
            response = {"samp.status": "samp.warning",
                        "samp.result": {},
                        "samp.error": {"samp.errortxt": "no action"}};
        }
        this.connection.reply([msgId, response]);
        return handled;
    };
    CallableClient.prototype.receiveResponse = function(responderId, msgTag,
                                                        response) {
        var handled = false;
        var e;
        if (msgTag in this.replyHandler) {
            try {
                this.replyHandler[msgTag](responderId, msgTag, response);
                handled = true;
            }
            catch (e) {
            }
        }
        return handled;
    };
    CallableClient.prototype.calculateSubscriptions = function() {
        var subs = {};
        var mt;
        for (mt in this.callHandler) {
            subs[mt] = {};
        }
        return subs;
    };

    // ClientTracker is a CallableClient which also provides tracking of
    // registered clients.
    //
    // Its onchange member, if defined, will be called with arguments
    // (client-id, change-type, associated-data) whenever the list or
    // characteristics of registered clients has changed.
    var ClientTracker = function() {
        var tracker = this;
        this.ids = {};
        this.metas = {};
        this.subs = {};
        this.replyHandler = {};
        this.callHandler = {
            "samp.hub.event.shutdown": function(senderId, message) {
                tracker.connection.close();
            },
            "samp.hub.disconnect": function(senderId, message) {
                tracker.connection.close();
            },
            "samp.hub.event.register": function(senderId, message) {
                var id = message["samp.params"]["id"];
                tracker.ids[id] = true;
                tracker.changed(id, "register", null);
            },
            "samp.hub.event.unregister": function(senderId, message) {
                var id = message["samp.params"]["id"];
                delete tracker.ids[id];
                delete tracker.metas[id];
                delete tracker.subs[id];
                tracker.changed(id, "unregister", null);
            },
            "samp.hub.event.metadata": function(senderId, message) {
                var id = message["samp.params"]["id"];
                var meta = message["samp.params"]["metadata"];
                tracker.metas[id] = meta;
                tracker.changed(id, "meta", meta);
            },
            "samp.hub.event.subscriptions": function(senderId, message) {
                var id = message["samp.params"]["id"];
                var subs = message["samp.params"]["subscriptions"];
                tracker.subs[id] = subs;
                tracker.changed(id, "subs", subs);
            }
        };
    };
    ClientTracker.prototype = heir(CallableClient.prototype);
    ClientTracker.prototype.changed = function(id, type, data) {
        if (this.onchange) {
            this.onchange(id, type, data);
        }
    };
    ClientTracker.prototype.init = function(connection) {
        var tracker = this;
        this.connection = connection;
        var retrieveInfo = function(id, type, infoFuncName, infoArray) {
            connection[infoFuncName]([id], function(info) {
                infoArray[id] = info;
                tracker.changed(id, type, info);
            });
        };
        connection.getRegisteredClients([], function(idlist) {
            var i;
            var id;
            tracker.ids = {};
            for (i = 0; i < idlist.length; i++) {
                id = idlist[i];
                tracker.ids[id] = true;
                retrieveInfo(id, "meta", "getMetadata", tracker.metas);
                retrieveInfo(id, "subs", "getSubscriptions", tracker.subs);
            }
            tracker.changed(null, "ids", null);
        });
    };
    ClientTracker.prototype.getName = function(id) {
        var meta = this.metas[id];
        return (meta && meta["samp.name"]) ? meta["samp.name"] : "[" + id + "]";
    };

    // Connector class:
    // A higher level class which can manage transparent hub
    // registration/unregistration and client tracking.
    //
    // On construction, the name argument is mandatory, and corresponds
    // to the samp.name item submitted at registration time.
    // The other arguments are optional.
    // meta is a metadata map (if absent, no metadata is declared)
    // callableClient is a callable client object for receiving callbacks
    // (if absent, the client is not callable).
    // subs is a subscriptions map (if absent, no subscriptions are declared)
    var Connector = function(name, meta, callableClient, subs) {
        this.name = name;
        this.meta = meta;
        this.callableClient = callableClient;
        this.subs = subs;
        this.regTextNodes = [];
        this.whenRegs = [];
        this.whenUnregs = [];
        this.connection = undefined;
        this.onreg = undefined;
        this.onunreg = undefined;
    };
    var setRegText = function(connector, txt) {
        var i;
        var nodes = connector.regTextNodes;
        var node;
        for (i = 0; i < nodes.length; i++) {
            node = nodes[i];
            node.innerHTML = "";
            node.appendChild(document.createTextNode(txt));
        }
    };
    Connector.prototype.setConnection = function(conn) {
        var connector = this;
        var e;
        if (this.connection) {
            this.connection.close();
            if (this.onunreg) {
                try {
                    this.onunreg();
                }
                catch (e) {
                }
            }
        }
        this.connection = conn;
        if (conn) {
            conn.onclose = function() {
                connector.connection = null;
                if (connector.onunreg) {
                    try {
                        connector.onunreg();
                    }
                    catch (e) {
                    }
                }
                connector.update();
            };
            if (this.meta) {
                conn.declareMetadata([this.meta]);
            }
            if (this.callableClient) {
                if (this.callableClient.init) {
                    this.callableClient.init(conn);
                }
                conn.setCallable(this.callableClient, function() {
                    conn.declareSubscriptions([connector.subs]);
                });
            }
            if (this.onreg) {
                try {
                    this.onreg(conn);
                }
                catch (e) {
                }
            }
        }
        this.update();
    };
    Connector.prototype.register = function() {
        var connector = this;
        var regErrHandler = function(err) {
            setRegText(connector, "no (" + err.toString() + ")");
        };
        var regSuccessHandler = function(conn) {
            connector.setConnection(conn);
            setRegText(connector, conn ? "Yes" : "No");
        };
        register(this.name, regSuccessHandler, regErrHandler);
    };
    Connector.prototype.unregister = function() {
        if (this.connection) {
            this.connection.unregister([]);
            this.setConnection(null);
        }
    };

    // Returns a document fragment which contains Register/Unregister
    // buttons for use by the user to attempt to connect/disconnect
    // with the hub.  This is useful for models where explicit
    // user registration is encouraged or required, but when using
    // the register-on-demand model such buttons are not necessary.
    Connector.prototype.createRegButtons = function() {
        var connector = this;
        var regButt = document.createElement("button");
        regButt.setAttribute("type", "button");
        regButt.appendChild(document.createTextNode("Register"));
        regButt.onclick = function() {connector.register();};
        this.whenUnregs.push(regButt);
        var unregButt = document.createElement("button");
        unregButt.setAttribute("type", "button");
        unregButt.appendChild(document.createTextNode("Unregister"));
        unregButt.onclick = function() {connector.unregister();};
        this.whenRegs.push(unregButt);
        var regText = document.createElement("span");
        this.regTextNodes.push(regText);
        var node = document.createDocumentFragment();
        node.appendChild(regButt);
        node.appendChild(document.createTextNode(" "));
        node.appendChild(unregButt);
        var label = document.createElement("span");
        label.innerHTML = " <strong>Registered: </strong>";
        node.appendChild(label);
        node.appendChild(regText);
        this.update();
        return node;
    };

    Connector.prototype.update = function() {
        var i;
        var isConnected = !! this.connection;
        var enableds = isConnected ? this.whenRegs : this.whenUnregs;
        var disableds = isConnected ? this.whenUnregs : this.whenRegs;
        for (i = 0; i < enableds.length; i++) {
            enableds[i].removeAttribute("disabled");
        }
        for (i = 0; i < disableds.length; i++) {
            disableds[i].setAttribute("disabled", "disabled");
        }
        setRegText(this, "No");
    };

    // Provides execution of a SAMP operation with register-on-demand.
    // You can use this method to provide lightweight registration/use
    // of web SAMP.  Simply provide a connHandler function which
    // does something with a connection (e.g. sends a message) and
    // Connector.runWithConnection on it.  This will connect if not
    // already connected, and call the connHandler on with the connection.
    // No explicit registration action is then required from the user.
    //
    // If the regErrorHandler argument is supplied, it is a function of
    // one (error) argument called in the case that registration-on-demand
    // fails.
    //
    // This is a more-or-less complete sampjs page:
    //   <script>
    //     var connector = new samp.Connector("pinger", {"samp.name": "Pinger"})
    //     var pingFunc = function(connection) {
    //       connection.notifyAll([new samp.Message("samp.app.ping", {})])
    //     }
    //   </script>
    //   <button onclick="connector.runWithConnection(pingFunc)">Ping</button>
    Connector.prototype.runWithConnection =
            function(connHandler, regErrorHandler) {
        var connector = this;
        var regSuccessHandler = function(conn) {
            connector.setConnection(conn);
            connHandler(conn);
        };
        var regFailureHandler = function(e) {
            connector.setConnection(undefined);
            regErrorHandler(e);
        };
        var pingResultHandler = function(result) {
            connHandler(connector.connection);
        };
        var pingErrorHandler = function(err) {
            register(this.name, regSuccessHandler, regFailureHandler);
        };
        if (this.connection) {
            // Use getRegisteredClients as the most lightweight check
            // I can think of that this connection is still OK.
            // Ping doesn't work because the server replies even if the
            // private-key is incorrect/invalid.  Is that a bug or not?
            this.connection.
                 getRegisteredClients([], pingResultHandler, pingErrorHandler);
        }
        else {
            register(this.name, regSuccessHandler, regFailureHandler);
        }
    };

    // Sets up an interval timer to run at intervals and notify a callback
    // about whether a hub is currently running.
    // Every millis milliseconds, the supplied availHandler function is
    // called with a boolean argument: true if a (web profile) hub is
    // running, false if not.
    // Returns the interval timer (can be passed to clearInterval()).
    Connector.prototype.onHubAvailability = function(availHandler, millis) {
        samp.ping(availHandler);

        // Could use the W3C Page Visibility API to avoid making these
        // checks when the page is not visible.
        return setInterval(function() {samp.ping(availHandler);}, millis);
    };

    // Determines whether a given subscriptions map indicates subscription
    // to a given mtype.
    var isSubscribed = function(subs, mtype) {
        var matching = function(pattern, mtype) {
            if (pattern == mtype) {
                return true;
            }
            else if (pattern === "*") {
                return true;
            }
            else {
                var prefix;
                var split = /^(.*)\.\*$/.exec(pat);
                if (split) {
                    prefix = split[1];
                    if (prefix === mtype.substring(0, prefix.length)) {
                        return true;
                    }
                }
            }
            return false;
        };
        var pat;
        for (pat in subs) {
            if (matching(pat, mtype)) {
                return true;
            }
        }
        return false;
    }

    // Attempts registration with a SAMP hub.
    // On success the supplied connectionHandler function is called
    // with the connection as an argument, on failure the supplied
    // errorHandler is called with an argument that may be an Error
    // or an XmlRpc.Fault.
    var register = function(appName, connectionHandler, errorHandler) {
        var xClient = new XmlRpcClient();
        var regRequest = new XmlRpcRequest(WEBSAMP_PREFIX + "register");
        var securityInfo = {"samp.name": appName};
        regRequest.addParam(securityInfo);
        regRequest.checkParams([TYPE_MAP]);
        var resultHandler = function(result) {
            var conn;
            var e;
            try {
                conn = new Connection(result);
            }
            catch (e) {
                errorHandler(e);
                return;
            }
            connectionHandler(conn);
        };
        xClient.execute(regRequest, resultHandler, errorHandler);
    };

    // Calls the hub ping method once.  It is not necessary to be
    // registered to do this.
    // The supplied pingHandler function is called with a boolean argument:
    // true if a (web profile) hub is running, false if not.
    var ping = function(pingHandler) {
        var xClient = new XmlRpcClient();
        var pingRequest = new XmlRpcRequest(WEBSAMP_PREFIX + "ping");
        var resultHandler = function(result) {
            pingHandler(true);
        };
        var errorHandler = function(error) {
            pingHandler(false);
        };
        xClient.execute(pingRequest, resultHandler, errorHandler);
    };


    /* Exports. */
    var jss = {};
    jss.XmlRpcRequest = XmlRpcRequest;
    jss.XmlRpcClient = XmlRpcClient;
    jss.Message = Message;
    jss.TYPE_STRING = TYPE_STRING;
    jss.TYPE_LIST = TYPE_LIST;
    jss.TYPE_MAP = TYPE_MAP;
    jss.register = register;
    jss.ping = ping;
    jss.isSubscribed = isSubscribed;
    jss.Connector = Connector;
    jss.CallableClient = CallableClient;
    jss.ClientTracker = ClientTracker;

    return jss;
})();

define("samp", function(){});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * SampCore Module : containing core methods
 */
define('gw/Services/SampCore',[
    "jquery",
    "underscore-min",
    "../Utils/Constants",
    "../Parser/JsonProcessor",
    "../Gui/dialog/ErrorDialog",
    "samp",
    "jquery.ui"
], function($, _, Constants, JsonProcessor, ErrorDialog) {
    var mizar;
    var navigation;
    var imageManager;

    var connector; // SAMP connector
    var sampLayer; // SAMP vector layer containing all incoming fits images
    var pointAtReceived = false; // Parameter avoiding looping while receiving coord.pointAt.sky SAMP event
    var votable2geojsonBaseUrl;
    //var sitoolsBaseUrl;

    /**************************************************************************************************************/

    /**
     *    Create SAMP ClientTracker object which handles incoming messages
     */
    function createClientTracker() {
        // Initialize client tracker
        var clientTracker = new samp.ClientTracker();

        // Init available samp income message handlers(as ping, load.votable..)
        var callHandler = clientTracker.callHandler;
        callHandler["samp.app.ping"] = function(senderId, message, isCall) {
            if (isCall) {
                return {
                    text: "ping to you, " + clientTracker.getName(senderId)
                };
            }
        };

        callHandler["table.load.votable"] = function(
            senderId,
            message,
            isCall
        ) {
            if (votable2geojsonBaseUrl) {
                //var params = message["samp.params"];
                //var origUrl = params.url;
                //var proxyUrl = clientTracker.connection.translateUrl(origUrl);
                //Utils.convertVotable2JsonFromURL(proxyUrl, function (response) {
                // Add feature collection
                //    JsonProcessor.handleFeatureCollection(sampLayer, response);
                //    sampLayer.addFeatureCollection(response);
                //});
            } else {
                ErrorDialog.open(
                    Constants.LEVEL.ERROR,
                    "votable2geojson plugin base url isn't defined"
                );
            }
        };

        // callHandler["table.highlight.row"] = function(senderId, message, isCall) {
        // 	var params = message["samp.params"];
        // 	var url = params['url'];
        // 	var row = params['row'];

        // 	if ( highlightedData )
        // 	{
        // 		highlightedData.layer.modifyFeatureStyle( highlightedData.feature, highlightedData.layer.style );
        // 	}

        // 	if ( tables[url] )
        // 	{
        // 		var layer = tables[url].layer;
        // 		var feature = tables[url].features[parseInt(row)];

        // 		layer.modifyFeatureStyle( feature, highlightStyle );
        // 		highlightedData = {
        // 			layer: layer,
        // 			feature: feature
        // 		}

        // 		var barycenter = Utils.computeGeometryBarycenter( feature.geometry );
        // 		navigation.zoomTo( barycenter, (navigation.renderContext.fov < 1. ? navigation.renderContext.fov : 1.), 300. );
        // 	}
        // };

        callHandler["image.load.fits"] = function(senderId, message, isCall) {
            // var params = message["samp.params"];
            //
            // // Create feature
            // var feature = {
            //     "geometry": {
            //         "gid": params.name,
            //         "coordinates": [],
            //         "type": "Polygon"
            //     },
            //     "properties": {
            //         "identifier": params.name
            //     },
            //     "services": {
            //         "download": {
            //             "mimetype": "image/fits",
            //             "url": params['image-id']
            //         }
            //     },
            //     "type": "Feature"
            // };
            //
            // // Get fits texture from url
            // var featureData = {
            //     layer: sampLayer,
            //     feature: feature,
            //     isFits: true
            // };
            // var url = sitoolsBaseUrl + "/proxy?external_url=" + encodeURIComponent(params['image-id']);
            // mizar.publish("image:add", featureData);
            // imageManager.computeFits(featureData, url, function (featureData, fits) {
            //     // Update feature coordinates according to Fits header
            //     var coords = Utils.getPolygonCoordinatesFromFits(fits);
            //     featureData.feature.geometry.coordinates = [coords];
            //     sampLayer.addFeature(featureData.feature);
            // });
        };

        callHandler["coord.pointAt.sky"] = function(senderId, message, isCall) {
            pointAtReceived = true;
            var params = message["samp.params"];
            var ra = parseFloat(params.ra);
            var dec = parseFloat(params.dec);
            var navigation = mizar.getActivatedContext().getNavigation();
            navigation.zoomTo([ra, dec]);
        };

        callHandler["samp.hub.event.unregister"] = function(
            senderId,
            message,
            isCall
        ) {
            // Update jQuery UI buttons
            $("#registerSamp")
                .removeAttr("disabled")
                .button("refresh");
            $("#unregisterSamp")
                .attr("disabled", "disabled")
                .button("refresh");
            $("#sampInvoker").toggleClass("selected");
        };

        return clientTracker;
    }

    /**************************************************************************************************************/

    /**
     *    Init SAMP connector
     */
    function initSamp(mizarAPI) {
        mizar = mizarAPI;
        var clientTracker = createClientTracker();

        // Samp event callbacks
        var logCc = {
            receiveNotification: function(senderId, message) {
                var handled = clientTracker.receiveNotification(
                    senderId,
                    message
                );
                if (message["samp.mtype"] === "samp.hub.event.subscriptions") {
                    // Update jQuery UI buttons
                    $("#unregisterSamp")
                        .removeAttr("disabled")
                        .button("refresh");
                    $("#registerSamp")
                        .attr("disabled", "disabled")
                        .button("refresh");
                    $("#sampInvoker").addClass("selected");
                }
            },
            receiveCall: function(senderId, msgId, message) {
                var handled = clientTracker.receiveCall(
                    senderId,
                    msgId,
                    message
                );
            },
            receiveResponse: function(responderId, msgTag, response) {
                var handled = clientTracker.receiveResponse(
                    responderId,
                    msgTag,
                    response
                );
            },
            init: function(connection) {
                clientTracker.init(connection);
            }
        };

        // Meta-data
        var meta = {
            "samp.name": "Mizar",
            "samp.description.text":
                "Module for Interactive visualiZation from Astronomical Repositories",
            "mizar.version": "v1.0",
            "author.affiliation": "CNES/TPZ",
            "home.page": "http://github.com/MizarWeb"
        };

        // Generate subscriptions map
        var subs = clientTracker.calculateSubscriptions();

        connector = new samp.Connector("Mizar", meta, logCc, subs);

        // Uncomment for automatic registration(check every 2 sec if Hub is available)
        // Adjusts page content depending on whether the hub exists or not.
        // var configureSampEnabled = function(isHubRunning) {
        //     // TODO
        // };
        // connector.onHubAvailability(configureSampEnabled, 2000);

        // Registration status element is updated by samp.js
        connector.regTextNodes.push($("#sampResult")[0]);

        return connector;
    }

    /**************************************************************************************************************/

    return {
        initSamp: initSamp,
        sendImage: function(url) {
            if (this.isConnected()) {
                // Send message
                var msg = new samp.Message("image.load.fits", { url: url });
                connector.connection.notifyAll([msg]);
                return "Image has been sent";
            } else {
                return "Connect to SAMP Hub first";
            }
        },

        sendVOTable: function(layer, url) {
            if (this.isConnected()) {
                // Send message
                var msg = new samp.Message("table.load.votable", {
                    url: url + "&media=votable"
                });
                connector.connection.notifyAll([msg]);

                // Part used to highlighting
                // $.ajax({
                // 	type: "GET",
                // 	url: url,
                // 	success: function(response) {

                // 		if ( response.totalResults > 0 )
                // 		{
                // 			// Store table to be able to highlight features later
                // 			tables[ url+'&media=votable' ] = {
                // 				layer: layer,
                // 				features: []
                // 			};
                // 			for ( var i=0; i<response.features.length; i++ )
                // 			{
                // 				var feature = response.features[i];
                // 				tables[url+'&media=votable'].features.push(feature);
                // 			}
                // 		}
                // 		// Send message
                // 		var msg = new samp.Message("table.load.votable", {url: url+"&media=votable"});
                // 		connector.connection.notifyAll([msg]);
                // 	},
                // 	error: function(thrownError)
                // 	{
                // 		console.error(thrownError);
                // 	}
                // });
                return "VOTable has been sent";
            } else {
                return "Connect to SAMP Hub first";
            }
        },

        // Commented part is used for highlighting feature which wasn't implemented due to
        // difficulty of SAMP protocol (client doesn't know the feature from row)
        highlightFeature: function(layer, feature) {
            /**if (this.isConnected()) {
                    // for ( var url in tables )
                    // {
                    // 	var table = tables[url];
                    // 	if ( layer == table.layer )
                    // 	{
                    // 		var featureToHighlight = _.filter( table.features, function(x){ return(feature.properties.identifier == x.properties.identifier) } );
                    // 		if ( featureToHighlight.length )
                    // 		{
                    // var featureRow = table.features.indexOf(featureToHighlight[0]);
                    // var msg = new samp.Message("table.highlight.row", {url: url, row: featureRow.toString()});
                    // connector.connection.notifyAll([msg]);
                    // 		}
                    // 	}
                    // }
                }
                */
        },
        isConnected: function() {
            return connector.connection;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to select areas on planet
 */

define('gw/Services/SelectionToolCore',[
    "jquery",
    "../Utils/Constants",
    "../Utils/UtilsIntersection",
    "../Utils/Numeric",
    "../Layer/VectorLayer",
    "../Renderer/FeatureStyle",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function(
    $,
    Constants,
    UtilsIntersection,
    Numeric,
    VectorLayer,
    FeatureStyle,
    Ray
) {
    var ctx, navigation, onselect;
    /**
     *    @constructor
     *    @param options Configuration options
     *        <ul>
     *            <li>planet: planet</li>
     *            <li>navigation: Navigation</li>
     *            <li>onselect: On selection callback</li>
     *            <li>style: Selection tool style</li>
     *        </ul>
     */
    var SelectionToolCore = function(options) {
        // Required options
        ctx = options.ctx;
        navigation = ctx.getNavigation();
        onselect = options.onselect;

        this.activated = options.activated || false;
        this.renderContext = ctx.getRenderContext();
        this.coordinateSystem = ctx.getCoordinateSystem();

        // Set style
        var style;
        if (options && options.style) {
            style = options.style;
        } else {
            style = new FeatureStyle();
        }
        style.zIndex = Constants.DISPLAY.SELECTED_VECTOR;

        // Layer containing selection feature
        this.selectionLayer = new VectorLayer({
            style: style,
            visible: true
        });
        ctx.addDraw(this.selectionLayer);

        this.selectionFeature = null;

        // Selection attributes
        this.radius = null; // Window radius
        this.pickPoint = null; // Window pick point
        this.geoRadius = null; // Radius in geographic reference
        this.geoPickPoint = null; // Pick point in geographic reference

        var self = this;
        var dragging = false;
        var state;

        this.renderContext.canvas.addEventListener("mousedown", function(event) {
            var pickPoint = [event.layerX, event.layerY];
            var geoPickPoint = ctx.getLonLatFromPixel(
                event.layerX,
                event.layerY
            );

            if (!self.activated && !self.selectionFeature) {
                return;
            }

            // Dragging : moving/resizing OR drawing selection
            if (self.activated) {
                // Draw
                navigation.stop();
                dragging = true;
                self.pickPoint = pickPoint;
                self.geoPickPoint = geoPickPoint;
                self.radius = 0.0;
                state = "resize";
            } else {
                var pickIsInside = UtilsIntersection.pointInRing(
                    geoPickPoint,
                    self.selectionFeature.geometry.coordinates[0]
                );
                if (!pickIsInside) {
                    return;
                }
                navigation.stop();
                dragging = true;
                // Resize/move
                var inside = false;
                // Check if user clicked on one of control points
                for (
                    var i = 0;
                    i < self.selectionFeature.geometry.coordinates[0].length;
                    i++
                ) {
                    var controlPoint =
                        self.selectionFeature.geometry.coordinates[0][i];
                    inside |= UtilsIntersection.pointInSphere(
                        ctx,
                        geoPickPoint,
                        controlPoint,
                        20
                    );
                }

                if (inside) {
                    state = "resize";
                } else {
                    state = "move";
                }
            }
        });

        this.renderContext.canvas.addEventListener("mousemove", function(
            event
        ) {
            if (!dragging) {
                return;
            }

            var geoPickPoint = ctx.getLonLatFromPixel(
                event.layerX,
                event.layerY
            );
            if (state === "resize") {
                // Update radius
                self.radius = Math.sqrt(
                    Math.pow(event.layerX - self.pickPoint[0], 2) +
                        Math.pow(event.layerY - self.pickPoint[1], 2)
                );
                self.computeGeoRadius(geoPickPoint);
            } else if (state === "move") {
                // Update pick point position
                self.pickPoint = [event.layerX, event.layerY];
                self.geoPickPoint = ctx.getLonLatFromPixel(
                    event.layerX,
                    event.layerY
                );

                // TODO: scale radius of selection shape if fov has been changed(or not?)
            }
            self.updateSelection();
        });

        this.renderContext.canvas.addEventListener("mouseup", function(event) {
            if (!dragging) {
                return;
            }

            // Compute geo radius
            var stopPickPoint = ctx.getLonLatFromPixel(
                event.layerX,
                event.layerY
            );

            var coordinates = self.computeSelection();
            if (self.activated && onselect) {
                onselect(coordinates);
            }

            // Reactivate standard navigation events
            navigation.start();
            dragging = false;
        });
    };

    /**********************************************************************************************/

    /**
     *    Compute selection tool radius between pickPoint and the given point
     *    @param {Array} pt point
     */
    SelectionToolCore.prototype.computeGeoRadius = function(pt) {
        // Find angle between start and stop vectors which is in fact the radius
        var dotProduct = vec3.dot(
            vec3.normalize(this.coordinateSystem.get3DFromWorld(pt)),
            vec3.normalize(
                this.coordinateSystem.get3DFromWorld(this.geoPickPoint)
            )
        );
        var theta = Math.acos(dotProduct);
        this.geoRadius = Numeric.toDegree(theta);
    };

    /**********************************************************************************************/

    /**
     *    Compute selection for the given pick point depending on radius
     *    @return {Array} points
     */
    SelectionToolCore.prototype.computeSelection = function() {
        var rc = this.renderContext;
        var tmpMat = mat4.create();

        // Compute eye in world space
        mat4.inverse(rc.viewMatrix, tmpMat);
        var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];

        // Compute the inverse of view/proj matrix
        mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
        mat4.inverse(tmpMat);

        // Scale to [-1,1]
        var widthScale = 2 / rc.canvas.width;
        var heightScale = 2 / rc.canvas.height;
        var points = [
            [
                (this.pickPoint[0] - this.radius) * widthScale - 1.0,
                (rc.canvas.height - this.pickPoint[1] - this.radius) *
                    heightScale -
                    1.0,
                1,
                1
            ],
            [
                (this.pickPoint[0] - this.radius) * widthScale - 1.0,
                (rc.canvas.height - this.pickPoint[1] + this.radius) *
                    heightScale -
                    1.0,
                1,
                1
            ],
            [
                (this.pickPoint[0] + this.radius) * widthScale - 1.0,
                (rc.canvas.height - this.pickPoint[1] + this.radius) *
                    heightScale -
                    1.0,
                1,
                1
            ],
            [
                (this.pickPoint[0] + this.radius) * widthScale - 1.0,
                (rc.canvas.height - this.pickPoint[1] - this.radius) *
                    heightScale -
                    1.0,
                1,
                1
            ]
        ];

        // Transform the four corners of selection shape into world space
        // and then for each corner compute the intersection of ray starting from the eye with the sphere
        var worldCenter = [0, 0, 0];
        for (var i = 0; i < 4; i++) {
            mat4.multiplyVec4(tmpMat, points[i]);
            vec3.scale(points[i], 1.0 / points[i][3]);
            vec3.subtract(points[i], eye, points[i]);
            vec3.normalize(points[i]);

            var ray = new Ray(eye, points[i]);
            var pos3d = ray.computePoint(
                ray.sphereIntersect(
                    worldCenter,
                    this.coordinateSystem.getGeoide().getRadius()
                )
            );
            points[i] = this.coordinateSystem.getWorldFrom3D(pos3d);
        }

        return points;
    };

    /**************************************************************************************************************/

    /**
     *    Update selection coordinates
     */
    SelectionToolCore.prototype.updateSelection = function() {
        if (this.selectionFeature) {
            this.selectionLayer.removeFeature(this.selectionFeature);
        }

        var coordinates = this.computeSelection();
        // Close the polygon
        coordinates.push(coordinates[0]);

        this.selectionFeature = {
            geometry: {
                gid: "selectionShape",
                coordinates: [coordinates],
                type: "Polygon",
                crs: {
                    type: "name",
                    properties: {
                        name: ctx.getCoordinateSystem().getGeoideName()
                    }
                }
            },
            type: "Feature"
        };

        this.selectionLayer.addFeature(this.selectionFeature);
    };

    /**************************************************************************************************************/

    /**
     *    Activate/desactivate the tool
     */
    SelectionToolCore.prototype.toggle = function() {
        this.activated = !this.activated;
        if (this.activated) {
            // TODO : Find more sexy image for cursor
            $(this.renderContext.canvas).css(
                "cursor",
                "url(css/images/selectionCursor.png)"
            );
        } else {
            $(this.renderContext.canvas).css("cursor", "default");
        }
    };

    /**************************************************************************************************************/

    /**
     *    Clear selection
     */
    SelectionToolCore.prototype.clear = function() {
        if (this.selectionFeature) {
            this.selectionLayer.removeFeature(this.selectionFeature);
        }

        this.pickPoint = null;
        this.radius = null;
        this.geoPickPoint = null;
        this.geoRadius = null;
    };

    /**************************************************************************************************************/

    return SelectionToolCore;
});

/*!

JSZip v3.1.5 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define('jszip',[],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.JSZip=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";var d=a("./utils"),e=a("./support"),f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a){for(var b,c,e,g,h,i,j,k=[],l=0,m=a.length,n=m,o="string"!==d.getTypeOf(a);l<a.length;)n=m-l,o?(b=a[l++],c=l<m?a[l++]:0,e=l<m?a[l++]:0):(b=a.charCodeAt(l++),c=l<m?a.charCodeAt(l++):0,e=l<m?a.charCodeAt(l++):0),g=b>>2,h=(3&b)<<4|c>>4,i=n>1?(15&c)<<2|e>>6:64,j=n>2?63&e:64,k.push(f.charAt(g)+f.charAt(h)+f.charAt(i)+f.charAt(j));return k.join("")},c.decode=function(a){var b,c,d,g,h,i,j,k=0,l=0,m="data:";if(a.substr(0,m.length)===m)throw new Error("Invalid base64 input, it looks like a data url.");a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");var n=3*a.length/4;if(a.charAt(a.length-1)===f.charAt(64)&&n--,a.charAt(a.length-2)===f.charAt(64)&&n--,n%1!==0)throw new Error("Invalid base64 input, bad content length.");var o;for(o=e.uint8array?new Uint8Array(0|n):new Array(0|n);k<a.length;)g=f.indexOf(a.charAt(k++)),h=f.indexOf(a.charAt(k++)),i=f.indexOf(a.charAt(k++)),j=f.indexOf(a.charAt(k++)),b=g<<2|h>>4,c=(15&h)<<4|i>>2,d=(3&i)<<6|j,o[l++]=b,64!==i&&(o[l++]=c),64!==j&&(o[l++]=d);return o}},{"./support":30,"./utils":32}],2:[function(a,b,c){"use strict";function d(a,b,c,d,e){this.compressedSize=a,this.uncompressedSize=b,this.crc32=c,this.compression=d,this.compressedContent=e}var e=a("./external"),f=a("./stream/DataWorker"),g=a("./stream/DataLengthProbe"),h=a("./stream/Crc32Probe"),g=a("./stream/DataLengthProbe");d.prototype={getContentWorker:function(){var a=new f(e.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new g("data_length")),b=this;return a.on("end",function(){if(this.streamInfo.data_length!==b.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),a},getCompressedWorker:function(){return new f(e.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},d.createWorkerFrom=function(a,b,c){return a.pipe(new h).pipe(new g("uncompressedSize")).pipe(b.compressWorker(c)).pipe(new g("compressedSize")).withStreamInfo("compression",b)},b.exports=d},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(a,b,c){"use strict";var d=a("./stream/GenericWorker");c.STORE={magic:"\0\0",compressWorker:function(a){return new d("STORE compression")},uncompressWorker:function(){return new d("STORE decompression")}},c.DEFLATE=a("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(a,b,c){"use strict";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b[g])];return a^-1}function f(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b.charCodeAt(g))];return a^-1}var g=a("./utils"),h=d();b.exports=function(a,b){if("undefined"==typeof a||!a.length)return 0;var c="string"!==g.getTypeOf(a);return c?e(0|b,a,a.length,0):f(0|b,a,a.length,0)}},{"./utils":32}],5:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!0,c.date=null,c.compression=null,c.compressionOptions=null,c.comment=null,c.unixPermissions=null,c.dosPermissions=null},{}],6:[function(a,b,c){"use strict";var d=null;d="undefined"!=typeof Promise?Promise:a("lie"),b.exports={Promise:d}},{lie:58}],7:[function(a,b,c){"use strict";function d(a,b){h.call(this,"FlateWorker/"+a),this._pako=null,this._pakoAction=a,this._pakoOptions=b,this.meta={}}var e="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,f=a("pako"),g=a("./utils"),h=a("./stream/GenericWorker"),i=e?"uint8array":"array";c.magic="\b\0",g.inherits(d,h),d.prototype.processChunk=function(a){this.meta=a.meta,null===this._pako&&this._createPako(),this._pako.push(g.transformTo(i,a.data),!1)},d.prototype.flush=function(){h.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},d.prototype.cleanUp=function(){h.prototype.cleanUp.call(this),this._pako=null},d.prototype._createPako=function(){this._pako=new f[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var a=this;this._pako.onData=function(b){a.push({data:b,meta:a.meta})}},c.compressWorker=function(a){return new d("Deflate",a)},c.uncompressWorker=function(){return new d("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:59}],8:[function(a,b,c){"use strict";function d(a,b,c,d){f.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=b,this.zipPlatform=c,this.encodeFileName=d,this.streamFiles=a,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}var e=a("../utils"),f=a("../stream/GenericWorker"),g=a("../utf8"),h=a("../crc32"),i=a("../signature"),j=function(a,b){var c,d="";for(c=0;c<b;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},k=function(a,b){var c=a;return a||(c=b?16893:33204),(65535&c)<<16},l=function(a,b){return 63&(a||0)},m=function(a,b,c,d,f,m){var n,o,p=a.file,q=a.compression,r=m!==g.utf8encode,s=e.transformTo("string",m(p.name)),t=e.transformTo("string",g.utf8encode(p.name)),u=p.comment,v=e.transformTo("string",m(u)),w=e.transformTo("string",g.utf8encode(u)),x=t.length!==p.name.length,y=w.length!==u.length,z="",A="",B="",C=p.dir,D=p.date,E={crc32:0,compressedSize:0,uncompressedSize:0};b&&!c||(E.crc32=a.crc32,E.compressedSize=a.compressedSize,E.uncompressedSize=a.uncompressedSize);var F=0;b&&(F|=8),r||!x&&!y||(F|=2048);var G=0,H=0;C&&(G|=16),"UNIX"===f?(H=798,G|=k(p.unixPermissions,C)):(H=20,G|=l(p.dosPermissions,C)),n=D.getUTCHours(),n<<=6,n|=D.getUTCMinutes(),n<<=5,n|=D.getUTCSeconds()/2,o=D.getUTCFullYear()-1980,o<<=4,o|=D.getUTCMonth()+1,o<<=5,o|=D.getUTCDate(),x&&(A=j(1,1)+j(h(s),4)+t,z+="up"+j(A.length,2)+A),y&&(B=j(1,1)+j(h(v),4)+w,z+="uc"+j(B.length,2)+B);var I="";I+="\n\0",I+=j(F,2),I+=q.magic,I+=j(n,2),I+=j(o,2),I+=j(E.crc32,4),I+=j(E.compressedSize,4),I+=j(E.uncompressedSize,4),I+=j(s.length,2),I+=j(z.length,2);var J=i.LOCAL_FILE_HEADER+I+s+z,K=i.CENTRAL_FILE_HEADER+j(H,2)+I+j(v.length,2)+"\0\0\0\0"+j(G,4)+j(d,4)+s+z+v;return{fileRecord:J,dirRecord:K}},n=function(a,b,c,d,f){var g="",h=e.transformTo("string",f(d));return g=i.CENTRAL_DIRECTORY_END+"\0\0\0\0"+j(a,2)+j(a,2)+j(b,4)+j(c,4)+j(h.length,2)+h},o=function(a){var b="";return b=i.DATA_DESCRIPTOR+j(a.crc32,4)+j(a.compressedSize,4)+j(a.uncompressedSize,4)};e.inherits(d,f),d.prototype.push=function(a){var b=a.meta.percent||0,c=this.entriesCount,d=this._sources.length;this.accumulate?this.contentBuffer.push(a):(this.bytesWritten+=a.data.length,f.prototype.push.call(this,{data:a.data,meta:{currentFile:this.currentFile,percent:c?(b+100*(c-d-1))/c:100}}))},d.prototype.openedSource=function(a){this.currentSourceOffset=this.bytesWritten,this.currentFile=a.file.name;var b=this.streamFiles&&!a.file.dir;if(b){var c=m(a,b,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:c.fileRecord,meta:{percent:0}})}else this.accumulate=!0},d.prototype.closedSource=function(a){this.accumulate=!1;var b=this.streamFiles&&!a.file.dir,c=m(a,b,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(c.dirRecord),b)this.push({data:o(a),meta:{percent:100}});else for(this.push({data:c.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},d.prototype.flush=function(){for(var a=this.bytesWritten,b=0;b<this.dirRecords.length;b++)this.push({data:this.dirRecords[b],meta:{percent:100}});var c=this.bytesWritten-a,d=n(this.dirRecords.length,c,a,this.zipComment,this.encodeFileName);this.push({data:d,meta:{percent:100}})},d.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},d.prototype.registerPrevious=function(a){this._sources.push(a);var b=this;return a.on("data",function(a){b.processChunk(a)}),a.on("end",function(){b.closedSource(b.previous.streamInfo),b._sources.length?b.prepareNextSource():b.end()}),a.on("error",function(a){b.error(a)}),this},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},d.prototype.error=function(a){var b=this._sources;if(!f.prototype.error.call(this,a))return!1;for(var c=0;c<b.length;c++)try{b[c].error(a)}catch(a){}return!0},d.prototype.lock=function(){f.prototype.lock.call(this);for(var a=this._sources,b=0;b<a.length;b++)a[b].lock()},b.exports=d},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(a,b,c){"use strict";var d=a("../compressions"),e=a("./ZipFileWorker"),f=function(a,b){var c=a||b,e=d[c];if(!e)throw new Error(c+" is not a valid compression method !");return e};c.generateWorker=function(a,b,c){var d=new e(b.streamFiles,c,b.platform,b.encodeFileName),g=0;try{a.forEach(function(a,c){g++;var e=f(c.options.compression,b.compression),h=c.options.compressionOptions||b.compressionOptions||{},i=c.dir,j=c.date;c._compressWorker(e,h).withStreamInfo("file",{name:a,dir:i,date:j,comment:c.comment||"",unixPermissions:c.unixPermissions,dosPermissions:c.dosPermissions}).pipe(d)}),d.entriesCount=g}catch(h){d.error(h)}return d}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(a,b,c){"use strict";function d(){if(!(this instanceof d))return new d;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files={},this.comment=null,this.root="",this.clone=function(){var a=new d;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a}}d.prototype=a("./object"),d.prototype.loadAsync=a("./load"),d.support=a("./support"),d.defaults=a("./defaults"),d.version="3.1.5",d.loadAsync=function(a,b){return(new d).loadAsync(a,b)},d.external=a("./external"),b.exports=d},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(a,b,c){"use strict";function d(a){return new f.Promise(function(b,c){var d=a.decompressed.getContentWorker().pipe(new i);d.on("error",function(a){c(a)}).on("end",function(){d.streamInfo.crc32!==a.decompressed.crc32?c(new Error("Corrupted zip : CRC32 mismatch")):b()}).resume()})}var e=a("./utils"),f=a("./external"),g=a("./utf8"),e=a("./utils"),h=a("./zipEntries"),i=a("./stream/Crc32Probe"),j=a("./nodejsUtils");b.exports=function(a,b){var c=this;return b=e.extend(b||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:g.utf8decode}),j.isNode&&j.isStream(a)?f.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):e.prepareContent("the loaded zip file",a,!0,b.optimizedBinaryString,b.base64).then(function(a){var c=new h(b);return c.load(a),c}).then(function(a){var c=[f.Promise.resolve(a)],e=a.files;if(b.checkCRC32)for(var g=0;g<e.length;g++)c.push(d(e[g]));return f.Promise.all(c)}).then(function(a){for(var d=a.shift(),e=d.files,f=0;f<e.length;f++){var g=e[f];c.file(g.fileNameStr,g.decompressed,{binary:!0,optimizedBinaryString:!0,date:g.date,dir:g.dir,comment:g.fileCommentStr.length?g.fileCommentStr:null,unixPermissions:g.unixPermissions,dosPermissions:g.dosPermissions,createFolders:b.createFolders})}return d.zipComment.length&&(c.comment=d.zipComment),c})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(a,b,c){"use strict";function d(a,b){f.call(this,"Nodejs stream input adapter for "+a),this._upstreamEnded=!1,this._bindStream(b)}var e=a("../utils"),f=a("../stream/GenericWorker");e.inherits(d,f),d.prototype._bindStream=function(a){var b=this;this._stream=a,a.pause(),a.on("data",function(a){b.push({data:a,meta:{percent:0}})}).on("error",function(a){b.isPaused?this.generatedError=a:b.error(a)}).on("end",function(){b.isPaused?b._upstreamEnded=!0:b.end()})},d.prototype.pause=function(){return!!f.prototype.pause.call(this)&&(this._stream.pause(),!0)},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},b.exports=d},{"../stream/GenericWorker":28,"../utils":32}],13:[function(a,b,c){"use strict";function d(a,b,c){e.call(this,b),this._helper=a;var d=this;a.on("data",function(a,b){d.push(a)||d._helper.pause(),c&&c(b)}).on("error",function(a){d.emit("error",a)}).on("end",function(){d.push(null)})}var e=a("readable-stream").Readable,f=a("../utils");f.inherits(d,e),d.prototype._read=function(){this._helper.resume()},b.exports=d},{"../utils":32,"readable-stream":16}],14:[function(a,b,c){"use strict";b.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(a,b){return new Buffer(a,b)},allocBuffer:function(a){return Buffer.alloc?Buffer.alloc(a):new Buffer(a)},isBuffer:function(a){return Buffer.isBuffer(a)},isStream:function(a){return a&&"function"==typeof a.on&&"function"==typeof a.pause&&"function"==typeof a.resume}}},{}],15:[function(a,b,c){"use strict";function d(a){return"[object RegExp]"===Object.prototype.toString.call(a)}var e=a("./utf8"),f=a("./utils"),g=a("./stream/GenericWorker"),h=a("./stream/StreamHelper"),i=a("./defaults"),j=a("./compressedObject"),k=a("./zipObject"),l=a("./generate"),m=a("./nodejsUtils"),n=a("./nodejs/NodejsStreamInputAdapter"),o=function(a,b,c){var d,e=f.getTypeOf(b),h=f.extend(c||{},i);h.date=h.date||new Date,null!==h.compression&&(h.compression=h.compression.toUpperCase()),"string"==typeof h.unixPermissions&&(h.unixPermissions=parseInt(h.unixPermissions,8)),h.unixPermissions&&16384&h.unixPermissions&&(h.dir=!0),h.dosPermissions&&16&h.dosPermissions&&(h.dir=!0),h.dir&&(a=q(a)),h.createFolders&&(d=p(a))&&r.call(this,d,!0);var l="string"===e&&h.binary===!1&&h.base64===!1;c&&"undefined"!=typeof c.binary||(h.binary=!l);var o=b instanceof j&&0===b.uncompressedSize;(o||h.dir||!b||0===b.length)&&(h.base64=!1,h.binary=!0,b="",h.compression="STORE",e="string");var s=null;s=b instanceof j||b instanceof g?b:m.isNode&&m.isStream(b)?new n(a,b):f.prepareContent(a,b,h.binary,h.optimizedBinaryString,h.base64);var t=new k(a,s,h);this.files[a]=t},p=function(a){"/"===a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},q=function(a){return"/"!==a.slice(-1)&&(a+="/"),a},r=function(a,b){return b="undefined"!=typeof b?b:i.createFolders,a=q(a),this.files[a]||o.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},s={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(a){var b,c,d;for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],c=b.slice(this.root.length,b.length),c&&b.slice(0,this.root.length)===this.root&&a(c,d))},filter:function(a){var b=[];return this.forEach(function(c,d){a(c,d)&&b.push(d)}),b},file:function(a,b,c){if(1===arguments.length){if(d(a)){var e=a;return this.filter(function(a,b){return!b.dir&&e.test(a)})}var f=this.files[this.root+a];return f&&!f.dir?f:null}return a=this.root+a,o.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(d(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=r.call(this,b),e=this.clone();return e.root=c.name,e},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!==a.slice(-1)&&(a+="/"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(a){var b,c={};try{if(c=f.extend(a||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:e.utf8encode}),c.type=c.type.toLowerCase(),c.compression=c.compression.toUpperCase(),"binarystring"===c.type&&(c.type="string"),!c.type)throw new Error("No output type specified.");f.checkSupport(c.type),"darwin"!==c.platform&&"freebsd"!==c.platform&&"linux"!==c.platform&&"sunos"!==c.platform||(c.platform="UNIX"),"win32"===c.platform&&(c.platform="DOS");var d=c.comment||this.comment||"";b=l.generateWorker(this,c,d)}catch(i){b=new g("error"),b.error(i)}return new h(b,c.type||"string",c.mimeType)},generateAsync:function(a,b){return this.generateInternalStream(a).accumulate(b)},generateNodeStream:function(a,b){return a=a||{},a.type||(a.type="nodebuffer"),this.generateInternalStream(a).toNodejsStream(b)}};b.exports=s},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(a,b,c){b.exports=a("stream")},{stream:void 0}],17:[function(a,b,c){"use strict";function d(a){e.call(this,a);for(var b=0;b<this.data.length;b++)a[b]=255&a[b]}var e=a("./DataReader"),f=a("../utils");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data[this.zero+a]},d.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f-this.zero;return-1},d.prototype.readAndCheckSignature=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.readData(4);return b===f[0]&&c===f[1]&&d===f[2]&&e===f[3]},d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return[];var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./DataReader":18}],18:[function(a,b,c){"use strict";function d(a){this.data=a,this.length=a.length,this.index=0,this.zero=0}var e=a("../utils");d.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<this.zero+a||a<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(a){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return e.transformTo("string",this.readData(a))},readData:function(a){},lastIndexOfSignature:function(a){},readAndCheckSignature:function(a){},readDate:function(){var a=this.readInt(4);return new Date(Date.UTC((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1))}},b.exports=d},{"../utils":32}],19:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./Uint8ArrayReader"),f=a("../utils");f.inherits(d,e),d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./DataReader"),f=a("../utils");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data.charCodeAt(this.zero+a)},d.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)-this.zero},d.prototype.readAndCheckSignature=function(a){var b=this.readData(4);return a===b},d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./DataReader":18}],21:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./ArrayReader"),f=a("../utils");f.inherits(d,e),d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./ArrayReader":17}],22:[function(a,b,c){"use strict";var d=a("../utils"),e=a("../support"),f=a("./ArrayReader"),g=a("./StringReader"),h=a("./NodeBufferReader"),i=a("./Uint8ArrayReader");b.exports=function(a){var b=d.getTypeOf(a);return d.checkSupport(b),"string"!==b||e.uint8array?"nodebuffer"===b?new h(a):e.uint8array?new i(d.transformTo("uint8array",a)):new f(d.transformTo("array",a)):new g(a)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],24:[function(a,b,c){"use strict";function d(a){e.call(this,"ConvertWorker to "+a),this.destType=a}var e=a("./GenericWorker"),f=a("../utils");f.inherits(d,e),d.prototype.processChunk=function(a){this.push({data:f.transformTo(this.destType,a.data),meta:a.meta})},b.exports=d},{"../utils":32,"./GenericWorker":28}],25:[function(a,b,c){"use strict";function d(){e.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}var e=a("./GenericWorker"),f=a("../crc32"),g=a("../utils");g.inherits(d,e),d.prototype.processChunk=function(a){this.streamInfo.crc32=f(a.data,this.streamInfo.crc32||0),this.push(a)},b.exports=d},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(a,b,c){"use strict";function d(a){f.call(this,"DataLengthProbe for "+a),this.propName=a,this.withStreamInfo(a,0)}var e=a("../utils"),f=a("./GenericWorker");e.inherits(d,f),d.prototype.processChunk=function(a){if(a){var b=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=b+a.data.length}f.prototype.processChunk.call(this,a)},b.exports=d},{"../utils":32,"./GenericWorker":28}],27:[function(a,b,c){"use strict";function d(a){f.call(this,"DataWorker");var b=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,a.then(function(a){b.dataIsReady=!0,b.data=a,b.max=a&&a.length||0,b.type=e.getTypeOf(a),b.isPaused||b._tickAndRepeat()},function(a){b.error(a)})}var e=a("../utils"),f=a("./GenericWorker"),g=16384;e.inherits(d,f),d.prototype.cleanUp=function(){f.prototype.cleanUp.call(this),this.data=null},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,e.delay(this._tickAndRepeat,[],this)),!0)},d.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(e.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},d.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var a=g,b=null,c=Math.min(this.max,this.index+a);if(this.index>=this.max)return this.end();switch(this.type){case"string":b=this.data.substring(this.index,c);break;case"uint8array":b=this.data.subarray(this.index,c);break;case"array":case"nodebuffer":b=this.data.slice(this.index,c)}return this.index=c,this.push({data:b,meta:{percent:this.max?this.index/this.max*100:0}})},b.exports=d},{"../utils":32,"./GenericWorker":28}],28:[function(a,b,c){"use strict";function d(a){this.name=a||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}d.prototype={push:function(a){this.emit("data",a)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(a){this.emit("error",a)}return!0},error:function(a){return!this.isFinished&&(this.isPaused?this.generatedError=a:(this.isFinished=!0,this.emit("error",a),this.previous&&this.previous.error(a),this.cleanUp()),!0)},on:function(a,b){return this._listeners[a].push(b),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(a,b){if(this._listeners[a])for(var c=0;c<this._listeners[a].length;c++)this._listeners[a][c].call(this,b)},pipe:function(a){return a.registerPrevious(this)},registerPrevious:function(a){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=a.streamInfo,this.mergeStreamInfo(),this.previous=a;var b=this;return a.on("data",function(a){b.processChunk(a)}),a.on("end",function(){b.end()}),a.on("error",function(a){b.error(a)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;this.isPaused=!1;var a=!1;return this.generatedError&&(this.error(this.generatedError),a=!0),this.previous&&this.previous.resume(),!a},flush:function(){},processChunk:function(a){this.push(a)},withStreamInfo:function(a,b){return this.extraStreamInfo[a]=b,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var a in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(a)&&(this.streamInfo[a]=this.extraStreamInfo[a])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var a="Worker "+this.name;return this.previous?this.previous+" -> "+a:a}},b.exports=d},{}],29:[function(a,b,c){"use strict";function d(a,b,c){switch(a){case"blob":return h.newBlob(h.transformTo("arraybuffer",b),c);case"base64":return k.encode(b);default:return h.transformTo(a,b)}}function e(a,b){var c,d=0,e=null,f=0;for(c=0;c<b.length;c++)f+=b[c].length;switch(a){case"string":return b.join("");case"array":return Array.prototype.concat.apply([],b);case"uint8array":for(e=new Uint8Array(f),c=0;c<b.length;c++)e.set(b[c],d),d+=b[c].length;return e;case"nodebuffer":return Buffer.concat(b);default:throw new Error("concat : unsupported type '"+a+"'")}}function f(a,b){return new m.Promise(function(c,f){var g=[],h=a._internalType,i=a._outputType,j=a._mimeType;a.on("data",function(a,c){g.push(a),b&&b(c)}).on("error",function(a){g=[],f(a)}).on("end",function(){try{var a=d(i,e(h,g),j);c(a)}catch(b){f(b)}g=[]}).resume()})}function g(a,b,c){var d=b;switch(b){case"blob":case"arraybuffer":d="uint8array";break;case"base64":d="string"}try{this._internalType=d,this._outputType=b,this._mimeType=c,h.checkSupport(d),this._worker=a.pipe(new i(d)),a.lock()}catch(e){this._worker=new j("error"),this._worker.error(e)}}var h=a("../utils"),i=a("./ConvertWorker"),j=a("./GenericWorker"),k=a("../base64"),l=a("../support"),m=a("../external"),n=null;if(l.nodestream)try{n=a("../nodejs/NodejsStreamOutputAdapter")}catch(o){}g.prototype={accumulate:function(a){return f(this,a)},on:function(a,b){var c=this;return"data"===a?this._worker.on(a,function(a){b.call(c,a.data,a.meta)}):this._worker.on(a,function(){h.delay(b,arguments,c)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(a){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new n(this,{objectMode:"nodebuffer"!==this._outputType},a)}},b.exports=g},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(a,b,c){"use strict";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer="undefined"!=typeof Buffer,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var d=new ArrayBuffer(0);try{c.blob=0===new Blob([d],{type:"application/zip"}).size}catch(e){try{var f=self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder,g=new f;g.append(d),c.blob=0===g.getBlob("application/zip").size}catch(e){c.blob=!1}}}try{c.nodestream=!!a("readable-stream").Readable}catch(e){c.nodestream=!1}},{"readable-stream":16}],31:[function(a,b,c){"use strict";function d(){i.call(this,"utf-8 decode"),this.leftOver=null}function e(){i.call(this,"utf-8 encode")}for(var f=a("./utils"),g=a("./support"),h=a("./nodejsUtils"),i=a("./stream/GenericWorker"),j=new Array(256),k=0;k<256;k++)j[k]=k>=252?6:k>=248?5:k>=240?4:k>=224?3:k>=192?2:1;j[254]=j[254]=1;var l=function(a){var b,c,d,e,f,h=a.length,i=0;for(e=0;e<h;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=g.uint8array?new Uint8Array(i):new Array(i),f=0,e=0;f<i;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),c<128?b[f++]=c:c<2048?(b[f++]=192|c>>>6,b[f++]=128|63&c):c<65536?(b[f++]=224|c>>>12,b[f++]=128|c>>>6&63,b[f++]=128|63&c):(b[f++]=240|c>>>18,b[f++]=128|c>>>12&63,b[f++]=128|c>>>6&63,b[f++]=128|63&c);return b},m=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+j[a[c]]>b?c:b},n=function(a){var b,c,d,e,g=a.length,h=new Array(2*g);for(c=0,b=0;b<g;)if(d=a[b++],d<128)h[c++]=d;else if(e=j[d],e>4)h[c++]=65533,b+=e-1;else{for(d&=2===e?31:3===e?15:7;e>1&&b<g;)d=d<<6|63&a[b++],e--;e>1?h[c++]=65533:d<65536?h[c++]=d:(d-=65536,h[c++]=55296|d>>10&1023,h[c++]=56320|1023&d)}return h.length!==c&&(h.subarray?h=h.subarray(0,c):h.length=c),f.applyFromCharCode(h)};c.utf8encode=function(a){return g.nodebuffer?h.newBufferFrom(a,"utf-8"):l(a)},c.utf8decode=function(a){return g.nodebuffer?f.transformTo("nodebuffer",a).toString("utf-8"):(a=f.transformTo(g.uint8array?"uint8array":"array",a),n(a))},f.inherits(d,i),d.prototype.processChunk=function(a){var b=f.transformTo(g.uint8array?"uint8array":"array",a.data);if(this.leftOver&&this.leftOver.length){if(g.uint8array){var d=b;b=new Uint8Array(d.length+this.leftOver.length),b.set(this.leftOver,0),b.set(d,this.leftOver.length)}else b=this.leftOver.concat(b);this.leftOver=null}var e=m(b),h=b;e!==b.length&&(g.uint8array?(h=b.subarray(0,e),this.leftOver=b.subarray(e,b.length)):(h=b.slice(0,e),this.leftOver=b.slice(e,b.length))),this.push({data:c.utf8decode(h),meta:a.meta})},d.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:c.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},c.Utf8DecodeWorker=d,f.inherits(e,i),e.prototype.processChunk=function(a){this.push({data:c.utf8encode(a.data),meta:a.meta})},c.Utf8EncodeWorker=e},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(a,b,c){"use strict";function d(a){var b=null;return b=i.uint8array?new Uint8Array(a.length):new Array(a.length),f(a,b)}function e(a){return a}function f(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function g(a){var b=65536,d=c.getTypeOf(a),e=!0;if("uint8array"===d?e=n.applyCanBeUsed.uint8array:"nodebuffer"===d&&(e=n.applyCanBeUsed.nodebuffer),e)for(;b>1;)try{return n.stringifyByChunk(a,d,b)}catch(f){b=Math.floor(b/2)}return n.stringifyByChar(a)}function h(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];
return b}var i=a("./support"),j=a("./base64"),k=a("./nodejsUtils"),l=a("core-js/library/fn/set-immediate"),m=a("./external");c.newBlob=function(a,b){c.checkSupport("blob");try{return new Blob([a],{type:b})}catch(d){try{var e=self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder,f=new e;return f.append(a),f.getBlob(b)}catch(d){throw new Error("Bug : can't construct the Blob.")}}};var n={stringifyByChunk:function(a,b,c){var d=[],e=0,f=a.length;if(f<=c)return String.fromCharCode.apply(null,a);for(;e<f;)"array"===b||"nodebuffer"===b?d.push(String.fromCharCode.apply(null,a.slice(e,Math.min(e+c,f)))):d.push(String.fromCharCode.apply(null,a.subarray(e,Math.min(e+c,f)))),e+=c;return d.join("")},stringifyByChar:function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(a[c]);return b},applyCanBeUsed:{uint8array:function(){try{return i.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(a){return!1}}(),nodebuffer:function(){try{return i.nodebuffer&&1===String.fromCharCode.apply(null,k.allocBuffer(1)).length}catch(a){return!1}}()}};c.applyFromCharCode=g;var o={};o.string={string:e,array:function(a){return f(a,new Array(a.length))},arraybuffer:function(a){return o.string.uint8array(a).buffer},uint8array:function(a){return f(a,new Uint8Array(a.length))},nodebuffer:function(a){return f(a,k.allocBuffer(a.length))}},o.array={string:g,array:e,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBufferFrom(a)}},o.arraybuffer={string:function(a){return g(new Uint8Array(a))},array:function(a){return h(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:e,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBufferFrom(new Uint8Array(a))}},o.uint8array={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:e,nodebuffer:function(a){return k.newBufferFrom(a)}},o.nodebuffer={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){return o.nodebuffer.uint8array(a).buffer},uint8array:function(a){return h(a,new Uint8Array(a.length))},nodebuffer:e},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=o[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":i.nodebuffer&&k.isBuffer(a)?"nodebuffer":i.uint8array&&a instanceof Uint8Array?"uint8array":i.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=i[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this platform")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(b<16?"0":"")+b.toString(16).toUpperCase();return d},c.delay=function(a,b,c){l(function(){a.apply(c||null,b||[])})},c.inherits=function(a,b){var c=function(){};c.prototype=b.prototype,a.prototype=new c},c.extend=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c},c.prepareContent=function(a,b,e,f,g){var h=m.Promise.resolve(b).then(function(a){var b=i.blob&&(a instanceof Blob||["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(a))!==-1);return b&&"undefined"!=typeof FileReader?new m.Promise(function(b,c){var d=new FileReader;d.onload=function(a){b(a.target.result)},d.onerror=function(a){c(a.target.error)},d.readAsArrayBuffer(a)}):a});return h.then(function(b){var h=c.getTypeOf(b);return h?("arraybuffer"===h?b=c.transformTo("uint8array",b):"string"===h&&(g?b=j.decode(b):e&&f!==!0&&(b=d(b))),b):m.Promise.reject(new Error("Can't read the data of '"+a+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"core-js/library/fn/set-immediate":36}],33:[function(a,b,c){"use strict";function d(a){this.files=[],this.loadOptions=a}var e=a("./reader/readerFor"),f=a("./utils"),g=a("./signature"),h=a("./zipEntry"),i=(a("./utf8"),a("./support"));d.prototype={checkSignature:function(a){if(!this.reader.readAndCheckSignature(a)){this.reader.index-=4;var b=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+f.pretty(b)+", expected "+f.pretty(a)+")")}},isSignature:function(a,b){var c=this.reader.index;this.reader.setIndex(a);var d=this.reader.readString(4),e=d===b;return this.reader.setIndex(c),e},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var a=this.reader.readData(this.zipCommentLength),b=i.uint8array?"uint8array":"array",c=f.transformTo(b,a);this.zipComment=this.loadOptions.decodeFileName(c)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;e<d;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readData(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(g.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8(),b.processAttributes()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(g.CENTRAL_FILE_HEADER);)a=new h({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(g.CENTRAL_DIRECTORY_END);if(a<0){var b=!this.isSignature(0,g.LOCAL_FILE_HEADER);throw b?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory")}this.reader.setIndex(a);var c=a;if(this.checkSignature(g.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===f.MAX_VALUE_16BITS||this.diskWithCentralDirStart===f.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===f.MAX_VALUE_16BITS||this.centralDirRecords===f.MAX_VALUE_16BITS||this.centralDirSize===f.MAX_VALUE_32BITS||this.centralDirOffset===f.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),a<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(a),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,g.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var d=this.centralDirOffset+this.centralDirSize;this.zip64&&(d+=20,d+=12+this.zip64EndOfCentralSize);var e=c-d;if(e>0)this.isSignature(c,g.CENTRAL_FILE_HEADER)||(this.reader.zero=e);else if(e<0)throw new Error("Corrupted zip: missing "+Math.abs(e)+" bytes.")},prepareReader:function(a){this.reader=e(a)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=d},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(a,b,c){"use strict";function d(a,b){this.options=a,this.loadOptions=b}var e=a("./reader/readerFor"),f=a("./utils"),g=a("./compressedObject"),h=a("./crc32"),i=a("./utf8"),j=a("./compressions"),k=a("./support"),l=0,m=3,n=function(a){for(var b in j)if(j.hasOwnProperty(b)&&j[b].magic===a)return j[b];return null};d.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readData(this.fileNameLength),a.skip(c),this.compressedSize===-1||this.uncompressedSize===-1)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(b=n(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+f.pretty(this.compressionMethod)+" unknown (inner file : "+f.transformTo("string",this.fileName)+")");this.decompressed=new g(this.compressedSize,this.uncompressedSize,this.crc32,b,a.readData(this.compressedSize))},readCentralPart:function(a){this.versionMadeBy=a.readInt(2),a.skip(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4);var b=a.readInt(2);if(this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");a.skip(b),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var a=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),a===l&&(this.dosPermissions=63&this.externalFileAttributes),a===m&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(a){if(this.extraFields[1]){var b=e(this.extraFields[1].value);this.uncompressedSize===f.MAX_VALUE_32BITS&&(this.uncompressedSize=b.readInt(8)),this.compressedSize===f.MAX_VALUE_32BITS&&(this.compressedSize=b.readInt(8)),this.localHeaderOffset===f.MAX_VALUE_32BITS&&(this.localHeaderOffset=b.readInt(8)),this.diskNumberStart===f.MAX_VALUE_32BITS&&(this.diskNumberStart=b.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});a.index<e;)b=a.readInt(2),c=a.readInt(2),d=a.readData(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){var a=k.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=i.utf8decode(this.fileName),this.fileCommentStr=i.utf8decode(this.fileComment);else{var b=this.findExtraFieldUnicodePath();if(null!==b)this.fileNameStr=b;else{var c=f.transformTo(a,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(c)}var d=this.findExtraFieldUnicodeComment();if(null!==d)this.fileCommentStr=d;else{var e=f.transformTo(a,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(e)}}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileName)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileComment)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null}},b.exports=d},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(a,b,c){"use strict";var d=a("./stream/StreamHelper"),e=a("./stream/DataWorker"),f=a("./utf8"),g=a("./compressedObject"),h=a("./stream/GenericWorker"),i=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this.unixPermissions=c.unixPermissions,this.dosPermissions=c.dosPermissions,this._data=b,this._dataBinary=c.binary,this.options={compression:c.compression,compressionOptions:c.compressionOptions}};i.prototype={internalStream:function(a){var b=null,c="string";try{if(!a)throw new Error("No output type specified.");c=a.toLowerCase();var e="string"===c||"text"===c;"binarystring"!==c&&"text"!==c||(c="string"),b=this._decompressWorker();var g=!this._dataBinary;g&&!e&&(b=b.pipe(new f.Utf8EncodeWorker)),!g&&e&&(b=b.pipe(new f.Utf8DecodeWorker))}catch(i){b=new h("error"),b.error(i)}return new d(b,c,"")},async:function(a,b){return this.internalStream(a).accumulate(b)},nodeStream:function(a,b){return this.internalStream(a||"nodebuffer").toNodejsStream(b)},_compressWorker:function(a,b){if(this._data instanceof g&&this._data.compression.magic===a.magic)return this._data.getCompressedWorker();var c=this._decompressWorker();return this._dataBinary||(c=c.pipe(new f.Utf8EncodeWorker)),g.createWorkerFrom(c,a,b)},_decompressWorker:function(){return this._data instanceof g?this._data.getContentWorker():this._data instanceof h?this._data:new e(this._data)}};for(var j=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],k=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},l=0;l<j.length;l++)i.prototype[j[l]]=k;b.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(a,b,c){a("../modules/web.immediate"),b.exports=a("../modules/_core").setImmediate},{"../modules/_core":40,"../modules/web.immediate":56}],37:[function(a,b,c){b.exports=function(a){if("function"!=typeof a)throw TypeError(a+" is not a function!");return a}},{}],38:[function(a,b,c){var d=a("./_is-object");b.exports=function(a){if(!d(a))throw TypeError(a+" is not an object!");return a}},{"./_is-object":51}],39:[function(a,b,c){var d={}.toString;b.exports=function(a){return d.call(a).slice(8,-1)}},{}],40:[function(a,b,c){var d=b.exports={version:"2.3.0"};"number"==typeof __e&&(__e=d)},{}],41:[function(a,b,c){var d=a("./_a-function");b.exports=function(a,b,c){if(d(a),void 0===b)return a;switch(c){case 1:return function(c){return a.call(b,c)};case 2:return function(c,d){return a.call(b,c,d)};case 3:return function(c,d,e){return a.call(b,c,d,e)}}return function(){return a.apply(b,arguments)}}},{"./_a-function":37}],42:[function(a,b,c){b.exports=!a("./_fails")(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},{"./_fails":45}],43:[function(a,b,c){var d=a("./_is-object"),e=a("./_global").document,f=d(e)&&d(e.createElement);b.exports=function(a){return f?e.createElement(a):{}}},{"./_global":46,"./_is-object":51}],44:[function(a,b,c){var d=a("./_global"),e=a("./_core"),f=a("./_ctx"),g=a("./_hide"),h="prototype",i=function(a,b,c){var j,k,l,m=a&i.F,n=a&i.G,o=a&i.S,p=a&i.P,q=a&i.B,r=a&i.W,s=n?e:e[b]||(e[b]={}),t=s[h],u=n?d:o?d[b]:(d[b]||{})[h];n&&(c=b);for(j in c)k=!m&&u&&void 0!==u[j],k&&j in s||(l=k?u[j]:c[j],s[j]=n&&"function"!=typeof u[j]?c[j]:q&&k?f(l,d):r&&u[j]==l?function(a){var b=function(b,c,d){if(this instanceof a){switch(arguments.length){case 0:return new a;case 1:return new a(b);case 2:return new a(b,c)}return new a(b,c,d)}return a.apply(this,arguments)};return b[h]=a[h],b}(l):p&&"function"==typeof l?f(Function.call,l):l,p&&((s.virtual||(s.virtual={}))[j]=l,a&i.R&&t&&!t[j]&&g(t,j,l)))};i.F=1,i.G=2,i.S=4,i.P=8,i.B=16,i.W=32,i.U=64,i.R=128,b.exports=i},{"./_core":40,"./_ctx":41,"./_global":46,"./_hide":47}],45:[function(a,b,c){b.exports=function(a){try{return!!a()}catch(b){return!0}}},{}],46:[function(a,b,c){var d=b.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=d)},{}],47:[function(a,b,c){var d=a("./_object-dp"),e=a("./_property-desc");b.exports=a("./_descriptors")?function(a,b,c){return d.f(a,b,e(1,c))}:function(a,b,c){return a[b]=c,a}},{"./_descriptors":42,"./_object-dp":52,"./_property-desc":53}],48:[function(a,b,c){b.exports=a("./_global").document&&document.documentElement},{"./_global":46}],49:[function(a,b,c){b.exports=!a("./_descriptors")&&!a("./_fails")(function(){return 7!=Object.defineProperty(a("./_dom-create")("div"),"a",{get:function(){return 7}}).a})},{"./_descriptors":42,"./_dom-create":43,"./_fails":45}],50:[function(a,b,c){b.exports=function(a,b,c){var d=void 0===c;switch(b.length){case 0:return d?a():a.call(c);case 1:return d?a(b[0]):a.call(c,b[0]);case 2:return d?a(b[0],b[1]):a.call(c,b[0],b[1]);case 3:return d?a(b[0],b[1],b[2]):a.call(c,b[0],b[1],b[2]);case 4:return d?a(b[0],b[1],b[2],b[3]):a.call(c,b[0],b[1],b[2],b[3])}return a.apply(c,b)}},{}],51:[function(a,b,c){b.exports=function(a){return"object"==typeof a?null!==a:"function"==typeof a}},{}],52:[function(a,b,c){var d=a("./_an-object"),e=a("./_ie8-dom-define"),f=a("./_to-primitive"),g=Object.defineProperty;c.f=a("./_descriptors")?Object.defineProperty:function(a,b,c){if(d(a),b=f(b,!0),d(c),e)try{return g(a,b,c)}catch(h){}if("get"in c||"set"in c)throw TypeError("Accessors not supported!");return"value"in c&&(a[b]=c.value),a}},{"./_an-object":38,"./_descriptors":42,"./_ie8-dom-define":49,"./_to-primitive":55}],53:[function(a,b,c){b.exports=function(a,b){return{enumerable:!(1&a),configurable:!(2&a),writable:!(4&a),value:b}}},{}],54:[function(a,b,c){var d,e,f,g=a("./_ctx"),h=a("./_invoke"),i=a("./_html"),j=a("./_dom-create"),k=a("./_global"),l=k.process,m=k.setImmediate,n=k.clearImmediate,o=k.MessageChannel,p=0,q={},r="onreadystatechange",s=function(){var a=+this;if(q.hasOwnProperty(a)){var b=q[a];delete q[a],b()}},t=function(a){s.call(a.data)};m&&n||(m=function(a){for(var b=[],c=1;arguments.length>c;)b.push(arguments[c++]);return q[++p]=function(){h("function"==typeof a?a:Function(a),b)},d(p),p},n=function(a){delete q[a]},"process"==a("./_cof")(l)?d=function(a){l.nextTick(g(s,a,1))}:o?(e=new o,f=e.port2,e.port1.onmessage=t,d=g(f.postMessage,f,1)):k.addEventListener&&"function"==typeof postMessage&&!k.importScripts?(d=function(a){k.postMessage(a+"","*")},k.addEventListener("message",t,!1)):d=r in j("script")?function(a){i.appendChild(j("script"))[r]=function(){i.removeChild(this),s.call(a)}}:function(a){setTimeout(g(s,a,1),0)}),b.exports={set:m,clear:n}},{"./_cof":39,"./_ctx":41,"./_dom-create":43,"./_global":46,"./_html":48,"./_invoke":50}],55:[function(a,b,c){var d=a("./_is-object");b.exports=function(a,b){if(!d(a))return a;var c,e;if(b&&"function"==typeof(c=a.toString)&&!d(e=c.call(a)))return e;if("function"==typeof(c=a.valueOf)&&!d(e=c.call(a)))return e;if(!b&&"function"==typeof(c=a.toString)&&!d(e=c.call(a)))return e;throw TypeError("Can't convert object to primitive value")}},{"./_is-object":51}],56:[function(a,b,c){var d=a("./_export"),e=a("./_task");d(d.G+d.B,{setImmediate:e.set,clearImmediate:e.clear})},{"./_export":44,"./_task":54}],57:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||"undefined"==typeof a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],58:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(e){return p.reject(a,e)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&("object"==typeof a||"function"==typeof a)&&"function"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);"error"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status="success"}catch(d){c.status="error",c.value=d}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a("immediate"),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=e,e.prototype["catch"]=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){var e=this.state===r?a:b;g(c,e,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n},{immediate:57}],59:[function(a,b,c){"use strict";var d=a("./lib/utils/common").assign,e=a("./lib/deflate"),f=a("./lib/inflate"),g=a("./lib/zlib/constants"),h={};d(h,e,f,g),b.exports=h},{"./lib/deflate":60,"./lib/inflate":61,"./lib/utils/common":62,"./lib/zlib/constants":65}],60:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=i.assign({level:s,method:u,chunkSize:16384,windowBits:15,memLevel:8,strategy:t,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=h.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==p)throw new Error(k[c]);if(b.header&&h.deflateSetHeader(this.strm,b.header),b.dictionary){var e;if(e="string"==typeof b.dictionary?j.string2buf(b.dictionary):"[object ArrayBuffer]"===m.call(b.dictionary)?new Uint8Array(b.dictionary):b.dictionary,c=h.deflateSetDictionary(this.strm,e),c!==p)throw new Error(k[c]);this._dict_set=!0}}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg||k[c.err];return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}function g(a,b){return b=b||{},b.gzip=!0,e(a,b)}var h=a("./zlib/deflate"),i=a("./utils/common"),j=a("./utils/strings"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=Object.prototype.toString,n=0,o=4,p=0,q=1,r=2,s=-1,t=0,u=8;d.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?o:n,"string"==typeof a?e.input=j.string2buf(a):"[object ArrayBuffer]"===m.call(a)?e.input=new Uint8Array(a):e.input=a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new i.Buf8(f),e.next_out=0,e.avail_out=f),c=h.deflate(e,d),c!==q&&c!==p)return this.onEnd(c),this.ended=!0,!1;0!==e.avail_out&&(0!==e.avail_in||d!==o&&d!==r)||("string"===this.options.to?this.onData(j.buf2binstring(i.shrinkBuf(e.output,e.next_out))):this.onData(i.shrinkBuf(e.output,e.next_out)))}while((e.avail_in>0||0===e.avail_out)&&c!==q);return d===o?(c=h.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===p):d!==r||(this.onEnd(p),e.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===p&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=d,c.deflate=e,c.deflateRaw=f,c.gzip=g},{"./utils/common":62,"./utils/strings":63,"./zlib/deflate":67,"./zlib/messages":72,"./zlib/zstream":74}],61:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=h.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=g.inflateInit2(this.strm,b.windowBits);if(c!==j.Z_OK)throw new Error(k[c]);this.header=new m,g.inflateGetHeader(this.strm,this.header)}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg||k[c.err];return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}var g=a("./zlib/inflate"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/constants"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=a("./zlib/gzheader"),n=Object.prototype.toString;d.prototype.push=function(a,b){var c,d,e,f,k,l,m=this.strm,o=this.options.chunkSize,p=this.options.dictionary,q=!1;if(this.ended)return!1;d=b===~~b?b:b===!0?j.Z_FINISH:j.Z_NO_FLUSH,"string"==typeof a?m.input=i.binstring2buf(a):"[object ArrayBuffer]"===n.call(a)?m.input=new Uint8Array(a):m.input=a,m.next_in=0,m.avail_in=m.input.length;do{if(0===m.avail_out&&(m.output=new h.Buf8(o),m.next_out=0,m.avail_out=o),c=g.inflate(m,j.Z_NO_FLUSH),c===j.Z_NEED_DICT&&p&&(l="string"==typeof p?i.string2buf(p):"[object ArrayBuffer]"===n.call(p)?new Uint8Array(p):p,c=g.inflateSetDictionary(this.strm,l)),c===j.Z_BUF_ERROR&&q===!0&&(c=j.Z_OK,q=!1),c!==j.Z_STREAM_END&&c!==j.Z_OK)return this.onEnd(c),this.ended=!0,!1;m.next_out&&(0!==m.avail_out&&c!==j.Z_STREAM_END&&(0!==m.avail_in||d!==j.Z_FINISH&&d!==j.Z_SYNC_FLUSH)||("string"===this.options.to?(e=i.utf8border(m.output,m.next_out),f=m.next_out-e,k=i.buf2string(m.output,e),m.next_out=f,m.avail_out=o-f,f&&h.arraySet(m.output,m.output,e,f,0),this.onData(k)):this.onData(h.shrinkBuf(m.output,m.next_out)))),0===m.avail_in&&0===m.avail_out&&(q=!0)}while((m.avail_in>0||0===m.avail_out)&&c!==j.Z_STREAM_END);return c===j.Z_STREAM_END&&(d=j.Z_FINISH),d===j.Z_FINISH?(c=g.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===j.Z_OK):d!==j.Z_SYNC_FLUSH||(this.onEnd(j.Z_OK),m.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===j.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=d,c.inflate=e,c.inflateRaw=f,c.ungzip=e},{"./utils/common":62,"./utils/strings":63,"./zlib/constants":65,"./zlib/gzheader":68,"./zlib/inflate":70,"./zlib/messages":72,"./zlib/zstream":74}],62:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;b<c;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;b<c;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],63:[function(a,b,c){"use strict";function d(a,b){if(b<65537&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c="",d=0;d<b;d++)c+=String.fromCharCode(a[d]);return c}var e=a("./common"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;j<256;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;f<h;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=new e.Buf8(i),g=0,f=0;g<i;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),c<128?b[g++]=c:c<2048?(b[g++]=192|c>>>6,b[g++]=128|63&c):c<65536?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;c<d;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;c<h;)if(f=a[c++],f<128)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&c<h;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:f<65536?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+i[a[c]]>b?c:b}},{"./common":62}],64:[function(a,b,c){"use strict";function d(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0;
}b.exports=d},{}],65:[function(a,b,c){"use strict";b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],66:[function(a,b,c){"use strict";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=f,g=d+c;a^=-1;for(var h=d;h<g;h++)a=a>>>8^e[255&(a^b[h])];return a^-1}var f=d();b.exports=e},{}],67:[function(a,b,c){"use strict";function d(a,b){return a.msg=I[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(E.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){F._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,E.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=G(a.adler,b,e,c):2===a.state.wrap&&(a.adler=H(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-la?a.strstart-(a.w_size-la):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ka,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&f<m);if(d=ka-(m-f),f=m-ka,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-la)){E.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=ja)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+ja-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<ja)););}while(a.lookahead<la&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===J)return ua;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return ua;if(a.strstart-a.block_start>=a.w_size-la&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?ua:ua}function o(a,b){for(var c,d;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c)),a.match_length>=ja)if(d=F._tr_tally(a,a.strstart-a.match_start,a.match_length-ja),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=ja){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function p(a,b){for(var c,d,e;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=ja-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===U||a.match_length===ja&&a.strstart-a.match_start>4096)&&(a.match_length=ja-1)),a.prev_length>=ja&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-ja,d=F._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-ja),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=ja-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return ua}else if(a.match_available){if(d=F._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return ua}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=F._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ka){if(m(a),a.lookahead<=ka&&b===J)return ua;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=ja&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ka;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&e<f);a.match_length=ka-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=ja?(c=F._tr_tally(a,1,a.match_length-ja),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===J)return ua;break}if(a.match_length=0,c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function s(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e}function t(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=D[a.level].max_lazy,a.good_match=D[a.level].good_length,a.nice_match=D[a.level].nice_length,a.max_chain_length=D[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=ja-1,a.match_available=0,a.ins_h=0}function u(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=$,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new E.Buf16(2*ha),this.dyn_dtree=new E.Buf16(2*(2*fa+1)),this.bl_tree=new E.Buf16(2*(2*ga+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new E.Buf16(ia+1),this.heap=new E.Buf16(2*ea+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new E.Buf16(2*ea+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function v(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=Z,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?na:sa,a.adler=2===b.wrap?0:1,b.last_flush=J,F._tr_init(b),O):d(a,Q)}function w(a){var b=v(a);return b===O&&t(a.state),b}function x(a,b){return a&&a.state?2!==a.state.wrap?Q:(a.state.gzhead=b,O):Q}function y(a,b,c,e,f,g){if(!a)return Q;var h=1;if(b===T&&(b=6),e<0?(h=0,e=-e):e>15&&(h=2,e-=16),f<1||f>_||c!==$||e<8||e>15||b<0||b>9||g<0||g>X)return d(a,Q);8===e&&(e=9);var i=new u;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+ja-1)/ja),i.window=new E.Buf8(2*i.w_size),i.head=new E.Buf16(i.hash_size),i.prev=new E.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new E.Buf8(i.pending_buf_size),i.d_buf=1*i.lit_bufsize,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,w(a)}function z(a,b){return y(a,b,$,aa,ba,Y)}function A(a,b){var c,h,k,l;if(!a||!a.state||b>N||b<0)return a?d(a,Q):Q;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===ta&&b!==M)return d(a,0===a.avail_out?S:Q);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===na)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=H(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=oa):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,ya),h.status=sa);else{var m=$+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=V||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=ma),m+=31-m%31,h.status=sa,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===oa)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=pa)}else h.status=pa;if(h.status===pa)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=qa)}else h.status=qa;if(h.status===qa)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=ra)}else h.status=ra;if(h.status===ra&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=sa)):h.status=sa),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,O}else if(0===a.avail_in&&e(b)<=e(c)&&b!==M)return d(a,S);if(h.status===ta&&0!==a.avail_in)return d(a,S);if(0!==a.avail_in||0!==h.lookahead||b!==J&&h.status!==ta){var o=h.strategy===V?r(h,b):h.strategy===W?q(h,b):D[h.level].func(h,b);if(o!==wa&&o!==xa||(h.status=ta),o===ua||o===wa)return 0===a.avail_out&&(h.last_flush=-1),O;if(o===va&&(b===K?F._tr_align(h):b!==N&&(F._tr_stored_block(h,0,0,!1),b===L&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,O}return b!==M?O:h.wrap<=0?P:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?O:P)}function B(a){var b;return a&&a.state?(b=a.state.status,b!==na&&b!==oa&&b!==pa&&b!==qa&&b!==ra&&b!==sa&&b!==ta?d(a,Q):(a.state=null,b===sa?d(a,R):O)):Q}function C(a,b){var c,d,e,g,h,i,j,k,l=b.length;if(!a||!a.state)return Q;if(c=a.state,g=c.wrap,2===g||1===g&&c.status!==na||c.lookahead)return Q;for(1===g&&(a.adler=G(a.adler,b,l,0)),c.wrap=0,l>=c.w_size&&(0===g&&(f(c.head),c.strstart=0,c.block_start=0,c.insert=0),k=new E.Buf8(c.w_size),E.arraySet(k,b,l-c.w_size,c.w_size,0),b=k,l=c.w_size),h=a.avail_in,i=a.next_in,j=a.input,a.avail_in=l,a.next_in=0,a.input=b,m(c);c.lookahead>=ja;){d=c.strstart,e=c.lookahead-(ja-1);do c.ins_h=(c.ins_h<<c.hash_shift^c.window[d+ja-1])&c.hash_mask,c.prev[d&c.w_mask]=c.head[c.ins_h],c.head[c.ins_h]=d,d++;while(--e);c.strstart=d,c.lookahead=ja-1,m(c)}return c.strstart+=c.lookahead,c.block_start=c.strstart,c.insert=c.lookahead,c.lookahead=0,c.match_length=c.prev_length=ja-1,c.match_available=0,a.next_in=i,a.input=j,a.avail_in=h,c.wrap=g,O}var D,E=a("../utils/common"),F=a("./trees"),G=a("./adler32"),H=a("./crc32"),I=a("./messages"),J=0,K=1,L=3,M=4,N=5,O=0,P=1,Q=-2,R=-3,S=-5,T=-1,U=1,V=2,W=3,X=4,Y=0,Z=2,$=8,_=9,aa=15,ba=8,ca=29,da=256,ea=da+1+ca,fa=30,ga=19,ha=2*ea+1,ia=15,ja=3,ka=258,la=ka+ja+1,ma=32,na=42,oa=69,pa=73,qa=91,ra=103,sa=113,ta=666,ua=1,va=2,wa=3,xa=4,ya=3;D=[new s(0,0,0,0,n),new s(4,4,8,4,o),new s(4,5,16,8,o),new s(4,6,32,32,o),new s(4,4,16,16,p),new s(8,16,32,32,p),new s(8,16,128,128,p),new s(8,32,128,256,p),new s(32,128,258,1024,p),new s(32,258,258,4096,p)],c.deflateInit=z,c.deflateInit2=y,c.deflateReset=w,c.deflateResetKeep=v,c.deflateSetHeader=x,c.deflate=A,c.deflateEnd=B,c.deflateSetDictionary=C,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":62,"./adler32":64,"./crc32":66,"./messages":72,"./trees":73}],68:[function(a,b,c){"use strict";function d(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=d},{}],69:[function(a,b,c){"use strict";var d=30,e=12;b.exports=function(a,b){var c,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;c=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=c.dmax,l=c.wsize,m=c.whave,n=c.wnext,o=c.window,p=c.hold,q=c.bits,r=c.lencode,s=c.distcode,t=(1<<c.lenbits)-1,u=(1<<c.distbits)-1;a:do{q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){c.mode=e;break a}a.msg="invalid literal/length code",c.mode=d;break a}x=65535&v,w&=15,w&&(q<w&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",c.mode=d;break a}if(y=65535&v,w&=15,q<w&&(p+=B[f++]<<q,q+=8,q<w&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",c.mode=d;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&c.sane){a.msg="invalid distance too far back",c.mode=d;break a}if(z=0,A=o,0===n){if(z+=l-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(n<w){if(z+=l+n-w,w-=n,w<x){x-=w;do C[h++]=o[z++];while(--w);if(z=0,n<x){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(f<g&&h<j);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=f<g?5+(g-f):5-(f-g),a.avail_out=h<j?257+(j-h):257-(h-j),c.hold=p,c.bits=q}},{}],70:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new s.Buf16(320),this.work=new s.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=L,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new s.Buf32(pa),b.distcode=b.distdyn=new s.Buf32(qa),b.sane=1,b.back=-1,D):G}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):G}function h(a,b){var c,d;return a&&a.state?(d=a.state,b<0?(c=0,b=-b):(c=(b>>4)+1,b<48&&(b&=15)),b&&(b<8||b>15)?G:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):G}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==D&&(a.state=null),c):G}function j(a){return i(a,sa)}function k(a){if(ta){var b;for(q=new s.Buf32(512),r=new s.Buf32(32),b=0;b<144;)a.lens[b++]=8;for(;b<256;)a.lens[b++]=9;for(;b<280;)a.lens[b++]=7;for(;b<288;)a.lens[b++]=8;for(w(y,a.lens,0,288,q,0,a.work,{bits:9}),b=0;b<32;)a.lens[b++]=5;w(z,a.lens,0,32,r,0,a.work,{bits:5}),ta=!1}a.lencode=q,a.lenbits=9,a.distcode=r,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new s.Buf8(f.wsize)),d>=f.wsize?(s.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),s.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(s.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,r,pa,qa,ra,sa,ta,ua,va,wa,xa,ya,za,Aa=0,Ba=new s.Buf8(4),Ca=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return G;c=a.state,c.mode===W&&(c.mode=X),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xa=D;a:for(;;)switch(c.mode){case L:if(0===c.wrap){c.mode=X;break}for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0),m=0,n=0,c.mode=M;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=ma;break}if((15&m)!==K){a.msg="unknown compression method",c.mode=ma;break}if(m>>>=4,n-=4,wa=(15&m)+8,0===c.wbits)c.wbits=wa;else if(wa>c.wbits){a.msg="invalid window size",c.mode=ma;break}c.dmax=1<<wa,a.adler=c.check=1,c.mode=512&m?U:W,m=0,n=0;break;case M:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==K){a.msg="unknown compression method",c.mode=ma;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=ma;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=N;case N:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,Ba[2]=m>>>16&255,Ba[3]=m>>>24&255,c.check=u(c.check,Ba,4,0)),m=0,n=0,c.mode=O;case O:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=P;case P:if(1024&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=Q;case Q:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wa=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),s.arraySet(c.head.extra,e,g,q,wa)),512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=R;case R:if(2048&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.name+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=S;case S:if(4096&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.comment+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.comment=null);c.mode=T;case T:if(512&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=ma;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=W;break;case U:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=V;case V:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,F;a.adler=c.check=1,c.mode=W;case W:if(b===B||b===C)break a;case X:if(c.last){m>>>=7&n,n-=7&n,c.mode=ja;break}for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=Y;break;case 1:if(k(c),c.mode=ca,b===C){m>>>=2,n-=2;break a}break;case 2:c.mode=_;break;case 3:a.msg="invalid block type",c.mode=ma}m>>>=2,n-=2;break;case Y:for(m>>>=7&n,n-=7&n;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=ma;break}if(c.length=65535&m,m=0,n=0,c.mode=Z,b===C)break a;case Z:c.mode=$;case $:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;s.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=W;break;case _:for(;n<14;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=ma;break}c.have=0,c.mode=aa;case aa:for(;c.have<c.ncode;){for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Ca[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Ca[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,ya={bits:c.lenbits},xa=w(x,c.lens,0,19,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid code lengths set",c.mode=ma;break}c.have=0,c.mode=ba;case ba:for(;c.have<c.nlen+c.ndist;){for(;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(sa<16)m>>>=qa,n-=qa,c.lens[c.have++]=sa;else{if(16===sa){for(za=qa+2;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qa,n-=qa,0===c.have){a.msg="invalid bit length repeat",c.mode=ma;break}wa=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sa){for(za=qa+3;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=3+(7&m),m>>>=3,n-=3}else{for(za=qa+7;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=ma;break}for(;q--;)c.lens[c.have++]=wa}}if(c.mode===ma)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=ma;break}if(c.lenbits=9,ya={bits:c.lenbits},xa=w(y,c.lens,0,c.nlen,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid literal/lengths set",c.mode=ma;break}if(c.distbits=6,c.distcode=c.distdyn,ya={bits:c.distbits},xa=w(z,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,ya),c.distbits=ya.bits,xa){a.msg="invalid distances set",c.mode=ma;break}if(c.mode=ca,b===C)break a;case ca:c.mode=da;case da:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,v(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===W&&(c.back=-1);break}for(c.back=0;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(ra&&0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.lencode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,c.length=sa,0===ra){c.mode=ia;break}if(32&ra){c.back=-1,c.mode=W;break}if(64&ra){a.msg="invalid literal/length code",c.mode=ma;break}c.extra=15&ra,c.mode=ea;case ea:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=fa;case fa:for(;Aa=c.distcode[m&(1<<c.distbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.distcode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,64&ra){a.msg="invalid distance code",c.mode=ma;break}c.offset=sa,c.extra=15&ra,c.mode=ga;case ga:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=ma;break}c.mode=ha;case ha:if(0===j)break a;if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=ma;break}q>c.wnext?(q-=c.wnext,r=c.wsize-q):r=c.wnext-q,q>c.length&&(q=c.length),pa=c.window}else pa=f,r=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pa[r++];while(--q);0===c.length&&(c.mode=da);break;case ia:if(0===j)break a;f[h++]=c.length,j--,c.mode=da;break;case ja:if(c.wrap){for(;n<32;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?u(c.check,f,p,h-p):t(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=ma;break}m=0,n=0}c.mode=ka;case ka:if(c.wrap&&c.flags){for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=ma;break}m=0,n=0}c.mode=la;case la:xa=E;break a;case ma:xa=H;break a;case na:return I;case oa:default:return G}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<ma&&(c.mode<ja||b!==A))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=na,I):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?u(c.check,f,p,a.next_out-p):t(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===W?128:0)+(c.mode===ca||c.mode===Z?256:0),(0===o&&0===p||b===A)&&xa===D&&(xa=J),xa)}function n(a){if(!a||!a.state)return G;var b=a.state;return b.window&&(b.window=null),a.state=null,D}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?G:(c.head=b,b.done=!1,D)):G}function p(a,b){var c,d,e,f=b.length;return a&&a.state?(c=a.state,0!==c.wrap&&c.mode!==V?G:c.mode===V&&(d=1,d=t(d,b,f,0),d!==c.check)?H:(e=l(a,b,f,f))?(c.mode=na,I):(c.havedict=1,D)):G}var q,r,s=a("../utils/common"),t=a("./adler32"),u=a("./crc32"),v=a("./inffast"),w=a("./inftrees"),x=0,y=1,z=2,A=4,B=5,C=6,D=0,E=1,F=2,G=-2,H=-3,I=-4,J=-5,K=8,L=1,M=2,N=3,O=4,P=5,Q=6,R=7,S=8,T=9,U=10,V=11,W=12,X=13,Y=14,Z=15,$=16,_=17,aa=18,ba=19,ca=20,da=21,ea=22,fa=23,ga=24,ha=25,ia=26,ja=27,ka=28,la=29,ma=30,na=31,oa=32,pa=852,qa=592,ra=15,sa=ra,ta=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateSetDictionary=p,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":62,"./adler32":64,"./crc32":66,"./inffast":69,"./inftrees":71}],71:[function(a,b,c){"use strict";var d=a("../utils/common"),e=15,f=852,g=592,h=0,i=1,j=2,k=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],l=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],m=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],n=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,c,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new d.Buf16(e+1),Q=new d.Buf16(e+1),R=null,S=0;for(D=0;D<=e;D++)P[D]=0;for(E=0;E<o;E++)P[b[c+E]]++;for(H=C,G=e;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;F<G&&0===P[F];F++);for(H<F&&(H=F),K=1,D=1;D<=e;D++)if(K<<=1,K-=P[D],K<0)return-1;if(K>0&&(a===h||1!==G))return-1;for(Q[1]=0,D=1;D<e;D++)Q[D+1]=Q[D]+P[D];for(E=0;E<o;E++)0!==b[c+E]&&(r[Q[b[c+E]]++]=E);if(a===h?(N=R=r,y=19):a===i?(N=k,O-=257,R=l,S-=257,y=256):(N=m,R=n,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===i&&L>f||a===j&&L>g)return 1;for(;;){z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[c+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;I+J<G&&(K-=P[I+J],!(K<=0));)I++,K<<=1;if(L+=1<<I,a===i&&L>f||a===j&&L>g)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":62}],72:[function(a,b,c){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],73:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length}function f(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b}function g(a){return a<256?ia[a]:ia[256+(a>>>7)]}function h(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function i(a,b,c){a.bi_valid>X-c?(a.bi_buf|=b<<a.bi_valid&65535,h(a,a.bi_buf),a.bi_buf=b>>X-a.bi_valid,a.bi_valid+=c-X):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function j(a,b,c){i(a,c[2*b],c[2*b+1])}function k(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function l(a){16===a.bi_valid?(h(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function m(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;f<=W;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,
c=a.heap_max+1;c<V;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function n(a,b,c){var d,e,f=new Array(W+1),g=0;for(d=1;d<=W;d++)f[d]=g=g+c[d-1]<<1;for(e=0;e<=b;e++){var h=a[2*e+1];0!==h&&(a[2*e]=k(f[h]++,h))}}function o(){var a,b,c,d,f,g=new Array(W+1);for(c=0,d=0;d<Q-1;d++)for(ka[d]=c,a=0;a<1<<ba[d];a++)ja[c++]=d;for(ja[c-1]=d,f=0,d=0;d<16;d++)for(la[d]=f,a=0;a<1<<ca[d];a++)ia[f++]=d;for(f>>=7;d<T;d++)for(la[d]=f<<7,a=0;a<1<<ca[d]-7;a++)ia[256+f++]=d;for(b=0;b<=W;b++)g[b]=0;for(a=0;a<=143;)ga[2*a+1]=8,a++,g[8]++;for(;a<=255;)ga[2*a+1]=9,a++,g[9]++;for(;a<=279;)ga[2*a+1]=7,a++,g[7]++;for(;a<=287;)ga[2*a+1]=8,a++,g[8]++;for(n(ga,S+1,g),a=0;a<T;a++)ha[2*a+1]=5,ha[2*a]=k(a,5);ma=new e(ga,ba,R+1,S,W),na=new e(ha,ca,0,T,W),oa=new e(new Array(0),da,0,U,Y)}function p(a){var b;for(b=0;b<S;b++)a.dyn_ltree[2*b]=0;for(b=0;b<T;b++)a.dyn_dtree[2*b]=0;for(b=0;b<U;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*Z]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function q(a){a.bi_valid>8?h(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function r(a,b,c,d){q(a),d&&(h(a,c),h(a,~c)),G.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function s(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function t(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&s(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!s(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function u(a,b,c){var d,e,f,h,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],e=a.pending_buf[a.l_buf+k],k++,0===d?j(a,e,b):(f=ja[e],j(a,f+R+1,b),h=ba[f],0!==h&&(e-=ka[f],i(a,e,h)),d--,f=g(d),j(a,f,c),h=ca[f],0!==h&&(d-=la[f],i(a,d,h)));while(k<a.last_lit);j(a,Z,b)}function v(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=V,c=0;c<i;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=j<2?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)t(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],t(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,t(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],m(a,b),n(f,j,a.bl_count)}function w(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;d<=c;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(h<j?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*$]++):h<=10?a.bl_tree[2*_]++:a.bl_tree[2*aa]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function x(a,b,c){var d,e,f=-1,g=b[1],h=0,k=7,l=4;for(0===g&&(k=138,l=3),d=0;d<=c;d++)if(e=g,g=b[2*(d+1)+1],!(++h<k&&e===g)){if(h<l){do j(a,e,a.bl_tree);while(0!==--h)}else 0!==e?(e!==f&&(j(a,e,a.bl_tree),h--),j(a,$,a.bl_tree),i(a,h-3,2)):h<=10?(j(a,_,a.bl_tree),i(a,h-3,3)):(j(a,aa,a.bl_tree),i(a,h-11,7));h=0,f=e,0===g?(k=138,l=3):e===g?(k=6,l=3):(k=7,l=4)}}function y(a){var b;for(w(a,a.dyn_ltree,a.l_desc.max_code),w(a,a.dyn_dtree,a.d_desc.max_code),v(a,a.bl_desc),b=U-1;b>=3&&0===a.bl_tree[2*ea[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function z(a,b,c,d){var e;for(i(a,b-257,5),i(a,c-1,5),i(a,d-4,4),e=0;e<d;e++)i(a,a.bl_tree[2*ea[e]+1],3);x(a,a.dyn_ltree,b-1),x(a,a.dyn_dtree,c-1)}function A(a){var b,c=4093624447;for(b=0;b<=31;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return I;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return J;for(b=32;b<R;b++)if(0!==a.dyn_ltree[2*b])return J;return I}function B(a){pa||(o(),pa=!0),a.l_desc=new f(a.dyn_ltree,ma),a.d_desc=new f(a.dyn_dtree,na),a.bl_desc=new f(a.bl_tree,oa),a.bi_buf=0,a.bi_valid=0,p(a)}function C(a,b,c,d){i(a,(L<<1)+(d?1:0),3),r(a,b,c,!0)}function D(a){i(a,M<<1,3),j(a,Z,ga),l(a)}function E(a,b,c,d){var e,f,g=0;a.level>0?(a.strm.data_type===K&&(a.strm.data_type=A(a)),v(a,a.l_desc),v(a,a.d_desc),g=y(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,f<=e&&(e=f)):e=f=c+5,c+4<=e&&b!==-1?C(a,b,c,d):a.strategy===H||f===e?(i(a,(M<<1)+(d?1:0),3),u(a,ga,ha)):(i(a,(N<<1)+(d?1:0),3),z(a,a.l_desc.max_code+1,a.d_desc.max_code+1,g+1),u(a,a.dyn_ltree,a.dyn_dtree)),p(a),d&&q(a)}function F(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(ja[c]+R+1)]++,a.dyn_dtree[2*g(b)]++),a.last_lit===a.lit_bufsize-1}var G=a("../utils/common"),H=4,I=0,J=1,K=2,L=0,M=1,N=2,O=3,P=258,Q=29,R=256,S=R+1+Q,T=30,U=19,V=2*S+1,W=15,X=16,Y=7,Z=256,$=16,_=17,aa=18,ba=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ca=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],da=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ea=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa=512,ga=new Array(2*(S+2));d(ga);var ha=new Array(2*T);d(ha);var ia=new Array(fa);d(ia);var ja=new Array(P-O+1);d(ja);var ka=new Array(Q);d(ka);var la=new Array(T);d(la);var ma,na,oa,pa=!1;c._tr_init=B,c._tr_stored_block=C,c._tr_flush_block=E,c._tr_tally=F,c._tr_align=D},{"../utils/common":62}],74:[function(a,b,c){"use strict";function d(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=d},{}]},{},[10])(10)});
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(view){"use strict";if(typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var doc=view.document,get_URL=function(){return view.URL||view.webkitURL||view},save_link=doc.createElementNS("http://www.w3.org/1999/xhtml","a"),can_use_save_link="download"in save_link,click=function(node){var event=new MouseEvent("click");node.dispatchEvent(event)},is_safari=/Version\/[\d\.]+.*Safari/.test(navigator.userAgent),webkit_req_fs=view.webkitRequestFileSystem,req_fs=view.requestFileSystem||webkit_req_fs||view.mozRequestFileSystem,throw_outside=function(ex){(view.setImmediate||view.setTimeout)(function(){throw ex},0)},force_saveable_type="application/octet-stream",fs_min_size=0,arbitrary_revoke_timeout=500,revoke=function(file){var revoker=function(){if(typeof file==="string"){get_URL().revokeObjectURL(file)}else{file.remove()}};if(view.chrome){revoker()}else{setTimeout(revoker,arbitrary_revoke_timeout)}},dispatch=function(filesaver,event_types,event){event_types=[].concat(event_types);var i=event_types.length;while(i--){var listener=filesaver["on"+event_types[i]];if(typeof listener==="function"){try{listener.call(filesaver,event||filesaver)}catch(ex){throw_outside(ex)}}}},auto_bom=function(blob){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)){return new Blob(["\ufeff",blob],{type:blob.type})}return blob},FileSaver=function(blob,name,no_auto_bom){if(!no_auto_bom){blob=auto_bom(blob)}var filesaver=this,type=blob.type,blob_changed=false,object_url,target_view,dispatch_all=function(){dispatch(filesaver,"writestart progress write writeend".split(" "))},fs_error=function(){if(target_view&&is_safari&&typeof FileReader!=="undefined"){var reader=new FileReader;reader.onloadend=function(){var base64Data=reader.result;target_view.location.href="data:attachment/file"+base64Data.slice(base64Data.search(/[,;]/));filesaver.readyState=filesaver.DONE;dispatch_all()};reader.readAsDataURL(blob);filesaver.readyState=filesaver.INIT;return}if(blob_changed||!object_url){object_url=get_URL().createObjectURL(blob)}if(target_view){target_view.location.href=object_url}else{var new_tab=view.open(object_url,"_blank");if(new_tab==undefined&&is_safari){view.location.href=object_url}}filesaver.readyState=filesaver.DONE;dispatch_all();revoke(object_url)},abortable=function(func){return function(){if(filesaver.readyState!==filesaver.DONE){return func.apply(this,arguments)}}},create_if_not_found={create:true,exclusive:false},slice;filesaver.readyState=filesaver.INIT;if(!name){name="download"}if(can_use_save_link){object_url=get_URL().createObjectURL(blob);setTimeout(function(){save_link.href=object_url;save_link.download=name;click(save_link);dispatch_all();revoke(object_url);filesaver.readyState=filesaver.DONE});return}if(view.chrome&&type&&type!==force_saveable_type){slice=blob.slice||blob.webkitSlice;blob=slice.call(blob,0,blob.size,force_saveable_type);blob_changed=true}if(webkit_req_fs&&name!=="download"){name+=".download"}if(type===force_saveable_type||webkit_req_fs){target_view=view}if(!req_fs){fs_error();return}fs_min_size+=blob.size;req_fs(view.TEMPORARY,fs_min_size,abortable(function(fs){fs.root.getDirectory("saved",create_if_not_found,abortable(function(dir){var save=function(){dir.getFile(name,create_if_not_found,abortable(function(file){file.createWriter(abortable(function(writer){writer.onwriteend=function(event){target_view.location.href=file.toURL();filesaver.readyState=filesaver.DONE;dispatch(filesaver,"writeend",event);revoke(file)};writer.onerror=function(){var error=writer.error;if(error.code!==error.ABORT_ERR){fs_error()}};"writestart progress write abort".split(" ").forEach(function(event){writer["on"+event]=filesaver["on"+event]});writer.write(blob);filesaver.abort=function(){writer.abort();filesaver.readyState=filesaver.DONE};filesaver.readyState=filesaver.WRITING}),fs_error)}),fs_error)};dir.getFile(name,{create:false},abortable(function(file){file.remove();save()}),abortable(function(ex){if(ex.code===ex.NOT_FOUND_ERR){save()}else{fs_error()}}))}),fs_error)}),fs_error)},FS_proto=FileSaver.prototype,saveAs=function(blob,name,no_auto_bom){return new FileSaver(blob,name,no_auto_bom)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(blob,name,no_auto_bom){if(!no_auto_bom){blob=auto_bom(blob)}return navigator.msSaveOrOpenBlob(blob,name||"download")}}FS_proto.abort=function(){var filesaver=this;filesaver.readyState=filesaver.DONE;dispatch(filesaver,"abort")};FS_proto.readyState=FS_proto.INIT=0;FS_proto.WRITING=1;FS_proto.DONE=2;FS_proto.error=FS_proto.onwritestart=FS_proto.onprogress=FS_proto.onwrite=FS_proto.onabort=FS_proto.onerror=FS_proto.onwriteend=null;return saveAs}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!=null){define('saveAs',[],function(){return saveAs})}
;
/**
 * Copyright (c) 2009 Sergiy Kovalchuk (serg472@gmail.com)
 * 
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *  
 * Following code is based on Element.mask() implementation from ExtJS framework (http://extjs.com/)
 *
 */
;(function($){
	
	/**
	 * Displays loading mask over selected element(s). Accepts both single and multiple selectors.
	 *
	 * @param label Text message that will be displayed on top of the mask besides a spinner (optional). 
	 * 				If not provided only mask will be displayed without a label or a spinner.  	
	 * @param delay Delay in milliseconds before element is masked (optional). If unmask() is called 
	 *              before the delay times out, no mask is displayed. This can be used to prevent unnecessary 
	 *              mask display for quick processes.   	
	 */
	$.fn.mask = function(label, delay){
		$(this).each(function() {
			if(delay !== undefined && delay > 0) {
		        var element = $(this);
		        element.data("_mask_timeout", setTimeout(function() { $.maskElement(element, label)}, delay));
			} else {
				$.maskElement($(this), label);
			}
		});
	};
	
	/**
	 * Removes mask from the element(s). Accepts both single and multiple selectors.
	 */
	$.fn.unmask = function(){
		$(this).each(function() {
			$.unmaskElement($(this));
		});
	};
	
	/**
	 * Checks if a single element is masked. Returns false if mask is delayed or not displayed. 
	 */
	$.fn.isMasked = function(){
		return this.hasClass("masked");
	};

	$.maskElement = function(element, label){
	
		//if this element has delayed mask scheduled then remove it and display the new one
		if (element.data("_mask_timeout") !== undefined) {
			clearTimeout(element.data("_mask_timeout"));
			element.removeData("_mask_timeout");
		}

		if(element.isMasked()) {
			$.unmaskElement(element);
		}
		
		if(element.css("position") == "static") {
			element.addClass("masked-relative");
		}
		
		element.addClass("masked");
		
		var maskDiv = $('<div class="loadmask"></div>');
		
		//auto height fix for IE
		if(navigator.userAgent.toLowerCase().indexOf("msie") > -1){
			maskDiv.height(element.height() + parseInt(element.css("padding-top")) + parseInt(element.css("padding-bottom")));
			maskDiv.width(element.width() + parseInt(element.css("padding-left")) + parseInt(element.css("padding-right")));
		}
		
		//fix for z-index bug with selects in IE6
		if(navigator.userAgent.toLowerCase().indexOf("msie 6") > -1){
			element.find("select").addClass("masked-hidden");
		}
		
		element.append(maskDiv);
		
		if(label !== undefined) {
			var maskMsgDiv = $('<div class="loadmask-msg" style="display:none;"></div>');
			maskMsgDiv.append('<div>' + label + '</div>');
			element.append(maskMsgDiv);
			
			//calculate center position
			maskMsgDiv.css("top", Math.round(element.height() / 2 - (maskMsgDiv.height() - parseInt(maskMsgDiv.css("padding-top")) - parseInt(maskMsgDiv.css("padding-bottom"))) / 2)+"px");
			maskMsgDiv.css("left", Math.round(element.width() / 2 - (maskMsgDiv.width() - parseInt(maskMsgDiv.css("padding-left")) - parseInt(maskMsgDiv.css("padding-right"))) / 2)+"px");
			
			maskMsgDiv.show();
		}
		
	};
	
	$.unmaskElement = function(element){
		//if this element has delayed mask scheduled then remove it
		if (element.data("_mask_timeout") !== undefined) {
			clearTimeout(element.data("_mask_timeout"));
			element.removeData("_mask_timeout");
		}
		
		element.find(".loadmask-msg,.loadmask").remove();
		element.removeClass("masked");
		element.removeClass("masked-relative");
		element.find("select").removeClass("masked-hidden");
	};
 
})(jQuery);
define("loadmask", ["jquery"], function(){});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to select areas on planet
 */

define('gw/Services/ExportToolCore',[
    "jquery",
    "underscore-min",
    "jszip",
    "saveAs",
    "../Gui/dialog/ErrorDialog",
    "../Utils/Constants",
    "../Utils/Proxy",
    "loadmask"
], function($, _, JSZip, saveAs, ErrorDialog, Constants, Proxy) {
    var self, mizarAPI, layers, availableLayers;

    /**************************************************************************************************************/

    /**
     *    Keep only layers having available searching services
     */
    function filterServicesAvailableOnLayers() {
        availableLayers = [];
        _.each(layers, function(layer) {
            if (
                layer.isVisible() &&
                layer.category !== "Other" &&
                layer.category !== "Solar System" &&
                layer.getName() !== "SAMP" &&
                layer.getName() !== "Planets"
            ) {
                layer.layerId = _.uniqueId("layer_");
                availableLayers.push(layer);
            }
        });
        return availableLayers;
    }

    /**************************************************************************************************************/

    /**
     * Export data included in the passed coordinates selection
     *
     * @param event.data = coordinates
     */
    function exportSelection(event) {
        self.coordinates = event.data;

        $("body").mask("Exporting data...");

        var JSZip = require("jszip");

        // creating empty archive
        var zip = new JSZip();

        // getting all visible and displayed layers
        var backgroundLayers = [];
        var dataLayers = [];
        _.each(availableLayers, function(layer) {
            if ($("#" + layer.layerId).is(":checked")) {
                if (
                    layer.getType() === Constants.LAYER.OpenSearch ||
                    layer.getType() === Constants.LAYER.GeoJSON
                ) {
                    //if (layer.type === "DynamicOpenSearch") {
                    dataLayers.push(layer);
                } else if (
                    layer.getType() === Constants.LAYER.Hips ||
                    layer.getType() === Constants.LAYER.HipsCat
                ) {
                    backgroundLayers.push(layer);
                }
            }
        });

        // Adding a middle point the bbox to be sure no data/image will be omitted
        var middlePoint = [
            (self.coordinates[0][1] + self.coordinates[1][1]) / 2,
            (self.coordinates[0][0] + self.coordinates[3][0]) / 2,
            0
        ];
        self.coordinates.push(middlePoint);

        // getting data url from layer using tile and bbox coordinates
        var tileLayerFeatures = [];
        _.each(dataLayers, function(dataLayer, index) {
            for (var i = 0; i < self.coordinates.length; i++) {
                var tile = mizarAPI
                    .getActivatedContext()
                    .getTileManager()
                    .getVisibleTile(
                        self.coordinates[i][0],
                        self.coordinates[i][1]
                    );

                if (_.isEmpty(tile)) {
                    return;
                }

                var osData = tile.extension[dataLayer.extId];

                if (!_.isEmpty(osData) && !_.isEmpty(osData.featureIds)) {
                    _.each(osData.featureIds, function(fId) {
                        var featureSet = dataLayer.featuresSet[fId];
                        if (!_.isEmpty(featureSet)) {
                            var feature = dataLayer.features[featureSet.index];

                            var isIncluded = true;
                            switch (feature.geometry.type) {
                            case Constants.GEOMETRY.Point:
                                isIncluded = self.checkIfPointInBbox(
                                    feature.geometry.coordinates,
                                    self.coordinates
                                );
                                break;

                            case Constants.GEOMETRY.Polygon:
                                for (
                                    var i = 0;
                                    i < feature.geometry.coordinates.length;
                                    i++
                                ) {
                                    if (!isIncluded) {
                                        return;
                                    }
                                    isIncluded = self.checkIfPointInBbox(
                                        feature.geometry.coordinates[0][i],
                                        self.coordinates
                                    );
                                }
                                break;
                            }
                            if (isIncluded) {
                                // Adding layer information in order to rank data in archive
                                feature.parentInformation = {
                                    copyright: dataLayer.copyright || "",
                                    copyrightUrl: dataLayer.copyrightUrl || "",
                                    category: dataLayer.category,
                                    name: dataLayer.name
                                };
                                tileLayerFeatures.push(feature);
                            }
                        }
                    });
                }
            }
        });

        // Adding features archive
        _.each(tileLayerFeatures, function(feature) {
            var folder = zip.folder(
                feature.parentInformation.category +
                    "/" +
                    feature.parentInformation.name
            );

            // Adding a copyright file into each folder
            if (
                !_.isEmpty(feature.parentInformation.copyright) ||
                !_.isEmpty(feature.parentInformation.copyrightUrl)
            ) {
                var copyright =
                    "Copyright : " +
                    feature.parentInformation.copyright +
                    " - link : " +
                    feature.parentInformation.copyrightUrl;
                folder.file(feature.parentInformation.name + ".txt", copyright);
            }

            var featureToStringify = {
                geometry: {
                    coordinates: feature.geometry.coordinates,
                    gid: feature.geometry.gid,
                    type: feature.geometry.type,
                    crs: {
                        type: "name",
                        properties: {
                            name: mizarAPI.getCrs().getGeoideName()
                        }
                    }
                },
                id: feature.id,
                properties: feature.properties,
                type: feature.type
            };

            folder.file(
                feature.properties.identifier + ".json",
                JSON.stringify(featureToStringify, null, "\t")
            );
        });

        if (backgroundLayers.length === 0) {
            self.downloadArchive(zip);
        } else {
            var numberOfImages = 0;
            var imageNotFound = false;
            // get images url from Background layer
            _.each(backgroundLayers, function(backgroundLayer, index) {
                backgroundLayer.urlImages = [];
                backgroundLayer.images = [];

                for (var i = 0; i < self.coordinates.length; i++) {
                    // Retrieve the tile according to a
                    var tile = mizarAPI
                        .getActivatedContext()
                        .getTileManager()
                        .getVisibleTile(
                            self.coordinates[i][0],
                            self.coordinates[i][1]
                        );

                    if (_.isEmpty(tile)) {
                        return;
                    }

                    numberOfImages++;
                    var url = backgroundLayer.getUrl(tile);

                    var image = new Image();
                    image.aborted = false;
                    image.crossOrigin = "";
                    image.backgroundName = backgroundLayer.name;
                    image.parentFolder =
                        backgroundLayer.category +
                        "/" +
                        backgroundLayer.name +
                        "/images";
                    image.imageName = url.substring(
                        url.lastIndexOf("/") + 1,
                        url.length
                    );

                    image.onload = function() {
                        self.addImageToArchive(this, zip);
                        numberOfImages--;

                        if (numberOfImages == 0) {
                            self.downloadArchive(zip);
                        }
                    };
                    image.onerror = function() {
                        imageNotFound = true;
                        ErrorDialog.open(Constants.LEVEL.WARNING, "Error while retrieving image : " + this.imageName);
                        numberOfImages--;
                        if (numberOfImages == 0) {
                            if (imageNotFound) {
                                ErrorDialog.open(
                                    Constants.LEVEL.WARNING,
                                    "Some images not found",
                                    "Change zoom level and retry download"
                                );
                            }

                            self.downloadArchive(zip);
                        }
                    };
                    image.src = Proxy.proxify(url);
                }
            });
        }
    }

    /**************************************************************************************************************/

    /**
     * Create a zip file containing data + readme file and download it
     *
     * @param zip
     */
    function downloadArchive(zip) {
        var saveAs = require("saveAs");

        var date = new Date();
        var currentDate = $.datepicker.formatDate(
            "yy/mm/dd " + date.getHours() + ":" + date.getMinutes(),
            date
        );
        var readme =
            "Date : " +
            currentDate +
            "\n" +
            "Query :" +
            JSON.stringify(self.coordinates, null, "\t") +
            "\n" +
            "Copyright : Generated by MIZAR";

        zip.file("README.txt", readme);

        var content = zip.generate({ type: "blob" });
        saveAs(content, "archive_" + currentDate + ".zip");
        $("body").unmask();
    }

    /**************************************************************************************************************/

    /**
     * Check if given is included into the drawn bbox
     * @param point
     * @param bbox
     * @returns {boolean}
     */
    function checkIfPointInBbox(point, bbox) {
        if (
            point[1] >= bbox[0][1] &&
            point[1] <= bbox[1][1] &&
            (point[0] <= bbox[0][0] && point[0] >= bbox[3][0])
        ) {
            return true;
        } else {
            return false;
        }
    }

    /**************************************************************************************************************/

    /**
     * Add an image into the passed archive
     * @param img
     * @param zip
     */
    function addImageToArchive(img, zip) {
        var folder = zip.folder(img.parentFolder);
        folder.file(img.imageName, self.getBase64Image(img), { base64: true });
    }

    /**************************************************************************************************************/

    /**
     * Convert an image into base64
     * @param img
     * @returns {string}
     */
    function getBase64Image(img) {
        // Create an empty canvas element
        var canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;

        // Copy the image contents to the canvas
        var ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        // Get the data-URL formatted image
        // Firefox supports PNG and JPEG. You could check img.src to
        // guess the original format, but be aware the using "image/jpg"
        // will re-encode the image.
        var dataURL = canvas.toDataURL("image/png");

        return dataURL.replace(/^data:image\/(png|jpg);base64,/, "");
    }

    /**************************************************************************************************************/

    return {
        /**
         *    @constructor
         *    @param options Configuration options
         *        <ul>
         *            <li>planet: planet</li>
         *            <li>layers: Layers</li>
         *        </ul>
         */
        init: function(mizar, options) {
            // Required options
            mizarAPI = mizar;
            layers = mizarAPI.getLayers(Constants.CONTEXT.Sky);
            self = this;
        },
        exportSelection: exportSelection,
        addImageToArchive: addImageToArchive,
        downloadArchive: downloadArchive,
        getBase64Image: getBase64Image,
        filterServicesAvailableOnLayers: filterServicesAvailableOnLayers
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/NameResolver/AbstractNameResolver',[], function() {
    /**************************************************************************************************************/

    /**
     * @name AbstractNameResolverer
     * @class
     * Abstract Wrapper constructor
     * @param {Context} options - Context
     * @implements {NameResolver}
     */
    var AbstractNameResolver = function(options) {
        this.ctx = options;
    };

    /**************************************************************************************************************/

    /**
     * @function handle
     * @memberof AbstractNameResolver#
     * @abstract
     */
    AbstractNameResolver.prototype.handle = function(options) {
        throw new SyntaxError(
            "handle from NameResolver not implemented",
            "AbstractNameResolver.js"
        );
    };

    /**
     * @function remove
     * @memberof AbstractNameResolver#
     * @abstract
     */
    AbstractNameResolver.prototype.remove = function() {
        throw new SyntaxError(
            "remove from NameResolver not implemented",
            "AbstractNameResolver.js"
        );
    };

    /**************************************************************************************************************/

    return AbstractNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/**
 * NameResolver is used to get the coordinate of a target. When the target is found, the camera is redirected to this point:
 * <ul>
 *     <li>{@link module:NameResolver.CDSNameResolver CDSNameResolver}: Name resolver from CDS</li>
 *     <li>{@link module:NameResolver.DefaultNameResolver DefaultNameResolver} : Deprecated</li>
 *     <li>{@link module:NameResolver.DictionaryNameResolver DictionaryNameResolver} : Name resolver on a GeoJson file</li>
 *     <li>{@link module:NameResolver.IMCCENameResolver IMCCENameResolver} : Name resolver from IMCCE</li>
 *     <li>{@link module:NameResolver.NameResolver NameResolver} : NameResolver object</li>
 * </ul>
 *
 * @module NameResolver
 * @implements {NameResolver}
 */

define('gw/NameResolver/DefaultNameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractNameResolver"
], function($, _, Utils, AbstractNameResolver) {
    /**************************************************************************************************************/

    /**
     * @name DefaultNameResolver
     * @class
     *  Plugin to access to default name resolver
     * @augments AbstractNameResolver
     * @param {Context} options - Context
     * @memberof module:NameResolver
     * @constructor
     */
    var DefaultNameResolver = function(options) {
        AbstractNameResolver.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractNameResolver, DefaultNameResolver);

    /**************************************************************************************************************/

    /**
     * Convert passed url into an url understandable by the service (input transformer)
     * @function handle
     * @memberof DefaultNameResolver#
     */
    DefaultNameResolver.prototype.handle = function(options) {
        var context = this.ctx;
        var objectName = options.objectName;
        var onError = options.onError;
        var onComplete = options.onComplete;
        var onSuccess = options.onSuccess;
        var searchLayer = options.searchLayer;
        var zoomTo = options.zoomTo;

        var url =
            context.getMizarConfiguration().nameResolver.baseUrl +
            "/" +
            objectName +
            "/EQUATORIAL";
        Utils.requestUrl(
            url,
            "text",
            "text/plain",
            null,
            function(response) {
                // Check if response contains features
                if (response.type === "FeatureCollection") {
                    var firstFeature = response.features[0];
                    var zoomToCallback = function() {
                        searchLayer(objectName, onSuccess, onError, response);
                    };
                    zoomTo(
                        firstFeature.geometry.coordinates[0],
                        firstFeature.geometry.coordinates[1],
                        null,
                        zoomToCallback,
                        response
                    );
                } else {
                    onError();
                }
            },
            function(err) {
                searchLayer(objectName, onSuccess, onError);
            },
            function(xhr, textStatus) {
                if (onComplete) {
                    onComplete(xhr);
                }
            }
        );
    };

    /**
     * @function remove
     * @memberof DefaultNameResolver#
     */
    DefaultNameResolver.prototype.remove = function() {};

    /**************************************************************************************************************/

    return DefaultNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/NameResolver/CDSNameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Constants",
    "../Utils/Utils",
    "./AbstractNameResolver"
], function($, _, Constants, Utils, AbstractNameResolver) {
    /**************************************************************************************************************/

    /**
     * @name CDSNameResolver
     * @class
     *  Plugin to access to CDS name resolver
     * @augments AbstractNameResolver
     * @param {Context} options - Context
     * @memberof module:NameResolver
     * @constructor
     */
    var CDSNameResolver = function(options) {
        AbstractNameResolver.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractNameResolver, CDSNameResolver);

    /**************************************************************************************************************/

    /**
     * Queries CDS using this URL : http://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/A?<i>objectName</i>
     * and the layers
     * @function handle
     * @memberof CDSNameResolver#
     */
    CDSNameResolver.prototype.handle = function(options) {
        var context = this.ctx;
        var objectName = options.objectName;
        var onError = options.onError;
        var onComplete = options.onComplete;
        var onSuccess = options.onSuccess;
        var searchLayer = options.searchLayer;
        var zoomTo = options.zoomTo;

        var url =
            "http://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/A?" +
            objectName;

        Utils.requestUrl(
            url,
            "xml",
            "application/xml",
            null,
            function(xmlResponse) {
                var target = $(xmlResponse).find("Target");
                var name = $(target)
                    .find("name")
                    .text();
                var features = [];

                $(target)
                    .find("Resolver")
                    .each(function(index) {
                        var resolver = this;
                        var ra = $(resolver).find("jradeg");
                        var dec = $(resolver).find("jdedeg");

                        if (!_.isEmpty(ra.text()) && !_.isEmpty(dec.text())) {
                            ra = parseFloat(ra.text());
                            dec = parseFloat(dec.text());
                            var feature = {};
                            feature.ra = ra;
                            feature.dec = dec;
                            feature.credit = $(resolver).attr("name");
                            features.push(feature);
                        }
                    });

                var response = {
                    totalResults: features.length,
                    type: "FeatureCollection",
                    features: []
                };

                _.each(features, function(feature) {
                    response.features.push({
                        type: "Feature",
                        geometry: {
                            coordinates: [feature.ra, feature.dec],
                            type: Constants.GEOMETRY.Point,
                            crs: {
                                type: "name",
                                properties: {
                                    name: Constants.CRS.Equatorial
                                }
                            }
                        },
                        properties: {
                            identifier: "CDS0",
                            name: name,
                            credits:
                                "Powered by <a href=\"http://cdsweb.u-strasbg.fr/cgi-bin/Sesame\">Sesame API</a> (" +
                                feature.credit +
                                ")"
                        }
                    });
                });

                // Check if response contains features
                if (
                    response.type === "FeatureCollection" &&
                    response.features.length > 0
                ) {
                    var firstFeature = response.features[0];
                    var zoomToCallback = function() {
                        searchLayer(objectName, onSuccess, onError, response);
                    };
                    zoomTo(
                        firstFeature.geometry.coordinates[0],
                        firstFeature.geometry.coordinates[1],
                        null,
                        Constants.CRS.Equatorial,
                        zoomToCallback,
                        response
                    );
                } else {
                    searchLayer(objectName, onSuccess, onError, response);
                }
            },
            function(err) {
                searchLayer(objectName, onSuccess, onError);
            },
            function(xhr, textStatus) {
                if (onComplete) {
                    onComplete(xhr);
                }
            }
        );
    };

    /**
     * @function remove
     * @memberof CDSNameResolver#
     */
    CDSNameResolver.prototype.remove = function() {};

    return CDSNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/NameResolver/DictionaryNameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractNameResolver",
    "../Layer/VectorLayer",
    "../Renderer/FeatureStyle",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function(
    $,
    _,
    Utils,
    AbstractNameResolver,
    VectorLayer,
    FeatureStyle,
    Constants,
    ErrorDialog
) {
    var dictionary;

    /**
     * In case if base url isn't a service but a json containing all known places
     * this method allows to retrieve it
     */
    var retrieveDictionary = function(context) {
        var containsDictionary =
            context
                .getContextConfiguration()
                .nameResolver.baseUrl.indexOf("json") >= 0;
        if (containsDictionary) {
            // Dictionary as json
            var marsResolverUrl = context.getContextConfiguration().nameResolver
                .baseUrl; //.replace('mizar_gui', 'mizar_lite');

            Utils.requestUrl(
                marsResolverUrl,
                "json",
                "application/json",
                null,
                function(response) {
                    dictionary = response;
                },
                function(err) {
                    ErrorDialog.open(
                        Constants.LEVEL.ERROR,
                        "Failed ot request " + marsResolverUrl,
                        err
                    );
                }
            );
        } else {
            dictionary = null;
        }
    };

    /**************************************************************************************************************/
    /**
     * @name DictionaryNameResolver
     * @class
     *      Plugin to access to the dictionary name resolver
     * @augments AbstractNameResolver
     * @param {Context} options - Configuration properties
     * @memberof module:NameResolver
     * @constructor
     */
    var DictionaryNameResolver = function(options) {
        AbstractNameResolver.prototype.constructor.call(this, options);
        dictionary = retrieveDictionary(options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractNameResolver, DictionaryNameResolver);

    function _computeDistance(pt1, pt2) {
        var pt = [
            parseFloat(pt2[0]) - parseFloat(pt1[0]),
            parseFloat(pt2[1]) - parseFloat(pt1[1])
        ];
        return Math.sqrt(pt[0] * pt[0] + pt[1] * pt[1]);
    }

    function _farestDistance(center, pts) {
        var distance = 0;
        for (var i = 0; i < pts.length; i++) {
            var newDistance = _computeDistance.call(this, center, pts[i]);
            if (newDistance > distance) {
                distance = newDistance;
            }
        }
        return distance;
    }

    function _computeFarestDistanceAlongLineString(center, pts) {
        return _farestDistance.call(this, center, pts);
    }

    function _addPoint(p1, p2) {
        return [
            parseFloat(p1[0]) + parseFloat(p2[0]),
            parseFloat(p1[1]) + parseFloat(p2[1])
        ];
    }

    function _computeLineStringBarycenter(pts) {
        var center = pts[0];
        for (var i = 1; i < pts.length; i++) {
            center = _addPoint.call(this, center, pts[i]);
        }
        center = [center[0] / pts.length, center[1] / pts.length];
        return center;
    }

    function _computeBarycenterAndDistance(geometry) {
        var type = geometry.type;
        var coordinates = geometry.coordinates;
        var center;
        var distance;
        var nbPts = null;
        var tmpCenter = null;
        var newDistance = null;
        switch (type) {
        case "Point":
            center = coordinates;
            distance = null;
            break;
        case "LineString":
            center = _computeLineStringBarycenter.call(this, coordinates);
            distance = _computeFarestDistanceAlongLineString.call(
                this,
                center,
                coordinates
            );
            break;
        case "Polygon":
            var exteriorRing = coordinates[0];
            center = _computeLineStringBarycenter.call(this, exteriorRing);
            distance = _computeFarestDistanceAlongLineString.call(
                this,
                center,
                exteriorRing
            );
            break;
        case "MultiPoint":
            center = _computeLineStringBarycenter.call(this, coordinates);
            distance = _computeFarestDistanceAlongLineString.call(
                this,
                center,
                coordinates
            );
            break;
        case "MultiLineString":
            var lineStringArray = coordinates[0];
            center = _computeLineStringBarycenter.call(
                this,
                lineStringArray[0]
            );
            center[0] = center[0] * lineStringArray[0].length;
            center[1] = center[1] * lineStringArray[0].length;
            nbPts = 0;
            for (var i = 1; i < lineStringArray.length; i++) {
                tmpCenter = _computeLineStringBarycenter.call(
                    this,
                    lineStringArray[i]
                );
                tmpCenter[0] = tmpCenter[0] * lineStringArray[i].length;
                tmpCenter[1] = tmpCenter[1] * lineStringArray[i].length;
                nbPts = nbPts + lineStringArray[i].length;
                center = _addPoint(center, tmpCenter);
            }
            center[0] = center[0] / nbPts;
            center[1] = center[1] / nbPts;

            distance = 0;
            for (i = 0; i < lineStringArray.length; i++) {
                newDistance = _farestDistance.call(
                    this,
                    center,
                    lineStringArray[i]
                );
                if (newDistance > distance) {
                    distance = newDistance;
                }
            }
            break;
        case "MultiPolygon":
            var polygonArray = coordinates[0];
            center = _computeLineStringBarycenter.call(
                this,
                polygonArray[0][0]
            );
            center[0] = center[0] * polygonArray[0][0].length;
            center[1] = center[1] * polygonArray[0][0].length;
            nbPts = 0;
            for (i = 1; i < polygonArray.length; i++) {
                tmpCenter = _computeLineStringBarycenter.call(
                    this,
                    lineStringArray[i][0]
                );
                tmpCenter[0] = tmpCenter[0] * lineStringArray[i][0].length;
                tmpCenter[1] = tmpCenter[1] * lineStringArray[i][0].length;
                nbPts = nbPts + lineStringArray[i][0].length;
                center = _addPoint.call(this, center, tmpCenter);
            }
            center[0] = center[0] / nbPts;
            center[1] = center[1] / nbPts;
            distance = 0;
            for (i = 0; i < polygonArray.length; i++) {
                newDistance = _farestDistance.call(
                    this,
                    center,
                    polygonArray[i][0]
                );
                if (newDistance > distance) {
                    distance = newDistance;
                }
            }
            break;
        default:
            throw "geometry " + type + " is not supported";
        }
        return [center, distance];
    }

    /**
     * Queries the GeoJSON passed in parameter in the Mizar options
     * @function handle
     * @memberof DictionaryNameResolver#
     */
    DictionaryNameResolver.prototype.handle = function(options) {
        var context = this.ctx;
        var crs = this.ctx.getCoordinateSystem();
        var objectName = options.objectName;
        var onError = options.onError;
        var onComplete = options.onComplete;
        var onSuccess = options.onSuccess;
        var searchLayer = options.searchLayer;
        var zoomTo = options.zoomTo;

        // Planet resolver(Mars only currently)
        var feature = _.find(dictionary.features, function(f) {
            var name =
                f.properties.Name == undefined
                    ? f.properties.name
                    : f.properties.Name;
            var isFound;
            if (name == null) {
                isFound = false;
            } else {
                isFound = name.toLowerCase() === objectName.toLowerCase();
            }
            return isFound;
        });

        if (feature) {
            var lon;
            var lat;
            var distance;
            if (
                feature.properties.center_lon == undefined ||
                feature.properties.center_lat == undefined
            ) {
                var centerAndDistance = _computeBarycenterAndDistance.call(
                    this,
                    feature.geometry
                );
                lon = parseFloat(centerAndDistance[0][0]);
                lat = parseFloat(centerAndDistance[0][1]);
                distance = centerAndDistance[1];
            } else {
                lon = parseFloat(feature.properties.center_lon);
                lat = parseFloat(feature.properties.center_lat);
                distance = null;
            }

            feature.geometry.crs = {
                type: "name",
                properties: {
                    name: context.getCoordinateSystem().getGeoideName()
                }
            };
            var zoomToCallback = function() {
                searchLayer(objectName, onSuccess, onError, {
                    features: [feature]
                });
            };

            var fov = context.getRenderContext().getFov();

            var distanceCamera;
            if (distance == null) {
                distanceCamera = null;
            } else {
                distance = distance > 180.0 ? 180.0 : distance;
                // aproximation of the distance in meters
                distance =
                    (2 *
                        Math.PI *
                        crs.getGeoide().getRealPlanetRadius() *
                        distance) /
                    360;
                distanceCamera =
                    distance / Math.tan((0.5 * fov * Math.PI) / 180);
            }

            zoomTo(
                lon,
                lat,
                distanceCamera,
                crs.getGeoideName(),
                zoomToCallback,
                { features: [feature] }
            );
        } else {
            searchLayer(objectName, onSuccess, onError);
        }
    };

    /**
     * Code to execute when remove
     * @function remove
     * @memberof DictionaryNameResolver#
     */
    DictionaryNameResolver.prototype.remove = function() {
        dictionary = null;
    };

    return DictionaryNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/NameResolver/IMCCENameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractNameResolver",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "../Utils/Proxy"
], function($, _, Utils, AbstractNameResolver, Constants, ErrorDialog, Proxy) {
    /**************************************************************************************************************/

    /**
     * @name IMCCENameResolver
     * @class
     *     Plugin to access to IMCCE name resolver
     * @augments AbstractNameResolver
     * @param {Context} options - Context
     * @memberof module:NameResolver
     * @constructor
     */
    var IMCCENameResolver = function(options) {
        AbstractNameResolver.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractNameResolver, IMCCENameResolver);

    /**************************************************************************************************************/

    /**
     * Queries SSODnet using this URL https://api.ssodnet.imcce.fr/quaero/1/sso?q=<i>objectName</i>
     * and the layers
     * @function handle
     * @memberof IMCCENameResolver#
     */
    IMCCENameResolver.prototype.handle = function(options) {
        //TODO refactor AJAX request
        var objectName = options.objectName;
        var onError = options.onError;
        var onComplete = options.onComplete;
        var onSuccess = options.onSuccess;
        var searchLayer = options.searchLayer;
        var zoomTo = options.zoomTo;
        var url =
            "https://api.ssodnet.imcce.fr/quaero/1/sso?q=" +
            objectName +
            "&from=Mizar";
        $.ajax({
            type: "GET",
            url: Proxy.proxify(url),
            dataType: "json",
            beforeSend: function(xhr) {
                xhr.setRequestHeader("Accept", "application/json");
            },
            success: function(jsonResponse) {
                var data = jsonResponse.data;
                parseResponse(data, createsGeoJsonResponse);

                function parseResponse(data, callback) {
                    var features = [];
                    var i = 0;
                    var dataLength = data.length;
                    if (dataLength === 0) {
                        onError();
                    } else {
                        _.each(data, function(data) {
                            parseItem(data, function(feature) {
                                i++;
                                if (!_.isEmpty(feature)) {
                                    features.push(feature);
                                }
                                if (i === dataLength) {
                                    callback(features);
                                }
                            });
                        });
                    }
                }

                function parseItem(data, callback) {
                    var type = data.type;
                    var id = data.id;
                    var name = data.name;
                    if (
                        $.inArray(type, [
                            "Planet",
                            "Asteroid",
                            "Satellite",
                            "Star",
                            "Comet"
                        ]) !== -1
                    ) {
                        var url =
                            "https://api.ssodnet.imcce.fr/quaero/1/sso/" +
                            id +
                            "/resolver";
                        Utils.requestUrl(
                            url,
                            "json",
                            "application/json",
                            null,
                            function(data) {
                                var coordinates = data.geometry.coordinates;
                                var ra = (coordinates[0] * 360) / 24;
                                var dec = coordinates[1];
                                if (_.isNumber(ra) && _.isNumber(dec)) {
                                    ra = parseFloat(ra);
                                    dec = parseFloat(dec);
                                    var feature = {};
                                    feature.ra = ra;
                                    feature.dec = dec;
                                    feature.credits =
                                        "Powered by <a href=\"http://vo.imcce.fr/webservices/ssodnet/?quaero\" target=\"_blank\">SsODNet/Quaero API</a>.";
                                    feature.id = id;
                                    feature.type = type;
                                    feature.name = name;
                                    callback(feature);
                                }
                            },
                            function(err) {
                                ErrorDialog.open(
                                    Constants.LEVEL.ERROR,
                                    "Failed ot request " + url,
                                    err
                                );
                            }
                        );
                    } else {
                        callback();
                    }
                }

                function createsGeoJsonResponse(features) {
                    var response = {
                        totalResults: features.length,
                        type: "FeatureCollection",
                        features: []
                    };
                    _.each(features, function(feature) {
                        response.features.push({
                            type: "Feature",
                            geometry: {
                                coordinates: [feature.ra, feature.dec],
                                type: "Point",
                                crs: {
                                    type: "name",
                                    properties: {
                                        name: Constants.CRS.Equatorial
                                    }
                                }
                            },
                            properties: {
                                identifier: feature.id,
                                type: feature.type,
                                name: feature.name,
                                credits: feature.credits
                            }
                        });
                    });
                    if (
                        response.type === "FeatureCollection" &&
                        response.features.length > 0
                    ) {
                        var firstFeature = response.features[0];
                        var zoomToCallback = function() {
                            searchLayer(
                                objectName,
                                onSuccess,
                                onError,
                                response
                            );
                        };
                        zoomTo(
                            firstFeature.geometry.coordinates[0],
                            firstFeature.geometry.coordinates[1],
                            null,
                            Constants.CRS.Equatorial,
                            zoomToCallback,
                            response
                        );
                    } else {
                        onError();
                    }
                }
            },
            error: function(xhr) {
                searchLayer(objectName, onSuccess, onError);
                if (onError) {
                    //TODO : network problem
                }
                ErrorDialog.open(Constants.LEVEL.ERROR,xhr.responseText);
            },
            complete: function(xhr) {
                if (onComplete) {
                    onComplete(xhr);
                }
            }
        });
    };

    /**
     * @function remove
     * @memberof IMCCENameResolver#
     */
    IMCCENameResolver.prototype.remove = function() {};

    return IMCCENameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name NameResolver
 * @class
 * Name resolver
 * @memberof module:NameResolver
 */
define('gw/NameResolver/NameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "../Renderer/FeatureStyle",
    "../Layer/VectorLayer",
    "../Tiling/HEALPixBase",
    "./DefaultNameResolver",
    "jquery.ui",
    "./CDSNameResolver",
    "./DictionaryNameResolver",
    "./IMCCENameResolver"
], function(
    $,
    _,
    Constants,
    ErrorDialog,
    FeatureStyle,
    VectorLayer,
    HEALPixBase,
    DefaultNameResolver
) {
    /**
     * plugin:not_found.<br/>
     * Called when no plugin is found whereas it is requested
     * @event NameResolver#plugin:not_found
     * @type {string}
     */

    // Name resolver globals
    var mizarAPI;
    var context;

    // Name resolver properties
    var duration;
    var zoomFov;
    var targetLayer; // Layer containing target feature(cross) on zoom
    var targetFeature; // Zooming destination feature

    //Wrapper Object
    var nameResolverImplementation = null;

    /**************************************************************************************************************/

    /**
     *    Update targetFeature and add it to the target layer
     *
     *    @param lon Destination longitude/right ascension in degrees
     *    @param lat Destination latitude/declination in degrees
     *    @param crs coordinate reference system of the (longitude,latitude)
     */
    function addTarget(lon, lat, crs) {
        targetFeature = {
            geometry: {
                coordinates: [lon, lat],
                type: Constants.GEOMETRY.Point,
                crs: {
                    type: "name",
                    properties: {
                        name: crs
                    }
                }
            },
            type: "Feature"
        };

        targetLayer.addFeature(targetFeature);
    }

    function zoomToHips(matchHealpix, onSuccess) {
        var order = parseInt(matchHealpix[1], 10);
        var pixelIndex = parseInt(matchHealpix[2], 10);

        // Compute vertices
        var nside = Math.pow(2, order);
        /*jslint bitwise: true */
        var pix = pixelIndex & (nside * nside - 1);
        var ix = HEALPixBase.compress_bits(pix);
        /*jslint bitwise: true */
        var iy = HEALPixBase.compress_bits(pix >>> 1);
        /*jslint bitwise: true */
        var face = pixelIndex >>> (2 * order);

        var i = 0.5;
        var j = 0.5;
        var vert = HEALPixBase.fxyf((ix + i) / nside, (iy + j) / nside, face);
        var geoPos = [];
        mizarAPI.getCrs().getWorldFrom3D(vert, geoPos);
        zoomTo(
            geoPos[0],
            geoPos[1],
            null,
            mizarAPI.getCrs().getGeoideName(),
            onSuccess
        );
    }

    function zoomToSexagesimal(coordinates, onSuccess) {
        // Format to equatorial coordinates
        var word = coordinates.split(" "); // [RA, Dec]

        word[0] = word[0].replace(/h|m|:/g, " ");
        word[0] = word[0].replace("s", "");
        word[1] = word[1].replace(/|'|:/g, " ");
        word[1] = word[1].replace("\"", "");

        // Convert to geo and zoom
        var geoPos = [];
        mizarAPI
            .getCrs()
            .getDecimalDegFromSexagesimal([word[0], word[1]], geoPos);
        zoomTo(
            geoPos[0],
            geoPos[1],
            null,
            mizarAPI.getCrs().getGeoideName(),
            onSuccess
        );
    }

    function zoomToDecimal(matchDegree, onSuccess, onErrorOutOfBound) {
        var currentGeoBound = mizarAPI.getCrs().getGeoBound();
        var lon = parseFloat(matchDegree[1]);
        var lat = parseFloat(matchDegree[3]);
        var geo = [lon, lat];
        if (currentGeoBound.isPointInside(geo)) {
            zoomTo(
                geo[0],
                geo[1],
                null,
                mizarAPI.getCrs().getGeoideName(),
                onSuccess
            );
        } else {
            onErrorOutOfBound.call(this);
        }
    }

    /**************************************************************************************************************/
    /**
     *    Search for object name
     *    Object name could be:
     *        * Degree in "HMS DMS" or "deg deg"
     *        * Object name as "Mars", "m31", "Mizar"
     *        * For debug : healpix(order,pixelIndex)
     *    @fires NameResolver#plugin:not_found
     */
    function search(
        objectName,
        onSuccess,
        onError,
        onErrorOutOfBound,
        onComplete
    ) {
        var geoPos;
        // regexp used only to distinct equatorial coordinates and objects
        // TODO more accurate ( "x < 24h", "x < 60mn", etc.. )
        objectName = objectName.replace(/\s{2,}/g, " "); // Replace multiple spaces by a single one
        var coordinatesExp = new RegExp(
            "\\d{1,2}[h|:]\\d{1,2}[m|:]\\d{1,2}([\\.]\\d+)?s?\\s[-+]?[\\d]+[|:]\\d{1,2}['|:]\\d{1,2}([\\.]\\d+)?\"?",
            "g"
        );
        var healpixRE = /^healpix\((\d)+,(\d+)\)/;
        var degRE = /^(-?\d+(\.\d+)?),?\s(-?\d+(\.\d+)?)/;
        var layerRE = /^layer:(.)*?/;
        var matchHealpix = healpixRE.exec(objectName);
        var matchDegree = degRE.exec(objectName);
        var matchLayer = layerRE.exec(objectName);
        if (matchHealpix) {
            zoomToHips(matchHealpix, onSuccess);
        } else if (objectName.match(coordinatesExp)) {
            zoomToSexagesimal(objectName, coordinatesExp, onSuccess);
        } else if (matchDegree) {
            zoomToDecimal(matchDegree, onSuccess, onErrorOutOfBound);
        } else {
            var options = {
                objectName: objectName,
                onError: onError,
                onComplete: onComplete,
                onSuccess: onSuccess,
                searchLayer: searchLayer,
                zoomTo: zoomTo
            };

            if (nameResolverImplementation) {
                nameResolverImplementation.handle(options);
            } else {
                mizarAPI.publish(
                    Constants.EVENT_MSG.PLUGIN_NOT_FOUND,
                    "No name resolver found"
                );
            }
        }
    }

    function searchLayer(objectName, onSuccess, onError, response) {
        var layers = mizarAPI.searchOnLayerDescription(
            objectName,
            mizarAPI.getActivatedContext().getMode()
        );
        if (layers.length === 0 && (!response || response.totalResults === 0)) {
            if (onError) {
                onError();
            }
            return;
        }

        layers = _.sortBy(layers, function(layer) {
            return layer.category === "background" ? 0 : 1;
        });

        var results;
        // Check if response contains features
        if (response && response.type === "FeatureCollection") {
            results = response;
        } else {
            results = {};
            results.type = "FeatureCollection";
            results.features = [];
        }

        _.each(layers, function(layer) {
            results.features.push({
                type: "Feature",
                properties: {
                    type: "layer",
                    name: layer.getName(),
                    description: layer.getDescription(),
                    layerType: layer.getType(),
                    visible: layer.isVisible(),
                    background: layer.category === "background"
                }
            });
        });

        onSuccess(results);
    }

    /**************************************************************************************************************/

    /**
     *    Zoom to the given longitude/latitude and add target at the end
     *    @param lon Longitude
     *    @param lat Latitude
     *    @param distanceCamera Final Distance in meters from the ground to the camera - only use for PlanetContext / set to null for the others contexts
     *    @param crs coordinate reference system of the (longitude, latitude)
     *    @param callback Callback once animation is over
     *    @param args Callback arguments
     */
    function zoomTo(lon, lat, distanceCamera, crs, callback, args) {
        if (args !== null && typeof args !== "undefined") {
            // updates the coordinates, which is displayed at the screen in the current CRS
            var idx = 0;
            while (idx < args.features.length) {
                args.features[
                    idx
                ].geometry.coordinates = mizarAPI
                    .getCrs()
                    .convert(
                        args.features[idx].geometry.coordinates,
                        crs,
                        mizarAPI.getCrs().getGeoideName()
                    );
                args.features[idx].geometry.crs.properties.name = crs;
                idx++;
            }
        }

        // Add target feature on animation stop
        var addTargetCallback = function() {
            addTarget(lon, lat, crs);
            if (callback) {
                callback.call(this, args);
            }
        };
        var position = mizarAPI
            .getCrs()
            .convert([lon, lat], crs, mizarAPI.getCrs().getGeoideName());
        if (
            mizarAPI.getActivatedContext().getMode() === Constants.CONTEXT.Sky
        ) {
            mizarAPI
                .getActivatedContext()
                .getNavigation()
                .zoomTo(position, {
                    fov: zoomFov,
                    duration: duration,
                    callback: addTargetCallback
                });
        } else {
            var distance =
                distanceCamera == null
                    ? mizarAPI
                        .getActivatedContext()
                        .getNavigation()
                        .getDistance()
                    : distanceCamera;
            mizarAPI
                .getActivatedContext()
                .getNavigation()
                .zoomTo([lon, lat], {
                    distance: distance,
                    duration: duration,
                    callback: addTargetCallback
                });
        }
    }

    /**************************************************************************************************************/

    /**
     *    Delete target image
     */
    function removeTarget() {
        if (targetFeature) {
            targetLayer.removeFeature(targetFeature);
            targetFeature = null;
        }
    }

    /**************************************************************************************************************/

    /**************************************************************************************************************/

    return {
        /**
         * Init name resolver
         * @param {Mizar} m - Mizar API
         * @alias module:NameResolver.NameResolver.init
         */
        init: function(m) {
            if (!context) {
                mizarAPI = m;
                this.setContext(mizarAPI.getActivatedContext());
            } else {
                ErrorDialog.open(Constants.LEVEL.DEBUG, "Name resolver is already initialized");
            }
        },

        /**
         * Unregisters all event handlers
         * @alias module:NameResolver.NameResolver.remove
         */
        remove: function() {
            if (context) {
                mizarAPI.getActivatedContext().removeDraw(targetLayer);
                if (nameResolverImplementation !== undefined) {
                    nameResolverImplementation.remove();
                }
                mizarAPI
                    .getActivatedContext()
                    .unsubscribe(
                        Constants.EVENT_MSG.NAVIGATION_MODIFIED,
                        removeTarget
                    );
                context = null;
            }
        },

        /**
         *    Search for object name
         *    Object name could be:
         *    <ul>
         *        <li>Degree in "HMS DMS" or "deg deg"</li>
         *        <li>Object name as "Mars", "m31", "Mizar"</li>
         *        <li>For debug : healpix(order,pixelIndex)</li>
         *    </ul>
         *    @alias module:NameResolver.NameResolver.goTo
         *    @fires Mizar#plugin:not_found
         */
        goTo: search,

        /**
         *    Zoom to the given longitude/latitude and add target at the end
         *    @param lon Longitude
         *    @param lat Latitude
         *    @param crs coordinate reference system of the (longitude, latitude)
         *    @param callback Callback once animation is over
         *    @param args Callback arguments
         *    @alias module:NameResolver.NameResolver.zoomTo
         */
        zoomTo: zoomTo,

        /**
         *    Set context
         *    @alias module:NameResolver.NameResolver.setContext
         *    @listens Context#modifiedNavigation
         *    @fires Context#backgroundLayer:added
         *    @fires Context#layer:added
         */
        setContext: function(ctx) {
            // Remove previous context
            this.remove();
            context = ctx;

            //instantiate name resolver nameResolverImplementation object
            var isDefaultNameResolver;
            var nameResolverClass;
            if (
                typeof context.getContextConfiguration().nameResolver !==
                "undefined"
            ) {
                nameResolverClass = require(context.getContextConfiguration()
                    .nameResolver.jsObject);
                isDefaultNameResolver = false;
                nameResolverImplementation = new nameResolverClass(context);
            } else {
                //Use default name resolver if none defined...
                isDefaultNameResolver = true;
                nameResolverImplementation = new DefaultNameResolver(context);
            }

            var style = new FeatureStyle({
                iconUrl:
                    ctx.getMizarConfiguration().mizarBaseUrl +
                    "css/images/target.png",
                fillColor: [1, 1, 1, 1]
            });
            targetLayer = new VectorLayer({ style: style, visible: true });

            mizarAPI.getActivatedContext().addDraw(targetLayer);

            // Update name resolver properties
            if (isDefaultNameResolver) {
                duration = 3000;
                zoomFov = 15;
            } else {
                duration =
                    context.getContextConfiguration().nameResolver.duration ||
                    3000;
                zoomFov =
                    context.getContextConfiguration().nameResolver.zoomFov ||
                    15;
            }

            ctx.subscribe(
                Constants.EVENT_MSG.NAVIGATION_MODIFIED,
                removeTarget
            );
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/ReverseNameResolver/AbstractReverseNameResolver',[], function() {
    /**************************************************************************************************************/

    /**
     * @class
     * Abstract Wrapper constructor
     * @param {Context} options - context
     * @implements {ReverseNameResolver}
     */
    var AbstractReverseNameResolver = function(options) {
        this.ctx = options;
    };

    /**************************************************************************************************************/

    /**
     * @function handle
     * @memberof AbstractReverseNameResolver#
     * @abstract
     */
    AbstractReverseNameResolver.prototype.handle = function() {
        throw new SyntaxError(
            "handle from AbstractReverseNameResolver not implemented",
            "AbstractReverseNameResolver.js"
        );
    };

    /**
     * @function remove
     * @memberof AbstractReverseNameResolver#
     * @abstract
     */
    AbstractReverseNameResolver.prototype.remove = function() {
        throw new SyntaxError(
            "remove from AbstractReverseNameResolver not implemented",
            "AbstractReverseNameResolver.js"
        );
    };

    /**************************************************************************************************************/

    ///**
    // *    Extract HealpixId, order from url
    // */
    //AbstractReverseNameResolver.prototype.extractFilters = function (url) {
    //    var filtersUrl = url.substring(url.indexOf('?') + 1, url.length);
    //
    //    var filtersParts = filtersUrl.split('&');
    //
    //    var startOrder, startHealpixID;
    //    var order, healpixID;
    //    _.each(filtersParts, function (part) {
    //
    //        var keyAndValue = part.split('=');
    //
    //        if (keyAndValue[0] === "order") {
    //            order = keyAndValue[1];
    //        }
    //        if (keyAndValue[0] === "healpix") {
    //            healpixID = keyAndValue[1];
    //        }
    //    });
    //
    //    return this.filters = {
    //        "healpixID": healpixID,
    //        "order": order
    //    };
    //};

    return AbstractReverseNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/ReverseNameResolver/DefaultReverseNameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractReverseNameResolver"
], function($, _, Utils, AbstractReverseNameResolver) {
    /**************************************************************************************************************/

    /**
     * @name DefaultReverseNameResolver
     * @class
     *   Plugin to access to Default reverse name resolver
     * @augments AbstractReverseNameResolver
     * @param {Context} options - Context
     * @memberof module:ReverseNameResolver
     */
    var DefaultReverseNameResolver = function(options) {
        AbstractReverseNameResolver.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractReverseNameResolver, DefaultReverseNameResolver);

    /**************************************************************************************************************/

    /**
     * @function handle
     * @memberof DefaultReverseNameResolver#
     * @param {Object} options
     */
    DefaultReverseNameResolver.prototype.handle = function(options) {
        var self = this;

        var maxOrder = options.maxOrder;
        var equatorialCoordinates = options.equatorialCoordinates;
        var context = options.context;

        var requestUrl =
            context.getMizarConfiguration().reverseNameResolver.baseUrl +
            "/EQUATORIAL/" +
            equatorialCoordinates[0] +
            " " +
            equatorialCoordinates[1] +
            ";" +
            maxOrder;

        Utils.requestUrl(
            requestUrl,
            "text",
            "text/plain",
            null,
            function(response) {
                if (options && options.success) {
                    options.success(response);
                }
            },
            function(err) {
                if (options && options.error) {
                    options.error(err);
                }
            }
        );
    };

    /**
     * @function remove
     * @memberof DefaultReverseNameResolver#
     */
    DefaultReverseNameResolver.prototype.remove = function(options) {};

    /**************************************************************************************************************/

    return DefaultReverseNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/**
 * Reverse Name resolver module : API allowing to retrieve information from a geo picking
 * @module ReverseNameResolver
 * @implements {ReverseNameResolver}
 */
define('gw/ReverseNameResolver/CDSReverseNameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Constants",
    "../Utils/Utils",
    "./AbstractReverseNameResolver",
    "../Tiling/HEALPixBase"
], function($, _, Constants, Utils, AbstractReverseNameResolver, HEALPixBase) {
    /**************************************************************************************************************/

    var HOUR_TO_DEG = 15.0;
    var lastCallTime = null;
    var callTimeInterval = 6000;

    /**
     * @name CDSReverseNameResolver
     * @class
     *   Plugin to access to CDS reverse name resolver
     * @augments AbstractReverseNameResolver
     * @param {Context} options - Context
     * @memberof module:ReverseNameResolver
     */
    var CDSReverseNameResolver = function(options) {
        AbstractReverseNameResolver.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractReverseNameResolver, CDSReverseNameResolver);

    /**************************************************************************************************************/

    /**
     * Queries the CDS reverse name resolver
     * @function handle
     * @memberof CDSReverseNameResolver#
     * @param {Object} options - parameters
     * @param {int} options.maxOrder - Max Hips order
     * @param {float[]} options.pos - position
     * @param {Mizar} options.mizarAPI - mizar API
     * @param {Function} options.error - error function
     * @param {Function} options.success - success function
     */
    CDSReverseNameResolver.prototype.handle = function(options) {
        //Do not call the service to often
        var now = Date.now();
        var diff = now - callTimeInterval;
        if (lastCallTime !== null && diff <= lastCallTime) {
            if (options && options.error) {
                options.error({
                    status: 503
                });
            }
            return;
        }

        var self = this;

        var maxOrder = options.maxOrder;
        var pos = options.pos;
        var mizarAPI = options.mizarAPI;
        pos = mizarAPI
            .getCrs()
            .convert(
                pos,
                mizarAPI.getCrs().getGeoideName(),
                Constants.CRS.Equatorial
            );

        var equatorialCoordinates = [];
        mizarAPI.getCrs().getSexagesimalFromDeg(pos, equatorialCoordinates);

        // Format to equatorial coordinates
        equatorialCoordinates[0] = equatorialCoordinates[0].replace("h ", ":");
        equatorialCoordinates[0] = equatorialCoordinates[0].replace("m ", ":");
        equatorialCoordinates[0] = equatorialCoordinates[0].replace("s", "");

        equatorialCoordinates[1] = equatorialCoordinates[1].replace(" ", ":");
        equatorialCoordinates[1] = equatorialCoordinates[1].replace("' ", ":");
        equatorialCoordinates[1] = equatorialCoordinates[1].replace("\"", "");

        //BEGINING OF SPECIFIC PROCESSING
        //DO IT WITHOUT REQUESTING SITOOLS
        /**
         * Arsec 2 degree conversion.
         */
        var ARCSEC_2_DEG = 1 / 3600.0;
        /**
         * MAX radius of a cone in arcsec.
         */
        var MAX_RADIUS = 1800.0;

        var nside = Math.pow(2, maxOrder);

        var pixRes = HEALPixBase.getPixRes(nside);
        var radius = pixRes > MAX_RADIUS ? MAX_RADIUS : pixRes / 2;
        radius *= ARCSEC_2_DEG;

        var requestUrl = mizarAPI
            .getActivatedContext()
            .getContextConfiguration().reverseNameResolver.baseUrl;

        requestUrl = requestUrl.replace(
            "{coordinates}",
            equatorialCoordinates[0] + " " + equatorialCoordinates[1]
        );
        requestUrl = requestUrl.replace("{radius}", radius);

        Utils.requestUrl(
            requestUrl,
            "text",
            "text/plain",
            null,
            function(response) {
                lastCallTime = Date.now();

                // we parse the message that is returned by the server
                var posParenthesis = response.indexOf("(");
                var posComma = response.indexOf(",");
                var posSlash = response.indexOf("/");
                var position = response.substring(0, posSlash);
                var name = response.substring(posSlash + 1, posParenthesis);

                var magnitude = parseFloat(
                    response.substring(posParenthesis + 1, posComma)
                );
                var objectType = response.substring(
                    posComma + 1,
                    response.length - 2
                );

                var positionElts = position.split(" ");

                //GET HMS
                var hours = parseFloat(positionElts[0]);
                var min = parseFloat(positionElts[1]);
                var sec = parseFloat(positionElts[2]);

                var degrees = parseFloat(positionElts[3]);
                var min2 = parseFloat(positionElts[4]);
                var sec2 = parseFloat(positionElts[5]);

                var ra = self._parseRa(hours, min, sec);
                var dec = self._parseDec(degrees, min2, sec2);

                var features = {
                    totalResults: 1,
                    type: "FeatureCollection",
                    features: [
                        {
                            type: "Feature",
                            geometry: {
                                coordinates: [ra, dec],
                                type: Constants.GEOMETRY.Point,
                                crs: {
                                    type: "name",
                                    properties: {
                                        name: Constants.CRS.Equatorial
                                    }
                                }
                            },
                            properties: {
                                title: name,
                                magnitude: magnitude,
                                credits: "CDS",
                                seeAlso:
                                    "http://simbad.u-strasbg.fr/simbad/sim-id?Ident=" +
                                    name,
                                type: objectType,
                                identifier: name
                            }
                        }
                    ]
                };

                if (options && options.success) {
                    options.success(features);
                }
                //END OF SPECIFIC PROCESSING
            },
            function(err) {
                if (options && options.error) {
                    options.error(err);
                }
            }
        );
    };

    /**
     * Parse RA.
     * @function _parseRa
     * @memberof CDSReverseNameResolver#
     * @param hours
     * @param min
     * @param sec
     * @returns {number}
     * @private
     */
    CDSReverseNameResolver.prototype._parseRa = function(hours, min, sec) {
        var intHours = parseInt(hours, 10);
        var val = (sec / 60.0 + min) / 60.0;

        if (hours <= 0.0) {
            val = hours - val;
            intHours = -intHours;
        } else {
            val = intHours + val;
        }
        return val * HOUR_TO_DEG;
    };

    /**
     * Parse dec
     * @function _parseDec
     * @memberof CDSReverseNameResolver#
     * @param degrees
     * @param min
     * @param sec
     * @returns {number}
     * @private
     */
    CDSReverseNameResolver.prototype._parseDec = function(degrees, min, sec) {
        var intDegrees = parseInt(degrees, 10);

        var val = (sec / 60.0 + min) / 60.0;

        if (degrees <= 0.0) {
            val = degrees - val;
            intDegrees = -intDegrees;
        } else {
            val = intDegrees + val;
        }
        return val;
    };

    /**
     * @function remove
     * @memberof CDSReverseNameResolver#
     */
    CDSReverseNameResolver.prototype.remove = function() {};

    /**************************************************************************************************************/

    return CDSReverseNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Name resolver module : search object name from its coordinates
 * TODO : move _handleMouseDown&Up to View ?
 */
define('gw/ReverseNameResolver/ReverseNameResolver',[
    "jquery",
    "../Utils/Constants",
    "./DefaultReverseNameResolver",
    "./CDSReverseNameResolver",
    "../Gui/dialog/ErrorDialog"
], function($, Constants, DefaultReverseNameResolver, ErrorDialog) {
    var mizarAPI;
    var context;

    var reverseNameResolverImplementation = null;

    return {
        init: function(m) {
            mizarAPI = m;
            this.setContext(mizarAPI.getActivatedContext());
        },

        /**************************************************************************************************************/

        /**
         *    Send request to reverse name resolver service for the given gepoint
         *    @param geoPick    Geographic position of point of interest
         *    @param options
         *        <li>success: Function called on success with the response of server as argument</li>
         *        <li>error: Function called on error with the xhr object as argument</li>
         *    @fires Mizar#plugin:not_found
         */
        sendRequest: function(geoPick, options) {
            var self = this;
            // TODO: depending on context, send the request
            // Currently only sky context is handled
            if (
                mizarAPI.getActivatedContext().getMode() ===
                Constants.CONTEXT.Sky
            ) {
                // Find max order
                var maxOrder = 3;
                mizarAPI
                    .getActivatedContext()
                    .getTileManager()
                    .visitTiles(function(tile) {
                        if (maxOrder < tile.order) {
                            maxOrder = tile.order;
                        }
                    });

                options.maxOrder = maxOrder;
                options.pos = geoPick;
                options.mizarAPI = mizarAPI;

                if (reverseNameResolverImplementation) {
                    reverseNameResolverImplementation.handle(options);
                } else {
                    mizarAPI.publish(
                        Constants.EVENT_MSG.PLUGIN_NOT_FOUND,
                        "No reserve name resolver found"
                    );
                }
            } else {
                ErrorDialog.open(Constants.LEVEL.DEBUG,"ReverseNameResolver.js","Not implemented yet");
                if (options && options.error) {
                    options.error();
                }
            }
        },

        /**************************************************************************************************************/

        /**
         *    Set new context
         */
        setContext: function(ctx) {
            context = ctx;

            //instantiate reverse name resolver nameResolverImplementation object
            var reverseNameResolverClass;
            if (
                typeof context.getContextConfiguration().reverseNameResolver !==
                "undefined"
            ) {
                reverseNameResolverClass = require(context.getContextConfiguration()
                    .reverseNameResolver.jsObject);
                reverseNameResolverImplementation = new reverseNameResolverClass(
                    context
                );
            } else {
                //Use default reverse name resolver if none defined...
                reverseNameResolverImplementation = new DefaultReverseNameResolver(
                    context
                );
            }
        }
    };
});

define('gw/Time/TimeSample',["jquery", "moment", "../Utils/Constants", "../Utils/Utils"], function(
    $,
    Moment,
    Constants,
    Utils
) {
    /**
     * @class
     * Store time sample
     * @constructor
     */
    var TimeSample = function() {
        this.start = null;
        this.end = null;
        this.stepValue = null;
        this.stepKind = null;
        this.layerID = null;
    };

    /**************************************************************************************************************/

    /**
     * Get the start date
     * @function getStart
     * @return {Date} Start date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getStart = function() {
        return this.start;
    };

    /**************************************************************************************************************/

    /**
     * Set the start date of sample
     * @function setStart
     * @param {Date} date Start date
     * @memberof TimeSample#
     */
    TimeSample.prototype.setStart = function(date) {
        this.start = Moment.utc(date);
    };

    /**************************************************************************************************************/

    /**
     * Get the end date
     * @function getEnd
     * @return {Date} End date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getEnd = function() {
        return this.end;
    };

    /**************************************************************************************************************/

    /**
     * Set the end date
     * @function setEnd
     * @param {Date} date End date
     * @memberof TimeSample#
     */
    TimeSample.prototype.setEnd = function(date) {
        this.end = Moment.utc(date);
    };

    /**************************************************************************************************************/

    /**
     * Get the step value
     * @function getStepValue
     * @return {Integer} Step value
     * @memberof TimeSample#
     */
    TimeSample.prototype.getStepValue = function() {
        return this.stepValue;
    };

    /**************************************************************************************************************/

    /**
     * Set the step value
     * @function setStepValue
     * @param {Integer} stepValue Step value
     * @memberof TimeSample#
     */
    TimeSample.prototype.setStepValue = function(stepValue) {
        this.stepValue = stepValue;
    };

    /**************************************************************************************************************/

    /**
     * Get the step kind
     * @function getStepKind
     * @return {string} Step kind
     * @memberof TimeSample#
     */
    TimeSample.prototype.getStepKind = function() {
        return this.stepKind;
    };

    /**************************************************************************************************************/

    /**
     * Set the step kind
     * @function setStepKind
     * @param {string} stepKind Step kind
     * @memberof TimeSample#
     */
    TimeSample.prototype.setStepKind = function(stepKind) {
        this.stepKind = stepKind;
    };

    /**************************************************************************************************************/

    /**
     * Set the layer ID
     * @function setLayerID
     * @param {string} layerID Layer ID
     * @memberof TimeSample#
     */
    TimeSample.prototype.setLayerID = function(layerID) {
        this.layerID = layerID;
    };

    /**************************************************************************************************************/

    /**
     * Get the layer ID
     * @function getLayerID
     * @return {string} Layer ID
     * @memberof TimeSample#
     */
    TimeSample.prototype.getLayerID = function() {
        return this.layerID;
    };

    /**************************************************************************************************************/

    /**
     * Get next date
     * @function getNextDate
     * @return {Date} Next date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getNextDate = function(date) {
        var nextDate = null;
        nextDate = Moment.utc(date).add(this.stepValue, this.stepKind);
        if (nextDate > this.end) {
            nextDate = null;
        }
        return nextDate;
    };

    /**************************************************************************************************************/

    /**
     * Get previous date
     * @function getPreviousDate
     * @return {Date} Previous date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getPreviousDate = function(date) {
        var previousDate = null;
        previousDate = Moment.utc(date).subtract(this.stepValue, this.stepKind);
        if (previousDate < this.start) {
            previousDate = null;
        }
        return previousDate;
    };

    /**************************************************************************************************************/

    /**
     * Get first date AFTER a specified date
     * @function getFirstDateAfter
     * @param {Date} date Date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getFirstDateAfter = function(date) {
        var foundDate = null;
        var foundPeriod = { from: null, to: null };
        var foundDisplay = null;

        if (date < this.start) {
            // trivial case, first date is after !
            foundDate = this.start;
            foundDisplay = Moment(foundDate.toISOString()).format(
                Moment(foundDate).creationData().format
            );
        } else if (date > this.end) {
            // trivial case, date is after the last date
            foundDate = null;
        } else {
            // go to search
            var currentDate = this.start;
            var isDone = false;
            var nextDate = null;
            while (!isDone) {
                currentDate = this.getNextDate(currentDate);
                if (currentDate === null) {
                    // Null found, no more date, stop it whith found date set to null
                    isDone = true;
                    foundDate = null;
                }
                if (currentDate > date) {
                    isDone = true;
                    foundDate = currentDate;
                }
            }
        }

        if (foundDate !== null) {
            foundPeriod.from = foundDate;
            foundPeriod.to = foundDate;
            foundDisplay = Moment(foundDate.toISOString()).format(
                Moment(foundDate).creationData().format
            );
        }

        return {
            date: foundDate,
            period: foundPeriod,
            display: foundDisplay
        };
    };

    /**************************************************************************************************************/

    /**
     * Get first date BEFORE a specified date
     * @function getFirstDateBefore
     * @param {Date} date Date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getFirstDateBefore = function(date) {
        var foundDate = null;
        var foundPeriod = { from: null, to: null };
        var foundDisplay = null;

        if (date > this.end) {
            // trivial case, end date is before !
            foundDate = this.end;
            foundDisplay = Moment(foundDate.toISOString()).format(
                Moment(foundDate).creationData().format
            );
        } else if (date < this.start) {
            // trivial case, date is before the first date
            foundDate = null;
        } else {
            // go to search
            var currentDate = this.start;
            var previousDate = null;
            var isDone = false;
            var nextDate = null;

            while (!isDone) {
                previousDate = currentDate;
                currentDate = this.getNextDate(currentDate);
                if (currentDate === null) {
                    // Null found, no more date, stop it whith found date set to null
                    isDone = true;
                    foundDate = previousDate;
                }
                if (currentDate > date) {
                    isDone = true;
                    foundDate = previousDate;
                }
            }
        }
        if (foundDate !== null) {
            foundDisplay = Moment(foundDate.toISOString()).format(
                Moment(foundDate).creationData().format
            );
            foundPeriod.from = foundDate;
            foundPeriod.to = foundDate;
        }
        return {
            date: foundDate,
            period: foundPeriod,
            display: foundDisplay
        };
    };

    /**************************************************************************************************************/

    /**
     * Get min date
     * @function getMinDate
     * @return {Date} Min date or null
     * @memberof TimeSample#
     */
    TimeSample.prototype.getMinDate = function() {
        return this.getStart();
    };

    /**************************************************************************************************************/

    /**
     * Get max date
     * @function getMaxDate
     * @return {Date} Max date or null
     * @memberof TimeSample#
     */
    TimeSample.prototype.getMaxDate = function() {
        return this.getEnd();
    };

    /**************************************************************************************************************/

    /**
     * Get string representation
     * @function toString
     * @return {string} String representation
     * @memberof TimeSample#
     */
    TimeSample.prototype.toString = function() {
        return (
            Moment(this.start) +
            " / " +
            Moment(this.end) +
            " / " +
            this.stepValue +
            this.stepKind +
            " / ID=" +
            this.layerID
        );
    };

    return TimeSample;
});

define('gw/Time/TimeEnumerated',["jquery", "moment", "../Utils/Constants", "../Utils/Utils","../Time/TimeTravelParams"], function(
    $,
    Moment,
    Constants,
    Utils,
    TimeTravelParams
) {
    /**
     * @class
     * Stock time sample
     * @constructor
     */
    var TimeEnumerated = function() {
        // Array of enumerated values
        this.enumeratedValues = null;
        this.currentIndex = null;
    };

    /**************************************************************************************************************/

    /**
     * Sort enumerated values by date
     * @function sortTime
     * @param {Date} a First date
     * @param {Date} b Second date
     * @memberof TimeEnumerated#
     * @private
     */
    function sortTime(a, b) {
        return a.date > b.date ? 1 : -1;
    }

    /**************************************************************************************************************/

    /**
     * Get the current index
     * @function getCurrentIndex
     * @return Integer Current index
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getCurrentIndex = function() {
        return this.currentIndex;
    };

    /**************************************************************************************************************/

    /**
     * Parse date
     * @function parseDate
     * @param {string} value Date to parse
     * @return {Json} date { "date", "display", "period" { "from", "to" } }
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.parseDate = function(value) {
        value = value.trim();
        var date = null;
        var period = null;

        var regExpYear = /^\d{4}$/;
        var regExpMonth = /^\d{4}-\d{2}$/;
        var regExpDay = /^\d{4}-\d{2}-\d{2}$/;
        if (typeof value === "string") {
            // Year management
            if (regExpYear.test(value)) {
                date = Moment.utc(value, "YYYY");
                period = {};
                period.from = date;
                period.to = Moment.utc(period.from).endOf(
                    Constants.TIME_STEP.YEAR
                );
            }
            // Month management
            if (regExpMonth.test(value)) {
                date = Moment.utc(value, "YYYY-MM");
                period = {};
                period.from = date;
                period.to = Moment.utc(period.from).endOf(
                    Constants.TIME_STEP.MONTH
                );
            }
            // Day management
            if (regExpDay.test(value)) {
                date = Moment.utc(value, "YYYY-MM-DD");
                period = {};
                period.from = date;
                period.to = Moment.utc(period.from).endOf(
                    Constants.TIME_STEP.DAY
                );
            }
            if (date === null) {
                date = Moment.utc(value);
            }
        } else {
            date = Moment.utc(value);
        }
        return {
            date: date,
            display: value,
            period: period
        };
    };

    /**************************************************************************************************************/

    /**
     * Add date to enumerated values (check if still present)
     * @function addDateToEnumeratedValues
     * @param {Json} date Date
     * @param {string} ID Id
     * @memberof TimeEnumerated#
     * @private
     */
    TimeEnumerated.prototype.addDateToEnumeratedValues = function(date, ID) {
        if (this.enumeratedValues === null) {
            this.enumeratedValues = [];
        }

        for (var i = 0; i < this.enumeratedValues.length; i++) {
            if (this.enumeratedValues[i].display === date.display) {
                // Still found : add only id
                if (
                    this.enumeratedValues[i].ids &&
                    this.enumeratedValues[i].ids.length
                ) {
                    this.enumeratedValues[i].ids.push(ID);
                    return;
                }
            }
        }
        // Not found, add all
        date.ids = [];
        date.ids.push(ID);
        this.enumeratedValues.push(date);
    };

    /**************************************************************************************************************/

    /**
     * Remove enumerated values for ID
     * @function removeEnumeratedValuesForID
     * @param {string} ID Id
     * @memberof TimeEnumerated#
     * @private
     */
    TimeEnumerated.prototype.removeEnumeratedValuesForID = function(ID) {
        if (ID === null) {
            ID = TimeTravelParams.NO_ID;
        }
        if (this.enumeratedValues) {
            for (var i = this.enumeratedValues.length - 1; i >= 0; i--) {
                if (
                    this.enumeratedValues[i].ids &&
                    this.enumeratedValues[i].ids.length
                ) {
                    var index = this.enumeratedValues[i].ids.indexOf(ID);
                    if (index !== -1) {
                        this.enumeratedValues[i].ids.splice(index, 1);
                    }
                    if (this.enumeratedValues[i].ids.length === 0) {
                        this.enumeratedValues.splice(i, 1);
                    }
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Add enumerated values for ID
     * @function addEnumeratedValuesForID
     * @param {Array<String>} values Array of enumerated values
     * @param {string} ID Id
     * @memberof TimeEnumerated#
     * @private
     */
    TimeEnumerated.prototype.addEnumeratedValuesForID = function(values, ID) {
        if (values === null) {
            // By pass
            return;
        }
        if (ID === null) {
            ID = TimeTravelParams.NO_ID;
        }

        // TODO soon : check format, need conversion ?
        var date = null;
        for (var i = 0; i < values.length; i++) {
            date = this.parseDate(values[i]);
            this.addDateToEnumeratedValues(date, ID);
        }

        // sort tab
        this.enumeratedValues.sort(sortTime);

        this.currentIndex = 0;
        this.currentDate = this.enumeratedValues[this.currentIndex].date;
    };

    /**************************************************************************************************************/

    /**
     * Get first date AFTER a specified date
     * @function getFirstDateAfter
     * @param Date date date
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getFirstDateAfter = function(date) {
        var foundDate = null;
        return foundDate;
    };

    /**************************************************************************************************************/

    /**
     * Get first date BEFORE a specified date
     * @function getFirstDateBefore
     * @param Date date date
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getFirstDateBefore = function(date) {
        var foundDate = null;
        return foundDate;
    };

    /**************************************************************************************************************/

    /**
     * Get first date AFTER a specified date
     * @function getFirstDateAfter
     * @param {Date} date Date
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getFirstDateAfter = function(date) {
        var foundDate = null;
        var foundPeriod = { from: null, to: null };
        var foundDisplay = null;

        if (this.enumeratedValues && this.enumeratedValues.length > 0) {
            if (date < this.enumeratedValues[0].date) {
                // trivial case, first date is before the first element
                foundDate = this.enumeratedValues[0].date;
                foundPeriod = this.enumeratedValues[0].period;
                foundDisplay = this.enumeratedValues[0].display;
            } else if (
                date >
                this.enumeratedValues[this.enumeratedValues.length - 1].date
            ) {
                // trivial case, date is after the last date
                foundDate = null;
            } else {
                // go to search
                var cpt = 0;
                var isDone = false;
                while (!isDone) {
                    var currentDate = this.enumeratedValues[cpt].date;
                    if (currentDate > date) {
                        isDone = true;
                        foundDate = this.enumeratedValues[cpt].date;
                        foundPeriod = this.enumeratedValues[cpt].period;
                        foundDisplay = this.enumeratedValues[cpt].display;
                    }
                    cpt++;
                    isDone = isDone || cpt >= this.enumeratedValues.length;
                }
            }
        }

        return {
            date: foundDate,
            period: foundPeriod,
            display: foundDisplay
        };
    };

    /**************************************************************************************************************/

    /**
     * Get first date BEFORE a specified date
     * @function getFirstDateBefore
     * @param {Date} date Date
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getFirstDateBefore = function(date) {
        var foundDate = null;
        var foundPeriod = { from: null, to: null };
        var foundDisplay = null;

        if (this.enumeratedValues && this.enumeratedValues.length > 0) {
            if (
                date >
                this.enumeratedValues[this.enumeratedValues.length - 1].date
            ) {
                // trivial case, end date is before !
                foundDate = this.enumeratedValues[
                    this.enumeratedValues.length - 1
                ].date;
                foundPeriod = this.enumeratedValues[
                    this.enumeratedValues.length - 1
                ].period;
                foundDisplay = this.enumeratedValues[
                    this.enumeratedValues.length - 1
                ].display;
            } else if (date < this.enumeratedValues[0].date) {
                // trivial case, date is before the first date
                foundDate = null;
            } else {
                // go to search
                var cpt = this.enumeratedValues.length - 1;
                var isDone = false;

                while (!isDone) {
                    while (!isDone) {
                        var currentDate = this.enumeratedValues[cpt].date;
                        if (currentDate < date) {
                            isDone = true;
                            foundDate = this.enumeratedValues[cpt].date;
                            foundPeriod = this.enumeratedValues[cpt].period;
                            foundDisplay = this.enumeratedValues[cpt].display;
                        }
                        cpt--;
                        isDone = isDone || cpt < 0;
                    }
                }
            }
        }

        return {
            date: foundDate,
            period: foundPeriod,
            display: foundDisplay
        };
    };

    /**************************************************************************************************************/

    /**
     * Get string representation
     * @function toString
     * @return {string} String representation
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.toString = function() {
        var res = "";
        if (this.enumeratedValues) {
            for (var i = 0; i < this.enumeratedValues.length; i++) {
                res += this.enumeratedValues[i].display + " / ";
            }
        }
        return res;
    };

    /**************************************************************************************************************/

    /**
     * Is empty ?
     * @function isEmpty
     * @return {Boolean} is empty ?
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.isEmpty = function() {
        return !(this.enumeratedValues && this.enumeratedValues.length > 0);
    };

    /**************************************************************************************************************/

    /**
     * Get min date
     * @function getMinDate
     * @return {Date} Min date or null
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getMinDate = function() {
        var result = null;
        if (this.enumeratedValues && this.enumeratedValues.length > 0) {
            result = this.enumeratedValues[0].date;
        }
        return result;
    };

    /**************************************************************************************************************/

    /**
     * Get max date
     * @function getMaxDate
     * @return {Date} Max date or null
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getMaxDate = function() {
        var result = null;
        if (this.enumeratedValues && this.enumeratedValues.length > 0) {
            result = this.enumeratedValues[this.enumeratedValues.length - 1]
                .date;
        }
        return result;
    };

    return TimeEnumerated;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * globalTime:changed.<br/>
 * Called when the time has changed
 * @event Context#globalTime:changed
 * @type {TimeTravelParams~details}
 */

/**
 * @class
 * The time object.
 * @typedef {object} TimeTravelParams~details
 * @property {date|moment} date - the current time.
 * @property {string} display - the current date as string for display.
 * @property {object} [period] - time period.
 * @property {moment} [period.from] - start date.
 * @property {moment} [period.to] - stop date.
 */

/**
 * Time travel module : time control
 */
define('gw/Time/TimeTravelParams',[
    "jquery",
    "moment",
    "./TimeSample",
    "./TimeEnumerated",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function($, Moment, TimeSample, TimeEnumerated, Constants, ErrorDialog) {
    /**
     * @name TimeTravelParams
     * @class
     * Management of time travel
     */
    var TimeTravelParams = function() {
        this.currentDate = new Date();

        this.currentPeriod = {
            from: null,
            to: null
        };

        this.currentDisplayDate = Moment(this.currentDate).format(
            Moment(this.currentDate).creationData().format
        );
        this.minDate = null;
        this.maxDate = null;

        this.ctx = null;
        // List of samples
        this.samples = [];
        // Enumerated values
        this.enumeratedValues = new TimeEnumerated();

        // TODO: internationalized
        Moment.locale("fr");
    };

    /**************************************************************************************************************/

    /**
     * Set the context
     * @function setContext
     * @param ctx Context context
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.setContext = function(ctx) {
        this.ctx = ctx;
        this.apply();
    };

    /**************************************************************************************************************/

    /**
     * Set the current date
     * @function setCurrentDate
     * @param date Date current date
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.setCurrentDate = function(date) {
        this.currentDate = Moment.utc(date);
    };

    /**************************************************************************************************************/

    /**
     * Get the current date
     * @function getCurrentDate
     * @return Date current date
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getCurrentDate = function() {
        return this.currentDate;
    };

    /**************************************************************************************************************/

    /**
     * Get the current period
     * @function getCurrentPeriod
     * @return {Json} period { "from", "to" }
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getCurrentPeriod = function() {
        return this.currentPeriod;
    };

    /**************************************************************************************************************/

    /**
     * Add a sample
     * @function addSample
     * @param {Date} start Start date
     * @param {Date} end End date
     * @param {string} stepKind Step kind
     * @param {Integer} stepValue Step value
     * @param {string} ID Layer ID
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.addSample = function(
        start,
        end,
        stepKind,
        stepValue,
        ID
    ) {
        var sample = new TimeSample();
        sample.setStart(start);
        sample.setEnd(end);
        sample.setStepKind(stepKind);
        sample.setStepValue(stepValue);
        sample.setLayerID(ID);
        this.samples.push(sample);
    };

    /**************************************************************************************************************/

    /**
     * Add values
     * @function add values
     * @param {Json} parameters Parameters
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.addValues = function(parameters) {
        if (!parameters) {
            return;
        }
        var saveCurrentValue = this.currentDate;

        if (parameters.enumeratedValues) {
            // Add to enumerated
            this.enumeratedValues.addEnumeratedValuesForID(
                parameters.enumeratedValues,
                parameters.ID
            );
        } else if (
            parameters.start &&
            parameters.end &&
            parameters.stepKind &&
            parameters.stepValue &&
            parameters.ID
        ) {
            // Add a new sample
            this.addSample(
                parameters.start,
                parameters.end,
                parameters.stepKind,
                parameters.stepValue,
                parameters.ID
            );
        } else {
            ErrorDialog.open(Constants.LEVEL.WARNING, "Can't understand add values for time travel with parameters : "+parameters);
        }

        this.setToNearestValue(saveCurrentValue);
    };

    /**************************************************************************************************************/

    /**
     * Remove values
     * @function remove values
     * @param {Json} parameters Parameters
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.removeValues = function(parameters) {
        if (!parameters) {
            return;
        }
        var saveCurrentValue = this.currentDate;

        if (parameters.ID) {
            // Remove values into enumerated values
            this.enumeratedValues.removeEnumeratedValuesForID(parameters.ID);

            // Remove samples with ID
            var newSamples = [];
            for (var i = 0; i < this.samples.length; i++) {
                if (this.samples[i].getLayerID() !== parameters.ID) {
                    newSamples.push(this.samples[i]);
                }
            }
            this.samples = newSamples;
        }
        this.setToNearestValue(saveCurrentValue);
    };

    /**************************************************************************************************************/

    /**
     * Get next date
     * @function getNextDate
     * @return {Date} Date
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getNextDate = function(date) {
        var minDate = {
            date: null
        };

        var allDates = [];
        var aDate = null;
        for (var i = 0; i < this.samples.length; i++) {
            aDate = this.samples[i].getFirstDateAfter(date);
            if (aDate.date !== null) {
                allDates.push(aDate);
            }
        }
        aDate = this.enumeratedValues.getFirstDateAfter(date);
        if (aDate.date !== null) {
            allDates.push(aDate);
        }

        for (i = 0; i < allDates.length; i++) {
            var currentNextDate = allDates[i];
            if (minDate.date === null) {
                minDate = currentNextDate;
            } else {
                if (Math.abs(currentNextDate - date < minDate - date)) {
                    minDate = currentNextDate;
                }
            }
        }
        return minDate;
    };

    /**************************************************************************************************************/

    /**
     * Get previous date
     * @function getNextDate
     * @return {Date} Date
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getPreviousDate = function(date) {
        var minDate = {
            date: null
        };

        var allDates = [];
        var aDate = null;
        for (var i = 0; i < this.samples.length; i++) {
            aDate = this.samples[i].getFirstDateBefore(date);
            if (aDate.date !== null) {
                allDates.push(aDate);
            }
        }
        aDate = this.enumeratedValues.getFirstDateBefore(date);
        if (aDate.date !== null) {
            allDates.push(aDate);
        }

        for (i = 0; i < allDates.length; i++) {
            var currentPreviousDate = allDates[i];
            if (minDate.date === null) {
                minDate = currentPreviousDate;
            } else {
                if (
                    Math.abs(
                        currentPreviousDate.date - date < minDate.date - date
                    )
                ) {
                    minDate = currentPreviousDate;
                }
            }
        }

        return minDate;
    };

    /**************************************************************************************************************/

    /**
     * Set to nearest value (call only for enumerated)
     * @function setToNearestValue
     * @param {Date} date date
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.setToNearestValue = function(date) {
        var previousExistingDate = this.getPreviousDate(date);
        var nextExistingDate = this.getNextDate(date);

        if (
            previousExistingDate.date === null &&
            nextExistingDate.date === null
        ) {
            // No date found
            this.currentDate = new Date();
            this.currentDisplayDate = Moment(this.currentDate).format(
                "Do MMM Y"
            );
            this.currentPeriod = {
                from: this.currentDate,
                to: this.currentDate
            };
        } else if (previousExistingDate.date === null) {
            // Only before
            this.currentDate = nextExistingDate.date;
            this.currentDisplayDate = nextExistingDate.display;
            this.currentPeriod = nextExistingDate.period;
        } else if (nextExistingDate.date === null) {
            // Only after
            this.currentDate = previousExistingDate.date;
            this.currentDisplayDate = previousExistingDate.display;
            this.currentPeriod = previousExistingDate.period;
        } else {
            // Search nearest
            var deltaPrevious = Math.abs(date - previousExistingDate.date);
            var deltaNext = Math.abs(nextExistingDate.date - date);
            if (deltaPrevious < deltaNext) {
                this.currentDate = previousExistingDate.date;
                this.currentDisplayDate = previousExistingDate.display;
                this.currentPeriod = previousExistingDate.period;
            } else {
                this.currentDate = nextExistingDate.date;
                this.currentDisplayDate = nextExistingDate.display;
                this.currentPeriod = nextExistingDate.period;
            }
        }
        this.apply();
    };

    /**************************************************************************************************************/

    /**
     * Update
     * @function update
     * @param {Json} parameters Parameters
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.update = function(parameters) {
        if (!parameters) {
            return;
        }
        if (parameters.add) {
            this.addValues(parameters.add);
        }
        if (parameters.remove) {
            this.removeValues(parameters.remove);
        }

        // update metadata
        this.minDate = this.getMinDate();
        this.maxDate = this.getMaxDate();

        // apply !
        this.apply();

    };

    /**************************************************************************************************************/

    /**
     * Apply current date to IHM (launch event)
     * @function apply
     * @memberof TimeTravelParams#
     * @fires Context#globalTime:changed
     */
    TimeTravelParams.prototype.apply = function() {
        var details = {
            date: this.currentDate,
            display: this.currentDisplayDate,
            period: this.currentPeriod
        };
        this.ctx.publish(Constants.EVENT_MSG.GLOBAL_TIME_CHANGED, details);
    };

    /**************************************************************************************************************/

    /**
     * Rewind to previous time step
     * @function rewind
     * @memberof TimeTravelParams#
     * @fires Context#globalTime:changed
     */
    TimeTravelParams.prototype.rewind = function() {
        if (!this.isEmpty()) {
            var previousDate = this.getPreviousDate(
                Moment(this.currentDate).subtract(
                    1,
                    Constants.TIME_STEP.MILLISECOND
                )
            );
            if (previousDate.date !== null) {
                this.currentDate = previousDate.date;
                this.currentPeriod = previousDate.period;
                this.currentDisplayDate = previousDate.display;
                this.apply();
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Forward to next time step
     * @function forward
     * @memberof TimeTravelParams#
     * @fires Context#globalTime:changed
     */
    TimeTravelParams.prototype.forward = function() {
        if (!this.isEmpty()) {
            var nextDate = this.getNextDate(
                Moment(this.currentDate).add(1, Constants.TIME_STEP.MILLISECOND)
            );
            if (nextDate.date !== null) {
                this.currentDate = nextDate.date;
                this.currentPeriod = nextDate.period;
                this.currentDisplayDate = nextDate.display;
                this.apply();
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Get date formated (when there is no enumerated values)
     * @function getDateFormated
     * @param {Date} date Date
     * @return String Date formated
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getDateFormated = function(date) {
        // Check with STEP kind value
        var formatPattern = "LLLL";
        if (this.stepKind === Constants.TIME_STEP.YEAR) {
            formatPattern = "Y";
        } else if (
            this.stepKind === Constants.TIME_STEP.QUARTER ||
            this.stepKind === Constants.TIME_STEP.MONTH
        ) {
            formatPattern = "MMM Y";
        } else if (
            this.stepKind === Constants.TIME_STEP.WEEK ||
            this.stepKind === Constants.TIME_STEP.DAY ||
            this.stepKind === Constants.TIME_STEP.ENUMERATED
        ) {
            formatPattern = "Do MMM Y";
        } else if (
            this.stepKind === Constants.TIME_STEP.HOUR ||
            this.stepKind === Constants.TIME_STEP.MINUTE
        ) {
            formatPattern = "Do MMM Y HH:mm";
        } else if (this.stepKind === Constants.TIME_STEP.SECOND) {
            formatPattern = "Do MMM Y   HH:mm:ss";
        } else {
            formatPattern = "Do MMM Y   HH:mm:ss.SSS";
        }
        return Moment.utc(this.currentDate).format(formatPattern);
    };

    /**************************************************************************************************************/

    /**
     * Return date to display on IHM
     * @function getCurrentDisplayDate
     * @return String Date formated
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getCurrentDisplayDate = function() {
        return this.currentDisplayDate;
        /*
        var result = null;
        if (this.stepKind === Constants.TIME_STEP.ENUMERATED) {
            if (this.enumeratedValues.length>0) {
                result = this.enumeratedValues[this.currentIndex].display;
            } else {
                result = this.getDateFormated(new Date());
            }
        } else {
            result = this.getDateFormated(this.currentDate);
        }
        return result;
        */
    };

    /**************************************************************************************************************/

    /**
     * Is current date the first ?
     * @function isCurrentDateTheFirst
     * @return boolean If the current date is the first of range
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.isCurrentDateTheFirst = function() {
        if (this.isEmpty() === true) {
            this.isFirstDate = true;
        } else {
            var previousDate = this.getPreviousDate(
                Moment(this.currentDate).subtract(
                    1,
                    Constants.TIME_STEP.MILLISECOND
                )
            );
            this.isFirstDate = previousDate.date === null;
        }
        return this.isFirstDate;
    };

    /**************************************************************************************************************/

    /**
     * Is current date the last ?
     * @function isCurrentDateTheLast
     * @return boolean If the current date is the last of range
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.isCurrentDateTheLast = function() {
        if (this.isEmpty() === true) {
            this.isLastDate = true;
        } else {
            var nextDate = this.getNextDate(
                Moment(this.currentDate).add(1, Constants.TIME_STEP.MILLISECOND)
            );
            this.isLastDate = nextDate.date === null;
        }
        return this.isLastDate;
    };

    /**************************************************************************************************************/

    /**
     * Get min date
     * @function getMinDate
     * @return {Date} Min date or null
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getMinDate = function() {
        var result = null;

        var allDates = [];
        for (var i = 0; i < this.samples.length; i++) {
            allDates.push(this.samples[i].getMinDate());
        }
        allDates.push(this.enumeratedValues.getMinDate());

        for (i = 0; i < allDates.length; i++) {
            if (result === null) {
                result = allDates[i];
            } else if (allDates[i] < result && allDates[i] !== null) {
                result = allDates[i];
            }
        }
        return result;
    };

    /**************************************************************************************************************/

    /**
     * Get max date
     * @function getMaxDate
     * @return {Date} Max date or null
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getMaxDate = function() {
        var result = null;

        var allDates = [];
        for (var i = 0; i < this.samples.length; i++) {
            allDates.push(this.samples[i].getMaxDate());
        }
        allDates.push(this.enumeratedValues.getMaxDate());

        for (i = 0; i < allDates.length; i++) {
            if (result === null) {
                result = allDates[i];
            } else if (allDates[i] > result && allDates[i] !== null) {
                result = allDates[i];
            }
        }
        return result;
    };

    /**************************************************************************************************************/

    /**
     * Is time travel empty ?
     * @function toString
     * @return {Boolean} Is time travel empty
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.isEmpty = function() {
        var hasSamples = this.samples && this.samples.length > 0;
        return !hasSamples && this.enumeratedValues.isEmpty();
    };

    /**************************************************************************************************************/

    // /**
    //  * Get all steps
    //  * @function toString
    //  * @return {string} String representation
    //  * @memberof TimeTravelParams#
    //  */
    // TimeTravelParams.prototype.getAllSteps = function () {
    //     throw "TimeTravelParams.getAllSteps : deactivated because too long to execute";

    //     var res = [];
    //     var aDate = this.minDate;
    //     res.push(aDate);
    //     var nextDate = this.getNextDate(
    //         Moment(aDate).add(1, Constants.TIME_STEP.MILLISECOND)
    //     );

    //     while (nextDate.date !== null) {
    //         aDate = nextDate.date;
    //         res.push(aDate);
    //         if (res.length % 500 === 0) {
    //             console.log(res.length);
    //         }
    //         nextDate = this.getNextDate(
    //             Moment(aDate).add(1, Constants.TIME_STEP.MILLISECOND)
    //         );
    //     }

    //     return res;
    // };

    /**************************************************************************************************************/

    /**
     * Get string representation
     * @function toString
     * @return {string} String representation
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.toString = function() {
        var res = "";

        res += "Metadata : \n";
        res +=
            "  Start date : " +
            Moment(this.minDate).format(Constants.TIME.DEFAULT_FORMAT) +
            " : " +
            this.minDate +
            "\n";
        res +=
            "  End date   : " +
            Moment(this.maxDate).format(Constants.TIME.DEFAULT_FORMAT) +
            " : " +
            this.maxDate +
            "\n";

        if (this.samples) {
            for (var i = 0; i < this.samples.length; i++) {
                res += "Sample : " + this.samples[i].toString() + "\n";
            }
        }

        if (!this.enumeratedValues.isEmpty()) {
            res += "Enumerated : " + this.enumeratedValues.toString() + "\n";
        }

        return res;
    };

    return TimeTravelParams;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Compass module : map control with "north" component
 */
define('gw/Services/TimeTravelCore',["jquery", "../Time/TimeTravelParams", "../Utils/Constants"], function(
    $,
    TimeTravelParams,
    Constants
) {
    /**
     *    Private variables
     */

    var params = new TimeTravelParams();

    var parentElement = null;
    var ctx = null;

    /**************************************************************************************************************/

    /**
     * Go Rewind
     * @fires Context#globalTime:changed
     */
    function goRewind() {
        params.rewind();
    }

    /**
     * Go Forward
     * @fires Context#globalTime:changed
     */
    function goForward() {
        params.forward();
    }

    /**
     * Choose time
     *
     */
    function chooseTime(date) {
        if (date instanceof Date || typeof date === "string") {
            params.setCurrentDate(date);
        }
    }

    /**************************************************************************************************************/

    /**
     *    Remove time travel element
     *
     */
    function remove() {
        ctx.unsubscribe(Constants.EVENT_MSG.GLOBAL_TIME_FORWARD, goForward);
        ctx.unsubscribe(Constants.EVENT_MSG.GLOBAL_TIME_REWIND, goRewind);
        ctx.unsubscribe(Constants.EVENT_MSG.GLOBAL_TIME_SET, chooseTime);
        document.getElementById(parentElement).innerHTML = "";
    }

    /**************************************************************************************************************/

    /**
     *    reset values
     *
     */
    function reset() {
        params.reset();
    }

    /**
     *    update
     *
     */
    function update(parameters) {
        params.update(parameters);
    }

    /**
     *    get current date
     *
     */
    function getCurrentDate() {
        return params.getCurrentDate();
    }

    function isCurrentDateTheFirst() {
        return params.isCurrentDateTheFirst();
    }

    function isCurrentDateTheLast() {
        return params.isCurrentDateTheLast();
    }

    /**************************************************************************************************************/

    return {
        init: function(options) {
            parentElement = options.element;
            ctx = options.ctx;
            params.setContext(ctx);

            // subscribe
            if (ctx) {
                ctx.subscribe(
                    Constants.EVENT_MSG.GLOBAL_TIME_FORWARD,
                    goForward
                );
                ctx.subscribe(Constants.EVENT_MSG.GLOBAL_TIME_REWIND, goRewind);
                ctx.subscribe(Constants.EVENT_MSG.GLOBAL_TIME_SET, chooseTime);
            }
        },
        reset: reset,
        update: update,
        goForward: goForward,
        goRewind: goRewind,
        isCurrentDateTheFirst: isCurrentDateTheFirst,
        isCurrentDateTheLast: isCurrentDateTheLast,
        chooseTime: chooseTime,
        remove: remove,
        getCurrentDate: getCurrentDate
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Services/ServiceFactory',[
    "../Utils/Constants",
    "../Services/FitsVisu",
    "../Services/FitsHips",
    "../Services/HistogramCore",
    "../Services/ImageProcessingCore",
    "../Services/MeasureToolPlanetCore",
    "../Services/MeasureToolSkyCore",
    "../Services/MocBase",
    "../Services/MollweideViewerCore",
    "../Services/PickingManagerCore",
    "../Services/SampCore",
    "../Services/SelectionToolCore",
    "../Services/ExportToolCore",
    "../NameResolver/NameResolver",
    "../ReverseNameResolver/ReverseNameResolver",
    "../Services/TimeTravelCore"
], function(
    Constants,
    FitsVisu,
    FitsHips,
    HistogramCore,
    ImageProcessingCore,
    MeasureToolPlanetCore,
    MeasureToolSkyCore,
    MocBase,
    MollweideViewerCore,
    PickingManagerCore,
    SampCore,
    SelectionToolCore,
    ExportToolCore,
    NameResolver,
    ReverseNameResolver,
    TimeTravelCore
) {
    /**
     * image:added
     * Called when an image has been added
     * @event Mizar#image:added
     * @type {json}
     */

    /**
     * image:removed.<br/>
     * Called when an image has been removed
     * @event Mizar#image:removed
     * @type {json}
     */

    /**
     * image:downloaded.<br/>
     * Called when an image has been downloaded
     * @event Mizar#image:downloaded
     * @type {json}
     */

    return {
        create: function(serviceType, userOptions) {
            var obj;
            switch (serviceType) {
            case Constants.SERVICE.FitsVisu:
                obj = FitsVisu;
                break;
            case Constants.SERVICE.Histogram:
                obj = HistogramCore;
                break;
            case Constants.SERVICE.ImageProcessing:
                obj = ImageProcessingCore;
                break;
            case Constants.SERVICE.MeasureToolPlanet:
                obj = MeasureToolPlanetCore;
                break;
            case Constants.SERVICE.MeasureToolSky:
                obj = MeasureToolSkyCore;
                break;
            case Constants.SERVICE.MocBase:
                obj = MocBase;
                break;
            case Constants.SERVICE.MollweideViewer:
                obj = MollweideViewerCore;
                break;
            case Constants.SERVICE.TimeTravel:
                obj = TimeTravelCore;
                break;
            case Constants.SERVICE.PickingManager:
                obj = PickingManagerCore;
                break;
            case Constants.SERVICE.Samp:
                obj = SampCore;
                break;
            case Constants.SERVICE.SelectionTool:
                obj = new SelectionToolCore(userOptions);
                break;
            case Constants.SERVICE.NameResolver:
                obj = NameResolver;
                break;
            case Constants.SERVICE.ReverseNameResolver:
                obj = ReverseNameResolver;
                break;
            case Constants.SERVICE.ExportTool:
                obj = ExportToolCore;
                break;
            case Constants.SERVICE.FitsHips:
                obj = FitsHips;
                break;
            default:
                throw new RangeError(
                    "Cannot retrieve service " + serviceType,
                    "ServiceFactory.js"
                );
            }
            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/GeoTiling',[
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/UtilsIntersection",
    "./Tile",
    "../Renderer/GeoBound",
    "./HEALPixBase",
    "../Renderer/glMatrix"
], function(Utils, Constants, UtilsIntersection, Tile, GeoBound, HEALPixBase) {
    /** @constructor
         Tile constructor
         */
    var GeoTile = function(geoBound, level, x, y) {
        // Call ancestor constructor
        Tile.prototype.constructor.call(this);
        this.bound = this.geoBound = geoBound;
        this.level = level;
        this.x = x;
        this.y = y;
        this.key = this.level+"#"+this.x+"#"+this.y;
        this.type = Constants.TILE.GEO_TILE;
    };

    /**************************************************************************************************************/

    /** inherits from Tile */
    GeoTile.prototype = new Tile();

    /**************************************************************************************************************/

    /** @export
         Get elevation at a geo position
         */
    GeoTile.prototype.getElevation = function(lon, lat) {
        // Get the lon/lat in coordinates between [0,1] in the tile
        var u =
            (lon - this.geoBound.getWest()) /
            (this.geoBound.getEast() - this.geoBound.getWest());
        var v =
            (lat - this.geoBound.getNorth()) /
            (this.geoBound.getSouth() - this.geoBound.getNorth());

        // Quick fix when lat is on the border of the tile
        var childIndex =
            (v >= 1 ? 1 : Math.floor(2 * v)) * 2 + Math.floor(2 * u);

        if (
            this.children &&
            this.children[childIndex] &&
            this.children[childIndex].state === Tile.State.LOADED
        ) {
            return this.children[childIndex].getElevation(lon, lat);
        }

        var tess = this.config.tesselation;
        var i = Math.floor(u * tess);
        var j = Math.floor(v * tess);

        var vo = this.config.vertexSize * (j * tess + i);
        var vertex = [
            this.vertices[vo],
            this.vertices[vo + 1],
            this.vertices[vo + 2]
        ];
        mat4.multiplyVec3(this.matrix, vertex);

        var geo = this.config.coordinateSystem.getWorldFrom3D(vertex);
        return geo[2];
    };

    GeoTile.prototype.getKey = function() {
        return this.key;
    };    

    /**************************************************************************************************************/

    /**
         Create the children
         */
    GeoTile.prototype.createChildren = function() {
        // Create the children
        var lonCenter =
            (this.geoBound.getEast() + this.geoBound.getWest()) * 0.5;
        var latCenter =
            (this.geoBound.getNorth() + this.geoBound.getSouth()) * 0.5;

        var level = this.level + 1;

        var tile00 = new GeoTile(
            new GeoBound(
                this.geoBound.getWest(),
                latCenter,
                lonCenter,
                this.geoBound.getNorth()
            ),
            level,
            2 * this.x,
            2 * this.y
        );
        var tile10 = new GeoTile(
            new GeoBound(
                lonCenter,
                latCenter,
                this.geoBound.getEast(),
                this.geoBound.getNorth()
            ),
            level,
            2 * this.x + 1,
            2 * this.y
        );
        var tile01 = new GeoTile(
            new GeoBound(
                this.geoBound.getWest(),
                this.geoBound.getSouth(),
                lonCenter,
                latCenter
            ),
            level,
            2 * this.x,
            2 * this.y + 1
        );
        var tile11 = new GeoTile(
            new GeoBound(
                lonCenter,
                this.geoBound.getSouth(),
                this.geoBound.getEast(),
                latCenter
            ),
            level,
            2 * this.x + 1,
            2 * this.y + 1
        );

        tile00.initFromParent(this, 0, 0);
        tile10.initFromParent(this, 1, 0);
        tile01.initFromParent(this, 0, 1);
        tile11.initFromParent(this, 1, 1);

        this.children = [tile00, tile10, tile01, tile11];
    };

    /**************************************************************************************************************/

    /**
         Convert coordinates in longitude,latitude to coordinate in "tile space"
         Tile space means coordinates are between [0,tesselation-1] if inside the tile
         Used by renderers algorithm to clamp coordinates on the tile
         */
    GeoTile.prototype.lonlat2tile = function(coordinates) {
        var ul = this.geoBound.getEast() - this.geoBound.getWest();
        var vl = this.geoBound.getSouth() - this.geoBound.getNorth();
        var factor = this.config.tesselation - 1;
        var tileCoords = [];
        for (var i = 0; i < coordinates.length; i++) {
            var u =
                (factor * (coordinates[i][0] - this.geoBound.getWest())) / ul;
            var v =
                (factor * (coordinates[i][1] - this.geoBound.getNorth())) / vl;
            tileCoords.push([u, v]);
        }
        return tileCoords;
    };

    /**************************************************************************************************************/

    /**
         Generate vertices for tile
         */
    GeoTile.prototype.generateVertices = function(elevations) {
        // Compute tile matrix
        this.matrix = this.config.coordinateSystem.getLHVTransform(
            this.geoBound.getCenter()
        );
        var invMatrix = mat4.create();
        mat4.inverse(this.matrix, invMatrix);
        this.inverseMatrix = invMatrix;

        // Build the vertices
        var vertexSize = this.config.vertexSize;
        var size = this.config.tesselation;
        var vertices = new Float32Array(vertexSize * size * (size + 6));
        var lonStep =
            (this.geoBound.getEast() - this.geoBound.getWest()) / (size - 1);
        var latStep =
            (this.geoBound.getSouth() - this.geoBound.getNorth()) / (size - 1);
        var radius = this.config.coordinateSystem.getGeoide().getRadius();
        var scale = this.config.coordinateSystem.getGeoide().getHeightScale();
        var offset = 0;

        // Optimized build for sphere coordinates : uncomment if needed
        var lat = this.geoBound.getNorth() /* * Math.PI / 180.0*/;
        // latStep = latStep * Math.PI / 180.0;
        // lonStep = lonStep * Math.PI / 180.0;
        var pos3d = [0.0, 0.0, 0.0];
        for (var j = 0; j < size; j++) {
            //var cosLat = Math.cos( lat );
            //var sinLat = Math.sin( lat );

            var lon = this.geoBound.getWest() /* * Math.PI / 180.0*/;

            for (var i = 0; i < size; i++) {
                // var height = elevations ? scale * elevations[ offset ] : 0.0;
                // var x = (radius + height) * Math.cos( lon ) * cosLat;
                // var y = (radius + height) * Math.sin( lon ) * cosLat;
                // var z = (radius + height) * sinLat;

                var height = elevations ? elevations[offset] : 0.0;
                this.config.coordinateSystem.get3DFromWorld(
                    [lon, lat, height],
                    pos3d
                );
                var x = pos3d[0];
                var y = pos3d[1];
                var z = pos3d[2];
                var vi = offset * vertexSize;
                vertices[vi] =
                    invMatrix[0] * x +
                    invMatrix[4] * y +
                    invMatrix[8] * z +
                    invMatrix[12];
                vertices[vi + 1] =
                    invMatrix[1] * x +
                    invMatrix[5] * y +
                    invMatrix[9] * z +
                    invMatrix[13];
                vertices[vi + 2] =
                    invMatrix[2] * x +
                    invMatrix[6] * y +
                    invMatrix[10] * z +
                    invMatrix[14];

                offset++;
                lon += lonStep;
            }

            lat += latStep;
        }

        return vertices;
    };

    /**************************************************************************************************************/

    /** @constructor
         GeoTiling constructor
         */
    var GeoTiling = function(nx, ny) {
        this.level0NumTilesX = nx;
        this.level0NumTilesY = ny;
    };

    /**************************************************************************************************************/

    /**
         Generate the tiles for level zero
         */
    GeoTiling.prototype.generateLevelZeroTiles = function(config) {
        config.skirt = !config.coordinateSystem.isFlat();
        config.cullSign = 1;
        config.srs = "CRS:84";

        var level0Tiles = [];

        var latStep =
            (config.coordinateSystem.getGeoBound().getNorth() -
                config.coordinateSystem.getGeoBound().getSouth()) /
            this.level0NumTilesY;
        var lonStep =
            (config.coordinateSystem.getGeoBound().getEast() -
                config.coordinateSystem.getGeoBound().getWest()) /
            this.level0NumTilesX;

        // Manage (just for latitude) a partial GeoTiling cover (not only 360 * 180)
        this.latStart = config.coordinateSystem.getGeoBound().getSouth();
        this.latDelta =
            config.coordinateSystem.getGeoBound().getNorth() -
            config.coordinateSystem.getGeoBound().getSouth();

        for (var j = 0; j < this.level0NumTilesY; j++) {
            for (var i = 0; i < this.level0NumTilesX; i++) {
                var geoBound = new GeoBound(
                    config.coordinateSystem.getGeoBound().getWest() +
                        i * lonStep,
                    config.coordinateSystem.getGeoBound().getNorth() -
                        (j + 1) * latStep,
                    config.coordinateSystem.getGeoBound().getWest() +
                        (i + 1) * lonStep,
                    config.coordinateSystem.getGeoBound().getNorth() -
                        j * latStep
                );
                var tile = new GeoTile(geoBound, 0, i, j);
                tile.config = config;
                level0Tiles.push(tile);
            }
        }

        return level0Tiles;
    };

    /**
     * Compute the bbox of a feature
     */
    var _getBBox = function(geometry) {
        // Get the coordinates
        var coords;
        var checkDateLine = true;
        switch (geometry.type) {
        case Constants.GEOMETRY.Point:
            coords = geometry.coordinates;
            return [coords[0], coords[1], coords[0], coords[1]];
        case Constants.GEOMETRY.MultiPoint:
            coords = geometry.coordinates;
            checkDateLine = false;
            break;
        case Constants.GEOMETRY.Polygon:
            coords = geometry.coordinates[0];
            break;
        case Constants.GEOMETRY.MultiPolygon:
            coords = geometry.coordinates[0][0];
            break;
        case Constants.GEOMETRY.LineString:
            coords = geometry.coordinates;
            break;
        case Constants.GEOMETRY.MultiLineString:
            coords = geometry.coordinates[0];
            break;
        }

        if (!coords || coords.length === 0) {
            return;
        }

        var minX = coords[0][0];
        var minY = coords[0][1];
        var maxX = coords[0][0];
        var maxY = coords[0][1];

        var numOuterRings =
            geometry.type === Constants.GEOMETRY.MultiPolygon ||
            geometry.type === Constants.GEOMETRY.MultiLineString
                ? geometry.coordinates.length
                : 1;
        for (var j = 0; j < numOuterRings; j++) {
            switch (geometry.type) {
            case Constants.GEOMETRY.MultiPolygon:
                coords = geometry.coordinates[j][0];
                break;
            case Constants.GEOMETRY.MultiLineString:
                coords = geometry.coordinates[j];
                break;
            }

            for (var i = 0; i < coords.length; i++) {
                minX = Math.min(minX, coords[i][0]);
                minY = Math.min(minY, coords[i][1]);
                maxX = Math.max(maxX, coords[i][0]);
                maxY = Math.max(maxY, coords[i][1]);

                // Check if the coordinates cross dateline
                if (
                    checkDateLine &&
                    i > 0 &&
                    UtilsIntersection.isCrossDateLine(
                        coords[i - 1][0],
                        coords[i][0]
                    )
                ) {
                    minX = -180;
                    maxX = 180;
                }
            }
        }

        return [minX, minY, maxX, maxY];
    };

    /**************************************************************************************************************/

    /**
         Locate a level zero tile
         */

    GeoTiling.prototype._lon2LevelZeroIndex = function(lon) {
        return Math.min(
            this.level0NumTilesX - 1,
            Math.floor(((lon + 180) * this.level0NumTilesX) / 360)
        );
    };

    /**************************************************************************************************************/

    /**
         Locate a level zero tile
         */
    GeoTiling.prototype._lat2LevelZeroIndex = function(lat) {
        // Take into account a partial bbox for GeoTiling
        var topLat = this.latStart + this.latDelta;
        return Math.min(
            this.level0NumTilesY - 1,
            Math.floor(((topLat - lat) * this.level0NumTilesY) / this.latDelta)
        );
    };
    /**************************************************************************************************************/

    /**
         Locate a level zero tile
         */
    GeoTiling.prototype.lonlat2LevelZeroIndex = function(lon, lat) {
        return (
            this._lat2LevelZeroIndex(lat) * this.level0NumTilesX +
            this._lon2LevelZeroIndex(lon)
        );
    };

    /**************************************************************************************************************/

    /**
         Get the overlapped tile by the given geometry
         */
    GeoTiling.prototype.getOverlappedLevelZeroTiles = function(geometry) {
        var tileIndices = [];

        var bbox = _getBBox(geometry);
        if (bbox) {
            var i1 = this._lon2LevelZeroIndex(bbox[0]);
            var j1 = this._lat2LevelZeroIndex(bbox[3]);
            var i2 = this._lon2LevelZeroIndex(bbox[2]);
            var j2 = this._lat2LevelZeroIndex(bbox[1]);

            for (var j = j1; j <= j2; j++) {
                for (var i = i1; i <= i2; i++) {
                    tileIndices.push(j * this.level0NumTilesX + i);
                }
            }
        }

        return tileIndices;
    };

    /**************************************************************************************************************/

    /**
         Return tile of given longitude/latitude from tiles array if exists, null otherwise
         */
    GeoTiling.prototype.findInsideTile = function(lon, lat, tiles) {
        var tile = null;
        for (var i = 0; i < tiles.length; i++) {
            tile = tiles[i];
            var index = HEALPixBase.lonLat2pix(tile.order, lon, lat);
            if (index === tile.pixelIndex) {
                return tile;
            }
        }
        // index not found, check with lon lat
        for (i = 0; i < tiles.length; i++) {
            tile = tiles[i];
            var found =
                lat <= tile.bound.north &&
                lat >= tile.bound.south &&
                lon <= tile.bound.east &&
                lon >= tile.bound.west;
            if (found === true) {
                return tile;
            }
        }
        return null;
    };

    /**************************************************************************************************************/

    return GeoTiling;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/WMSLayer',[
    "jquery",
    "../Utils/Utils",
    "./AbstractLayer",
    "./AbstractRasterLayer",
    "../Utils/Constants",
    "../Tiling/GeoTiling",
    "../Utils/UtilsIntersection"
], function(
    $,
    Utils,
    AbstractLayer,
    AbstractRasterLayer,
    Constants,
    GeoTiling,
    UtilsIntersection
) {
    /**
     * Configuration parameters to query a Web Map Service (WMS) and Web Map Service-Time (WMS-Time)
     * @typedef {AbstractLayer.configuration} AbstractRasterLayer.wms_configuration
     * @property {string} type - Must be "WMS" - the type of this service
     * @property {string} layers - Layers to display on map. Value is a comma-separated list of layer names.
     * @property {string} [styles=""] - Styles in which layers are to be rendered. Value is a comma-separated list
     * of style names, or empty if default styling is required. Style names may be empty in the list, to use
     * default layer styling.
     * @property {string} [version = "1.3.0"] - Service version
     * @property {string} [format = "image/jpeg"] - Format for the map output
     * @property {string} [transparent = false] - 	Whether the map background should be transparent. Values are
     * true or false. Default is false
     * @property {string} [time] - Time value or range for map data using WMS-Time
     * @property {int} [tilePixelSize = 256] - tile in pixels
     * @property {int} [numberOfLevels = 21] - number of levels
     * @property {{west:float, north:float, east:float, south:float}} [restrictTo] - Bounding box on which the WMS
     * query is allowed. The WMS query must intersect the bounding box sets to restrictTo. When restrictTo is not
     * defined, the bounding box is equivalent to the whole planet.
     * @property {boolean} [autoFillTimeTravel] - Set to true so that Mizar can automatically retrieve the
     * defined time from the time dimension.
     * @property {{units:string,unitSymbol:string,default:string,multipleValues:string,nearestValue:string,value:string}} [dimension.time] - Supported time for WMS-T
     */

    //TODO : check id restrictTo is set to the extent of the layer
    //TODO : For version 1.3.0 crs must be CRS:84 and then tile.config.srs must be CRS:84 with BBOX coord long/lat
    //TODO : For version 1.3.0 and crs=EPSG:xxxx => too bad because we have the bbox coord in this order lat/long
    //TODO : For version != 1.3.0, crs is not used anymore, we srs and it akes an EPSG code with the bbox order long/lat

    /**
     * @name WMSLayer
     * @class
     *    Creates a layer for imagery data using WMS (Web Map Service) or WMS-Time (Web Map Service - Time) protocol
     *    based on a GeoTiling(4, 2) with a pixelSize = 256 by default.<br/>
     *    WMS provides a standard interface for requesting a geo-spatial map image.
     *    The standard guarantees that these images can all be overlaid on one another.
     *    <br/><br/>
     *    Example of a WMS request<br/>
     *    <code>
     *        http://example.com/wms?request=GetMap&service=WMS&version=1.3.0&layers=MyLayer
     *        &styles=population&crs=CRS:84&bbox=-145.15104058007,21.731919794922,-57.154894212888,58.961058642578
     *        &width=780&height=330&format=image/png
     *    </code>
     *
     * @augments AbstractRasterLayer
     * @param {AbstractRasterLayer.wms_configuration} options - WMS Configuration
     * @constructor
     * @memberof module:Layer
     * @see {@link http://www.opengeospatial.org/standards/wms WMS} standard
     */
    var WMSLayer = function(options) {
        options.tilePixelSize = options.tilePixelSize || 256;
        options.tiling = new GeoTiling(4, 2);
        options.numberOfLevels = options.numberOfLevels || 21;
        options.transparent = options.transparent || false;

        this.restrictTo = options.restrictTo;
        this.autoFillTimeTravel = options.autoFillTimeTravel;

        //this._computeBaseUrlAndCapabilities(options);

        AbstractRasterLayer.prototype.constructor.call(
            this,
            options.type,
            options
        );

        this.timeTravelValues = null;

        // If needed, try to fill time travel parameters
        if (
            this.autoFillTimeTravel === true &&
            this.containsDimension("time")
        ) {
            this.generateTimeTravel(options.dimension.time);
        }

        this.getMapBaseUrl = _queryImage.call(
            this,
            this.getBaseUrl(),
            this.tilePixelSize,
            this.tilePixelSize,
            options
        );
        this.layers = options.layers;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRasterLayer, WMSLayer);

    /**************************************************************************************************************/

    /**
     * Static part of the URL to query the WMS/WMS-T server.
     * @function _queryImage
     * @memberof WMSLayer#
     * @param {string} baseUrl - Base URL of the WMS/WMS-Time server
     * @param {int} xTilePixelSize - Number of pixels along X for the output image
     * @param {int} yTilePixelSize - Number of pixels along Y for the output image
     * @param {AbstractRasterLayer.wms_configuration} options - options
     * @return {string} the URL
     * @private
     */
    function _queryImage(baseUrl, xTilePixelSize, yTilePixelSize, options) {
        // Build the base GetMap URL
        var url = baseUrl;
        url = Utils.addParameterTo(url, "service", "wms");
        url = Utils.addParameterTo(
            url,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.3.0"
        );
        url = Utils.addParameterTo(url, "request", "getMap");
        url = Utils.addParameterTo(url, "layers", options.layers);
        url = Utils.addParameterTo(
            url,
            "styles",
            options.hasOwnProperty("styles") ? options.styles : ""
        );
        url = Utils.addParameterTo(
            url,
            "format",
            options.hasOwnProperty("format") ? options.format : "image/jpeg"
        );

        // transparent option
        if (options.hasOwnProperty("transparent")) {
            url = Utils.addParameterTo(url, "transparent", options.transparent);
        }
        url = Utils.addParameterTo(url, "width", xTilePixelSize);
        url = Utils.addParameterTo(url, "height", yTilePixelSize);

        if (options.hasOwnProperty("time")) {
            url = Utils.addParameterTo(url, "time", options.time);
        }

        // custom params
        for (var param in this.imageLoadedAtTime) {
            if (param !== "time" && this.imageLoadedAtTime[param] !== null) {
                url = Utils.addParameterTo(
                    url,
                    param,
                    this.imageLoadedAtTime[param]
                );
            }
        }

        return url;
    }

    /**
     * Checks whether the footprint (that represents the restricted zone area) intersects with the tile
     * @function _tileIsIntersectedFootprint
     * @memberof WMSLayer#
     * @param {{west:float, north:float, east:float, south:float}} tile - Tile
     * @param {{west:float, north:float, east:float, south:float}} footprint - restricted zone area
     * @return {boolean} true when the tile intersects with the footprint otherwise false
     * @private
     */
    function _tileIsIntersectedFootprint(tile, footprint) {
        var isIntersect;
        if (footprint != null) {
            // check if tile is inside restrict zone
            isIntersect = UtilsIntersection.boundsIntersects(tile, footprint);
        } else {
            isIntersect = true;
        }
        return isIntersect;
    }

    /**
     * Sets the time to query
     * @function setTime
     * @memberof WMSLayer#
     * @param {Time.configuration} time - time to query
     */
    WMSLayer.prototype.setTime = function(time) {
        AbstractLayer.prototype.setTime(time);
        this.setParameter("time", time);
    };

    /**
     * Returns the legend from the WMS/WMS-T server
     * @function getLegend
     * @memberof WMSLayer#
     * @return {{title:string, format:string, url:string, size:string}} the legend information
     */
    WMSLayer.prototype.getLegend = function() {
        var metadata = this.metadataAPI;
        var legend;
        if (metadata.Style) {
            var defaultStyle = metadata.Style[0];
            var title = defaultStyle.Title;
            var format = defaultStyle.LegendURL[0].Format;
            var url = defaultStyle.LegendURL[0].OnlineResource;
            var size = defaultStyle.LegendURL[0].size;
            if (title === undefined || title === "default") {
                legend = {};
            } else {
                legend = {
                    title: title,
                    format: format,
                    url: url,
                    size: size
                };
            }
        } else {
            legend = {};
        }
        return legend;
    };

    //WMSLayer.prototype.getFeatureInfo = function(position, resolution, callback, fallback) {
    //    var positionResolution;
    //    if (resolution) {
    //        positionResolution = resolution;
    //    } else {
    //        positionResolution = {
    //            longitude:0.0001,
    //            latitude:0.0001
    //        }
    //    }
    //    var url = this.getMapBaseUrl;
    //    var baseURL = Utils.parseBaseURL(url);
    //    var params = Utils.parseQueryString(url);
    //    params['crs'] = "CRS:84";
    //    params['query_layers'] = this.options.layers;
    //    params['request'] = "GetFeatureInfo";
    //    params['width'] = 2;
    //    params['height'] = 2;
    //    params['x'] = 1;
    //    params['y'] = 1;
    //    params['bbox'] = position.longitude+","+position.latitude+","+(position.longitude+positionResolution.longitude)+","+(position.latitude+positionResolution.latitude)
    //
    //    url = baseURL;
    //    for(var param in params) {
    //        url = Utils.addParameterTo(url, param, params[param]);
    //    }
    //
    //    Utils.requestUrl(url, "text", 'text/plain', null,
    //        function(response, options) {
    //            var lines = response.trim().split('\n');
    //            var featuresInfo = {};
    //            for (var i = 0; i < lines.length; ++i) {
    //                var layerName;
    //
    //                if (lines[i].substring(0, 5) === "Layer") {
    //                    layerName  = lines[i].match(/'(.*?)'/)[1];
    //                } else if(lines[i].substring(0, 9) === "  Feature") {
    //                    featuresInfo[layerName] = [];
    //                } else if(lines[i].substring(0, 11) === "    value_0") {
    //                    featuresInfo[layerName].push(parseFloat(lines[i].match(/'(.*?)'/)[1]));
    //                }
    //            }
    //            if(callback) {
    //                callback(featuresInfo);
    //            }
    //        },
    //        fallback);
    //
    //};

    /**
     * Sets visible/hidden the layer and the legend related to the layer.
     * To make visible the legend, a <div id="legendDiv"/> must be set in the HTML file.
     * @function setVisible
     * @memberof WMSLayer#
     * @param arg true when the layer must be visible otherwise false
     */
    WMSLayer.prototype.setVisible = function(arg) {
        AbstractRasterLayer.prototype.setVisible.call(this, arg);
        if (document.getElementById("legendDiv")) {
            var legend = this.getLegend();
            if (Object.keys(legend).length > 0) {
                document.getElementById("legendDiv").innerHTML = "";
                if (arg === true) {
                    document.getElementById("legendDiv").innerHTML =
                        "<div id='legendTxt' class='column'>" +
                        legend.title +
                        "</div><div id='legendUrl' class='column'><img src='" +
                        legend.url +
                        "'/></div>";
                }
            }
        }
    };

    /**
     * Returns the url for the given tile
     * The URL is returned in the following case :
     * - the HTTP request is allowed (case of the time request, the requested time is inside a supported time value
     * or range - when no time dimension, no constraint).
     * - the image is background (when an image is in background, this image is always request, we do not try to
     * make optimization)
     * - the spatial tile intersects with the image extent (useful when we want to display a single footprint as
     * an image - in this case, we do not want to make the request to the server when we know the request does not
     * intersect the image's footprint)
     * @function getUrl
     * @memberof WMSLayer#
     * @param {Tile} tile Tile
     * @return {string} Url
     */
    WMSLayer.prototype.getUrl = function(tile) {
        // Just add the bounding box to the GetMap URL
        var bound = tile.bound;
        var url, bbox;
        // we cannot reject the request to the server when the layer is defined as background otherwise there is
        // no image to show and Mizar is waiting for an image
        if (this.allowedHTTPRequest) {
            if (
                this.isBackground() ||
                _tileIsIntersectedFootprint(bound, this.restrictTo)
            ) {
                bbox =
                    bound.west +
                    "," +
                    bound.south +
                    "," +
                    bound.east +
                    "," +
                    bound.north;
                url = this.getMapBaseUrl;
                url = Utils.addParameterTo(
                    url,
                    "transparent",
                    this.options.transparent
                );
                url = Utils.addParameterTo(url, "crs", tile.config.srs);
                url = Utils.addParameterTo(url, "bbox", bbox);
            } else {
                url = null;
            }
        } else {
            url = null;
        }

        return this.allowRequest(url, tile.level);
    };

    /**
     * Set a parameter and add it to the static query parameters.
     * The parameter is added according to some [use cases]{@link AbstractLayer#_hasToBeRefreshed} with the time.
     * @function setParameter
     * @memberof WMSLayer#
     * @param paramName parameter name
     * @param value value name
     */
    WMSLayer.prototype.setParameter = function(paramName, value) {
        if (this._hasToBeRefreshed(paramName, value)) {
            this.options[paramName] = this.imageLoadedAtTime[paramName];
            this.getMapBaseUrl = _queryImage.call(
                this,
                this.getBaseUrl(),
                this.tilePixelSize,
                this.tilePixelSize,
                this.options
            );
            this.forceRefresh();
        }
    };

    /**************************************************************************************************************/

    return WMSLayer;
});

/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Registry/WMTSMetadata',[], function() {
    /**
     * @class
     * WMTS metadata from capabilities.
     * @param {string} json
     * @constructor
     * @memberof module:Registry
     */
    var WMTSMetadata = function(json) {
        this.serviceIdentification = new ServiceIdentification(
            json.Capabilities.ServiceIdentification
        );
        this.serviceProvider = new ServiceProvider(
            json.Capabilities.ServiceProvider
        );
        //this.operationsMetadata;
        this.contents = new Contents(json.Capabilities.Contents);
        //this.themes;
        this.serviceMetadataURL = WMTSMetadata.getValueTag(
            json.Capabilities._attrhref
        );
    };

    /**
     * @class
     * Creates ServiceIdentification object.
     * @param {string} json
     * @constructor
     * @memberof WMTSMetadata#
     */
    var ServiceIdentification = function(json) {
        if (json === undefined) {
            this.version = null;
            this.title = null;
            this.abstract = null;
            this.keywords = null;
            this.serviceType = null;
            this.fees = null;
            this.accessConstraints = null;
        } else {
            this.version = WMTSMetadata.getValueTag(json._attrversion);
            this.title = WMTSMetadata.getValueTag(json.Title);
            this.abstract = WMTSMetadata.getValueTag(json.Abstract);
            this.keywords = WMTSMetadata.parseKeywordList(json.Keywords);
            this.serviceType = WMTSMetadata.getValueTag(json.ServiceType);
            this.fees = WMTSMetadata.getValueTag(json.Fees);
            this.accessConstraints = WMTSMetadata.parseAccessConstraints(
                json.AccessConstraints
            );
        }
    };

    /**
     * @class
     * Creates ServiceProvider object.
     * @param {string} json
     * @constructor
     * @memberof WMTSMetadata#
     */

    var ServiceProvider = function(json) {
        if (json === undefined) {
            this.providerName = null;
            this.providerSite = null;
            this.serviceContact = null;
        } else {
            this.providerName = WMTSMetadata.getValueTag(json.ProviderName);
            this.providerSite = null;
            this.serviceContact = new ServiceContact(json.ServiceContact);
        }
    };

    /**
     * @class
     * Creates ServiceContact object.
     * @param {string} json
     * @constructor
     * @memberof WMTSMetadata#
     */

    var ServiceContact = function(json) {
        if (json === undefined) {
            this.individualName = null;
            this.positionName = null;
            this.contactInfo = null;
            this.role = null;
        } else {
            this.individualName = WMTSMetadata.getValueTag(json.IndividualName);
            this.positionName = WMTSMetadata.getValueTag(json.PositionName);
            this.contactInfo = new ContactInfo(json.ContactInfo);
            this.role = WMTSMetadata.getValueTag(json.Role);
        }
    };

    /**
     * @class
     * Creates ContactInfo object.
     * @param {string} json
     * @constructor
     * @memberof WMTSMetadata#
     */

    var ContactInfo = function(json) {
        if (json === undefined) {
            this.phone = null;
            this.address = null;
            this.onlineResource = null;
            this.hoursOfService = null;
            this.contactInstructions = null;
        } else {
            this.phone = new Phone(json.Phone);
            this.address = new Address(json.Address);
            this.onlineResource = null;
            this.hoursOfService = WMTSMetadata.getValueTag(json.HoursOfService);
            this.contactInstructions = WMTSMetadata.getValueTag(
                json.ContactInstructions
            );
        }
    };

    /**
     * @class
     * Create Phone object
     * @param {string} json
     * @constructor
     * @memberof WMTSMetadata#
     */

    var Phone = function(json) {
        if (json === undefined) {
            this.voice = null;
            this.facsimile = null;
        } else {
            this.voice = WMTSMetadata.parseVoice(json.Voice);
            this.facsimile = WMTSMetadata.parsePhone(json.Facsimile);
        }
    };

    /**
     * @class
     * Create Address object
     * @param {string} json
     * @constructor
     * @memberof WMTSMetadata#
     */

    var Address = function(json) {
        if (json === undefined) {
            this.deliveryPoint = null;
            this.city = null;
            this.administrativeArea = null;
            this.postalCode = null;
            this.country = null;
            this.electronicMailAddress = null;
        } else {
            this.deliveryPoint = WMTSMetadata.getValueTag(json.DeliveryPoint);
            this.city = WMTSMetadata.getValueTag(json.City);
            this.administrativeArea = WMTSMetadata.getValueTag(
                json.AdministrativeArea
            );
            this.postalCode = WMTSMetadata.getValueTag(json.PostalCode);
            this.country = WMTSMetadata.getValueTag(json.Country);
            this.electronicMailAddress = WMTSMetadata.getValueTag(
                json.ElectronicMailAddress
            );
        }
    };

    /**
     * @class
     * Create Contents object
     * @param {string} json
     * @constructor
     * @memberof WMTSMetadata#
     */

    var Contents = function(json) {
        if (json === undefined) {
            this.layers = null;
            this.tileMatrixSets = null;
        } else {
            this.layers = WMTSMetadata.parseLayer(json.Layer);
            this.tileMatrixSets = new TileMatrixSet(json.TileMatrixSet);
        }
    };

    /**
     * @class
     * Create Layer object
     * @param {string} json
     * @constructor
     * @memberof WMTSMetadata#
     */
    var Layer = function(json) {
        if (json === undefined) {
            this.identifier = null;
            this.format = null;
            this.infoFormat = null;
            this.style = null;
            this.tileMatrixSetLink = null;
            this.title = null;
            this.abstract = null;
            this.wgs84BoundingBox = null;
            this.boundingBox = null;
            this.keywords = null;
            this.metadata = null;
            this.datasetDescriptionSummary = null;
            this.otherSource = null;
            this.dimension = null;
            this.resourceURL = null;
        } else {
            this.identifier = WMTSMetadata.getValueTag(json.Identifier);
            this.format = WMTSMetadata.parseFormat(json.Format);
            this.infoFormat = null;
            this.style = null;
            this.tileMatrixSetLink = WMTSMetadata.parseTileMatrixSetLink(
                json.TileMatrixSetLink
            );
            this.title = WMTSMetadata.getValueTag(json.Title);
            this.abstract = WMTSMetadata.getValueTag(json.Abstract);
            this.wgs84BoundingBox = WMTSMetadata.parseWGS84BoundingBox(
                json.WGS84BoundingBox
            );
            this.boundingBox = WMTSMetadata.parseBoundingBox(json.BoundingBox);
            this.keywords = WMTSMetadata.parseKeywordList(json.Keywords);
            this.metadata = null;
            this.datasetDescriptionSummary = null;
            this.otherSource = null;
            this.dimension = null;
            this.resourceURL = null;
        }
    };

    /**
     * @class
     * Create TileMatrixSet object
     * @param {string} json
     * @constructor
     * @memberof WMTSMetadata#
     */

    var TileMatrixSet = function(json) {
        this.identifier = null;
        this.supportedCRS = null;
        this.wellKnownScaleSet = null;
        this.tileMatrix = null;
    };

    /**
     * @class
     * Create TileMatrix object
     * @param {string} json
     * @constructor
     * @memberof WMTSMetadata#
     */

    var TileMatrix = function(json) {
        this.identifier = null;
        this.scaleDenominator = null;
        this.topLeftCorner = null;
        this.tileWidth = null;
        this.tileHeight = null;
        this.matrixWidth = null;
        this.matrixHeight = null;
    };

    /**
     * Parses layer element
     * @param {string} json
     * @returns {Layer[]} Returns Array of Layer object
     * @function parseLayer
     * @memberof WMTSMetadata#
     * @private
     */

    WMTSMetadata.parseLayer = function(json) {
        var layers = [];
        if (json === undefined) {
            // do nothing
        } else if (Array.isArray(json)) {
            for (var i = 0; i < json.length; i++) {
                layers.push(new Layer(json[i]));
            }
        } else {
            layers.push(new Layer(json));
        }
        return layers;
    };

    /**
     * Parses TileMatrixSetLink element
     * @param {string} json
     * @returns {string[]} Returns array of parseTileMatrixSetLink value.
     * @function parseTileMatrixSetLink
     * @memberof WMTSMetadata#
     * @private
     */

    WMTSMetadata.parseTileMatrixSetLink = function(json) {
        var tileMatrixSetLink = [];
        if (json === undefined) {
            // do nothing
        } else if (Array.isArray(json)) {
            for (var i = 0; i < json.length; i++) {
                tileMatrixSetLink.push(
                    WMTSMetadata.getValueTag(json.TileMatrixSet[i])
                );
            }
        } else {
            tileMatrixSetLink.push(
                WMTSMetadata.getValueTag(json.TileMatrixSet)
            );
        }
        return tileMatrixSetLink;
    };

    /**
     * Parses Format element
     * @param {string} json
     * @returns {string[]} Array of format.
     * @function parseFormat
     * @memberof WMTSMetadata#
     * @private
     */
    WMTSMetadata.parseFormat = function(json) {
        var formats = [];
        if (json === undefined) {
            // do nothing
        } else if (Array.isArray(json)) {
            for (var i = 0; i < json.length; i++) {
                formats.push(WMTSMetadata.getValueTag(json.Format[i]));
            }
        } else {
            formats.push(WMTSMetadata.getValueTag(json));
        }
        return formats;
    };

    /**
     * Get Value
     * @param {string} json
     * @returns {string} Returns the value
     * @function getValueTag
     * @memberof WMTSMetadata#
     * @private
     */

    WMTSMetadata.getValueTag = function(json) {
        var result;
        if (json !== undefined) {
            result = json.hasOwnProperty("_text")
                ? WMTSMetadata.getText(json)
                : WMTSMetadata.getValue(json);
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Get Text
     * @param {string} json
     * @return {string} Returns the text
     * @function getText
     * @memberof WMTSMetadata#
     * @private
     */

    WMTSMetadata.getText = function(keyword) {
        return keyword._text;
    };

    /**
     * Get Value
     * @param {string} json
     * @returns {string} Returns the value
     * @function getValue
     * @memberof WMTSMetadata#
     * @private
     */

    WMTSMetadata.getValue = function(keyword) {
        return keyword._value;
    };

    /**
     * Parses keyword list
     * @param {string} json
     * @returns {string[]} Returns the array of keyword.
     * @function parseKeywordList
     * @memberof WMTSMetadata#
     * @private
     */

    WMTSMetadata.parseKeywordList = function(keywordsJson) {
        var keywords = [];
        if (
            keywordsJson !== undefined &&
            keywordsJson.hasOwnProperty("Keyword")
        ) {
            if (Array.isArray(keywordsJson.Keyword)) {
                for (var keyword in keywordsJson.Keyword) {
                    keywords.push(
                        WMTSMetadata.getValueTag(keywordsJson.Keyword[keyword])
                    );
                }
            } else {
                keywords.push(WMTSMetadata.getValueTag(keywordsJson.Keyword));
            }
        }
        return keywords;
    };

    /**
     * Parses Voice
     * @param {string} json
     * @returns {string[]} Returns the array of voice
     * @function parseVoice
     * @memberof WMTSMetadata#
     * @private
     */

    WMTSMetadata.parseVoice = function(json) {
        var voices = [];
        if (json !== undefined && json.hasOwnProperty("Voice")) {
            if (Array.isArray(json.Voice)) {
                for (var voice in json.Voice) {
                    voices.push(WMTSMetadata.getValueTag(json.Voice[voice]));
                }
            } else {
                voices.push(WMTSMetadata.getValueTag(json.Voice));
            }
        }
        return voices;
    };

    /**
     * Parses Fac simile element
     * @param {string} json
     * @returns {string[]} Returns the array of Facsimile
     * @function parseFacsimile
     * @memberof WMTSMetadata#
     * @private
     */

    WMTSMetadata.parseFacsimile = function(json) {
        var phones = [];
        if (json !== undefined && json.hasOwnProperty("Facsimile")) {
            if (Array.isArray(json.Facsimile)) {
                for (var facs in json.Facsimile) {
                    phones.push(WMTSMetadata.getValueTag(json.Facsimile[facs]));
                }
            } else {
                phones.push(WMTSMetadata.getValueTag(json.Facsimile));
            }
        }
        return phones;
    };

    /**
     * Parses AccessConstraints element
     * @param {string} json
     * @return {string[]} Returns the array of AccessConstraints
     * @function parseAccessConstraints
     * @memberof WMTSMetadata#
     * @private
     */

    WMTSMetadata.parseAccessConstraints = function(json) {
        var acccessConstraints = [];
        if (json !== undefined && json.hasOwnProperty("AccessConstraints")) {
            if (Array.isArray(json.AccessConstraints)) {
                for (var access in json.AccessConstraints) {
                    acccessConstraints.push(
                        WMTSMetadata.getValueTag(json.AccessConstraints[access])
                    );
                }
            } else {
                acccessConstraints.push(
                    WMTSMetadata.getValueTag(json.AccessConstraints)
                );
            }
        }
        return acccessConstraints;
    };

    /**
     * Parses WGS84BoundingBox element
     * @param {string} json
     * @returns {string[]} Returns the WGS84 bounding box
     * @function parseWGS84BoundingBox
     * @memberof WMTSMetadata#
     * @private
     */

    WMTSMetadata.parseWGS84BoundingBox = function(wgs84BoundingBoxJson) {
        var wgs84BoundingBox = [];
        if (wgs84BoundingBoxJson !== undefined) {
            if (Array.isArray(wgs84BoundingBoxJson)) {
                for (var wgs84 in wgs84BoundingBoxJson) {
                    wgs84BoundingBox.push({
                        lowerCorner: WMTSMetadata.getValueTag(
                            wgs84.LowerCorner
                        ),
                        upperCorner: WMTSMetadata.getValueTag(wgs84.UpperCorner)
                    });
                }
            } else {
                wgs84BoundingBox.push({
                    lowerCorner: WMTSMetadata.getValueTag(
                        wgs84BoundingBoxJson.LowerCorner
                    ),
                    upperCorner: WMTSMetadata.getValueTag(
                        wgs84BoundingBoxJson.UpperCorner
                    )
                });
            }
        }
        return wgs84BoundingBox;
    };

    /**
     * Parses BoundingBox element
     * @param {string} json
     * @return {string[]} Returns the bounding box
     * @function parseBoundingBox
     * @memberof WMTSMetadata#
     * @private
     */

    WMTSMetadata.parseBoundingBox = function(BoundingBoxJson) {
        //TODO crs dimensions
        var boundingBox = [];
        if (BoundingBoxJson !== undefined) {
            if (Array.isArray(BoundingBoxJson)) {
                for (var bbox in BoundingBoxJson) {
                    boundingBox.push({
                        lowerCorner: WMTSMetadata.getValueTag(bbox.LowerCorner),
                        upperCorner: WMTSMetadata.getValueTag(bbox.UpperCorner)
                    });
                }
            } else {
                boundingBox.push({
                    lowerCorner: WMTSMetadata.getValueTag(
                        BoundingBoxJson.LowerCorner
                    ),
                    upperCorner: WMTSMetadata.getValueTag(
                        BoundingBoxJson.UpperCorner
                    )
                });
            }
        }
        return boundingBox;
    };

    return WMTSMetadata;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/WMTSLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "./AbstractRasterLayer",
    "../Utils/Constants",
    "../Registry/WMTSMetadata"
], function(
    Utils,
    AbstractLayer,
    AbstractRasterLayer,
    Constants,
    WMTSMetadata
) {
    /**
     * Configuration parameters to query a Web Map Tile Service (WMTS)
     * @typedef {AbstractRasterLayer} AbstractRasterLayer.wmts_configuration
     * @property {string} [version = "1.0.0"] WMTS version
     * @property {string} layer - basic unit of geographic information that may be requested as a map from a server
     * @property {string} matrixSet - The name of pyramidal images
     * @property {int} startLevel - Start level of the index
     * @property {string} [style] - Styled Layers Descriptor
     */
    /**
     * @name WMTSLayer
     * @class
     *    Creates a layer for imagery data using WMTS protocol.
     *    <br/>
     *    WMTS protocol provides tiles with a resolution of <i>tilePixelSize</i><br/>
     *    based on a GeoTiling(4, 2)<br/>
     *    <img src="../doc/images/wmts_tile.png"/><br/>
     *    <br/
     *    Example of a WMTS request:
     *    <code>
     *            http://example.com/wmts?LAYER=MyLayer1,MyLayer2&
     *            EXCEPTIONS=text/xml&FORMAT=image/jpeg&SERVICE=WMTS&
     *            VERSION=1.0.0&REQUEST=GetTile&STYLE=normal&
     *            TILEMATRIXSET=PM&TILEMATRIX=18&TILEROW=90241&TILECOL=132877&
     *    </code>
     *    <br/><br/>
     *    The parameters of a WMTS server are the following:
     *    <ul>
     *        <li><b>TILEMATRIXSET</b>: The name of pyramidal images</li>
     *        <li><b>TILEMATRIX</b>: The name of the matrix that contains the tile</li>
     *        <li><b>TILEROW</b>: The line number from the top left corner from the tile</li>
     *        <li><b>TILECOL</b>: The column number from the top left corner from the tile</li>
     *    </ul>
     *    <img src="../doc/images/wmts_pixel.png"/>
     *
     * @augments AbstractRasterLayer
     * @param {AbstractRasterLayer.configuration} options - WMTS configuration
     * @property {int} [tilePixelSize = 256] - tile in pixels
     * @property {int} [numberOfLevels = 21] - number of levels
     * @property {string} [version = "1.0.0"] - WMS version
     * @property {string} [transparent]
     * @property {string} [time] - Time dimension
     * @property {string} [format = "image/png"] - output image format
     * @constructor
     * @memberof module:Layer
     * @see {@link http://www.opengeospatial.org/standards/wmts WMTS} standard
     * @see {@link http://www.opengeospatial.org/standards/sld SLD} standard
     */
    var WMTSLayer = function(options) {
        AbstractRasterLayer.prototype.constructor.call(
            this,
            Constants.LAYER.WMTS,
            options
        );
        this.getTileBaseUrl = _queryImage.call(
            this,
            this.getBaseUrl(),
            options
        );
        this.imageLoadedAtTime = null;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRasterLayer, WMTSLayer);

    /**************************************************************************************************************/

    function _queryImage(baseUrl, options) {
        var url = baseUrl;
        url = Utils.addParameterTo(url, "service", "wmts");
        url = Utils.addParameterTo(url, "version", options.version || "1.0.0");
        url = Utils.addParameterTo(url, "request", "GetTile");
        url = Utils.addParameterTo(url, "layer", options.layers);
        url = Utils.addParameterTo(url, "tilematrixset", "WGS84");
        //            url = Utils.addParameterTo(url, "tilematrixset", options.tilematrixset);

        if (options.hasOwnProperty("style")) {
            url = Utils.addParameterTo(url, "style", options.style);
        }

        url = Utils.addParameterTo(
            url,
            "format",
            options.hasOwnProperty("format") ? options.format : "image/png"
        );

        if (options.hasOwnProperty("time")) {
            url = Utils.addParameterTo(url, "time", options.time);
        }

        //custom params
        for (var param in this.imageLoadedAtTime) {
            if (param !== "time" && this.imageLoadedAtTime[param] !== null) {
                url = Utils.addParameterTo(
                    url,
                    param,
                    this.imageLoadedAtTime[param]
                );
            }
        }

        return url;
    }

    WMTSLayer.prototype.setTime = function(time) {
        AbstractLayer.prototype.setTime(time);
        this.setParameter("time", time);
    };

    WMTSLayer.getCapabilitiesFromBaseURl = function(baseUrl, options) {
        var getCapabilitiesUrl = baseUrl;
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "service",
            "WMTS"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "request",
            "getCapabilities"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.0.0"
        );
        return getCapabilitiesUrl;
    };

    /**************************************************************************************************************/

    /**
     * Returns an url for the given tile
     * @function getUrl
     * @memberof WMTSLayer#
     * @param {Tile} tile Tile
     * @return {string} Url
     */
    WMTSLayer.prototype.getUrl = function(tile) {
        var url;
        if (this.allowedHTTPRequest) {
            url = this.getTileBaseUrl;
            url = Utils.addParameterTo(url, "tilematrix", tile.level + 1);
            url = Utils.addParameterTo(url, "tilecol", tile.x);
            url = Utils.addParameterTo(url, "tilerow", tile.y);
        } else {
            url = null;
        }
        return this.allowRequest(url, tile.level);
    };

    WMTSLayer.prototype.setParameter = function(paramName, value) {
        if (this._hasToBeRefreshed(paramName, value)) {
            this.options[paramName] = this.imageLoadedAtTime[paramName];
            this.getCoverageBaseUrl = _queryImage.call(
                this,
                this.getBaseUrl(),
                this.options
            );
            this.forceRefresh();
        }
    };

    ///**
    // * Checks if Mizar must query the WMS server to refresh data.
    // * When the camera does not move but that the time change, we have two cases :
    // * - the requested time is included in the time frame of the image => no query
    // * - the requested time is outside of the time frame of the image => this is a new image, need to query
    // * @param paramName
    // * @param value
    // * @return {*}
    // * @private
    // */
    //WMTSLayer.prototype._hasToBeRefreshed = function(paramName, value) {
    //    var hasToBeRefreshed;
    //    if(paramName==="time") {
    //        var timeRequest = AbstractLayer.createTimeRequest(value);
    //        var allowedTime = this.getDimensions().time;
    //        var selectedDate = AbstractLayer.selectedTime(allowedTime.value, timeRequest);
    //        if(this.imageLoadedAtTime != null && selectedDate == null) {
    //            // we query because the state has changed
    //            hasToBeRefreshed = true;
    //            this.imageLoadedAtTime = null;
    //        } else if(selectedDate == null) {
    //            // No image found on the server related to the requested time, no need to query => we save network
    //            hasToBeRefreshed = false;
    //        } else if (this.imageLoadedAtTime === selectedDate) {
    //            // Same state, no need to query
    //            hasToBeRefreshed = false;
    //        } else {
    //            // At the requested time, there is an image on the server and this is not the current one => query
    //            hasToBeRefreshed = true;
    //            this.imageLoadedAtTime = selectedDate;
    //        }
    //    } else {
    //        hasToBeRefreshed = true;
    //    }
    //    this.mustbeSkipped = !hasToBeRefreshed;
    //    return hasToBeRefreshed;
    //};

    /**************************************************************************************************************/

    return WMTSLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/WCSElevationLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "./AbstractRasterLayer",
    "../Utils/Constants",
    "../Tiling/GeoTiling",
    "../Gui/dialog/ErrorDialog"
], function(Utils, AbstractLayer, AbstractRasterLayer, Constants, GeoTiling, ErrorDialog) {
    /**
     * WCSElevation configuration
     * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.wcsElevation_configuration
     * @property {int} [tilePixelSize = 33]
     * @property {int} [numberOfLevels = 21]
     * @property {string} baseUrl - the base Url to access the WCS server
     * @property {string} coverage - the name of the coverage to use (WCS parameter)
     * @property {string} crs - the coordinate reference system to use (WCS parameter)
     * @property {string} [outputCRS=crs] for 2.0
     * @property {string} version -  2.0.x or 1.0.x is supported
     * @property {float} [scale=1] - elevation scale value
     * @property {float} [scaleData=1] - elevation scale value to apply to have the true altitude
     * @property {string} [format='image/x-aaigrid']
     * @property {float} [minElevation=0]
     */

    /**
     * @name WCSElevationLayer
     * @class
     *    Create a layer for elevation data using WCS protocol  based on a GeoTiling(4, 2)
     *    with a pixelSize = 33 by default. The only supported format is right now image/x-aaigrid. It is an ASCII
     *    format that is easily parsed in Javascript.
     * @augments AbstractRasterLayer
     * @param {AbstractLayer.wcsElevation_configuration} options - WCSElevation Configuration
     * @constructor
     * @memberof module:Layer
     */
    var WCSElevationLayer = function(options) {
        options.tilePixelSize = options.tilePixelSize || 33;
        options.tiling = new GeoTiling(4, 2);
        options.numberOfLevels = options.numberOfLevels || 21;
        options.version = options.version || "2.0.0";
        options.format = options.format || "image/x-aaigrid";
        options.minElevation = options.minElevation || 0;
        options.scale = options.scale || 1;
        options.scaleData = options.scaleData || 1;
        options.crs = options.crs || "EPSG:4326";
        AbstractRasterLayer.prototype.constructor.call(
            this,
            Constants.LAYER.WCSElevation,
            options
        );
        // Build the base GetMap URL
        this.getCoverageBaseUrl = _queryImage.call(
            this,
            this.getBaseUrl(),
            options
        );

        this.level = null;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRasterLayer, WCSElevationLayer);

    /**************************************************************************************************************/

    function _queryImage(baseUrl, options) {
        var url = baseUrl;
        url = Utils.addParameterTo(url, "service", "wcs");
        url = Utils.addParameterTo(url, "version", options.version);
        url = Utils.addParameterTo(url, "request", "GetCoverage");

        switch (options.version.substring(0, 3)) {
        case "2.0":
            url = Utils.addParameterTo(url, "outputCRS", options.crs);
            url = Utils.addParameterTo(
                url,
                "size",
                "x(" + options.tilePixelSize + ")"
            );
            url = Utils.addParameterTo(
                url,
                "size",
                "y(" + options.tilePixelSize + ")"
            );
            url = Utils.addParameterTo(url, "coverageid", options.coverage);
            break;
        case "1.0":
            url = Utils.addParameterTo(url, "width", options.tilePixelSize);
            url = Utils.addParameterTo(
                url,
                "height",
                options.tilePixelSize
            );
            url = Utils.addParameterTo(url, "crs", options.crs);
            url = Utils.addParameterTo(url, "coverage", options.coverage);
            break;
        }
        url = Utils.addParameterTo(url, "format", options.format);

        if (options.hasOwnProperty("time")) {
            url = Utils.addParameterTo(url, "time", options.time);
        }

        // time constraints and custom params
        for (var param in this.imageLoadedAtTime) {
            if (param !== "time" && this.imageLoadedAtTime[param] !== null) {
                url = Utils.addParameterTo(
                    url,
                    param,
                    this.imageLoadedAtTime[param]
                );
            }
        }

        return url;
    }

    /**
     * Parse a elevation response
     * @function parseElevations
     * @memberof WCSElevationLayer#
     * @param {string} text Response as text
     */
    WCSElevationLayer.prototype.parseElevations = function(text) {
        if (text === null || text.match("ServiceExceptionReport") != null) {
            return this._returnZeroElevations();
        }
        switch (this.options.format) {
        case "image/x-aaigrid":
            return this._parseAAIGrid(text);
        default:
            ErrorDialog.open(Constants.LEVEL.WARNING,"Format '" + this.format + "' could not be parsed.");
            return this._returnZeroElevations();
        }
    };

    /**
     * Fallback elevations when no data was returned
     * @function _returnZeroElevations
     * @memberof WCSElevationLayer#
     * @returns {float[]} Array of float
     * @private
     */
    WCSElevationLayer.prototype._returnZeroElevations = function() {
        var elevations = [];
        for (
            var i = 0;
            i < this.options.tilePixelSize * this.options.tilePixelSize;
            ++i
        ) {
            elevations.push(0);
        }
        return elevations;
    };

    /**
     * Parse a elevation response from AAIGrid
     * @function _parseAAIGrid
     * @memberof WCSElevationLayer#
     * @param {string} text Response as text
     * @private
     */
    WCSElevationLayer.prototype._parseAAIGrid = function(text) {
        var elevations = [];
        var i;
        var lines = text.trim().split("\n");

        var dataLinesStart = 0;
        var noDATA = Number.NEGATIVE_INFINITY;
        for (i = 0; i < lines.length; ++i) {
            if (lines[i].substring(0, 1) === " ") {
                dataLinesStart = i;
                break;
            } else if (lines[i].substring(0, 1) === "NODATA_value") {
                var elt = lines[i].trim().split(/\s+/);
                noDATA = elt[1];
            }
        }

        var oldVal = Number.NEGATIVE_INFINITY;
        for (i = dataLinesStart; i < lines.length; i++) {
            var elts = lines[i].trim().split(/\s+/);
            for (var n = 0; n < elts.length; n++) {
                var elevation;
                if (isNaN(elts[n]) || elts[n] === noDATA) {
                    elevation = oldVal;
                } else {
                    elevation = parseFloat(elts[n], 10);
                    oldVal = elevation;
                }
                //var elevation = parseInt(elts[n], 10);
                if (elevation < this.options.minElevation) {
                    elevation = this.options.minElevation;
                }
                elevations.push(
                    elevation * this.options.scale * this.options.scaleData
                );
            }
        }

        return elevations;
    };

    /**
     * Checks if the Elevation is requested at the current level.
     * @function isRequested
     * @memberof WCSElevationLayer#
     * @return {boolean} True when the elevation is requested at the current level otherwise False.
     */
    WCSElevationLayer.prototype.isRequested = function() {
        return (this.level == null) ? false : this.isBetweenMinMaxLevel(this.level);
    };

    /**
     * Get an url for the given tile
     * @function getUrl
     * @memberof WCSElevationLayer#
     * @param {Tile} tile Tile
     * @return {string} Url
     */
    WCSElevationLayer.prototype.getUrl = function(tile) {
        var geoBound = tile.geoBound;

        var url;
        if (this.allowedHTTPRequest) {
            url = this.getCoverageBaseUrl;

            if (this.options.version.substring(0, 3) === "2.0") {
                url = Utils.addParameterTo(
                    url,
                    "subset",
                    "x" +
                        this.options.crs +
                        "(" +
                        geoBound.west +
                        "," +
                        geoBound.east +
                        ")"
                );
                url = Utils.addParameterTo(
                    url,
                    "subset",
                    "y" +
                        this.options.crs +
                        "(" +
                        geoBound.south +
                        "," +
                        geoBound.north +
                        ")"
                );
            } else if (this.options.version.substring(0, 3) === "1.0") {
                url = Utils.addParameterTo(
                    url,
                    "bbox",
                    geoBound.west +
                        "," +
                        geoBound.south +
                        "," +
                        geoBound.east +
                        "," +
                        geoBound.north
                );
            }
            this.level = tile.level;
        } else {
            url = null;
            this.level = null;
        }
        return this.allowRequest(url, tile.level);
    };

    WCSElevationLayer.prototype.setParameter = function(paramName, value) {
        if (this._hasToBeRefreshed(paramName, value)) {
            this.options[paramName] = this.imageLoadedAtTime[paramName];
            this.getCoverageBaseUrl = _queryImage.call(
                this,
                this.getBaseUrl(),
                this.options
            );
            this.forceRefresh();
        }
    };

    WCSElevationLayer.prototype.getScale = function() {
        return this.options.scale;
    };

    WCSElevationLayer.prototype.getScaleData = function() {
        return this.options.scaleData;
    };

    WCSElevationLayer.prototype.setTime = function(time) {
        AbstractLayer.prototype.setTime(time);
        this.setParameter("time", time);
    };

    /**************************************************************************************************************/

    return WCSElevationLayer;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Provider/AbstractProvider',["jquery"], function($) {
    /**************************************************************************************************************/

    /**
     * @name AbstractProvider
     * @class
     *  Abstract Provider constructor
     * @param {object} options
     * @implements {Provider}
     */
    var AbstractProvider = function(options) {
        this.options = options;
    };

    /**
     * @function loadFiles
     * @memberof Provider#
     * @abstract
     */
    AbstractProvider.prototype.loadFiles = function(layer, configuration) {};

    /**
     * @function handleFeatures
     * @memberof Provider#
     */
    AbstractProvider.prototype.handleFeatures = function(layer) {};

    /**************************************************************************************************************/

    return AbstractProvider;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 * Mizar is able to load a whole file as GeoJson format for vectorial data. If the data format is not in GeoJson then a Provider must be applied.
 * <ul>
 *     <li>{@link module:Provider.ConstellationProvider ConstellationProvider}: Loads constellation data</li>
 *     <li>{@link module:Provider.CraterProvider CraterProvider} : Loads craters</li>
 *     <li>{@link module:Provider.PlanetProvider PlanetProvider} : Loads planets position on the sky</li>
 *     <li>{@link module:Provider.StarProvider StarProvider} : Loads stars name on the sky</li>
 *     <li>{@link module:Provider.TrajectoryProvider TrajectoryProvider} : Loads a file to display a trajectory</li>
 * </ul>
 *
 * In addition to the classes, a {@link module:Provider.ProviderFactory factory} is available to help for creating
 * provider. Once the provider is created, the client can handle it by the use of its {@link Provider interface}.
 *
 * @module Provider
 * @implements {Provider}
 * @todo Describes here and link to the tutos about Animation
 */
define('gw/Provider/PlanetProvider',[
    "jquery",
    "./AbstractProvider",
    "../Renderer/FeatureStyle",
    "../Utils/Constants"
], function($, AbstractProvider, FeatureStyle, Constants) {
    var self;
    var interval;
    var poiFeatureCollection;
    var DEGS = 180 / Math.PI; // convert radians to degrees
    var RADS = Math.PI / 180; // convert degrees to radians
    var EPS = 1.0e-12; // machine error constant
    var pname = new Array(
        "Mercury",
        "Venus",
        "Sun",
        "Mars",
        "Jupiter",
        "Saturn",
        "Uranus",
        "Neptune",
        "Pluto"
    );

    function frealstr(num, width, fract) {
        var str = num.toFixed(fract);
        var len = str.length;
        var real = "";
        var i;

        for (i = 0; i < width - len; i++) {
            // append leading spaces
            real += " ";
        }

        for (i = 0; i < len; i++) {
            // append digits
            real += str.charAt(i);
        }

        return real;
    }

    /*
     * Json template for a point
    */
    function poiDesc(mizarLayer, type, name, obj) {
        var style;
        if (type === Constants.GEOMETRY.Point) {
            style = new FeatureStyle({
                iconUrl: mizarLayer.style.iconUrl,
                strokeColor: FeatureStyle.fromStringToColor(obj.color),
                fillColor: FeatureStyle.fromStringToColor(obj.color)
            });
        } else {
            style = new FeatureStyle({
                label: name,
                strokeColor: FeatureStyle.fromStringToColor(obj.color),
                fillColor: FeatureStyle.fromStringToColor(obj.color)
            });
        }
        return {
            geometry: {
                type: Constants.GEOMETRY.Point,
                gid: "planet" + type + "_" + name,
                coordinates: [obj.ra, obj.dec],
                crs: {
                    type: "name",
                    properties: {
                        name: Constants.CRS.Equatorial
                    }
                }
            },
            properties: {
                name: name,
                distance: frealstr(obj.rvec, 9, 6) + " AU",
                style: style
            }
        };
    }

    // right ascension, declination coordinate structure
    function Coord() {
        this.ra = parseFloat("0"); // right ascension [deg]
        this.dec = parseFloat("0"); // declination [deg]
        this.rvec = parseFloat("0"); // distance [AU]
    }

    // day number to/from J2000 (Jan 1.5, 2000)
    function day_number(y, m, d, hour, mins) {
        var h = hour + mins / 60;
        return (
            367 * y -
            Math.floor((7 * (y + Math.floor((m + 9) / 12))) / 4) +
            Math.floor((275 * m) / 9) +
            d -
            730531.5 +
            h / 24
        );
    }

    /**************************************************************************************************************/

    // orbital element structure
    function Elem() {
        this.color = ""; // color of the planet
        this.a = parseFloat("0"); // semi-major axis [AU]
        this.e = parseFloat("0"); // eccentricity of orbit
        this.i = parseFloat("0"); // inclination of orbit [deg]
        this.O = parseFloat("0"); // longitude of the ascending node [deg]
        this.w = parseFloat("0"); // longitude of perihelion [deg]
        this.L = parseFloat("0"); // mean longitude [deg]
    }

    // return the integer part of a number
    function abs_floor(x) {
        var r;
        if (x >= 0.0) {
            r = Math.floor(x);
        } else {
            r = Math.ceil(x);
        }
        return r;
    }

    // return an angle in the range 0 to 2pi radians
    function mod2pi(x) {
        var b = x / (2 * Math.PI);
        var a = 2 * Math.PI * (b - abs_floor(b));
        if (a < 0) {
            a = 2 * Math.PI + a;
        }
        return a;
    }

    // compute the true anomaly from mean anomaly using iteration
    //  M - mean anomaly in radians
    //  e - orbit eccentricity
    function true_anomaly(M, e) {
        var V, E1;

        // initial approximation of eccentric anomaly
        var E = M + e * Math.sin(M) * (1.0 + e * Math.cos(M));

        do // iterate to improve accuracy
        {
            E1 = E;
            E = E1 - (E1 - e * Math.sin(E1) - M) / (1 - e * Math.cos(E1));
        } while (Math.abs(E - E1) > EPS);

        // convert eccentric anomaly to true anomaly
        V = 2 * Math.atan(Math.sqrt((1 + e) / (1 - e)) * Math.tan(0.5 * E));

        if (V < 0) {
            V = V + 2 * Math.PI;
        } // modulo 2pi

        return V;
    }

    /**
     * Computes the elements of the orbit for planet-i at day number-d
     * @param p - result
     * @param i - planet-i
     * @param d - day number
     * @throws {RangeError} function mean_elements() failed!
     */
    function mean_elements(p, i, d) {
        var cy = d / 36525; // centuries since J2000

        switch (i) {
        case 0: // Mercury
            p.color = "rgb(170,150,170)";
            p.a = 0.38709893 + 0.00000066 * cy;
            p.e = 0.20563069 + 0.00002527 * cy;
            p.i = (7.00487 - (23.51 * cy) / 3600) * RADS;
            p.O = (48.33167 - (446.3 * cy) / 3600) * RADS;
            p.w = (77.45645 + (573.57 * cy) / 3600) * RADS;
            p.L = mod2pi((252.25084 + (538101628.29 * cy) / 3600) * RADS);
            break;
        case 1: // Venus
            p.color = "rgb(245,222,179)";
            p.a = 0.72333199 + 0.00000092 * cy;
            p.e = 0.00677323 - 0.00004938 * cy;
            p.i = (3.39471 - (2.86 * cy) / 3600) * RADS;
            p.O = (76.68069 - (996.89 * cy) / 3600) * RADS;
            p.w = (131.53298 - (108.8 * cy) / 3600) * RADS;
            p.L = mod2pi((181.97973 + (210664136.06 * cy) / 3600) * RADS);
            break;
        case 2: // Earth/Sun
            p.color = "rgb(255,193,37)";
            p.a = 1.00000011 - 0.00000005 * cy;
            p.e = 0.01671022 - 0.00003804 * cy;
            p.i = (0.00005 - (46.94 * cy) / 3600) * RADS;
            p.O = (-11.26064 - (18228.25 * cy) / 3600) * RADS;
            p.w = (102.94719 + (1198.28 * cy) / 3600) * RADS;
            p.L = mod2pi((100.46435 + (129597740.63 * cy) / 3600) * RADS);
            break;
        case 3: // Mars
            p.color = "rgb(255,50,50)";
            p.a = 1.52366231 - 0.00007221 * cy;
            p.e = 0.09341233 + 0.00011902 * cy;
            p.i = (1.85061 - (25.47 * cy) / 3600) * RADS;
            p.O = (49.57854 - (1020.19 * cy) / 3600) * RADS;
            p.w = (336.04084 + (1560.78 * cy) / 3600) * RADS;
            p.L = mod2pi((355.45332 + (68905103.78 * cy) / 3600) * RADS);
            break;
        case 4: // Jupiter
            p.color = "rgb(255,150,150)";
            p.a = 5.20336301 + 0.00060737 * cy;
            p.e = 0.04839266 - 0.0001288 * cy;
            p.i = (1.3053 - (4.15 * cy) / 3600) * RADS;
            p.O = (100.55615 + (1217.17 * cy) / 3600) * RADS;
            p.w = (14.75385 + (839.93 * cy) / 3600) * RADS;
            p.L = mod2pi((34.40438 + (10925078.35 * cy) / 3600) * RADS);
            break;
        case 5: // Saturn
            p.color = "rgb(200,150,150)";
            p.a = 9.53707032 - 0.0030153 * cy;
            p.e = 0.0541506 - 0.00036762 * cy;
            p.i = (2.48446 + (6.11 * cy) / 3600) * RADS;
            p.O = (113.71504 - (1591.05 * cy) / 3600) * RADS;
            p.w = (92.43194 - (1948.89 * cy) / 3600) * RADS;
            p.L = mod2pi((49.94432 + (4401052.95 * cy) / 3600) * RADS);
            break;
        case 6: // Uranus
            p.color = "rgb(130,150,255)";
            p.a = 19.19126393 + 0.00152025 * cy;
            p.e = 0.04716771 - 0.0001915 * cy;
            p.i = (0.76986 - (2.09 * cy) / 3600) * RADS;
            p.O = (74.22988 - (1681.4 * cy) / 3600) * RADS;
            p.w = (170.96424 + (1312.56 * cy) / 3600) * RADS;
            p.L = mod2pi((313.23218 + (1542547.79 * cy) / 3600) * RADS);
            break;
        case 7: // Neptune
            p.color = "rgb(100,100,255)";
            p.a = 30.06896348 - 0.00125196 * cy;
            p.e = 0.00858587 + 0.0000251 * cy;
            p.i = (1.76917 - (3.64 * cy) / 3600) * RADS;
            p.O = (131.72169 - (151.25 * cy) / 3600) * RADS;
            p.w = (44.97135 - (844.43 * cy) / 3600) * RADS;
            p.L = mod2pi((304.88003 + (786449.21 * cy) / 3600) * RADS);
            break;
        case 8: // Pluto
            p.color = "rgb(100,100,255)";
            p.a = 39.48168677 - 0.00076912 * cy;
            p.e = 0.24880766 + 0.00006465 * cy;
            p.i = (17.14175 + (11.07 * cy) / 3600) * RADS;
            p.O = (110.30347 - (37.33 * cy) / 3600) * RADS;
            p.w = (224.06676 - (132.25 * cy) / 3600) * RADS;
            p.L = mod2pi((238.92881 + (522747.9 * cy) / 3600) * RADS);
            break;
        default:
            throw RangeError(
                "function mean_elements() failed!",
                "PlanetProvider.js"
            );
        }
    }

    // compute RA, DEC, and distance of planet-p for day number-d
    // result returned in structure obj in degrees and astronomical units
    function get_coord(obj, p, d) {
        var planet = new Elem();
        mean_elements(planet, p, d);
        var ap = planet.a;
        var ep = planet.e;
        var ip = planet.i;
        var op = planet.O;
        var pp = planet.w;
        var lp = planet.L;

        var earth = new Elem();
        mean_elements(earth, 2, d);
        var ae = earth.a;
        var ee = earth.e;
        //var ie = earth.i;
        //var oe = earth.O;
        var pe = earth.w;
        var le = earth.L;

        // position of Earth in its orbit
        var me = mod2pi(le - pe);
        var ve = true_anomaly(me, ee);
        var re = (ae * (1 - ee * ee)) / (1 + ee * Math.cos(ve));

        // heliocentric rectangular coordinates of Earth
        var xe = re * Math.cos(ve + pe);
        var ye = re * Math.sin(ve + pe);
        var ze = 0.0;

        // position of planet in its orbit
        var mp = mod2pi(lp - pp);
        var vp = true_anomaly(mp, planet.e);
        var rp = (ap * (1 - ep * ep)) / (1 + ep * Math.cos(vp));

        // heliocentric rectangular coordinates of planet
        var xh =
            rp *
            (Math.cos(op) * Math.cos(vp + pp - op) -
                Math.sin(op) * Math.sin(vp + pp - op) * Math.cos(ip));
        var yh =
            rp *
            (Math.sin(op) * Math.cos(vp + pp - op) +
                Math.cos(op) * Math.sin(vp + pp - op) * Math.cos(ip));
        var zh = rp * (Math.sin(vp + pp - op) * Math.sin(ip));

        if (p === 2) {
            // earth --> compute sun
            xh = 0;
            yh = 0;
            zh = 0;
        }

        // convert to geocentric rectangular coordinates
        var xg = xh - xe;
        var yg = yh - ye;
        var zg = zh - ze;

        // rotate around x axis from ecliptic to equatorial coords
        var ecl = 23.439281 * RADS; //value for J2000.0 frame
        var xeq = xg;
        var yeq = yg * Math.cos(ecl) - zg * Math.sin(ecl);
        var zeq = yg * Math.sin(ecl) + zg * Math.cos(ecl);

        // find the RA and DEC from the rectangular equatorial coords
        obj.ra = mod2pi(Math.atan2(yeq, xeq)) * DEGS;
        obj.dec = Math.atan(zeq / Math.sqrt(xeq * xeq + yeq * yeq)) * DEGS;
        obj.rvec = Math.sqrt(xeq * xeq + yeq * yeq + zeq * zeq);
        obj.color = planet.color;
    }

    /**
     *    Handle features on layer
     */
    var computePositions = function(mizarLayer) {
        var pois = [];
        var now = new Date();
        var year = now.getUTCFullYear();
        var month = now.getUTCMonth() + 1;
        var day = now.getUTCDate();
        var hour = now.getUTCHours();
        var mins = now.getUTCMinutes();
        var secs = now.getUTCSeconds();

        // compute day number for date/time
        var dn = day_number(year, month, day, hour, mins + secs / 60);
        var obj = new Coord();
        // compute location of objects
        for (var p = 0; p < 9; p++) {
            get_coord(obj, p, dn);
            // Add label
            var poi_label = poiDesc(mizarLayer, "Label", pname[p], obj);
            pois.push(poi_label);

            // Add point itself
            var poi_point = poiDesc(
                mizarLayer,
                Constants.GEOMETRY.Point,
                pname[p],
                obj
            );
            pois.push(poi_point);
        }

        // Create feature collection
        poiFeatureCollection = {
            type: "FeatureCollection",
            features: pois
        };

        mizarLayer.addFeatureCollection(poiFeatureCollection);
    };

    /**************************************************************************************************************/

    /**
     * @name PlanetProvider
     * @class
     *    Providing planet positions based on ephemeris computations
     * @param {Object} options
     * @augments AbstractProvider
     * @constructor
     * @memberof module:Provider
     * @see http://www.abecedarical.com/javascript/script_planet_orbits.html
     */
    var PlanetProvider = function(options) {
        AbstractProvider.prototype.constructor.call(this, options);
        self = this;
    };

    /**
     * Loads files
     * @param {Layer} layer - Mizar layer
     * @param {Object} configuration - configuration
     * @param {int} [configuration.interval = 60000] - Recomputes planet position every minute if not defined
     * @memberof PlanetProvider#
     */
    PlanetProvider.prototype.loadFiles = function(layer, configuration) {
        interval = configuration.interval ? configuration.interval : 60000;
        self.handleFeatures(layer);
    };

    /**
     * Calculate planets position and add them to the passed layer
     * @function handleFeatures
     * @memberof PlanetProvider#
     * @param {Layer} layer
     */
    PlanetProvider.prototype.handleFeatures = function(layer) {
        computePositions(layer);
        setInterval(function() {
            layer.removeFeatureCollection(poiFeatureCollection);
            computePositions(layer);
        }, interval);
    };

    /**
     * Returns the Sun position at the date.
     * @param {date} date
     * @returns {float[]} the Sun position
     */
    PlanetProvider.prototype.getSunPosition = function(date) {
        var year = date.getUTCFullYear();
        var month = date.getUTCMonth() + 1;
        var day = date.getUTCDate();
        var hour = date.getUTCHours();
        var mins = date.getUTCMinutes();
        var secs = date.getUTCSeconds();
        // compute day number for date/time
        var dn = day_number(year, month, day, hour, mins + secs / 60);
        var obj = new Coord();
        get_coord(obj, 2, dn);
        return obj;
    };

    return PlanetProvider;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 * A layer is an information that can be superimposed on another information.
 * <img src="../doc/images/gis_layers.gif">
 * It exists different natures of layer,
 * which are listed as below :
 * <ul>
 *     <li>{@link module:Layer.AtmosphereLayer AtmosphereLayer} : A layer to create an atmosphere on a planet.</li>
 *     <li>{@link module:Layer.BingLayer BingLayer}: The Microsoft service proving a WMTS server.</li>
 *     <li>{@link module:Layer.CoordinateGridLayer CoordinateGridLayer} : A layer to create a grid on the sky</li>
 *     <li>{@link module:Layer.GeoJsonLayer GeoJSONLayer} : A layer to add a GeoJSON on the globe</li>
 *     <li>{@link module:Layer.GroundOverlayLayer GroundOverlayLayer} : A layer to draw an image overlay draped onto the terrain</li>
 *     <li>{@link module:Layer.HipsCatLayer HipsCatLayer} : A layer to draw a HIPS catalogue</li>
 *     <li>{@link module:Layer.HipsFitsLayer HipsFitsLayer} : A layer to draw an Hips Fits</li>
 *     <li>{@link module:Layer.HipsGraphicLayer HipsGraphicLayer} : A layer to draw a Hips JPEG/PNG</li>
 *     <li>{@link module:Layer.MocLayer MocLayer} : A layer to draw a multi-order-coverage index</li>
 *     <li>{@link module:Layer.OpenSearchLayer OpenSearchLayer} : A layer to draw the result from an open search service</li>
 *     <li>{@link module:Layer.OSMLayer OSMLayer} : A layer to display data coming from OpenStreetMap server</li>
 *     <li>{@link module:Layer.TileWireframeLayer TileWireframeLayer} : A layer to draw a grid on the planet</li>
 *     <li>{@link module:Layer.VectorLayer VectorLayer} : A layer to draw a vector</li>
 *     <li>{@link module:Layer.WCSElevationLayer WCSElevationLayer} : A layer to draw the elevation</li>
 *     <li>{@link module:Layer.WMSElevationLayer WMSElevationLayer} : A layer to draw the elevation</li>
 *     <li>{@link module:Layer.WMSLayer WMSLayer} : A layer to draw images coming from the WMS server</li>
 *     <li>{@link module:Layer.WMTSLayer WMTSLayer} : A layer to draw predefined tiles coming from a WMTS server</li>
 * </ul>
 * <br/>
 * In addition to the classes, a {@link module:Layer.LayerFactory factory} is available to help for creating layer.
 * Once the layer is created, the client can handle it by the use of its {@link Layer interface}.
 * @implements {Layer}
 * @module Layer
 */
define('gw/Layer/AtmosphereLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "../Utils/Constants",
    "../Provider/PlanetProvider",
    "../Renderer/Program",
    "../Time/Time"
], function(Utils, AbstractLayer, Constants, PlanetProvider, Program, Time) {
    /**
     * Atmosphere layer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.atmosphere_configuration
     * @property {float} [kr=0.0025] the rayleigh parameter
     * @property {float} [km=0.0015] the mie parameter
     * @property {float} [sunBrightness=15] The Sun brightness
     * @property {float} [exposure=2.0] the exposure, use for basic high dynamic range
     * @property {float[]} [wavelength=[0.650, 0.570, 0.475]] the RGB color of the sun
     * @property {float[]} [lightDir=[1, 0, 0]] The location of the light in (x,y,z)
     */

    /**
     * @name AtmosphereLayer
     * @class
     * Creates an atmosphere on the planet.
     * @augments AbstractLayer
     * @param {AbstractLayer.atmosphere_configuration} options - Atmosphere configuration.
     * @constructor
     * @memberof module:Layer
     */
    var AtmosphereLayer = function(options) {
        var currentDate = new Date();
        var tomorrow = new Date();
        tomorrow.setDate(currentDate.getDate() + 1);
        options.dimension = {
            time: {
                units: "ISO8601",
                unitSymbol: null,
                default: null,
                multipleValues: null,
                nearestValue: null,
                current: null,
                value:
                    currentDate.toISOString() +
                    "/" +
                    tomorrow.toISOString() +
                    "/PT1H"
            }
        };
        // For rendering
        options.zIndex = Constants.DISPLAY.RENDERING;

        AbstractLayer.prototype.constructor.call(
            this,
            Constants.LAYER.Atmosphere,
            options
        );
        if (!this.name) {
            this.name = "Atmosphere";
        }
        this.kr = (options && options.kr) || 0.0025;
        this.km = (options && options.km) || 0.0015;
        this.sunBrightness = (options && options.sunBrightness) || 15.0;
        this.exposure = (options && options.exposure) || 2.0;
        this.wavelength = (options && options.wavelength) || [
            0.65,
            0.57,
            0.475
        ];
        this.lightDir =
            (options && options.lightDir) ||
            _computeLightDir.call(this, new Date());

        // internal properties
        this._skyProgram = null;
        this._groundProgram = null;
        this._originalProgram = null;
        this._isValid = false;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, AtmosphereLayer);

    /**************************************************************************************************************/

    /**
     * Computes light direction
     * @param date date
     * @returns {number[]} [x, y, z]
     * @private
     */
    function _computeLightDir(date) {
        var sunProvider = new PlanetProvider();
        var sunPosition = sunProvider.getSunPosition(date);
        var latitude = sunPosition.dec;
        var longitude = -Utils.GHA(date, sunPosition.ra);
        var coords = Utils.longLat2XYZ(longitude, latitude);
        return [coords.x, coords.y, coords.z];
    }

    /**
     * @function getInformationType
     * @memberof AtmosphereLayer#
     */
    AtmosphereLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.ATMOSPHERE;
    };

    /**
     * Attaches the atmosphere layer to the planet.
     * @function _attach
     * @memberof AtmosphereLayer#
     * @param {Planet} g Planet
     * @private
     */
    AtmosphereLayer.prototype._attach = function(g) {
        this.globe = g;
        this._innerRadius = this.getGlobe()
            .getCoordinateSystem()
            .getGeoide()
            .getRadius();
        this._outerRadius = this._innerRadius * 1.005;
        var renderContext = g.getRenderContext();

        // Setup program, uniform now that we have the render context

        this._skyFromSpaceProgram = new Program(renderContext);
        this._skyFromSpaceProgram.loadFromFile(
            "SkyFromSpaceVert.glsl",
            "SkyFrag.glsl"
        );
        this._skyFromAtmosphereProgram = new Program(renderContext);
        this._skyFromAtmosphereProgram.loadFromFile(
            "SkyFromAtmosphereVert.glsl",
            "SkyFrag.glsl"
        );

        this._groundFromSpaceProgram = new Program(renderContext);
        this._groundFromSpaceProgram.loadFromFile(
            "GroundFromSpaceVert.glsl",
            "GroundFrag.glsl"
        );

        this._groundFromAtmosphereProgram = new Program(renderContext);
        this._groundFromAtmosphereProgram.loadFromFile(
            "GroundFromAtmosphereVert.glsl",
            "GroundFrag.glsl"
        );

        // Check if the atmosphre is valid : all programs must be OK
        this._isValid =
            this._skyFromSpaceProgram.glProgram !== null &&
            this._skyFromAtmosphereProgram.glProgram !== null &&
            this._groundFromSpaceProgram.glProgram !== null &&
            this._groundFromAtmosphereProgram.glProgram !== null;

        if (!this._isValid) {
            return;
        }
        this._skyFromSpaceProgram.apply();
        this._initUniforms(this._skyFromSpaceProgram.uniforms);
        this._skyFromAtmosphereProgram.apply();
        this._initUniforms(this._skyFromAtmosphereProgram.uniforms);
        this._groundFromSpaceProgram.apply();
        this._initUniforms(this._groundFromSpaceProgram.uniforms);
        this._groundFromAtmosphereProgram.apply();
        this._initUniforms(this._groundFromAtmosphereProgram.uniforms);

        // Create the sphere
        var vertices = [];
        var indices = [];

        var nbEl = 72;
        var nbAz = 144;

        // Create the vertices
        var el;
        var az;
        for (el = -nbEl; el <= nbEl; el++) {
            var elevation = (el * (Math.PI * 0.5)) / nbEl;
            for (az = -nbAz; az <= nbAz; az++) {
                var azimuth = (az * Math.PI) / nbAz;

                var x =
                    this._outerRadius * Math.cos(azimuth) * Math.cos(elevation);
                var y =
                    this._outerRadius * Math.sin(azimuth) * Math.cos(elevation);
                var z = this._outerRadius * Math.sin(elevation);

                vertices.push(x);
                vertices.push(y);
                vertices.push(z);
            }
        }

        // build the sphere triangles
        for (el = 0; el < 2 * nbEl; el++) {
            for (az = 0; az < 2 * nbAz; az++) {
                indices.push(el * (2 * nbAz + 1) + az);
                indices.push((el + 1) * (2 * nbAz + 1) + az + 1);
                indices.push(el * (2 * nbAz + 1) + az + 1);

                indices.push((el + 1) * (2 * nbAz + 1) + az + 1);
                indices.push(el * (2 * nbAz + 1) + az);
                indices.push((el + 1) * (2 * nbAz + 1) + az);
            }
        }

        var gl = renderContext.gl;
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(vertices),
            gl.STATIC_DRAW
        );

        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
        );
        this._numIndices = indices.length;

        this._originalProgram = g.getTileManager().program;

        g.preRenderers.push(this);
        g.getTileManager().addPostRenderer(this);
    };

    /**************************************************************************************************************/

    /**
     * Initializes uniforms.
     * @function _initUniforms
     * @memberof AtmosphereLayer#
     * @param uniforms
     * @private
     */
    AtmosphereLayer.prototype._initUniforms = function(uniforms) {
        var gl = this.getGlobe().getRenderContext().gl;

        var g = -0.95; // The Mie phase asymmetry factor
        var scale = 1.0 / (this._outerRadius - this._innerRadius);
        var rayleighScaleDepth = 0.25;
        //var mieScaleDepth = 0.1;

        vec3.normalize(this.lightDir);

        gl.uniform1f(uniforms.fKrESun, this.kr * this.sunBrightness);
        gl.uniform1f(uniforms.fKmESun, this.kr * this.sunBrightness);
        gl.uniform1f(uniforms.fKr4PI, this.kr * 4.0 * Math.PI);
        gl.uniform1f(uniforms.fKm4PI, this.km * 4.0 * Math.PI);
        gl.uniform1f(uniforms.fExposure, this.exposure);

        var wavelength = [
            Math.pow(this.wavelength[0], 4.0),
            Math.pow(this.wavelength[1], 4.0),
            Math.pow(this.wavelength[2], 4.0)
        ];
        gl.uniform3f(
            uniforms.v3InvWavelength,
            1.0 / wavelength[0],
            1.0 / wavelength[1],
            1.0 / wavelength[2]
        );

        gl.uniform3f(
            uniforms.v3LightPos,
            this.lightDir[0],
            this.lightDir[1],
            this.lightDir[2]
        );
        gl.uniform1f(uniforms.fInnerRadius, this._innerRadius);
        gl.uniform1f(
            uniforms.fInnerRadius2,
            this._innerRadius * this._innerRadius
        );
        gl.uniform1f(uniforms.fOuterRadius, this._outerRadius);
        gl.uniform1f(
            uniforms.fOuterRadius2,
            this._outerRadius * this._outerRadius
        );
        gl.uniform1f(uniforms.fScale, scale);
        gl.uniform1f(uniforms.fScaleDepth, rayleighScaleDepth);
        gl.uniform1f(uniforms.fScaleOverScaleDepth, scale / rayleighScaleDepth);
        gl.uniform1f(uniforms.g, g);
        gl.uniform1f(uniforms.g2, g * g);
    };

    /**************************************************************************************************************/

    /**
     * Pre-rendesr the atmoshpere.
     * @function preRender
     * @memberof AtmosphereLayer#
     */
    AtmosphereLayer.prototype.preRender = function() {
        if (!this._isValid) {
            return;
        }
        var tileManager = this.getGlobe().getTileManager();
        if (!this.isVisible()) {
            tileManager.program = this._originalProgram;
            return;
        }

        var rc = this.getGlobe().getRenderContext();
        var gl = rc.gl;
        var x, y, z;

        // Compute the eye position from the view matrix : the eye position is equals to [0,0,0] * inv(viewMatrix)
        // Optimized to avoid to compute the view matrix inverse
        var vm = rc.viewMatrix;
        x = vm[12];
        y = vm[13];
        z = vm[14];
        var eyePos = [
            -(vm[0] * x + vm[1] * y + vm[2] * z),
            -(vm[4] * x + vm[5] * y + vm[6] * z),
            -(vm[8] * x + vm[9] * y + vm[10] * z)
        ];
        var eyeHeight = vec3.length(eyePos);

        this._skyProgram =
            eyeHeight < this._outerRadius
                ? this._skyFromAtmosphereProgram
                : this._skyFromSpaceProgram;
        this._groundProgram =
            eyeHeight < this._outerRadius
                ? this._groundFromAtmosphereProgram
                : this._groundFromSpaceProgram;

        this._skyProgram.apply();

        gl.uniform3f(
            this._skyProgram.uniforms.v3CameraPos,
            eyePos[0],
            eyePos[1],
            eyePos[2]
        );
        gl.uniform1f(
            this._skyProgram.uniforms.fCameraHeight2,
            eyeHeight * eyeHeight
        );
        gl.uniform1f(this._skyProgram.uniforms.fCameraHeight, eyeHeight);

        this._groundProgram.apply();

        var earthCenter = [0.0, 0.0, 0.0];
        mat4.multiplyVec3(rc.viewMatrix, earthCenter);
        gl.uniform3f(
            this._groundProgram.uniforms.earthCenter,
            earthCenter[0],
            earthCenter[1],
            earthCenter[2]
        );

        vec3.normalize(this.lightDir);
        x = this.lightDir[0];
        y = this.lightDir[1];
        z = this.lightDir[2];
        var mat = rc.viewMatrix;
        var lightDirUpdated = [];
        lightDirUpdated[0] = mat[0] * x + mat[4] * y + mat[8] * z;
        lightDirUpdated[1] = mat[1] * x + mat[5] * y + mat[9] * z;
        lightDirUpdated[2] = mat[2] * x + mat[6] * y + mat[10] * z;
        gl.uniform3f(
            this._groundProgram.uniforms.lightDir,
            lightDirUpdated[0],
            lightDirUpdated[1],
            lightDirUpdated[2]
        );

        gl.uniform3f(
            this._groundProgram.uniforms.v3CameraPos,
            eyePos[0],
            eyePos[1],
            eyePos[2]
        );
        gl.uniform1f(
            this._groundProgram.uniforms.fCameraHeight2,
            eyeHeight * eyeHeight
        );
        gl.uniform1f(this._groundProgram.uniforms.fCameraHeight, eyeHeight);

        tileManager.program = this._groundProgram;

        //	rc.minFar = 2.0;
    };

    /**************************************************************************************************************/

    /**
     * Renders the atmosphere.
     * @function render
     * @memberof AtmosphereLayer#
     */
    AtmosphereLayer.prototype.render = function() {
        if (!this._isValid || !this.isVisible() || !this.getGlobe()) {
            return;
        }
        var rc = this.getGlobe().getRenderContext();
        var gl = rc.gl;

        gl.enable(gl.CULL_FACE);

        this._skyProgram.apply();

        gl.uniformMatrix4fv(
            this._skyProgram.uniforms.projectionMatrix,
            false,
            rc.projectionMatrix
        );
        gl.uniformMatrix4fv(
            this._skyProgram.uniforms.viewMatrix,
            false,
            rc.viewMatrix
        );

        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(
            this._skyProgram.attributes.vertex,
            3,
            gl.FLOAT,
            false,
            0,
            0
        );
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.drawElements(gl.TRIANGLES, this._numIndices, gl.UNSIGNED_SHORT, 0);

        gl.disable(gl.CULL_FACE);
    };

    AtmosphereLayer.prototype.setTime = function(time) {
        AbstractLayer.prototype.setTime(time);
        this.setParameter("time", time);
    };

    AtmosphereLayer.prototype.setParameter = function(param, value) {
        if (param === "time") {
            var time = Time.parse(value);
            var date = new Date(time.date);
            this.lightDir = _computeLightDir.call(this, date);
            this._skyFromSpaceProgram.apply();
            this._initUniforms(this._skyFromSpaceProgram.uniforms);
            this._skyFromAtmosphereProgram.apply();
            this._initUniforms(this._skyFromAtmosphereProgram.uniforms);
            this._groundFromSpaceProgram.apply();
            this._initUniforms(this._groundFromSpaceProgram.uniforms);
            this._groundFromAtmosphereProgram.apply();
            this._initUniforms(this._groundFromAtmosphereProgram.uniforms);
            this.forceRefresh();
        }
    };

    /**************************************************************************************************************/

    return AtmosphereLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/MercatorTiling',["./Tile", "../Utils/Constants","../Renderer/GeoBound", "./GeoTiling"], function(
    Tile,
    Constants,
    GeoBound,
    GeoTiling
) {
    var lon2merc = function(lon) {
        return (lon * 20037508.34) / 180;
    };

    var lat2merc = function(lat) {
        var y =
            Math.log(Math.tan(((90 + lat) * Math.PI) / 360)) / (Math.PI / 180);
        return (y * 20037508.34) / 180;
    };

    var tile2long = function(x, z) {
        return (x / Math.pow(2, z)) * 360 - 180;
    };

    var tile2lat = function(y, z) {
        var n = Math.PI - (2 * Math.PI * y) / Math.pow(2, z);
        return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    };

    /**************************************************************************************************************/

    /** @constructor
       Tile constructor
       */
    var MercatorTile = function(level, x, y) {
        // Call ancestor constructor
        Tile.prototype.constructor.call(this);

        this.level = level;
        this.x = x;
        this.y = y;
        this.key = this.level+"#"+this.x+"#"+this.y;
        this.type = Constants.TILE.MERCATOR_TILE;        

        this.geoBound = new GeoBound(
            tile2long(x, level),
            tile2lat(y + 1, level),
            tile2long(x + 1, level),
            tile2lat(y, level)
        );
        this.bound = new GeoBound(
            lon2merc(this.geoBound.west),
            lat2merc(this.geoBound.south),
            lon2merc(this.geoBound.east),
            lat2merc(this.geoBound.north)
        );
    };

    /**************************************************************************************************************/

    /** Inhertis from tile */
    MercatorTile.prototype = new Tile();

    /**************************************************************************************************************/

    /** @export
       Get elevation at a geo position
       */
    MercatorTile.prototype.getElevation = function(lon, lat) {
        // TODO
        return 0.0;
    };

    MercatorTile.prototype.getKey = function() {
        return this.key;
    };

    /**************************************************************************************************************/

    /**
       Create the children
       */
    MercatorTile.prototype.createChildren = function() {
        // Create the children
        var tile00 = new MercatorTile(this.level + 1, 2 * this.x, 2 * this.y);
        var tile10 = new MercatorTile(
            this.level + 1,
            2 * this.x + 1,
            2 * this.y
        );
        var tile01 = new MercatorTile(
            this.level + 1,
            2 * this.x,
            2 * this.y + 1
        );
        var tile11 = new MercatorTile(
            this.level + 1,
            2 * this.x + 1,
            2 * this.y + 1
        );

        tile00.initFromParent(this, 0, 0);
        tile10.initFromParent(this, 1, 0);
        tile01.initFromParent(this, 0, 1);
        tile11.initFromParent(this, 1, 1);

        this.children = [tile00, tile10, tile01, tile11];
    };

    /**************************************************************************************************************/

    /**
       Convert coordinates in longitude,latitude to coordinate in "tile space"
       Tile space means coordinates are between [0,tesselation-1] if inside the tile
       Used by renderers algorithm to clamp coordinates on the tile
       */
    MercatorTile.prototype.lonlat2tile = function(coordinates) {
        var tpl = Math.pow(2, this.level);
        var factor = this.config.tesselation - 1;

        var tileCoords = [];
        for (var i = 0; i < coordinates.length; i++) {
            var x = (coordinates[i][0] + 180.0) / 360.0;
            var sinLat = Math.sin((coordinates[i][1] * Math.PI) / 180.0);
            var y =
                0.5 - Math.log((1 + sinLat) / (1 - sinLat)) / (4.0 * Math.PI);

            tileCoords.push([
                factor * (x * tpl - this.x),
                factor * (y * tpl - this.y)
            ]);
        }

        return tileCoords;
    };

    /**************************************************************************************************************/

    /**
       Generate vertices for tile
       */
    MercatorTile.prototype.generateVertices = function(elevations) {
        // Compute tile matrix
        this.matrix = this.config.coordinateSystem.getLHVTransform(
            this.geoBound.getCenter()
        );
        var invMatrix = mat4.create();
        mat4.inverse(this.matrix, invMatrix);
        this.inverseMatrix = invMatrix;

        // Build the vertices
        var size = this.config.tesselation;
        var vertices = new Float32Array(3 * size * (size + 6));
        var step = 1.0 / (size - 1);
        var radius = this.config.coordinateSystem.geoide.radius;
        var scale = this.config.coordinateSystem.geoide.heightScale;
        var offset = 0;

        var twoPowLevel = Math.pow(2, this.level);
        var pos3d = [0.0, 0.0, 0.0];
        var v = this.y;
        for (var j = 0; j < size; j++) {
            var n = Math.PI * (1.0 - (2.0 * v) / twoPowLevel);
            var lat = Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
            lat = (lat * 180) / Math.PI;

            var cosLat = Math.cos(lat);
            var sinLat = Math.sin(lat);

            var u = this.x;

            for (var i = 0; i < size; i++) {
                var lon = 180 * ((2.0 * u) / twoPowLevel - 1.0);
                var height = elevations ? scale * elevations[offset] : 0.0;

                this.config.coordinateSystem.fromGeoTo3D(
                    [lon, lat, height],
                    pos3d
                );
                var x = pos3d[0];
                var y = pos3d[1];
                var z = pos3d[2];

                var vertexOffset = offset * 3;
                vertices[vertexOffset] =
                    invMatrix[0] * x +
                    invMatrix[4] * y +
                    invMatrix[8] * z +
                    invMatrix[12];
                vertices[vertexOffset + 1] =
                    invMatrix[1] * x +
                    invMatrix[5] * y +
                    invMatrix[9] * z +
                    invMatrix[13];
                vertices[vertexOffset + 2] =
                    invMatrix[2] * x +
                    invMatrix[6] * y +
                    invMatrix[10] * z +
                    invMatrix[14];

                offset++;
                u += step;
            }

            v += step;
        }

        return vertices;
    };

    /**************************************************************************************************************/

    /**
       Override buildSkirtVertices for mercator.
       Use skirt to "fill" the pole
       */
    MercatorTile.prototype.buildSkirtVertices = function(
        center,
        srcOffset,
        srcStep,
        dstOffset
    ) {
        var size = this.config.tesselation;
        var vertexSize = this.config.vertexSize;
        var numTilesY = Math.pow(2, this.level);

        // Check if the tile is at the north (isTop) or south (isBottom) pole
        var isTop = this.y === 0 && dstOffset === vertexSize * (size * size);
        var isBottom =
            this.y === numTilesY - 1 &&
            dstOffset === vertexSize * ((size + 1) * size);

        if (isTop || isBottom) {
            var vertices = this.vertices;

            var pt = this.config.coordinateSystem.fromGeoTo3D(
                isTop ? [0.0, 90.0, 0.0] : [0.0, -90.0, 0.0]
            );
            mat4.multiplyVec3(this.inverseMatrix, pt);

            for (var i = 0; i < size; i++) {
                vertices[dstOffset] = pt[0];
                vertices[dstOffset + 1] = pt[1];
                vertices[dstOffset + 2] = pt[2];

                for (var n = 3; n < vertexSize; n++) {
                    vertices[dstOffset + n] = vertices[srcOffset + n];
                }

                dstOffset += vertexSize;
            }

            // Recompute the bbox to have correct culling
            //this.bbox.compute(this.vertices,dstOffset + vertexSize*size,vertexSize);
            //this.radius = this.bbox.getRadius();
        } else {
            Tile.prototype.buildSkirtVertices.call(
                this,
                center,
                srcOffset,
                srcStep,
                dstOffset
            );
        }
    };

    /**************************************************************************************************************/

    /**
     MercatorTiling constructor
     @constructor
     */
    var MercatorTiling = function(startLevel) {
        this.startLevel = startLevel;
        this.level0NumTilesX = Math.pow(2, this.startLevel);
    };

    /** inherits from geotiling */
    MercatorTiling.prototype = new GeoTiling();

    /**************************************************************************************************************/

    /**
     Generate the tiles for level zero
     */
    MercatorTiling.prototype.generateLevelZeroTiles = function(config) {
        config.skirt = !config.coordinateSystem.isFlat();
        config.cullSign = 1;
        config.srs = "EPSG:3857";
        config.project = function(coord) {
            return [lon2merc(coord[0]), lat2merc(coord[1])];
        };

        var level0Tiles = [];

        var level0NumTilesX = Math.pow(2, this.startLevel);
        var level0NumTilesY = Math.pow(2, this.startLevel);

        for (var j = 0; j < level0NumTilesY; j++) {
            for (var i = 0; i < level0NumTilesX; i++) {
                var tile = new MercatorTile(this.startLevel, i, j);
                tile.config = config;
                level0Tiles.push(tile);
            }
        }

        return level0Tiles;
    };

    /**************************************************************************************************************/

    /**
     Locate a level zero tile
     */
    MercatorTiling.prototype._lon2LevelZeroIndex = function(lon) {
        var x = (lon + 180) / 360;
        return Math.min(
            this.level0NumTilesX - 1,
            Math.floor(x * this.level0NumTilesX)
        );
    };

    /**************************************************************************************************************/

    /**
     Locate a level zero tile
     */
    MercatorTiling.prototype._lat2LevelZeroIndex = function(lat) {
        var sinLatitude = Math.sin((lat * Math.PI) / 180);
        var y =
            0.5 -
            Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
        return Math.min(
            this.level0NumTilesX - 1,
            Math.floor(y * this.level0NumTilesX)
        );
    };

    /**************************************************************************************************************/

    return MercatorTiling;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/BingLayer',[
    "../Utils/Utils",
    "./AbstractRasterLayer",
    "../Utils/Constants",
    "../Tiling/MercatorTiling",
    "../Utils/Proxy"
], function(Utils, AbstractRasterLayer, Constants, MercatorTiling, Proxy) {
    /**************************************************************************************************************/
    var BingTileSystem = (function() {
        var EarthRadius = 6378137;
        var MinLatitude = -85.05112878;
        var MaxLatitude = 85.05112878;
        var MinLongitude = -180;
        var MaxLongitude = 180;

        /**
         * Clips a number to the specified minimum and maximum values.
         * @param n - The number to clip.
         * @param minValue - Minimum allowable value.
         * @param maxValue - Maximum allowable value.
         * @returns {number} The clipped value.
         * @private
         * @constructor
         */
        function Clip(n, minValue, maxValue) {
            return Math.min(Math.max(n, minValue), maxValue);
        }

        /**
         * Determines the map width and height (in pixels) at a specified level of detail.
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {number} The map width and height in pixels.
         * @constructor
         * @private
         */
        function MapSize(levelOfDetail) {
            return 256 << levelOfDetail;
        }

        /**
         * Determines the ground resolution (in meters per pixel) at a specified
         * latitude and level of detail.
         * @param latitude - Latitude (in degrees) at which to measure the ground resolution
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {number}
         * @constructor
         */
        function GroundResolution(latitude, levelOfDetail) {
            latitude = Clip(latitude, MinLatitude, MaxLatitude);
            return (
                (Math.cos((latitude * Math.PI) / 180.0) *
                    2.0 *
                    Math.PI *
                    EarthRadius) /
                MapSize(levelOfDetail)
            );
        }

        /**
         * Determines the map scale at a specified latitude, level of detail, and screen resolution.
         * @param latitude - Latitude (in degrees) at which to measure the map scale.
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @param screenDpi - Resolution of the screen, in dots per inch.
         * @returns {number} The map scale, expressed as the denominator N of the ratio 1 : N.
         * @constructor
         * @private
         */
        function MapScale(latitude, levelOfDetail, screenDpi) {
            return (
                (GroundResolution(latitude, levelOfDetail) * screenDpi) / 0.0254
            );
        }

        /**
         * Converts a point from latitude/longitude WGS-84 coordinates (in degrees)
         * into pixel XY coordinates at a specified level of detail.
         * @param latitude - Latitude of the point, in degrees
         * @param longitude - Longitude of the point, in degrees
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {float[]} [Output parameter receiving the X coordinate in pixels, Output parameter receiving the Y coordinate in pixels]
         * @constructor
         */
        function LatLongToPixelXY(latitude, longitude, levelOfDetail) {
            latitude = Clip(latitude, MinLatitude, MaxLatitude);
            longitude = Clip(longitude, MinLongitude, MaxLongitude);

            var x = (longitude + 180) / 360;
            var sinLatitude = Math.sin((latitude * Math.PI) / 180);
            var y =
                0.5 -
                Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);

            var mapSize = MapSize(levelOfDetail);
            var pixelX = Clip(x * mapSize + 0.5, 0, mapSize - 1);
            var pixelY = Clip(y * mapSize + 0.5, 0, mapSize - 1);

            return [Math.floor(pixelX), Math.floor(pixelY)];
        }

        /**
         * Converts a pixel from pixel XY coordinates at a specified level of detail
         * into latitude/longitude WGS-84 coordinates (in degrees).
         * @param pixelX - X coordinate of the point, in pixels
         * @param pixelY - Y coordinates of the point, in pixels
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {float[]} [Output parameter receiving the latitude in degrees, Output parameter receiving the longitude in degrees]
         * @constructor
         */
        function PixelXYToLatLong(pixelX, pixelY, levelOfDetail) {
            var mapSize = MapSize(levelOfDetail);
            var x = Clip(pixelX, 0, mapSize - 1) / mapSize - 0.5;
            var y = 0.5 - Clip(pixelY, 0, mapSize - 1) / mapSize;

            var latitude =
                90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;
            var longitude = 360 * x;

            return [latitude, longitude];
        }

        /**
         * Converts pixel XY coordinates into tile XY coordinates of the tile containing the specified pixel.
         * @param pixelXY [Pixel X coordinate, Pixel Y coordinate]
         * @returns {float[]} [Output parameter receiving the tile X coordinate, Output parameter receiving the tile Y coordinate]
         * @constructor
         */
        function PixelXYToTileXY(pixelXY) {
            return [pixelXY[0] / 256, pixelXY[1] / 256];
        }

        /**
         * Converts tile XY coordinates into pixel XY coordinates of the upper-left pixel of the specified tile.
         * @param tileXY [Tile X coordinate, Tile Y coordinate.]
         * @returns {float[]} [Output parameter receiving the pixel X coordinate,  Output parameter receiving the pixel Y coordinate]
         * @constructor
         */
        function TileXYToPixelXY(tileXY) {
            return [tileXY[0] * 256, tileXY[1] * 256];
        }

        /**
         * Converts tile XY coordinates into a QuadKey at a specified level of detail.
         * @param tileX - Tile X coordinate
         * @param tileY - Tile Y coordinate
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {string} A string containing the QuadKey
         * @constructor
         * @private
         */
        function TileXYToQuadKey(tileX, tileY, levelOfDetail) {
            var quadKey = "";
            for (var i = levelOfDetail; i > 0; i--) {
                var digit = "0";
                var mask = 1 << (i - 1);
                if ((tileX & mask) !== 0) {
                    digit++;
                }
                if ((tileY & mask) !== 0) {
                    digit++;
                    digit++;
                }
                quadKey += digit;
            }
            return quadKey;
        }

        /**
         * Converts a QuadKey into tile XY coordinates.
         * @param quadKey - QuadKey of the tile
         * @constructor
         */
        function QuadKeyToTileXY(quadKey) {
            var tileX = 0,
                tileY = 0;
            var levelOfDetail = quadKey.length();
            for (var i = levelOfDetail; i > 0; i--) {
                var mask = 1 << (i - 1);
                switch (quadKey[levelOfDetail - i]) {
                case "0":
                    break;

                case "1":
                    tileX |= mask;
                    break;

                case "2":
                    tileY |= mask;
                    break;

                case "3":
                    tileX |= mask;
                    tileY |= mask;
                    break;

                default:
                    throw new Error(
                        "Invalid QuadKey digit sequence."
                    );
                }
            }
        }

        return {
            tileXYToQuadKey: TileXYToQuadKey,
            latLongToPixelXY: LatLongToPixelXY
        };
    })();

    /**************************************************************************************************************/

    /**
     * Bing layer configuration
     * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.bing_configuration
     * @property {int} [baseLevel=2]
     * @property {onreadyCallback} [onready] - CallBack function.
     * @property {string} imageSet the image set to use, can be Aerial, Road
     * @property {string} key the bing key to use
     */

    /**
     * Callback when the layer is ready.
     * @callback onreadyCallback
     * @param {BingLayer} Bing layer
     */

    /**
     * @name BingLayer
     * @class
     *     Bing Maps is a web mapping service provided as a part of Microsoft's Bing suite of search engines and powered
     * by the Bing Maps for Enterprise framework.
     * @augments AbstractRasterLayer
     * @param {AbstractRasterLayer.bing_configuration} options -Bing Layer configuration
     * @see {@link https://en.wikipedia.org/wiki/Bing_Maps}
     * @memberof module:Layer
     */
    var BingLayer = function(options) {
        // Call ancestor
        AbstractRasterLayer.prototype.constructor.call(
            this,
            Constants.LAYER.Bing,
            options
        );

        this.tilePixelSize = 256;
        this.tiling = new MercatorTiling(options.baseLevel || 2);
        this.numberOfLevels = 18;
        this.baseUrl = "";
        this.baseUrlSubDomains = [];
        this._ready = false;

        var self = this;

        // Need to provide a global callback for JSONP
        window._bingTileProviderCallback = function(result) {
            self.baseUrl = Proxy.proxify(
                result.resourceSets[0].resources[0].imageUrl
            );
            self.baseUrlSubDomains = Proxy.proxify(
                result.resourceSets[0].resources[0].imageUrlSubdomains
            );
            self._ready = true;

            // Call callback if set
            if (options.onready && options.onready instanceof Function) {
                options.onready(self);
            }

            // Request a frame
            if (self.globe) {
                self.globe.getRenderContext().requestFrame();
            }
        };

        // JSONP Call : needed because of cross-site origin policy
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = Proxy.proxify(
            "http://dev.virtualearth.net/REST/V1/Imagery/Metadata/" +
                options.imageSet +
                "?jsonp=_bingTileProviderCallback&key=" +
                options.key
        );
        script.id = "_bingTileProviderCallback";
        document.getElementsByTagName("head")[0].appendChild(script);
    };

    Utils.inherits(AbstractRasterLayer, BingLayer);

    /**************************************************************************************************************/

    /**
     * Returns an url for the given tile.
     * @function getUrl
     * @memberof BingLayer#
     * @param {Tile} tile Tile
     * @returns {string} Url
     */
    BingLayer.prototype.getUrl = function(tile) {
        var url = this.baseUrl.replace(
            "{quadkey}",
            BingTileSystem.tileXYToQuadKey(tile.x, tile.y, tile.level)
        );
        url = url.replace(
            "{subdomain}",
            this.baseUrlSubDomains[
                Math.floor(Math.random() * this.baseUrlSubDomains.length)
            ]
        );
        return this.allowRequest(url, tile.level);
    };

    /**************************************************************************************************************/

    return BingLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/OSMLayer',[
    "../Utils/Utils",
    "./AbstractRasterLayer",
    "../Utils/Constants",
    "../Tiling/MercatorTiling"
], function(Utils, AbstractRasterLayer, Constants, MercatorTiling) {
    /**************************************************************************************************************/

    /**
     * Open Street Map configuration
     * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.osm_configuration
     * @property {int} [tilePixelSize=256]
     * @property {int} [baseLevel=2]
     * @property {int} [numberOfLevels=21]
     */
    /**
     * @name OSMLayer
     * @class
     *    A layer to display data coming from OpenStreetMap server. OpenStreetMap (OSM) is a collaborative project to
     * create a free editable map of the world
     * @augments AbstractRasterLayer
     * @param {AbstractRasterLayer.osm_configuration} options - OSM Configuration
     * @memberof module:Layer
     */
    var OSMLayer = function(options) {
        options.tilePixelSize = options.tilePixelSize || 256;
        options.tiling = new MercatorTiling(options.baseLevel || 2);
        options.numberOfLevels = options.numberOfLevels || 21;
        AbstractRasterLayer.prototype.constructor.call(
            this,
            Constants.LAYER.OSM,
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRasterLayer, OSMLayer);

    /**************************************************************************************************************/

    /**
     * Returns an url for the given tile.
     * @function getUrl
     * @memberof OSMLayer#
     * @param {Tile} tile Tile
     * @return {string} Url
     */
    OSMLayer.prototype.getUrl = function(tile) {
        var url =
            this.baseUrl +
            "/" +
            tile.level +
            "/" +
            tile.x +
            "/" +
            tile.y +
            ".png";
        return this.allowRequest(url, tile.level);
    };

    /**************************************************************************************************************/

    return OSMLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/TileWireframeLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "../Utils/Constants",
    "../Renderer/Program",
    "../Tiling/Tile"
], function(Utils, AbstractLayer, Constants, Program, Tile) {
    /**
     * TileWireFrameLayer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.tileWireFrame_configuration
     * @property [outline=false]
     */

    /**
     * @name TileWireframeLayer
     * @class
     *    This layer draws an TileWireframe  layer
     * @augments AbstractLayer
     * @param {AbstractLayer.tileWireFrame_configuration} options - TileWireFrame configuration
     * @memberof module:Layer
     * @constructor
     */
    var TileWireframeLayer = function(options) {
        options.zIndex = Constants.DISPLAY.RENDERING;
        AbstractLayer.prototype.constructor.call(
            this,
            Constants.LAYER.TileWireframe,
            options
        );
        this.outline = options && options.outline ? options.outline : false;
        this.globe = null;
        this.program = null;
        this.indexBuffer = null;
        this.subIndexBuffer = [null, null, null, null];
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, TileWireframeLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof TileWireframeLayer#
     */
    TileWireframeLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.VECTOR;
    };

    /**
     * Build the index buffer
     * @function buildIndexBuffer
     * @memberof TileWireframeLayer#
     */
    TileWireframeLayer.prototype.buildIndexBuffer = function() {
        var gl = this.getGlobe().getRenderContext().gl;
        var size = this.getGlobe().getTileManager().tileConfig.tesselation;
        var indices = [];
        var i, j, ii, n, k;
        var step = this.outline ? size - 1 : 1;
        var ib;

        // Build horizontal lines
        for (j = 0; j < size; j += step) {
            for (i = 0; i < size - 1; i++) {
                indices.push(j * size + i);
                indices.push(j * size + i + 1);
            }
        }

        // Build vertical lines
        for (j = 0; j < size; j += step) {
            for (i = 0; i < size - 1; i++) {
                indices.push(i * size + j);
                indices.push((i + 1) * size + j);
            }
        }

        ib = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
        );

        ib.numIndices = indices.length;
        this.indexBuffer = ib;

        var halfTesselation = (size - 1) / 2;
        step = this.outline ? halfTesselation : 1;
        for (ii = 0; ii < 4; ii++) {
            i = ii % 2;
            j = Math.floor(ii / 2);

            // Build the sub grid for 'inside' tile
            indices = [];
            for (
                n = halfTesselation * j;
                n < halfTesselation * (j + 1) + 1;
                n += step
            ) {
                for (
                    k = halfTesselation * i;
                    k < halfTesselation * (i + 1);
                    k++
                ) {
                    indices.push(n * size + k);
                    indices.push(n * size + k + 1);
                }
            }
            for (
                n = halfTesselation * i;
                n < halfTesselation * (i + 1) + 1;
                n += step
            ) {
                for (
                    k = halfTesselation * j;
                    k < halfTesselation * (j + 1);
                    k++
                ) {
                    indices.push(k * size + n);
                    indices.push((k + 1) * size + n);
                }
            }

            ib = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
            gl.bufferData(
                gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(indices),
                gl.STATIC_DRAW
            );
            ib.numIndices = indices.length;
            this.subIndexBuffer[ii] = ib;
        }
    };

    /**************************************************************************************************************/
    /**
     * Attaches the layer to the planet
     * @function _attach
     * @memberof TileWireframeLayer#
     * @param {AbstractGlobe} g globe
     * @private
     */
    TileWireframeLayer.prototype._attach = function(g) {
        AbstractLayer.prototype._attach.call(this, g);

        if (this.isVisible()) {
            this.getGlobe()
                .getTileManager()
                .addPostRenderer(this);
        }

        if (!this.program) {
            var vertexShader = "attribute vec3 vertex;\n";
            vertexShader += "uniform mat4 modelViewMatrix;\n";
            vertexShader += "uniform mat4 projectionMatrix;\n";
            vertexShader += "void main(void) \n";
            vertexShader += "{\n";
            vertexShader +=
                "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
            vertexShader += "}\n";

            var fragmentShader = "precision highp float; \n";
            fragmentShader += "uniform vec3 color; \n";
            fragmentShader += "uniform float alpha; \n";
            fragmentShader += "void main(void)\n";
            fragmentShader += "{\n";
            fragmentShader += "	gl_FragColor = vec4(color,alpha);\n";
            fragmentShader += "}\n";

            this.program = new Program(this.getGlobe().getRenderContext());
            this.program.createFromSource(vertexShader, fragmentShader);

            this.buildIndexBuffer();
        }
    };

    /**************************************************************************************************************/

    /**
     * Detaches the layer from the planet
     * @function _detach
     * @memberof TileWireframeLayer#
     * @private
     */
    TileWireframeLayer.prototype._detach = function() {
        this.getGlobe()
            .getTileManager()
            .removePostRenderer(this);
        AbstractLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    /**
     * Renders the tiles outline
     * @function render
     * @memberof TileWireframeLayer#
     * @param {Array} tiles Array of Tile
     */
    TileWireframeLayer.prototype.render = function(tiles) {
        var rc = this.getGlobe().getRenderContext();
        var gl = rc.gl;

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);

        // Setup program
        this.program.apply();
        gl.uniformMatrix4fv(
            this.program.uniforms.projectionMatrix,
            false,
            rc.projectionMatrix
        );

        var vertexAttribute = this.program.attributes.vertex;
        var currentIB = null;

        for (var i = 0; i < tiles.length; i++) {
            var tile = tiles[i];

            var isLoaded = tile.state === Tile.State.LOADED;
            var isLevelZero = tile.parentIndex === -1;

            // Update uniforms for modelview matrix
            mat4.multiply(rc.viewMatrix, tile.matrix, rc.modelViewMatrix);
            gl.uniformMatrix4fv(
                this.program.uniforms.modelViewMatrix,
                false,
                rc.modelViewMatrix
            );
            var color = this.getStyle().getStrokeColor();
            gl.uniform3f(
                this.program.uniforms.color,
                color[0],
                color[1],
                color[2]
            );
            gl.uniform1f(this.program.uniforms.alpha, this.getOpacity());

            // Bind the vertex buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
            gl.vertexAttribPointer(
                vertexAttribute,
                3,
                gl.FLOAT,
                false,
                4 * tile.config.vertexSize,
                0
            );
            var indexBuffer =
                isLoaded || isLevelZero
                    ? this.indexBuffer
                    : this.subIndexBuffer[tile.parentIndex];
            // Bind the index buffer only if different (index buffer is shared between tiles)
            if (currentIB !== indexBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                currentIB = indexBuffer;
            }

            // Draw the tiles in wireframe mode
            var numIndices = currentIB.numIndices;
            gl.drawElements(gl.LINES, numIndices, gl.UNSIGNED_SHORT, 0);
        }

        gl.disable(gl.BLEND);
        gl.depthFunc(gl.LESS);
    };

    /**************************************************************************************************************/

    /**
     * Get/Set visibility of the layer
     * @function setVisible
     * @memberof TileWireframeLayer#
     * @param {boolean} arg Visiblity
     */
    TileWireframeLayer.prototype.setVisible = function(arg) {
        AbstractLayer.prototype.setVisible.call(this, arg);

        if (typeof arg === "boolean") {
            if (this.isVisible()) {
                this.getGlobe()
                    .getTileManager()
                    .addPostRenderer(this);
            } else {
                this.getGlobe()
                    .getTileManager()
                    .removePostRenderer(this);
            }
        }

        return this.isVisible();
    };

    return TileWireframeLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/Mesh',[],function() {
    /**************************************************************************************************************/

    /** @constructor
     Mesh constructor
     */
    var Mesh = function(renderContext) {
        this.renderContext = renderContext;
        this.vertexBuffer = null;
        this.tcoordBuffer = null;
        this.indexBuffer = null;
        this.colorBuffer = null;
        this.numVertices = 0;
        this.mode = renderContext.gl.TRIANGLES;
    };

    /**************************************************************************************************************/

    /*
     Mesh setVertices method
     */
    Mesh.prototype.setVertices = function(vertices) {
        var gl = this.renderContext.gl;
        if (this.vertexBuffer === null) {
            this.vertexBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(vertices),
            gl.STATIC_DRAW
        );
        this.numVertices = vertices.length;
    };

    /**************************************************************************************************************/

    /*
     Mesh setTexCoords method
     */
    Mesh.prototype.setTexCoords = function(tcoords) {
        var gl = this.renderContext.gl;
        if (this.tcoordBuffer === null) {
            this.tcoordBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(tcoords),
            gl.STATIC_DRAW
        );
    };

    /**************************************************************************************************************/

    /*
     Mesh setColors method
     */
    Mesh.prototype.setColors = function(colors) {
        var gl = this.renderContext.gl;
        if (this.colorBuffer === null) {
            this.colorBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(colors),
            gl.STATIC_DRAW
        );
    };

    /**************************************************************************************************************/

    /*
     Mesh setIndices method
     */
    Mesh.prototype.setIndices = function(indices) {
        var gl = this.renderContext.gl;
        if (this.indexBuffer === null) {
            this.indexBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
        );
        this.numIndices = indices.length;
    };

    /**************************************************************************************************************/

    /*
     Convert to wireframe (for debug purposes)
     */
    Mesh.prototype.setIndicesToWireframe = function(indices) {
        this.mode = this.renderContext.gl.LINES;

        // Convert indices
        var wireframeIndices = [];
        wireframeIndices.length = 2 * indices.length;

        for (var i = 0; i < indices.length; i += 3) {
            wireframeIndices[2 * i] = indices[i];
            wireframeIndices[2 * i + 1] = indices[i + 1];

            wireframeIndices[2 * i + 2] = indices[i + 1];
            wireframeIndices[2 * i + 3] = indices[i + 2];

            wireframeIndices[2 * i + 4] = indices[i + 2];
            wireframeIndices[2 * i + 5] = indices[i];
        }

        this.setIndices(wireframeIndices);
    };

    /**************************************************************************************************************/

    /*
     Mesh render method
     */
    Mesh.prototype.render = function(attributes) {
        var gl = this.renderContext.gl;

        // Warning : use quoted strings to access properties of the attributes, to work correclty in advanced mode with closure compiler
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(attributes.vertex, 3, gl.FLOAT, false, 0, 0);
        if (attributes.hasOwnProperty("tcoord")) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
            gl.vertexAttribPointer(attributes.tcoord, 2, gl.FLOAT, false, 0, 0);
        }
        if (attributes.hasOwnProperty("color")) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
            gl.vertexAttribPointer(attributes.color, 4, gl.FLOAT, false, 0, 0);
        }
        if (this.indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.drawElements(this.mode, this.numIndices, gl.UNSIGNED_SHORT, 0);
        } else {
            gl.drawArrays(this.mode, 0, this.numVertices / 3);
        }
    };

    /**************************************************************************************************************/

    /*
     Mesh dispose method
     */
    Mesh.prototype.dispose = function() {
        var gl = this.renderContext.gl;
        if (this.indexBuffer) {
            gl.deleteBuffer(this.indexBuffer);
        }
        if (this.vertexBuffer) {
            gl.deleteBuffer(this.vertexBuffer);
        }
        if (this.tcoordBuffer) {
            gl.deleteBuffer(this.tcoordBuffer);
        }
        if (this.colorBuffer) {
            gl.deleteBuffer(this.colorBuffer);
        }

        this.indexBuffer = null;
        this.vertexBuffer = null;
        this.tcoordBuffer = null;
        this.colorBuffer = null;
    };

    /**************************************************************************************************************/

    return Mesh;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/CoordinateGridLayer',[
    "./AbstractLayer",
    "../Utils/Utils",
    "../Renderer/Ray",
    "../Renderer/Program",
    "../Tiling/Mesh",
    "../Renderer/FeatureStyle",
    "../Utils/Constants",
    "../Crs/CoordinateSystemFactory",
    "../Gui/dialog/ErrorDialog"
], function(
    AbstractLayer,
    Utils,
    Ray,
    Program,
    Mesh,
    FeatureStyle,
    Constants,
    CoordinateSystemFactory,
    ErrorDialog
) {
    /**
     *    GL Textures pool
     *    @constructor
     */
    var TexturePool = function(pgl) {
        // TODO : changement gl en pgl pour viter doublon
        var gl = pgl;
        var glTextures = [];

        /**
             Create a non power of two texture from an image
             */
        var createNewGLTexture = function(image) {
            var tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                image
            );
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_S,
                gl.CLAMP_TO_EDGE
            );
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_T,
                gl.CLAMP_TO_EDGE
            );
            return tex;
        };

        /**
             Reuse a GL texture
             */
        var reuseGLTexture = function(image) {
            var glTexture = glTextures.pop();
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                image
            );
            return glTexture;
        };

        /**
             Create a GL texture
             */
        this.createGLTexture = function(image) {
            if (glTextures.length > 0) {
                return reuseGLTexture(image);
            } else {
                return createNewGLTexture(image);
            }
        };

        /**
             Dispose a GL texture
             */
        this.disposeGLTexture = function(texture) {
            glTextures.push(texture);
        };

        this.disposeAll = function() {
            for (var i = 0; i < glTextures.length; i++) {
                gl.deleteTexture(glTextures[i]);
            }
            glTextures.length = 0;
        };
    };

    /**************************************************************************************************************/

    /**
     * CoordinateGridLayer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.coordinateGrid_configuration
     * @property {float} [longitudeSample=15] - Longitude sampling in decimal degree
     * @property {float} [latitudeSample=10] - Latitude sampling in decimal degree
     * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - The coordinate system of the grid
     * @property {string} [longFormat="Deg"] Representation of longitude axe(HMS, DMS, Deg)
     * @property {string} [latFormat="Deg"] Representation of latitude axe(HMS, DMS, Deg)
     * @property {Integer} [tesselation=2] Tesselation order (only for latitude bands currently)
     */
    /**
     * @name CoordinateGridLayer
     * @class
     *    A layer for coordinate grid
     * @augments AbstractLayer
     * @param {AbstractLayer.coordinateGrid_configuration} options - coordinate grid layer configuration
     * @constructor
     * @memberof module:Layer
     */
    var CoordinateGridLayer = function(options) {
        AbstractLayer.prototype.constructor.call(
            this,
            Constants.LAYER.CoordinateGrid,
            options
        );
        this.globe = null;

        // Equatorial coordinates label renderables
        this.labels = {};

        // WebGL textures
        this.texturePool = null;

        this.longitudeSample = options.longitudeSample || 15; // *24 = 360
        this.latitudeSample = options.latitudeSample || 10; // *18 = 180

        // Canvas for generation of equatorial coordinate labels
        this.canvas2d = document.createElement("canvas");
        this.canvas2d.width = 100;
        this.canvas2d.height = 20;

        // Grid buffers
        this.vertexBuffer = null;
        this.indexBuffer = null;

        this.gridCrs = CoordinateSystemFactory.create(options.coordinateSystem);

        this.longFormat = options.longFormat ? options.longFormat : "Deg";
        this.latFormat = options.latFormat ? options.latFormat : "Deg";

        // Keep trace on geoBound
        this.geoBound = {};
        this.tesselation = options.tesselation || 2;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, CoordinateGridLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof CoordinateGridLayer#
     */
    CoordinateGridLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.VECTOR;
    };

    /**
     * Generates an image data from text.
     * @function generateImageData
     * @memberof CoordinateGridLayer#
     * @param {string} text Text generated in canvas
     * @return {Object} Context of 2D canvas
     */
    CoordinateGridLayer.prototype.generateImageData = function(text) {
        var ctx = this.canvas2d.getContext("2d");
        ctx.clearRect(0, 0, this.canvas2d.width, this.canvas2d.height);
        ctx.fillStyle = FeatureStyle.fromColorToString(
            this.getStyle().getStrokeColor()
        );
        ctx.font = "18px sans-serif";
        ctx.textBaseline = "top";
        ctx.textAlign = "center";
        var x = this.canvas2d.width / 2;

        ctx.fillText(text, x, 0);

        return ctx.getImageData(
            0,
            0,
            this.canvas2d.width,
            this.canvas2d.height
        );
    };

    /**************************************************************************************************************/

    /**
     * Attaches the layer to the globe.
     * @function _attach
     * @memberof CoordinateGridLayer#
     * @param {Planet} g Planet
     * @private
     */
    CoordinateGridLayer.prototype._attach = function(g) {
        AbstractLayer.prototype._attach.call(this, g);

        if (this.isVisible()) {
            this.getGlobe()
                .getTileManager()
                .addPostRenderer(this);
        }

        if (!this.gridProgram) {
            /*  var vertexShader = "\
                 attribute vec3 vertex;\n\
                 uniform mat4 viewProjectionMatrix;\n\
                 void main(void) \n\
                 {\n\
                 gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n\
                 }\n\
                 ";*/
            var vertexShader = "attribute vec3 vertex;\n";
            vertexShader += "uniform mat4 viewProjectionMatrix;\n";
            vertexShader += "void main(void) \n";
            vertexShader += "{\n";
            vertexShader +=
                "gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
            vertexShader += "}\n";

            /*                var fragmentShader = "\
                 precision highp float; \n\
                 uniform float alpha; \n\
                 uniform vec3 color; \n\
                 void main(void)\n\
                 {\n\
                 gl_FragColor = vec4(color,alpha);\n\
                 }\n\
                 ";*/

            var fragmentShader = "precision highp float; \n";
            fragmentShader += "uniform float alpha; \n";
            fragmentShader += "uniform vec3 color; \n";
            fragmentShader += "void main(void)\n";
            fragmentShader += "{\n";
            fragmentShader += "gl_FragColor = vec4(color,alpha);\n";
            fragmentShader += "}\n";

            /*                var vertexLabelShader = "\
                 attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n\
                 uniform mat4 viewProjectionMatrix; \n\
                 uniform vec3 poiPosition; // world position \n\
                 uniform vec2 poiScale; // x,y scale \n\
                 \n\
                 varying vec2 texCoord; \n\
                 \n\
                 void main(void)  \n\
                 { \n\
                 // Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n\
                 texCoord = vertex.xy + vec2(0.5); \n\
                 // Invert y \n\
                 texCoord.y = 1.0 - texCoord.y; \n\
                 \n\
                 // Compute poi position in clip coordinate \n\
                 gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n\
                 gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n\
                 } \n\
                 ";*/

            var vertexLabelShader =
                "attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n";
            vertexLabelShader += "uniform mat4 viewProjectionMatrix; \n";
            vertexLabelShader +=
                "uniform vec3 poiPosition; // world position \n";
            vertexLabelShader += "uniform vec2 poiScale; // x,y scale \n";
            vertexLabelShader += "\n";
            vertexLabelShader += "varying vec2 texCoord; \n";
            vertexLabelShader += "\n";
            vertexLabelShader += "void main(void)  \n";
            vertexLabelShader += "{ \n";
            vertexLabelShader +=
                "// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n";
            vertexLabelShader += "texCoord = vertex.xy + vec2(0.5); \n";
            vertexLabelShader += "// Invert y \n";
            vertexLabelShader += "texCoord.y = 1.0 - texCoord.y; \n";
            vertexLabelShader += "\n";
            vertexLabelShader +=
                "// Compute poi position in clip coordinate \n";
            vertexLabelShader +=
                "gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n";
            vertexLabelShader +=
                "gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n";
            vertexLabelShader += "} \n";

            /*    var fragmentLabelShader = "\
                 #ifdef GL_ES \n\
                 precision highp float; \n\
                 #endif \n\
                 \n\
                 varying vec2 texCoord; \n\
                 uniform sampler2D texture; \n\
                 uniform float alpha; \n\
                 \n\
                 void main(void) \n\
                 { \n\
                 vec4 textureColor = texture2D(texture, texCoord); \n\
                 gl_FragColor = vec4(textureColor.rgb, textureColor.a * alpha); \n\
                 } \n\
                 ";*/
            var fragmentLabelShader = "#ifdef GL_ES \n";
            fragmentLabelShader += "precision highp float; \n";
            fragmentLabelShader += "#endif \n";
            fragmentLabelShader += "\n";
            fragmentLabelShader += "varying vec2 texCoord; \n";
            fragmentLabelShader += "uniform sampler2D texture; \n";
            fragmentLabelShader += "uniform float alpha; \n";
            fragmentLabelShader += "\n";
            fragmentLabelShader += "void main(void) \n";
            fragmentLabelShader += "{ \n";
            fragmentLabelShader +=
                "	vec4 textureColor = texture2D(texture, texCoord); \n";
            fragmentLabelShader +=
                "	gl_FragColor = vec4(textureColor.rgb, textureColor.a * alpha); \n";
            fragmentLabelShader += "} \n";

            this.gridProgram = new Program(this.getGlobe().getRenderContext());
            this.labelProgram = new Program(this.getGlobe().getRenderContext());
            this.gridProgram.createFromSource(vertexShader, fragmentShader);
            this.labelProgram.createFromSource(
                vertexLabelShader,
                fragmentLabelShader
            );
        }

        // Texture used to show the equatorial coordinates
        this.labelMesh = new Mesh(this.getGlobe().getRenderContext());
        var vertices = [
            -0.5,
            -0.5,
            0.0,
            -0.5,
            0.5,
            0.0,
            0.5,
            0.5,
            0.0,
            0.5,
            -0.5,
            0.0
        ];
        var indices = [0, 3, 1, 1, 3, 2];
        this.labelMesh.setVertices(vertices);
        this.labelMesh.setIndices(indices);

        // Init grid buffers
        var gl = this.getGlobe().getRenderContext().gl;
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();

        // Init texture pool
        if (!this.texturePool) {
            this.texturePool = new TexturePool(gl);
        }
    };

    /**************************************************************************************************************/

    /**
     * Detaches the layer from the globe.
     * @function _detach
     * @memberof CoordinateGridLayer#
     * @private
     */
    CoordinateGridLayer.prototype._detach = function() {
        var gl = this.getGlobe().getRenderContext().gl;
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.indexBuffer);

        this.texturePool.disposeAll();
        for (var i in this.labels) {
            if (this.labels.hasOwnProperty(i)) {
                delete this.labels[i];
            }
        }

        this.getGlobe()
            .getTileManager()
            .removePostRenderer(this);
        AbstractLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    /**
     * Clamps the geoBound to longitude/latitude samples.
     * @function clampGeoBound
     * @memberof CoordinateGridLayer#
     * @param {GeoBound} geoBound Bbox
     * @return {GeoBound} Bbox clamped
     */
    CoordinateGridLayer.prototype.clampGeoBound = function(geoBound) {
        geoBound.west =
            Math.floor(geoBound.west / this.longitudeSample) *
            this.longitudeSample;
        geoBound.east =
            Math.ceil(geoBound.east / this.longitudeSample) *
            this.longitudeSample;
        geoBound.north =
            Math.ceil(geoBound.north / this.latitudeSample) *
            this.latitudeSample;
        geoBound.south =
            Math.floor(geoBound.south / this.latitudeSample) *
            this.latitudeSample;
        return geoBound;
    };

    /**
     * Renders the grid.
     * @function render
     * @memberof CoordinateGridLayer#
     * @param {Array} tiles Tiles
     */
    CoordinateGridLayer.prototype.render = function(tiles) {
        var renderContext = this.getGlobe().getRenderContext();
        var gl = renderContext.gl;

        gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Compute current geoBound
        //TODO a modifier
        var geoBound;
        // Transform geoBound computed in default coordinate system to coordinate system of current grid if different
        var self = this;
        geoBound = this.getGlobe().getViewportGeoBound(function(coordinate) {
            //return coordinate;
            return self.globe
                .getCoordinateSystem()
                .convert(
                    coordinate,
                    Constants.CRS.Equatorial,
                    self.gridCrs.getGeoideName()
                );
        });

        // Clamp geoBound angles to longitude/latitude samples
        geoBound = this.clampGeoBound(geoBound);

        // Regenerate grid & labels only if geoBound has changed
        if (
            this.geoBound.west !== geoBound.west ||
            this.geoBound.east !== geoBound.east ||
            this.geoBound.north !== geoBound.north ||
            this.geoBound.south !== geoBound.south
        ) {
            this.geoBound = geoBound;
            this.computeSamples();
            this.generateGridBuffers();
            this.generateLabels();
        } else {
            this.updateLabels();
        }

        /*** Render grid ***/
        this.gridProgram.apply();
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            renderContext.modelViewMatrix
        );
        gl.uniformMatrix4fv(
            this.gridProgram.uniforms.viewProjectionMatrix,
            false,
            renderContext.modelViewMatrix
        );
        gl.uniform1f(this.gridProgram.uniforms.alpha, this.getOpacity());
        var color = this.getStyle().getStrokeColor();
        gl.uniform3f(
            this.gridProgram.uniforms.color,
            color[0],
            color[1],
            color[2]
        );

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(
            this.gridProgram.attributes.vertex,
            this.vertexBuffer.itemSize,
            gl.FLOAT,
            false,
            0,
            0
        );

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.drawElements(
            gl.LINES,
            this.indexBuffer.numItems,
            gl.UNSIGNED_SHORT,
            0
        );

        /*** Render labels ***/
        this.labelProgram.apply();

        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            renderContext.modelViewMatrix
        );
        gl.uniformMatrix4fv(
            this.labelProgram.uniforms.viewProjectionMatrix,
            false,
            renderContext.modelViewMatrix
        );
        gl.uniform1i(this.labelProgram.uniforms.texture, 0);

        var pixelSizeVector = renderContext.computePixelSizeVector();
        for (var n in this.labels) {
            if (this.labels.hasOwnProperty(n)) {
                var label = this.labels[n];
                // Bind point texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, label.texture);

                // 2.0 * because normalized device coordinates goes from -1 to 1
                var scale = [
                    (2.0 * label.textureWidth) / renderContext.canvas.width,
                    (2.0 * label.textureHeight) / renderContext.canvas.height
                ];

                gl.uniform2fv(this.labelProgram.uniforms.poiScale, scale);
                // gl.uniform2fv(this.labelProgram.uniforms["tst"], [ 0.5 / (label.textureWidth), 0.5 / (label.textureHeight)  ]);

                // Poi culling
                var worldPoi = label.pos3d;
                var poiVec = label.vertical;
                scale =
                    label.textureHeight *
                    (pixelSizeVector[0] * worldPoi[0] +
                        pixelSizeVector[1] * worldPoi[1] +
                        pixelSizeVector[2] * worldPoi[2] +
                        pixelSizeVector[3]);

                var x = poiVec[0] * scale + worldPoi[0];
                var y = poiVec[1] * scale + worldPoi[1];
                var z = poiVec[2] * scale + worldPoi[2];

                gl.uniform3f(this.labelProgram.uniforms.poiPosition, x, y, z);
                gl.uniform1f(this.labelProgram.uniforms.alpha, 1.0);

                this.labelMesh.render(this.labelProgram.attributes);
                label.needed = false;
            }
        }
        gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    /**
     * Get/Set visibility of the layer.
     * @function setVisible
     * @memberof CoordinateGridLayer#
     * @param {boolean} arg Visibility or not
     */
    CoordinateGridLayer.prototype.setVisible = function(arg) {
        AbstractLayer.prototype.setVisible.call(this, arg);
        if (typeof arg === "boolean") {
            if (this.isVisible()) {
                this.getGlobe()
                    .getTileManager()
                    .addPostRenderer(this);
            } else {
                this.getGlobe()
                    .getTileManager()
                    .removePostRenderer(this);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Computes samples depending on geoBound.
     * @function computeSamples
     * @memberof CoordinateGridLayer#
     */
    CoordinateGridLayer.prototype.computeSamples = function() {
        var dlong = this.geoBound.east - this.geoBound.west;
        var dlat = this.geoBound.north - this.geoBound.south;

        // if under-sampled and not divergent
        while (
            dlong / this.longitudeSample < 3.0 &&
            this.longitudeSample > 1.0
        ) {
            this.longitudeSample /= 2;
            this.latitudeSample /= 2;
        }

        // if over-sampled and not exceed the initial value
        while (
            dlong / this.longitudeSample > 7.0 &&
            this.longitudeSample < 15.0
        ) {
            this.longitudeSample *= 2;
            this.latitudeSample *= 2;
        }
    };

    /**************************************************************************************************************/

    /**
     * Generates buffers object of the grid.
     * @function generateGridBuffers
     * @memberof CoordinateGridLayer#
     */
    CoordinateGridLayer.prototype.generateGridBuffers = function() {
        var phiStart, phiStop;
        var latNumber, phi, i;
        // Difference is larger than hemisphere
        if (this.geoBound.east - this.geoBound.west > 180.0) {
            // pole in the viewport
            phiStart = 0;
            phiStop = 360;
        } else {
            phiStart = this.geoBound.west;
            phiStop = this.geoBound.east;
        }

        // TODO adaptative generation of theta value
        // for (var theta = geoBound.south; theta <= geoBound.north; theta+=latStep) {

        var vertexPositionData = [];
        var latitudeBands = 180.0 / this.latitudeSample;

        for (latNumber = 0; latNumber <= latitudeBands; latNumber++) {
            var theta = (latNumber * Math.PI) / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (phi = phiStart; phi <= phiStop; phi += this.longitudeSample) {
                // Tesselation
                var step = this.longitudeSample / this.tesselation;
                for (i = 0; i < this.tesselation; i++) {
                    var radPhi = ((phi + i * step) * Math.PI) / 180;

                    var sinPhi = Math.sin(radPhi);
                    var cosPhi = Math.cos(radPhi);

                    // z is the up vector
                    var x =
                        cosPhi *
                        sinTheta *
                        this.getGlobe()
                            .getCoordinateSystem()
                            .getGeoide()
                            .getRadius();
                    var y =
                        sinPhi *
                        sinTheta *
                        this.getGlobe()
                            .getCoordinateSystem()
                            .getGeoide()
                            .getRadius();
                    var z =
                        cosTheta *
                        this.getGlobe()
                            .getCoordinateSystem()
                            .getGeoide()
                            .getRadius();

                    //TODO a modifier
                    if (
                        this.gridCrs.getGeoideName() !==
                        Constants.CRS.Equatorial
                    ) {
                        var geo = this.getGlobe()
                            .getCoordinateSystem()
                            .from3DToGeo([x, y, z]);
                        geo = this.getGlobe()
                            .getCoordinateSystem()
                            .convert(
                                geo,
                                this.gridCrs.getGeoideName(),
                                Constants.CRS.Equatorial
                            );
                        var eq = this.getGlobe()
                            .getCoordinateSystem()
                            .fromGeoTo3D(geo);
                        vertexPositionData.push(eq[0], eq[1], eq[2]);
                    } else {
                        vertexPositionData.push(x, y, z);
                    }
                }
            }
        }

        var gl = this.getGlobe().getRenderContext().gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(vertexPositionData),
            gl.STATIC_DRAW
        );
        this.vertexBuffer.itemSize = 3;
        this.vertexBuffer.numItems = vertexPositionData.length / 3;

        var indexData = [];
        var longitudeBands = (phiStop - phiStart) / this.longitudeSample + 1;
        var longNumber;

        // Tesselation
        longitudeBands *= this.tesselation;

        for (latNumber = 0; latNumber < latitudeBands; latNumber++) {
            for (
                phi = phiStart, longNumber = 0;
                phi < phiStop;
                phi += this.longitudeSample, longNumber += this.tesselation
            ) {
                var first =
                    latNumber * longitudeBands +
                    (longNumber % (longitudeBands - 1));
                var second = first + longitudeBands;

                // Horizontal lines
                for (i = 0; i < this.tesselation; i++) {
                    indexData.push(first + i);
                    indexData.push(first + i + 1);
                }

                // Vertical lines
                indexData.push(first + this.tesselation);
                indexData.push(second + this.tesselation);

                indexData.push(second);
                indexData.push(first);
            }
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indexData),
            gl.STATIC_DRAW
        );
        this.indexBuffer.itemSize = 1;
        this.indexBuffer.numItems = indexData.length;
    };

    /**************************************************************************************************************/

    /**
     * Builds the angle representation.
     * @function buildAngle
     * @memberof CoordinateGridLayer#
     * @param {string} format The building format("HMS", "DMS" or "Deg")
     * @param {float} angle The angle to build
     * @return {string} Label
     */
    CoordinateGridLayer.prototype.buildAngle = function(format, angle) {
        var label;
        switch (format) {
        case "Deg":
            label = angle + "";
            break;
        case "HMS":
            label = this.getGlobe()
                .getCoordinateSystem()
                .fromDegreesToHMS(angle);
            break;
        case "DMS":
            label = this.getGlobe()
                .getCoordinateSystem()
                .fromDegreesToDMS(angle);
            break;
        default:
            ErrorDialog.open(Constants.LEVEL.ERROR, "Format not supported");
            return null;
        }
        return label;
    };

    /**************************************************************************************************************/

    /**
     * Computes the geographic center of canvas in grid's coordinate system
     * @function computeGeoCenter
     * @memberof CoordinateGridLayer#
     * @return {Array} Geocenter as array of float
     */
    CoordinateGridLayer.prototype.computeGeoCenter = function() {
        var ray = Ray.createFromPixel(
            this.getGlobe().getRenderContext(),
            this.getGlobe().getRenderContext().canvas.width / 2.0,
            this.getGlobe().getRenderContext().canvas.height / 2.0
        );
        var center3d = ray.computePoint(
            ray.sphereIntersect(
                [0, 0, 0],
                this.getGlobe()
                    .getCoordinateSystem()
                    .getGeoide()
                    .getRadius()
            )
        );
        var geoCenter = [];
        this.getGlobe()
            .getCoordinateSystem()
            .from3DToGeo(center3d, geoCenter);

        // Convert geoCenter into grid's coordinate system
        geoCenter = this.getGlobe()
            .getCoordinateSystem()
            .convert(
                geoCenter,
                Constants.CRS.Equatorial,
                this.gridCrs.getGeoideName()
            );

        return geoCenter;
    };

    /**************************************************************************************************************/

    /**
     * Updates 3D position of a given label.
     * @function updateLabel
     * @memberof CoordinateGridLayer#
     * @param {string} label The label id in labels object
     * @param {float[]} posGeo Updated geographic position of label
     */
    CoordinateGridLayer.prototype.updateLabel = function(label, posGeo) {
        posGeo = this.getGlobe()
            .getCoordinateSystem()
            .convert(
                posGeo,
                this.gridCrs.getGeoideName(),
                Constants.CRS.Equatorial
            );
        var pos3d = this.getGlobe()
            .getCoordinateSystem()
            .fromGeoTo3D(posGeo);
        var vertical = vec3.create();
        vec3.normalize(pos3d, vertical);

        this.labels[label].pos3d = pos3d;
        this.labels[label].vertical = vertical;
        this.labels[label].needed = true;
    };

    /**************************************************************************************************************/

    /**
     * Updates the position of all labels.
     * @function updateLabels
     * @memberof CoordinateGridLayer.prototype
     */
    CoordinateGridLayer.prototype.updateLabels = function() {
        var geoCenter = this.computeGeoCenter();
        for (var x in this.labels) {
            if (this.labels.hasOwnProperty(x)) {
                // Compute position of label
                var posGeo;
                if (this.labels[x].type === "lat") {
                    posGeo = [this.labels[x].angle, geoCenter[1]];
                } else if (this.labels[x].type === "long") {
                    posGeo = [geoCenter[0], this.labels[x].angle];
                }
                this.updateLabel(x, posGeo);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Generates labels of the grid.
     * @function generateLabels
     * @memberof CoordinateGridLayer#
     */
    CoordinateGridLayer.prototype.generateLabels = function() {
        var phiStop, phiStart;
        var imageData, phi, x, posGeo, angle, theta;

        // Difference is larger than hemisphere
        if (this.geoBound.east - this.geoBound.west > 180.0) {
            // pole in the viewport => generate all longitude bands
            phiStart = 0;
            phiStop = 360;
        } else {
            phiStart = this.geoBound.west;
            phiStop = this.geoBound.east;
        }

        var geoCenter = this.computeGeoCenter();
        var label;
        for (phi = phiStart; phi < phiStop; phi += this.longitudeSample) {
            // convert to positive [0..360[
            angle = phi < 0 ? phi + 360 : phi;

            label = this.buildAngle(this.longFormat, angle);

            if (!this.labels["lat_" + label]) {
                this.labels["lat_" + label] = {
                    angle: phi,
                    type: "lat"
                };
                imageData = this.generateImageData(label);
                this._buildTextureFromImage(
                    this.labels["lat_" + label],
                    imageData
                );
            }

            // Compute position of label
            posGeo = [phi, geoCenter[1]];
            this.updateLabel("lat_" + label, posGeo);
        }

        // TODO <!> Adaptative rendering isn't totally implemented for theta due to difficulty to compute extrem latitude using geoBound <!>
        var thetaStart = Math.min(this.geoBound.north, this.geoBound.south);
        var thetaStop = Math.max(this.geoBound.north, this.geoBound.south);

        for (
            theta = thetaStart;
            theta <= thetaStop;
            theta += this.latitudeSample
        ) {
            // 	for (var theta = -90; theta < 90; theta+=this.latitudeSample) {

            label = this.buildAngle(this.latFormat, theta);

            if (!this.labels["long_" + label]) {
                this.labels["long_" + label] = {
                    angle: theta,
                    type: "long"
                };
                imageData = this.generateImageData(label);
                this._buildTextureFromImage(
                    this.labels["long_" + label],
                    imageData
                );
            }

            // Compute position of label
            posGeo = [geoCenter[0], theta];
            this.updateLabel("long_" + label, posGeo);
        }

        // Dispose texture if not needed
        for (x in this.labels) {
            if (!this.labels[x].needed) {
                this.texturePool.disposeGLTexture(this.labels[x].texture);
                delete this.labels[x];
            }
        }
    };

    /**************************************************************************************************************/

    /*
         * Builds a texture from an image and store in a renderable
         * @function _buildTextureFromImage
         * @memberof CoordinateGridLayer#
         * @param {boolean} renderable Is renderable ?
         * @param {Object} image Image object
         */
    CoordinateGridLayer.prototype._buildTextureFromImage = function(
        renderable,
        image
    ) {
        renderable.texture = this.texturePool.createGLTexture(image);
        renderable.textureWidth = image.width;
        renderable.textureHeight = image.height;
    };

    /**************************************************************************************************************/

    return CoordinateGridLayer;
});

void function(global, callback) {
	if (typeof module === 'object') {
		module.exports = callback();
	} else if (typeof define === 'function') {
		define('crc32',callback);
	} else {
		global.crc32 = callback();
	}
}(this, function() {
	'use strict';

	var table = [],
		poly = 0xEDB88320; // reverse polynomial

	// build the table
	function makeTable() {
		var c, n, k;

		for (n = 0; n < 256; n += 1) {
			c = n;
			for (k = 0; k < 8; k += 1) {
				if (c & 1) {
					c = poly ^ (c >>> 1);
				} else {
					c = c >>> 1;
				}
			}
			table[n] = c >>> 0;
		}
	}

	function strToArr(str) {
		// sweet hack to turn string into a 'byte' array
		return Array.prototype.map.call(str, function (c) {
			return c.charCodeAt(0);
		});
	}

	/*
	 * Compute CRC of array directly.
	 *
	 * This is slower for repeated calls, so append mode is not supported.
	 */
	function crcDirect(arr) {
		var crc = -1, // initial contents of LFBSR
			i, j, l, temp;

		for (i = 0, l = arr.length; i < l; i += 1) {
			temp = (crc ^ arr[i]) & 0xff;

			// read 8 bits one at a time
			for (j = 0; j < 8; j += 1) {
				if ((temp & 1) === 1) {
					temp = (temp >>> 1) ^ poly;
				} else {
					temp = (temp >>> 1);
				}
			}
			crc = (crc >>> 8) ^ temp;
		}

		// flip bits
		return crc ^ -1;
	}

	/*
	 * Compute CRC with the help of a pre-calculated table.
	 *
	 * This supports append mode, if the second parameter is set.
	 */
	function crcTable(arr, append) {
		var crc, i, l;

		// if we're in append mode, don't reset crc
		// if arr is null or undefined, reset table and return
		if (typeof crcTable.crc === 'undefined' || !append || !arr) {
			crcTable.crc = 0 ^ -1;

			if (!arr) {
				return;
			}
		}

		// store in temp variable for minor speed gain
		crc = crcTable.crc;

		for (i = 0, l = arr.length; i < l; i += 1) {
			crc = (crc >>> 8) ^ table[(crc ^ arr[i]) & 0xff];
		}

		crcTable.crc = crc;

		return crc ^ -1;
	}

	// build the table
	// this isn't that costly, and most uses will be for table assisted mode
	makeTable();

	var exports = function (val, direct) {
		var val = (typeof val === 'string') ? strToArr(val) : val,
			ret = direct ? crcDirect(val) : crcTable(val);

		// convert to 2's complement hex
		return (ret >>> 0).toString(16);
	};
	exports.direct = crcDirect;
	exports.table = crcTable;

	return exports;
});
/*
 * $Id: rawinflate.js,v 0.2 2009/03/01 18:32:24 dankogai Exp $
 *
 * original:
 * http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt
 */

/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0.0.1
 * LastModified: Dec 25 1999
 */

/* Interface:
 * data = inflate(src);
 */

define('inflate-js',[],function(){

	/* constant parameters */
	var WSIZE = 32768, // Sliding Window size
		STORED_BLOCK = 0,
		STATIC_TREES = 1,
		DYN_TREES = 2,

	/* for inflate */
		lbits = 9, // bits in base literal/length lookup table
		dbits = 6, // bits in base distance lookup table

	/* variables (inflate) */
		slide,
		wp, // current position in slide
		fixed_tl = null, // inflate static
		fixed_td, // inflate static
		fixed_bl, // inflate static
		fixed_bd, // inflate static
		bit_buf, // bit buffer
		bit_len, // bits in bit buffer
		method,
		eof,
		copy_leng,
		copy_dist,
		tl, // literal length decoder table
		td, // literal distance decoder table
		bl, // number of bits decoded by tl
		bd, // number of bits decoded by td

		inflate_data,
		inflate_pos,


/* constant tables (inflate) */
		MASK_BITS = [
			0x0000,
			0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
			0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
		],
		// Tables for deflate from PKZIP's appnote.txt.
		// Copy lengths for literal codes 257..285
		cplens = [
			3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
			35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
		],
/* note: see note #13 above about the 258 in this list. */
		// Extra bits for literal codes 257..285
		cplext = [
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
			3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 // 99==invalid
		],
		// Copy offsets for distance codes 0..29
		cpdist = [
			1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
			257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
			8193, 12289, 16385, 24577
		],
		// Extra bits for distance codes
		cpdext = [
			0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
			7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
			12, 12, 13, 13
		],
		// Order of the bit length code lengths
		border = [
			16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
		];
	/* objects (inflate) */

	function HuftList() {
		this.next = null;
		this.list = null;
	}

	function HuftNode() {
		this.e = 0; // number of extra bits or operation
		this.b = 0; // number of bits in this code or subcode

		// union
		this.n = 0; // literal, length base, or distance base
		this.t = null; // (HuftNode) pointer to next level of table
	}

	/*
	 * @param b-  code lengths in bits (all assumed <= BMAX)
	 * @param n- number of codes (assumed <= N_MAX)
	 * @param s- number of simple-valued codes (0..s-1)
	 * @param d- list of base values for non-simple codes
	 * @param e- list of extra bits for non-simple codes
	 * @param mm- maximum lookup bits
	 */
	function HuftBuild(b, n, s, d, e, mm) {
		this.BMAX = 16; // maximum bit length of any code
		this.N_MAX = 288; // maximum number of codes in any set
		this.status = 0; // 0: success, 1: incomplete table, 2: bad input
		this.root = null; // (HuftList) starting table
		this.m = 0; // maximum lookup bits, returns actual

	/* Given a list of code lengths and a maximum table size, make a set of
	   tables to decode that set of codes. Return zero on success, one if
	   the given code set is incomplete (the tables are still built in this
	   case), two if the input is invalid (all zero length codes or an
	   oversubscribed set of lengths), and three if not enough memory.
	   The code with value 256 is special, and the tables are constructed
	   so that no bits beyond that code are fetched when that code is
	   decoded. */
		var a; // counter for codes of length k
		var c = [];
		var el; // length of EOB code (value 256)
		var f; // i repeats in table every f entries
		var g; // maximum code length
		var h; // table level
		var i; // counter, current code
		var j; // counter
		var k; // number of bits in current code
		var lx = [];
		var p; // pointer into c[], b[], or v[]
		var pidx; // index of p
		var q; // (HuftNode) points to current table
		var r = new HuftNode(); // table entry for structure assignment
		var u = [];
		var v = [];
		var w;
		var x = [];
		var xp; // pointer into x or c
		var y; // number of dummy codes added
		var z; // number of entries in current table
		var o;
		var tail; // (HuftList)

		tail = this.root = null;

		// bit length count table
		for (i = 0; i < this.BMAX + 1; i++) {
			c[i] = 0;
		}
		// stack of bits per table
		for (i = 0; i < this.BMAX + 1; i++) {
			lx[i] = 0;
		}
		// HuftNode[BMAX][]  table stack
		for (i = 0; i < this.BMAX; i++) {
			u[i] = null;
		}
		// values in order of bit length
		for (i = 0; i < this.N_MAX; i++) {
			v[i] = 0;
		}
		// bit offsets, then code stack
		for (i = 0; i < this.BMAX + 1; i++) {
			x[i] = 0;
		}

		// Generate counts for each bit length
		el = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any
		p = b; pidx = 0;
		i = n;
		do {
			c[p[pidx]]++; // assume all entries <= BMAX
			pidx++;
		} while (--i > 0);
		if (c[0] === n) { // null input--all zero length codes
			this.root = null;
			this.m = 0;
			this.status = 0;
			return;
		}

		// Find minimum and maximum length, bound *m by those
		for (j = 1; j <= this.BMAX; j++) {
			if (c[j] !== 0) {
				break;
			}
		}
		k = j; // minimum code length
		if (mm < j) {
			mm = j;
		}
		for (i = this.BMAX; i !== 0; i--) {
			if (c[i] !== 0) {
				break;
			}
		}
		g = i; // maximum code length
		if (mm > i) {
			mm = i;
		}

		// Adjust last length count to fill out codes, if needed
		for (y = 1 << j; j < i; j++, y <<= 1) {
			if ((y -= c[j]) < 0) {
				this.status = 2; // bad input: more codes than bits
				this.m = mm;
				return;
			}
		}
		if ((y -= c[i]) < 0) {
			this.status = 2;
			this.m = mm;
			return;
		}
		c[i] += y;

		// Generate starting offsets into the value table for each length
		x[1] = j = 0;
		p = c;
		pidx = 1;
		xp = 2;
		while (--i > 0) { // note that i == g from above
			x[xp++] = (j += p[pidx++]);
		}

		// Make a table of values in order of bit lengths
		p = b; pidx = 0;
		i = 0;
		do {
			if ((j = p[pidx++]) !== 0) {
				v[x[j]++] = i;
			}
		} while (++i < n);
		n = x[g]; // set n to length of v

		// Generate the Huffman codes and for each, make the table entries
		x[0] = i = 0; // first Huffman code is zero
		p = v; pidx = 0; // grab values in bit order
		h = -1; // no tables yet--level -1
		w = lx[0] = 0; // no bits decoded yet
		q = null; // ditto
		z = 0; // ditto

		// go through the bit lengths (k already is bits in shortest code)
		for (null; k <= g; k++) {
			a = c[k];
			while (a-- > 0) {
				// here i is the Huffman code of length k bits for value p[pidx]
				// make tables up to required level
				while (k > w + lx[1 + h]) {
					w += lx[1 + h]; // add bits already decoded
					h++;

					// compute minimum size table less than or equal to *m bits
					z = (z = g - w) > mm ? mm : z; // upper limit
					if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table
						// too few codes for k-w bit table
						f -= a + 1; // deduct codes from patterns left
						xp = k;
						while (++j < z) { // try smaller tables up to z bits
							if ((f <<= 1) <= c[++xp]) {
								break; // enough codes to use up j bits
							}
							f -= c[xp]; // else deduct codes from patterns
						}
					}
					if (w + j > el && w < el) {
						j = el - w; // make EOB code end at table
					}
					z = 1 << j; // table entries for j-bit table
					lx[1 + h] = j; // set table size in stack

					// allocate and link in new table
					q = [];
					for (o = 0; o < z; o++) {
						q[o] = new HuftNode();
					}

					if (!tail) {
						tail = this.root = new HuftList();
					} else {
						tail = tail.next = new HuftList();
					}
					tail.next = null;
					tail.list = q;
					u[h] = q; // table starts after link

					/* connect to last table, if there is one */
					if (h > 0) {
						x[h] = i; // save pattern for backing up
						r.b = lx[h]; // bits to dump before this table
						r.e = 16 + j; // bits in this table
						r.t = q; // pointer to this table
						j = (i & ((1 << w) - 1)) >> (w - lx[h]);
						u[h - 1][j].e = r.e;
						u[h - 1][j].b = r.b;
						u[h - 1][j].n = r.n;
						u[h - 1][j].t = r.t;
					}
				}

				// set up table entry in r
				r.b = k - w;
				if (pidx >= n) {
					r.e = 99; // out of values--invalid code
				} else if (p[pidx] < s) {
					r.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code
					r.n = p[pidx++]; // simple code is just the value
				} else {
					r.e = e[p[pidx] - s]; // non-simple--look up in lists
					r.n = d[p[pidx++] - s];
				}

				// fill code-like entries with r //
				f = 1 << (k - w);
				for (j = i >> w; j < z; j += f) {
					q[j].e = r.e;
					q[j].b = r.b;
					q[j].n = r.n;
					q[j].t = r.t;
				}

				// backwards increment the k-bit code i
				for (j = 1 << (k - 1); (i & j) !== 0; j >>= 1) {
					i ^= j;
				}
				i ^= j;

				// backup over finished tables
				while ((i & ((1 << w) - 1)) !== x[h]) {
					w -= lx[h]; // don't need to update q
					h--;
				}
			}
		}

		/* return actual size of base table */
		this.m = lx[1];

		/* Return true (1) if we were given an incomplete table */
		this.status = ((y !== 0 && g !== 1) ? 1 : 0);
	}


	/* routines (inflate) */

	function GET_BYTE() {
		if (inflate_data.length === inflate_pos) {
			return -1;
		}
		return inflate_data[inflate_pos++] & 0xff;
	}

	function NEEDBITS(n) {
		while (bit_len < n) {
			bit_buf |= GET_BYTE() << bit_len;
			bit_len += 8;
		}
	}

	function GETBITS(n) {
		return bit_buf & MASK_BITS[n];
	}

	function DUMPBITS(n) {
		bit_buf >>= n;
		bit_len -= n;
	}

	function inflate_codes(buff, off, size) {
		// inflate (decompress) the codes in a deflated (compressed) block.
		// Return an error code or zero if it all goes ok.
		var e; // table entry flag/number of extra bits
		var t; // (HuftNode) pointer to table entry
		var n;

		if (size === 0) {
			return 0;
		}

		// inflate the coded data
		n = 0;
		for (;;) { // do until end of block
			NEEDBITS(bl);
			t = tl.list[GETBITS(bl)];
			e = t.e;
			while (e > 16) {
				if (e === 99) {
					return -1;
				}
				DUMPBITS(t.b);
				e -= 16;
				NEEDBITS(e);
				t = t.t[GETBITS(e)];
				e = t.e;
			}
			DUMPBITS(t.b);

			if (e === 16) { // then it's a literal
				wp &= WSIZE - 1;
				buff[off + n++] = slide[wp++] = t.n;
				if (n === size) {
					return size;
				}
				continue;
			}

			// exit if end of block
			if (e === 15) {
				break;
			}

			// it's an EOB or a length

			// get length of block to copy
			NEEDBITS(e);
			copy_leng = t.n + GETBITS(e);
			DUMPBITS(e);

			// decode distance of block to copy
			NEEDBITS(bd);
			t = td.list[GETBITS(bd)];
			e = t.e;

			while (e > 16) {
				if (e === 99) {
					return -1;
				}
				DUMPBITS(t.b);
				e -= 16;
				NEEDBITS(e);
				t = t.t[GETBITS(e)];
				e = t.e;
			}
			DUMPBITS(t.b);
			NEEDBITS(e);
			copy_dist = wp - t.n - GETBITS(e);
			DUMPBITS(e);

			// do the copy
			while (copy_leng > 0 && n < size) {
				copy_leng--;
				copy_dist &= WSIZE - 1;
				wp &= WSIZE - 1;
				buff[off + n++] = slide[wp++] = slide[copy_dist++];
			}

			if (n === size) {
				return size;
			}
		}

		method = -1; // done
		return n;
	}

	function inflate_stored(buff, off, size) {
		/* "decompress" an inflated type 0 (stored) block. */
		var n;

		// go to byte boundary
		n = bit_len & 7;
		DUMPBITS(n);

		// get the length and its complement
		NEEDBITS(16);
		n = GETBITS(16);
		DUMPBITS(16);
		NEEDBITS(16);
		if (n !== ((~bit_buf) & 0xffff)) {
			return -1; // error in compressed data
		}
		DUMPBITS(16);

		// read and output the compressed data
		copy_leng = n;

		n = 0;
		while (copy_leng > 0 && n < size) {
			copy_leng--;
			wp &= WSIZE - 1;
			NEEDBITS(8);
			buff[off + n++] = slide[wp++] = GETBITS(8);
			DUMPBITS(8);
		}

		if (copy_leng === 0) {
			method = -1; // done
		}
		return n;
	}

	function inflate_fixed(buff, off, size) {
		// decompress an inflated type 1 (fixed Huffman codes) block.  We should
		// either replace this with a custom decoder, or at least precompute the
		// Huffman tables.

		// if first time, set up tables for fixed blocks
		if (!fixed_tl) {
			var i; // temporary variable
			var l = []; // 288 length list for huft_build (initialized below)
			var h; // HuftBuild

			// literal table
			for (i = 0; i < 144; i++) {
				l[i] = 8;
			}
			for (null; i < 256; i++) {
				l[i] = 9;
			}
			for (null; i < 280; i++) {
				l[i] = 7;
			}
			for (null; i < 288; i++) { // make a complete, but wrong code set
				l[i] = 8;
			}
			fixed_bl = 7;

			h = new HuftBuild(l, 288, 257, cplens, cplext, fixed_bl);
			if (h.status !== 0) {
				console.error("HufBuild error: " + h.status);
				return -1;
			}
			fixed_tl = h.root;
			fixed_bl = h.m;

			// distance table
			for (i = 0; i < 30; i++) { // make an incomplete code set
				l[i] = 5;
			}
			fixed_bd = 5;

			h = new HuftBuild(l, 30, 0, cpdist, cpdext, fixed_bd);
			if (h.status > 1) {
				fixed_tl = null;
				console.error("HufBuild error: " + h.status);
				return -1;
			}
			fixed_td = h.root;
			fixed_bd = h.m;
		}

		tl = fixed_tl;
		td = fixed_td;
		bl = fixed_bl;
		bd = fixed_bd;
		return inflate_codes(buff, off, size);
	}

	function inflate_dynamic(buff, off, size) {
		// decompress an inflated type 2 (dynamic Huffman codes) block.
		var i; // temporary variables
		var j;
		var l; // last length
		var n; // number of lengths to get
		var t; // (HuftNode) literal/length code table
		var nb; // number of bit length codes
		var nl; // number of literal/length codes
		var nd; // number of distance codes
		var ll = [];
		var h; // (HuftBuild)

		// literal/length and distance code lengths
		for (i = 0; i < 286 + 30; i++) {
			ll[i] = 0;
		}

		// read in table lengths
		NEEDBITS(5);
		nl = 257 + GETBITS(5); // number of literal/length codes
		DUMPBITS(5);
		NEEDBITS(5);
		nd = 1 + GETBITS(5); // number of distance codes
		DUMPBITS(5);
		NEEDBITS(4);
		nb = 4 + GETBITS(4); // number of bit length codes
		DUMPBITS(4);
		if (nl > 286 || nd > 30) {
			return -1; // bad lengths
		}

		// read in bit-length-code lengths
		for (j = 0; j < nb; j++) {
			NEEDBITS(3);
			ll[border[j]] = GETBITS(3);
			DUMPBITS(3);
		}
		for (null; j < 19; j++) {
			ll[border[j]] = 0;
		}

		// build decoding table for trees--single level, 7 bit lookup
		bl = 7;
		h = new HuftBuild(ll, 19, 19, null, null, bl);
		if (h.status !== 0) {
			return -1; // incomplete code set
		}

		tl = h.root;
		bl = h.m;

		// read in literal and distance code lengths
		n = nl + nd;
		i = l = 0;
		while (i < n) {
			NEEDBITS(bl);
			t = tl.list[GETBITS(bl)];
			j = t.b;
			DUMPBITS(j);
			j = t.n;
			if (j < 16) { // length of code in bits (0..15)
				ll[i++] = l = j; // save last length in l
			} else if (j === 16) { // repeat last length 3 to 6 times
				NEEDBITS(2);
				j = 3 + GETBITS(2);
				DUMPBITS(2);
				if (i + j > n) {
					return -1;
				}
				while (j-- > 0) {
					ll[i++] = l;
				}
			} else if (j === 17) { // 3 to 10 zero length codes
				NEEDBITS(3);
				j = 3 + GETBITS(3);
				DUMPBITS(3);
				if (i + j > n) {
					return -1;
				}
				while (j-- > 0) {
					ll[i++] = 0;
				}
				l = 0;
			} else { // j === 18: 11 to 138 zero length codes
				NEEDBITS(7);
				j = 11 + GETBITS(7);
				DUMPBITS(7);
				if (i + j > n) {
					return -1;
				}
				while (j-- > 0) {
					ll[i++] = 0;
				}
				l = 0;
			}
		}

		// build the decoding tables for literal/length and distance codes
		bl = lbits;
		h = new HuftBuild(ll, nl, 257, cplens, cplext, bl);
		if (bl === 0) { // no literals or lengths
			h.status = 1;
		}
		if (h.status !== 0) {
			if (h.status !== 1) {
				return -1; // incomplete code set
			}
			// **incomplete literal tree**
		}
		tl = h.root;
		bl = h.m;

		for (i = 0; i < nd; i++) {
			ll[i] = ll[i + nl];
		}
		bd = dbits;
		h = new HuftBuild(ll, nd, 0, cpdist, cpdext, bd);
		td = h.root;
		bd = h.m;

		if (bd === 0 && nl > 257) { // lengths but no distances
			// **incomplete distance tree**
			return -1;
		}
/*
		if (h.status === 1) {
			// **incomplete distance tree**
		}
*/
		if (h.status !== 0) {
			return -1;
		}

		// decompress until an end-of-block code
		return inflate_codes(buff, off, size);
	}

	function inflate_start() {
		if (!slide) {
			slide = []; // new Array(2 * WSIZE); // slide.length is never called
		}
		wp = 0;
		bit_buf = 0;
		bit_len = 0;
		method = -1;
		eof = false;
		copy_leng = copy_dist = 0;
		tl = null;
	}

	function inflate_internal(buff, off, size) {
		// decompress an inflated entry
		var n, i;

		n = 0;
		while (n < size) {
			if (eof && method === -1) {
				return n;
			}

			if (copy_leng > 0) {
				if (method !== STORED_BLOCK) {
					// STATIC_TREES or DYN_TREES
					while (copy_leng > 0 && n < size) {
						copy_leng--;
						copy_dist &= WSIZE - 1;
						wp &= WSIZE - 1;
						buff[off + n++] = slide[wp++] = slide[copy_dist++];
					}
				} else {
					while (copy_leng > 0 && n < size) {
						copy_leng--;
						wp &= WSIZE - 1;
						NEEDBITS(8);
						buff[off + n++] = slide[wp++] = GETBITS(8);
						DUMPBITS(8);
					}
					if (copy_leng === 0) {
						method = -1; // done
					}
				}
				if (n === size) {
					return n;
				}
			}

			if (method === -1) {
				if (eof) {
					break;
				}

				// read in last block bit
				NEEDBITS(1);
				if (GETBITS(1) !== 0) {
					eof = true;
				}
				DUMPBITS(1);

				// read in block type
				NEEDBITS(2);
				method = GETBITS(2);
				DUMPBITS(2);
				tl = null;
				copy_leng = 0;
			}

			switch (method) {
			case STORED_BLOCK:
				i = inflate_stored(buff, off + n, size - n);
				break;

			case STATIC_TREES:
				if (tl) {
					i = inflate_codes(buff, off + n, size - n);
				} else {
					i = inflate_fixed(buff, off + n, size - n);
				}
				break;

			case DYN_TREES:
				if (tl) {
					i = inflate_codes(buff, off + n, size - n);
				} else {
					i = inflate_dynamic(buff, off + n, size - n);
				}
				break;

			default: // error
				i = -1;
				break;
			}

			if (i === -1) {
				if (eof) {
					return 0;
				}
				return -1;
			}
			n += i;
		}
		return n;
	}

	function inflate(arr) {
		var buff = [], i;

		inflate_start();
		inflate_data = arr;
		inflate_pos = 0;

		do {
			i = inflate_internal(buff, buff.length, 1024);
		} while (i > 0);
		inflate_data = null; // G.C.
		return buff;
	}

	return {
		inflate: inflate
	};


});

/*
 * $Id: rawdeflate.js,v 0.3 2009/03/01 19:05:05 dankogai Exp dankogai $
 *
 * Original:
 *   http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt
 */

/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0.1
 * LastModified: Dec 25 1999
 */

/* Interface:
 * data = deflate(src);
 */
define ('deflate-js',[],function(){

	/* constant parameters */
	var WSIZE = 32768, // Sliding Window size
		STORED_BLOCK = 0,
		STATIC_TREES = 1,
		DYN_TREES = 2,

	/* for deflate */
		DEFAULT_LEVEL = 6,
		FULL_SEARCH = false,
		INBUFSIZ = 32768, // Input buffer size
		//INBUF_EXTRA = 64, // Extra buffer
		OUTBUFSIZ = 1024 * 8,
		window_size = 2 * WSIZE,
		MIN_MATCH = 3,
		MAX_MATCH = 258,
		BITS = 16,
	// for SMALL_MEM
		LIT_BUFSIZE = 0x2000,
//		HASH_BITS = 13,
	//for MEDIUM_MEM
	//	LIT_BUFSIZE = 0x4000,
	//	HASH_BITS = 14,
	// for BIG_MEM
	//	LIT_BUFSIZE = 0x8000,
		HASH_BITS = 15,
		DIST_BUFSIZE = LIT_BUFSIZE,
		HASH_SIZE = 1 << HASH_BITS,
		HASH_MASK = HASH_SIZE - 1,
		WMASK = WSIZE - 1,
		NIL = 0, // Tail of hash chains
		TOO_FAR = 4096,
		MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1,
		MAX_DIST = WSIZE - MIN_LOOKAHEAD,
		SMALLEST = 1,
		MAX_BITS = 15,
		MAX_BL_BITS = 7,
		LENGTH_CODES = 29,
		LITERALS = 256,
		END_BLOCK = 256,
		L_CODES = LITERALS + 1 + LENGTH_CODES,
		D_CODES = 30,
		BL_CODES = 19,
		REP_3_6 = 16,
		REPZ_3_10 = 17,
		REPZ_11_138 = 18,
		HEAP_SIZE = 2 * L_CODES + 1,
		H_SHIFT = parseInt((HASH_BITS + MIN_MATCH - 1) / MIN_MATCH, 10),

	/* variables */
		free_queue,
		qhead,
		qtail,
		initflag,
		outbuf = null,
		outcnt,
		outoff,
		complete,
		window,
		d_buf,
		l_buf,
		prev,
		bi_buf,
		bi_valid,
		block_start,
		ins_h,
		hash_head,
		prev_match,
		match_available,
		match_length,
		prev_length,
		strstart,
		match_start,
		eofile,
		lookahead,
		max_chain_length,
		max_lazy_match,
		compr_level,
		good_match,
		nice_match,
		dyn_ltree,
		dyn_dtree,
		static_ltree,
		static_dtree,
		bl_tree,
		l_desc,
		d_desc,
		bl_desc,
		bl_count,
		heap,
		heap_len,
		heap_max,
		depth,
		length_code,
		dist_code,
		base_length,
		base_dist,
		flag_buf,
		last_lit,
		last_dist,
		last_flags,
		flags,
		flag_bit,
		opt_len,
		static_len,
		deflate_data,
		deflate_pos;

	if (LIT_BUFSIZE > INBUFSIZ) {
		console.error("error: INBUFSIZ is too small");
	}
	if ((WSIZE << 1) > (1 << BITS)) {
		console.error("error: WSIZE is too large");
	}
	if (HASH_BITS > BITS - 1) {
		console.error("error: HASH_BITS is too large");
	}
	if (HASH_BITS < 8 || MAX_MATCH !== 258) {
		console.error("error: Code too clever");
	}

	/* objects (deflate) */

	function DeflateCT() {
		this.fc = 0; // frequency count or bit string
		this.dl = 0; // father node in Huffman tree or length of bit string
	}

	function DeflateTreeDesc() {
		this.dyn_tree = null; // the dynamic tree
		this.static_tree = null; // corresponding static tree or NULL
		this.extra_bits = null; // extra bits for each code or NULL
		this.extra_base = 0; // base index for extra_bits
		this.elems = 0; // max number of elements in the tree
		this.max_length = 0; // max bit length for the codes
		this.max_code = 0; // largest code with non zero frequency
	}

	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	function DeflateConfiguration(a, b, c, d) {
		this.good_length = a; // reduce lazy search above this match length
		this.max_lazy = b; // do not perform lazy search above this match length
		this.nice_length = c; // quit search above this match length
		this.max_chain = d;
	}

	function DeflateBuffer() {
		this.next = null;
		this.len = 0;
		this.ptr = []; // new Array(OUTBUFSIZ); // ptr.length is never read
		this.off = 0;
	}

	/* constant tables */
	var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
	var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
	var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
	var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	var configuration_table = [
		new DeflateConfiguration(0, 0, 0, 0),
		new DeflateConfiguration(4, 4, 8, 4),
		new DeflateConfiguration(4, 5, 16, 8),
		new DeflateConfiguration(4, 6, 32, 32),
		new DeflateConfiguration(4, 4, 16, 16),
		new DeflateConfiguration(8, 16, 32, 32),
		new DeflateConfiguration(8, 16, 128, 128),
		new DeflateConfiguration(8, 32, 128, 256),
		new DeflateConfiguration(32, 128, 258, 1024),
		new DeflateConfiguration(32, 258, 258, 4096)
	];


	/* routines (deflate) */

	function deflate_start(level) {
		var i;

		if (!level) {
			level = DEFAULT_LEVEL;
		} else if (level < 1) {
			level = 1;
		} else if (level > 9) {
			level = 9;
		}

		compr_level = level;
		initflag = false;
		eofile = false;
		if (outbuf !== null) {
			return;
		}

		free_queue = qhead = qtail = null;
		outbuf = []; // new Array(OUTBUFSIZ); // outbuf.length never called
		window = []; // new Array(window_size); // window.length never called
		d_buf = []; // new Array(DIST_BUFSIZE); // d_buf.length never called
		l_buf = []; // new Array(INBUFSIZ + INBUF_EXTRA); // l_buf.length never called
		prev = []; // new Array(1 << BITS); // prev.length never called

		dyn_ltree = [];
		for (i = 0; i < HEAP_SIZE; i++) {
			dyn_ltree[i] = new DeflateCT();
		}
		dyn_dtree = [];
		for (i = 0; i < 2 * D_CODES + 1; i++) {
			dyn_dtree[i] = new DeflateCT();
		}
		static_ltree = [];
		for (i = 0; i < L_CODES + 2; i++) {
			static_ltree[i] = new DeflateCT();
		}
		static_dtree = [];
		for (i = 0; i < D_CODES; i++) {
			static_dtree[i] = new DeflateCT();
		}
		bl_tree = [];
		for (i = 0; i < 2 * BL_CODES + 1; i++) {
			bl_tree[i] = new DeflateCT();
		}
		l_desc = new DeflateTreeDesc();
		d_desc = new DeflateTreeDesc();
		bl_desc = new DeflateTreeDesc();
		bl_count = []; // new Array(MAX_BITS+1); // bl_count.length never called
		heap = []; // new Array(2*L_CODES+1); // heap.length never called
		depth = []; // new Array(2*L_CODES+1); // depth.length never called
		length_code = []; // new Array(MAX_MATCH-MIN_MATCH+1); // length_code.length never called
		dist_code = []; // new Array(512); // dist_code.length never called
		base_length = []; // new Array(LENGTH_CODES); // base_length.length never called
		base_dist = []; // new Array(D_CODES); // base_dist.length never called
		flag_buf = []; // new Array(parseInt(LIT_BUFSIZE / 8, 10)); // flag_buf.length never called
	}

	function deflate_end() {
		free_queue = qhead = qtail = null;
		outbuf = null;
		window = null;
		d_buf = null;
		l_buf = null;
		prev = null;
		dyn_ltree = null;
		dyn_dtree = null;
		static_ltree = null;
		static_dtree = null;
		bl_tree = null;
		l_desc = null;
		d_desc = null;
		bl_desc = null;
		bl_count = null;
		heap = null;
		depth = null;
		length_code = null;
		dist_code = null;
		base_length = null;
		base_dist = null;
		flag_buf = null;
	}

	function reuse_queue(p) {
		p.next = free_queue;
		free_queue = p;
	}

	function new_queue() {
		var p;

		if (free_queue !== null) {
			p = free_queue;
			free_queue = free_queue.next;
		} else {
			p = new DeflateBuffer();
		}
		p.next = null;
		p.len = p.off = 0;

		return p;
	}

	function head1(i) {
		return prev[WSIZE + i];
	}

	function head2(i, val) {
		return (prev[WSIZE + i] = val);
	}

	/* put_byte is used for the compressed output, put_ubyte for the
	 * uncompressed output. However unlzw() uses window for its
	 * suffix table instead of its output buffer, so it does not use put_ubyte
	 * (to be cleaned up).
	 */
	function put_byte(c) {
		outbuf[outoff + outcnt++] = c;
		if (outoff + outcnt === OUTBUFSIZ) {
			qoutbuf();
		}
	}

	/* Output a 16 bit value, lsb first */
	function put_short(w) {
		w &= 0xffff;
		if (outoff + outcnt < OUTBUFSIZ - 2) {
			outbuf[outoff + outcnt++] = (w & 0xff);
			outbuf[outoff + outcnt++] = (w >>> 8);
		} else {
			put_byte(w & 0xff);
			put_byte(w >>> 8);
		}
	}

	/* ==========================================================================
	 * Insert string s in the dictionary and set match_head to the previous head
	 * of the hash chain (the most recent string with same hash key). Return
	 * the previous length of the hash chain.
	 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
	 *    input characters and the first MIN_MATCH bytes of s are valid
	 *    (except for the last MIN_MATCH-1 bytes of the input file).
	 */
	function INSERT_STRING() {
		ins_h = ((ins_h << H_SHIFT) ^ (window[strstart + MIN_MATCH - 1] & 0xff)) & HASH_MASK;
		hash_head = head1(ins_h);
		prev[strstart & WMASK] = hash_head;
		head2(ins_h, strstart);
	}

	/* Send a code of the given tree. c and tree must not have side effects */
	function SEND_CODE(c, tree) {
		send_bits(tree[c].fc, tree[c].dl);
	}

	/* Mapping from a distance to a distance code. dist is the distance - 1 and
	 * must not have side effects. dist_code[256] and dist_code[257] are never
	 * used.
	 */
	function D_CODE(dist) {
		return (dist < 256 ? dist_code[dist] : dist_code[256 + (dist >> 7)]) & 0xff;
	}

	/* ==========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function SMALLER(tree, n, m) {
		return tree[n].fc < tree[m].fc || (tree[n].fc === tree[m].fc && depth[n] <= depth[m]);
	}

	/* ==========================================================================
	 * read string data
	 */
	function read_buff(buff, offset, n) {
		var i;
		for (i = 0; i < n && deflate_pos < deflate_data.length; i++) {
			buff[offset + i] = deflate_data[deflate_pos++] & 0xff;
		}
		return i;
	}

	/* ==========================================================================
	 * Initialize the "longest match" routines for a new file
	 */
	function lm_init() {
		var j;

		// Initialize the hash table. */
		for (j = 0; j < HASH_SIZE; j++) {
			// head2(j, NIL);
			prev[WSIZE + j] = 0;
		}
		// prev will be initialized on the fly */

		// Set the default configuration parameters:
		max_lazy_match = configuration_table[compr_level].max_lazy;
		good_match = configuration_table[compr_level].good_length;
		if (!FULL_SEARCH) {
			nice_match = configuration_table[compr_level].nice_length;
		}
		max_chain_length = configuration_table[compr_level].max_chain;

		strstart = 0;
		block_start = 0;

		lookahead = read_buff(window, 0, 2 * WSIZE);
		if (lookahead <= 0) {
			eofile = true;
			lookahead = 0;
			return;
		}
		eofile = false;
		// Make sure that we always have enough lookahead. This is important
		// if input comes from a device such as a tty.
		while (lookahead < MIN_LOOKAHEAD && !eofile) {
			fill_window();
		}

		// If lookahead < MIN_MATCH, ins_h is garbage, but this is
		// not important since only literal bytes will be emitted.
		ins_h = 0;
		for (j = 0; j < MIN_MATCH - 1; j++) {
			// UPDATE_HASH(ins_h, window[j]);
			ins_h = ((ins_h << H_SHIFT) ^ (window[j] & 0xff)) & HASH_MASK;
		}
	}

	/* ==========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 */
	function longest_match(cur_match) {
		var chain_length = max_chain_length; // max hash chain length
		var scanp = strstart; // current string
		var matchp; // matched string
		var len; // length of current match
		var best_len = prev_length; // best match length so far

		// Stop when cur_match becomes <= limit. To simplify the code,
		// we prevent matches with the string of window index 0.
		var limit = (strstart > MAX_DIST ? strstart - MAX_DIST : NIL);

		var strendp = strstart + MAX_MATCH;
		var scan_end1 = window[scanp + best_len - 1];
		var scan_end = window[scanp + best_len];

		var i, broke;

		// Do not waste too much time if we already have a good match: */
		if (prev_length >= good_match) {
			chain_length >>= 2;
		}

		// Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, "insufficient lookahead");

		do {
			// Assert(cur_match < encoder->strstart, "no future");
			matchp = cur_match;

			// Skip to next match if the match length cannot increase
			// or if the match length is less than 2:
			if (window[matchp + best_len] !== scan_end  ||
					window[matchp + best_len - 1] !== scan_end1 ||
					window[matchp] !== window[scanp] ||
					window[++matchp] !== window[scanp + 1]) {
				continue;
			}

			// The check at best_len-1 can be removed because it will be made
			// again later. (This heuristic is not always a win.)
			// It is not necessary to compare scan[2] and match[2] since they
			// are always equal when the other bytes match, given that
			// the hash keys are equal and that HASH_BITS >= 8.
			scanp += 2;
			matchp++;

			// We check for insufficient lookahead only every 8th comparison;
			// the 256th check will be made at strstart+258.
			while (scanp < strendp) {
				broke = false;
				for (i = 0; i < 8; i += 1) {
					scanp += 1;
					matchp += 1;
					if (window[scanp] !== window[matchp]) {
						broke = true;
						break;
					}
				}

				if (broke) {
					break;
				}
			}

			len = MAX_MATCH - (strendp - scanp);
			scanp = strendp - MAX_MATCH;

			if (len > best_len) {
				match_start = cur_match;
				best_len = len;
				if (FULL_SEARCH) {
					if (len >= MAX_MATCH) {
						break;
					}
				} else {
					if (len >= nice_match) {
						break;
					}
				}

				scan_end1 = window[scanp + best_len - 1];
				scan_end = window[scanp + best_len];
			}
		} while ((cur_match = prev[cur_match & WMASK]) > limit && --chain_length !== 0);

		return best_len;
	}

	/* ==========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead, and sets eofile if end of input file.
	 * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0
	 * OUT assertions: at least one byte has been read, or eofile is set;
	 *    file reads are performed for at least two bytes (required for the
	 *    translate_eol option).
	 */
	function fill_window() {
		var n, m;

	 // Amount of free space at the end of the window.
		var more = window_size - lookahead - strstart;

		// If the window is almost full and there is insufficient lookahead,
		// move the upper half to the lower one to make room in the upper half.
		if (more === -1) {
			// Very unlikely, but possible on 16 bit machine if strstart == 0
			// and lookahead == 1 (input done one byte at time)
			more--;
		} else if (strstart >= WSIZE + MAX_DIST) {
			// By the IN assertion, the window is not empty so we can't confuse
			// more == 0 with more == 64K on a 16 bit machine.
			// Assert(window_size == (ulg)2*WSIZE, "no sliding with BIG_MEM");

			// System.arraycopy(window, WSIZE, window, 0, WSIZE);
			for (n = 0; n < WSIZE; n++) {
				window[n] = window[n + WSIZE];
			}

			match_start -= WSIZE;
			strstart    -= WSIZE; /* we now have strstart >= MAX_DIST: */
			block_start -= WSIZE;

			for (n = 0; n < HASH_SIZE; n++) {
				m = head1(n);
				head2(n, m >= WSIZE ? m - WSIZE : NIL);
			}
			for (n = 0; n < WSIZE; n++) {
			// If n is not on any hash chain, prev[n] is garbage but
			// its value will never be used.
				m = prev[n];
				prev[n] = (m >= WSIZE ? m - WSIZE : NIL);
			}
			more += WSIZE;
		}
		// At this point, more >= 2
		if (!eofile) {
			n = read_buff(window, strstart + lookahead, more);
			if (n <= 0) {
				eofile = true;
			} else {
				lookahead += n;
			}
		}
	}

	/* ==========================================================================
	 * Processes a new input file and return its compressed length. This
	 * function does not perform lazy evaluationof matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast() {
		while (lookahead !== 0 && qhead === null) {
			var flush; // set if current block must be flushed

			// Insert the string window[strstart .. strstart+2] in the
			// dictionary, and set hash_head to the head of the hash chain:
			INSERT_STRING();

			// Find the longest match, discarding those <= prev_length.
			// At this point we have always match_length < MIN_MATCH
			if (hash_head !== NIL && strstart - hash_head <= MAX_DIST) {
				// To simplify the code, we prevent matches with the string
				// of window index 0 (in particular we have to avoid a match
				// of the string with itself at the start of the input file).
				match_length = longest_match(hash_head);
				// longest_match() sets match_start */
				if (match_length > lookahead) {
					match_length = lookahead;
				}
			}
			if (match_length >= MIN_MATCH) {
				// check_match(strstart, match_start, match_length);

				flush = ct_tally(strstart - match_start, match_length - MIN_MATCH);
				lookahead -= match_length;

				// Insert new strings in the hash table only if the match length
				// is not too large. This saves time but degrades compression.
				if (match_length <= max_lazy_match) {
					match_length--; // string at strstart already in hash table
					do {
						strstart++;
						INSERT_STRING();
						// strstart never exceeds WSIZE-MAX_MATCH, so there are
						// always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
						// these bytes are garbage, but it does not matter since
						// the next lookahead bytes will be emitted as literals.
					} while (--match_length !== 0);
					strstart++;
				} else {
					strstart += match_length;
					match_length = 0;
					ins_h = window[strstart] & 0xff;
					// UPDATE_HASH(ins_h, window[strstart + 1]);
					ins_h = ((ins_h << H_SHIFT) ^ (window[strstart + 1] & 0xff)) & HASH_MASK;

				//#if MIN_MATCH !== 3
				//		Call UPDATE_HASH() MIN_MATCH-3 more times
				//#endif

				}
			} else {
				// No match, output a literal byte */
				flush = ct_tally(0, window[strstart] & 0xff);
				lookahead--;
				strstart++;
			}
			if (flush) {
				flush_block(0);
				block_start = strstart;
			}

			// Make sure that we always have enough lookahead, except
			// at the end of the input file. We need MAX_MATCH bytes
			// for the next match, plus MIN_MATCH bytes to insert the
			// string following the next match.
			while (lookahead < MIN_LOOKAHEAD && !eofile) {
				fill_window();
			}
		}
	}

	function deflate_better() {
		// Process the input block. */
		while (lookahead !== 0 && qhead === null) {
			// Insert the string window[strstart .. strstart+2] in the
			// dictionary, and set hash_head to the head of the hash chain:
			INSERT_STRING();

			// Find the longest match, discarding those <= prev_length.
			prev_length = match_length;
			prev_match = match_start;
			match_length = MIN_MATCH - 1;

			if (hash_head !== NIL && prev_length < max_lazy_match && strstart - hash_head <= MAX_DIST) {
				// To simplify the code, we prevent matches with the string
				// of window index 0 (in particular we have to avoid a match
				// of the string with itself at the start of the input file).
				match_length = longest_match(hash_head);
				// longest_match() sets match_start */
				if (match_length > lookahead) {
					match_length = lookahead;
				}

				// Ignore a length 3 match if it is too distant: */
				if (match_length === MIN_MATCH && strstart - match_start > TOO_FAR) {
					// If prev_match is also MIN_MATCH, match_start is garbage
					// but we will ignore the current match anyway.
					match_length--;
				}
			}
			// If there was a match at the previous step and the current
			// match is not better, output the previous match:
			if (prev_length >= MIN_MATCH && match_length <= prev_length) {
				var flush; // set if current block must be flushed

				// check_match(strstart - 1, prev_match, prev_length);
				flush = ct_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);

				// Insert in hash table all strings up to the end of the match.
				// strstart-1 and strstart are already inserted.
				lookahead -= prev_length - 1;
				prev_length -= 2;
				do {
					strstart++;
					INSERT_STRING();
					// strstart never exceeds WSIZE-MAX_MATCH, so there are
					// always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
					// these bytes are garbage, but it does not matter since the
					// next lookahead bytes will always be emitted as literals.
				} while (--prev_length !== 0);
				match_available = false;
				match_length = MIN_MATCH - 1;
				strstart++;
				if (flush) {
					flush_block(0);
					block_start = strstart;
				}
			} else if (match_available) {
				// If there was no match at the previous position, output a
				// single literal. If there was a match but the current match
				// is longer, truncate the previous match to a single literal.
				if (ct_tally(0, window[strstart - 1] & 0xff)) {
					flush_block(0);
					block_start = strstart;
				}
				strstart++;
				lookahead--;
			} else {
				// There is no previous match to compare with, wait for
				// the next step to decide.
				match_available = true;
				strstart++;
				lookahead--;
			}

			// Make sure that we always have enough lookahead, except
			// at the end of the input file. We need MAX_MATCH bytes
			// for the next match, plus MIN_MATCH bytes to insert the
			// string following the next match.
			while (lookahead < MIN_LOOKAHEAD && !eofile) {
				fill_window();
			}
		}
	}

	function init_deflate() {
		if (eofile) {
			return;
		}
		bi_buf = 0;
		bi_valid = 0;
		ct_init();
		lm_init();

		qhead = null;
		outcnt = 0;
		outoff = 0;

		if (compr_level <= 3) {
			prev_length = MIN_MATCH - 1;
			match_length = 0;
		} else {
			match_length = MIN_MATCH - 1;
			match_available = false;
		}

		complete = false;
	}

	/* ==========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_internal(buff, off, buff_size) {
		var n;

		if (!initflag) {
			init_deflate();
			initflag = true;
			if (lookahead === 0) { // empty
				complete = true;
				return 0;
			}
		}

		n = qcopy(buff, off, buff_size);
		if (n === buff_size) {
			return buff_size;
		}

		if (complete) {
			return n;
		}

		if (compr_level <= 3) {
			// optimized for speed
			deflate_fast();
		} else {
			deflate_better();
		}

		if (lookahead === 0) {
			if (match_available) {
				ct_tally(0, window[strstart - 1] & 0xff);
			}
			flush_block(1);
			complete = true;
		}

		return n + qcopy(buff, n + off, buff_size - n);
	}

	function qcopy(buff, off, buff_size) {
		var n, i, j;

		n = 0;
		while (qhead !== null && n < buff_size) {
			i = buff_size - n;
			if (i > qhead.len) {
				i = qhead.len;
			}
			// System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);
			for (j = 0; j < i; j++) {
				buff[off + n + j] = qhead.ptr[qhead.off + j];
			}

			qhead.off += i;
			qhead.len -= i;
			n += i;
			if (qhead.len === 0) {
				var p;
				p = qhead;
				qhead = qhead.next;
				reuse_queue(p);
			}
		}

		if (n === buff_size) {
			return n;
		}

		if (outoff < outcnt) {
			i = buff_size - n;
			if (i > outcnt - outoff) {
				i = outcnt - outoff;
			}
			// System.arraycopy(outbuf, outoff, buff, off + n, i);
			for (j = 0; j < i; j++) {
				buff[off + n + j] = outbuf[outoff + j];
			}
			outoff += i;
			n += i;
			if (outcnt === outoff) {
				outcnt = outoff = 0;
			}
		}
		return n;
	}

	/* ==========================================================================
	 * Allocate the match buffer, initialize the various tables and save the
	 * location of the internal file attribute (ascii/binary) and method
	 * (DEFLATE/STORE).
	 */
	function ct_init() {
		var n; // iterates over tree elements
		var bits; // bit counter
		var length; // length value
		var code; // code value
		var dist; // distance index

		if (static_dtree[0].dl !== 0) {
			return; // ct_init already called
		}

		l_desc.dyn_tree = dyn_ltree;
		l_desc.static_tree = static_ltree;
		l_desc.extra_bits = extra_lbits;
		l_desc.extra_base = LITERALS + 1;
		l_desc.elems = L_CODES;
		l_desc.max_length = MAX_BITS;
		l_desc.max_code = 0;

		d_desc.dyn_tree = dyn_dtree;
		d_desc.static_tree = static_dtree;
		d_desc.extra_bits = extra_dbits;
		d_desc.extra_base = 0;
		d_desc.elems = D_CODES;
		d_desc.max_length = MAX_BITS;
		d_desc.max_code = 0;

		bl_desc.dyn_tree = bl_tree;
		bl_desc.static_tree = null;
		bl_desc.extra_bits = extra_blbits;
		bl_desc.extra_base = 0;
		bl_desc.elems = BL_CODES;
		bl_desc.max_length = MAX_BL_BITS;
		bl_desc.max_code = 0;

	 // Initialize the mapping length (0..255) -> length code (0..28)
		length = 0;
		for (code = 0; code < LENGTH_CODES - 1; code++) {
			base_length[code] = length;
			for (n = 0; n < (1 << extra_lbits[code]); n++) {
				length_code[length++] = code;
			}
		}
	 // Assert (length === 256, "ct_init: length !== 256");

		// Note that the length 255 (match length 258) can be represented
		// in two different ways: code 284 + 5 bits or code 285, so we
		// overwrite length_code[255] to use the best encoding:
		length_code[length - 1] = code;

		// Initialize the mapping dist (0..32K) -> dist code (0..29) */
		dist = 0;
		for (code = 0; code < 16; code++) {
			base_dist[code] = dist;
			for (n = 0; n < (1 << extra_dbits[code]); n++) {
				dist_code[dist++] = code;
			}
		}
		// Assert (dist === 256, "ct_init: dist !== 256");
		// from now on, all distances are divided by 128
		for (dist >>= 7; code < D_CODES; code++) {
			base_dist[code] = dist << 7;
			for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
				dist_code[256 + dist++] = code;
			}
		}
		// Assert (dist === 256, "ct_init: 256+dist !== 512");

		// Construct the codes of the static literal tree
		for (bits = 0; bits <= MAX_BITS; bits++) {
			bl_count[bits] = 0;
		}
		n = 0;
		while (n <= 143) {
			static_ltree[n++].dl = 8;
			bl_count[8]++;
		}
		while (n <= 255) {
			static_ltree[n++].dl = 9;
			bl_count[9]++;
		}
		while (n <= 279) {
			static_ltree[n++].dl = 7;
			bl_count[7]++;
		}
		while (n <= 287) {
			static_ltree[n++].dl = 8;
			bl_count[8]++;
		}
		// Codes 286 and 287 do not exist, but we must include them in the
		// tree construction to get a canonical Huffman tree (longest code
		// all ones)
		gen_codes(static_ltree, L_CODES + 1);

		// The static distance tree is trivial: */
		for (n = 0; n < D_CODES; n++) {
			static_dtree[n].dl = 5;
			static_dtree[n].fc = bi_reverse(n, 5);
		}

		// Initialize the first block of the first file:
		init_block();
	}

	/* ==========================================================================
	 * Initialize a new block.
	 */
	function init_block() {
		var n; // iterates over tree elements

		// Initialize the trees.
		for (n = 0; n < L_CODES;  n++) {
			dyn_ltree[n].fc = 0;
		}
		for (n = 0; n < D_CODES;  n++) {
			dyn_dtree[n].fc = 0;
		}
		for (n = 0; n < BL_CODES; n++) {
			bl_tree[n].fc = 0;
		}

		dyn_ltree[END_BLOCK].fc = 1;
		opt_len = static_len = 0;
		last_lit = last_dist = last_flags = 0;
		flags = 0;
		flag_bit = 1;
	}

	/* ==========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 *
	 * @param tree- tree to restore
	 * @param k- node to move down
	 */
	function pqdownheap(tree, k) {
		var v = heap[k],
			j = k << 1; // left son of k

		while (j <= heap_len) {
			// Set j to the smallest of the two sons:
			if (j < heap_len && SMALLER(tree, heap[j + 1], heap[j])) {
				j++;
			}

			// Exit if v is smaller than both sons
			if (SMALLER(tree, v, heap[j])) {
				break;
			}

			// Exchange v with the smallest son
			heap[k] = heap[j];
			k = j;

			// And continue down the tree, setting j to the left son of k
			j <<= 1;
		}
		heap[k] = v;
	}

	/* ==========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(desc) { // the tree descriptor
		var tree = desc.dyn_tree;
		var extra = desc.extra_bits;
		var base = desc.extra_base;
		var max_code = desc.max_code;
		var max_length = desc.max_length;
		var stree = desc.static_tree;
		var h; // heap index
		var n, m; // iterate over the tree elements
		var bits; // bit length
		var xbits; // extra bits
		var f; // frequency
		var overflow = 0; // number of elements with bit length too large

		for (bits = 0; bits <= MAX_BITS; bits++) {
			bl_count[bits] = 0;
		}

		// In a first pass, compute the optimal bit lengths (which may
		// overflow in the case of the bit length tree).
		tree[heap[heap_max]].dl = 0; // root of the heap

		for (h = heap_max + 1; h < HEAP_SIZE; h++) {
			n = heap[h];
			bits = tree[tree[n].dl].dl + 1;
			if (bits > max_length) {
				bits = max_length;
				overflow++;
			}
			tree[n].dl = bits;
			// We overwrite tree[n].dl which is no longer needed

			if (n > max_code) {
				continue; // not a leaf node
			}

			bl_count[bits]++;
			xbits = 0;
			if (n >= base) {
				xbits = extra[n - base];
			}
			f = tree[n].fc;
			opt_len += f * (bits + xbits);
			if (stree !== null) {
				static_len += f * (stree[n].dl + xbits);
			}
		}
		if (overflow === 0) {
			return;
		}

		// This happens for example on obj2 and pic of the Calgary corpus

		// Find the first bit length which could increase:
		do {
			bits = max_length - 1;
			while (bl_count[bits] === 0) {
				bits--;
			}
			bl_count[bits]--; // move one leaf down the tree
			bl_count[bits + 1] += 2; // move one overflow item as its brother
			bl_count[max_length]--;
			// The brother of the overflow item also moves one step up,
			// but this does not affect bl_count[max_length]
			overflow -= 2;
		} while (overflow > 0);

		// Now recompute all bit lengths, scanning in increasing frequency.
		// h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
		// lengths instead of fixing only the wrong ones. This idea is taken
		// from 'ar' written by Haruhiko Okumura.)
		for (bits = max_length; bits !== 0; bits--) {
			n = bl_count[bits];
			while (n !== 0) {
				m = heap[--h];
				if (m > max_code) {
					continue;
				}
				if (tree[m].dl !== bits) {
					opt_len += (bits - tree[m].dl) * tree[m].fc;
					tree[m].fc = bits;
				}
				n--;
			}
		}
	}

	  /* ==========================================================================
	   * Generate the codes for a given tree and bit counts (which need not be
	   * optimal).
	   * IN assertion: the array bl_count contains the bit length statistics for
	   * the given tree and the field len is set for all tree elements.
	   * OUT assertion: the field code is set for all tree elements of non
	   *     zero code length.
	   * @param tree- the tree to decorate
	   * @param max_code- largest code with non-zero frequency
	   */
	function gen_codes(tree, max_code) {
		var next_code = []; // new Array(MAX_BITS + 1); // next code value for each bit length
		var code = 0; // running code value
		var bits; // bit index
		var n; // code index

		// The distribution counts are first used to generate the code values
		// without bit reversal.
		for (bits = 1; bits <= MAX_BITS; bits++) {
			code = ((code + bl_count[bits - 1]) << 1);
			next_code[bits] = code;
		}

		// Check that the bit counts in bl_count are consistent. The last code
		// must be all ones.
		// Assert (code + encoder->bl_count[MAX_BITS]-1 === (1<<MAX_BITS)-1, "inconsistent bit counts");
		// Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

		for (n = 0; n <= max_code; n++) {
			var len = tree[n].dl;
			if (len === 0) {
				continue;
			}
			// Now reverse the bits
			tree[n].fc = bi_reverse(next_code[len]++, len);

			// Tracec(tree !== static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ", n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));
		}
	}

	/* ==========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(desc) { // the tree descriptor
		var tree = desc.dyn_tree;
		var stree = desc.static_tree;
		var elems = desc.elems;
		var n, m; // iterate over heap elements
		var max_code = -1; // largest code with non zero frequency
		var node = elems; // next internal node of the tree

		// Construct the initial heap, with least frequent element in
		// heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
		// heap[0] is not used.
		heap_len = 0;
		heap_max = HEAP_SIZE;

		for (n = 0; n < elems; n++) {
			if (tree[n].fc !== 0) {
				heap[++heap_len] = max_code = n;
				depth[n] = 0;
			} else {
				tree[n].dl = 0;
			}
		}

		// The pkzip format requires that at least one distance code exists,
		// and that at least one bit should be sent even if there is only one
		// possible code. So to avoid special checks later on we force at least
		// two codes of non zero frequency.
		while (heap_len < 2) {
			var xnew = heap[++heap_len] = (max_code < 2 ? ++max_code : 0);
			tree[xnew].fc = 1;
			depth[xnew] = 0;
			opt_len--;
			if (stree !== null) {
				static_len -= stree[xnew].dl;
			}
			// new is 0 or 1 so it does not have extra bits
		}
		desc.max_code = max_code;

		// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
		// establish sub-heaps of increasing lengths:
		for (n = heap_len >> 1; n >= 1; n--) {
			pqdownheap(tree, n);
		}

		// Construct the Huffman tree by repeatedly combining the least two
		// frequent nodes.
		do {
			n = heap[SMALLEST];
			heap[SMALLEST] = heap[heap_len--];
			pqdownheap(tree, SMALLEST);

			m = heap[SMALLEST]; // m = node of next least frequency

			// keep the nodes sorted by frequency
			heap[--heap_max] = n;
			heap[--heap_max] = m;

			// Create a new node father of n and m
			tree[node].fc = tree[n].fc + tree[m].fc;
			//	depth[node] = (char)(MAX(depth[n], depth[m]) + 1);
			if (depth[n] > depth[m] + 1) {
				depth[node] = depth[n];
			} else {
				depth[node] = depth[m] + 1;
			}
			tree[n].dl = tree[m].dl = node;

			// and insert the new node in the heap
			heap[SMALLEST] = node++;
			pqdownheap(tree, SMALLEST);

		} while (heap_len >= 2);

		heap[--heap_max] = heap[SMALLEST];

		// At this point, the fields freq and dad are set. We can now
		// generate the bit lengths.
		gen_bitlen(desc);

		// The field len is now set, we can generate the bit codes
		gen_codes(tree, max_code);
	}

	/* ==========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree. Updates opt_len to take into account the repeat
	 * counts. (The contribution of the bit length codes will be added later
	 * during the construction of bl_tree.)
	 *
	 * @param tree- the tree to be scanned
	 * @param max_code- and its largest code of non zero frequency
	 */
	function scan_tree(tree, max_code) {
		var n, // iterates over all tree elements
			prevlen = -1, // last emitted length
			curlen, // length of current code
			nextlen = tree[0].dl, // length of next code
			count = 0, // repeat count of the current code
			max_count = 7, // max repeat count
			min_count = 4; // min repeat count

		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}
		tree[max_code + 1].dl = 0xffff; // guard

		for (n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[n + 1].dl;
			if (++count < max_count && curlen === nextlen) {
				continue;
			} else if (count < min_count) {
				bl_tree[curlen].fc += count;
			} else if (curlen !== 0) {
				if (curlen !== prevlen) {
					bl_tree[curlen].fc++;
				}
				bl_tree[REP_3_6].fc++;
			} else if (count <= 10) {
				bl_tree[REPZ_3_10].fc++;
			} else {
				bl_tree[REPZ_11_138].fc++;
			}
			count = 0; prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen === nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}

	/* ==========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 *
	 * @param tree- the tree to be scanned
	 * @param max_code- and its largest code of non zero frequency
	 */
	function send_tree(tree, max_code) {
		var n; // iterates over all tree elements
		var prevlen = -1; // last emitted length
		var curlen; // length of current code
		var nextlen = tree[0].dl; // length of next code
		var count = 0; // repeat count of the current code
		var max_count = 7; // max repeat count
		var min_count = 4; // min repeat count

		// tree[max_code+1].dl = -1; */  /* guard already set */
		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}

		for (n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[n + 1].dl;
			if (++count < max_count && curlen === nextlen) {
				continue;
			} else if (count < min_count) {
				do {
					SEND_CODE(curlen, bl_tree);
				} while (--count !== 0);
			} else if (curlen !== 0) {
				if (curlen !== prevlen) {
					SEND_CODE(curlen, bl_tree);
					count--;
				}
			// Assert(count >= 3 && count <= 6, " 3_6?");
				SEND_CODE(REP_3_6, bl_tree);
				send_bits(count - 3, 2);
			} else if (count <= 10) {
				SEND_CODE(REPZ_3_10, bl_tree);
				send_bits(count - 3, 3);
			} else {
				SEND_CODE(REPZ_11_138, bl_tree);
				send_bits(count - 11, 7);
			}
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen === nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}

	/* ==========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree() {
		var max_blindex; // index of last bit length code of non zero freq

		// Determine the bit length frequencies for literal and distance trees
		scan_tree(dyn_ltree, l_desc.max_code);
		scan_tree(dyn_dtree, d_desc.max_code);

		// Build the bit length tree:
		build_tree(bl_desc);
		// opt_len now includes the length of the tree representations, except
		// the lengths of the bit lengths codes and the 5+5+4 bits for the counts.

		// Determine the number of bit length codes to send. The pkzip format
		// requires that at least 4 bit length codes be sent. (appnote.txt says
		// 3 but the actual value used is 4.)
		for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
			if (bl_tree[bl_order[max_blindex]].dl !== 0) {
				break;
			}
		}
		// Update opt_len to include the bit length tree and counts */
		opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
		// Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
		// encoder->opt_len, encoder->static_len));

		return max_blindex;
	}

	/* ==========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree
		var rank; // index in bl_order

		// Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
		// Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES, "too many codes");
		// Tracev((stderr, "\nbl counts: "));
		send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt
		send_bits(dcodes - 1,   5);
		send_bits(blcodes - 4,  4); // not -3 as stated in appnote.txt
		for (rank = 0; rank < blcodes; rank++) {
			// Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
			send_bits(bl_tree[bl_order[rank]].dl, 3);
		}

		// send the literal tree
		send_tree(dyn_ltree, lcodes - 1);

		// send the distance tree
		send_tree(dyn_dtree, dcodes - 1);
	}

	/* ==========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function flush_block(eof) { // true if this is the last block for a file
		var opt_lenb, static_lenb, // opt_len and static_len in bytes
			max_blindex, // index of last bit length code of non zero freq
			stored_len, // length of input block
			i;

		stored_len = strstart - block_start;
		flag_buf[last_flags] = flags; // Save the flags for the last 8 items

		// Construct the literal and distance trees
		build_tree(l_desc);
		// Tracev((stderr, "\nlit data: dyn %ld, stat %ld",
		// encoder->opt_len, encoder->static_len));

		build_tree(d_desc);
		// Tracev((stderr, "\ndist data: dyn %ld, stat %ld",
		// encoder->opt_len, encoder->static_len));
		// At this point, opt_len and static_len are the total bit lengths of
		// the compressed block data, excluding the tree representations.

		// Build the bit length tree for the above two trees, and get the index
		// in bl_order of the last bit length code to send.
		max_blindex = build_bl_tree();

	 // Determine the best encoding. Compute first the block length in bytes
		opt_lenb = (opt_len + 3 + 7) >> 3;
		static_lenb = (static_len + 3 + 7) >> 3;

	//  Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ", opt_lenb, encoder->opt_len, static_lenb, encoder->static_len, stored_len, encoder->last_lit, encoder->last_dist));

		if (static_lenb <= opt_lenb) {
			opt_lenb = static_lenb;
		}
		if (stored_len + 4 <= opt_lenb && block_start >= 0) { // 4: two words for the lengths
			// The test buf !== NULL is only necessary if LIT_BUFSIZE > WSIZE.
			// Otherwise we can't have processed more than WSIZE input bytes since
			// the last block flush, because compression would have been
			// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
			// transform a block into a stored block.
			send_bits((STORED_BLOCK << 1) + eof, 3);  /* send block type */
			bi_windup();         /* align on byte boundary */
			put_short(stored_len);
			put_short(~stored_len);

			// copy block
			/*
				p = &window[block_start];
				for (i = 0; i < stored_len; i++) {
					put_byte(p[i]);
				}
			*/
			for (i = 0; i < stored_len; i++) {
				put_byte(window[block_start + i]);
			}
		} else if (static_lenb === opt_lenb) {
			send_bits((STATIC_TREES << 1) + eof, 3);
			compress_block(static_ltree, static_dtree);
		} else {
			send_bits((DYN_TREES << 1) + eof, 3);
			send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
			compress_block(dyn_ltree, dyn_dtree);
		}

		init_block();

		if (eof !== 0) {
			bi_windup();
		}
	}

	/* ==========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 *
	 * @param dist- distance of matched string
	 * @param lc- (match length - MIN_MATCH) or unmatched char (if dist === 0)
	 */
	function ct_tally(dist, lc) {
		l_buf[last_lit++] = lc;
		if (dist === 0) {
			// lc is the unmatched char
			dyn_ltree[lc].fc++;
		} else {
			// Here, lc is the match length - MIN_MATCH
			dist--; // dist = match distance - 1
			// Assert((ush)dist < (ush)MAX_DIST && (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) && (ush)D_CODE(dist) < (ush)D_CODES,  "ct_tally: bad match");

			dyn_ltree[length_code[lc] + LITERALS + 1].fc++;
			dyn_dtree[D_CODE(dist)].fc++;

			d_buf[last_dist++] = dist;
			flags |= flag_bit;
		}
		flag_bit <<= 1;

		// Output the flags if they fill a byte
		if ((last_lit & 7) === 0) {
			flag_buf[last_flags++] = flags;
			flags = 0;
			flag_bit = 1;
		}
		// Try to guess if it is profitable to stop the current block here
		if (compr_level > 2 && (last_lit & 0xfff) === 0) {
			// Compute an upper bound for the compressed length
			var out_length = last_lit * 8;
			var in_length = strstart - block_start;
			var dcode;

			for (dcode = 0; dcode < D_CODES; dcode++) {
				out_length += dyn_dtree[dcode].fc * (5 + extra_dbits[dcode]);
			}
			out_length >>= 3;
			// Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ", encoder->last_lit, encoder->last_dist, in_length, out_length, 100L - out_length*100L/in_length));
			if (last_dist < parseInt(last_lit / 2, 10) && out_length < parseInt(in_length / 2, 10)) {
				return true;
			}
		}
		return (last_lit === LIT_BUFSIZE - 1 || last_dist === DIST_BUFSIZE);
		// We avoid equality with LIT_BUFSIZE because of wraparound at 64K
		// on 16 bit machines and because stored blocks are restricted to
		// 64K-1 bytes.
	}

	  /* ==========================================================================
	   * Send the block data compressed using the given Huffman trees
	   *
	   * @param ltree- literal tree
	   * @param dtree- distance tree
	   */
	function compress_block(ltree, dtree) {
		var dist; // distance of matched string
		var lc; // match length or unmatched char (if dist === 0)
		var lx = 0; // running index in l_buf
		var dx = 0; // running index in d_buf
		var fx = 0; // running index in flag_buf
		var flag = 0; // current flags
		var code; // the code to send
		var extra; // number of extra bits to send

		if (last_lit !== 0) {
			do {
				if ((lx & 7) === 0) {
					flag = flag_buf[fx++];
				}
				lc = l_buf[lx++] & 0xff;
				if ((flag & 1) === 0) {
					SEND_CODE(lc, ltree); /* send a literal byte */
					//	Tracecv(isgraph(lc), (stderr," '%c' ", lc));
				} else {
					// Here, lc is the match length - MIN_MATCH
					code = length_code[lc];
					SEND_CODE(code + LITERALS + 1, ltree); // send the length code
					extra = extra_lbits[code];
					if (extra !== 0) {
						lc -= base_length[code];
						send_bits(lc, extra); // send the extra length bits
					}
					dist = d_buf[dx++];
					// Here, dist is the match distance - 1
					code = D_CODE(dist);
					//	Assert (code < D_CODES, "bad d_code");

					SEND_CODE(code, dtree); // send the distance code
					extra = extra_dbits[code];
					if (extra !== 0) {
						dist -= base_dist[code];
						send_bits(dist, extra); // send the extra distance bits
					}
				} // literal or match pair ?
				flag >>= 1;
			} while (lx < last_lit);
		}

		SEND_CODE(END_BLOCK, ltree);
	}

	/* ==========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 *
	 * @param value- value to send
	 * @param length- number of bits
	 */
	var Buf_size = 16; // bit size of bi_buf
	function send_bits(value, length) {
		// If not enough room in bi_buf, use (valid) bits from bi_buf and
		// (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
		// unused bits in value.
		if (bi_valid > Buf_size - length) {
			bi_buf |= (value << bi_valid);
			put_short(bi_buf);
			bi_buf = (value >> (Buf_size - bi_valid));
			bi_valid += length - Buf_size;
		} else {
			bi_buf |= value << bi_valid;
			bi_valid += length;
		}
	}

	/* ==========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 *
	 * @param code- the value to invert
	 * @param len- its bit length
	 */
	function bi_reverse(code, len) {
		var res = 0;
		do {
			res |= code & 1;
			code >>= 1;
			res <<= 1;
		} while (--len > 0);
		return res >> 1;
	}

	/* ==========================================================================
	 * Write out any remaining bits in an incomplete byte.
	 */
	function bi_windup() {
		if (bi_valid > 8) {
			put_short(bi_buf);
		} else if (bi_valid > 0) {
			put_byte(bi_buf);
		}
		bi_buf = 0;
		bi_valid = 0;
	}

	function qoutbuf() {
		var q, i;
		if (outcnt !== 0) {
			q = new_queue();
			if (qhead === null) {
				qhead = qtail = q;
			} else {
				qtail = qtail.next = q;
			}
			q.len = outcnt - outoff;
			// System.arraycopy(outbuf, outoff, q.ptr, 0, q.len);
			for (i = 0; i < q.len; i++) {
				q.ptr[i] = outbuf[outoff + i];
			}
			outcnt = outoff = 0;
		}
	}

	function deflate(arr, level) {
		var i, j, buff;

		deflate_data = arr;
		deflate_pos = 0;
		if (typeof level === "undefined") {
			level = DEFAULT_LEVEL;
		}
		deflate_start(level);

		buff = [];

		do {
			i = deflate_internal(buff, buff.length, 1024);
		} while (i > 0);

		deflate_data = null; // G.C.
		return buff;
	}

	return {
		deflate: deflate
	};

});

define('gzip',['crc32', 'inflate-js', 'deflate-js'], function(crc32, inflate, deflate){
			
		// magic numbers marking this file as GZIP
		ID1 = 0x1F,
		ID2 = 0x8B,
		compressionMethods = {
			'deflate': 8
		},
		possibleFlags = {
			'FTEXT': 0x01,
			'FHCRC': 0x02,
			'FEXTRA': 0x04,
			'FNAME': 0x08,
			'FCOMMENT': 0x10
		},
		osMap = {
			'fat': 0, // FAT file system (DOS, OS/2, NT) + PKZIPW 2.50 VFAT, NTFS
			'amiga': 1, // Amiga
			'vmz': 2, // VMS (VAX or Alpha AXP)
			'unix': 3, // Unix
			'vm/cms': 4, // VM/CMS
			'atari': 5, // Atari
			'hpfs': 6, // HPFS file system (OS/2, NT 3.x)
			'macintosh': 7, // Macintosh
			'z-system': 8, // Z-System
			'cplm': 9, // CP/M
			'tops-20': 10, // TOPS-20
			'ntfs': 11, // NTFS file system (NT)
			'qdos': 12, // SMS/QDOS
			'acorn': 13, // Acorn RISC OS
			'vfat': 14, // VFAT file system (Win95, NT)
			'vms': 15, // MVS (code also taken for PRIMOS)
			'beos': 16, // BeOS (BeBox or PowerMac)
			'tandem': 17, // Tandem/NSK
			'theos': 18 // THEOS
		},
		os = 'unix',
		DEFAULT_LEVEL = 6;

	function putByte(n, arr) {
		arr.push(n & 0xFF);
	}

	// LSB first
	function putShort(n, arr) {
		arr.push(n & 0xFF);
		arr.push(n >>> 8);
	}

	// LSB first
	function putLong(n, arr) {
		putShort(n & 0xffff, arr);
		putShort(n >>> 16, arr);
	}

	function putString(s, arr) {
		var i, len = s.length;
		for (i = 0; i < len; i += 1) {
			putByte(s.charCodeAt(i), arr);
		}
	}

	function readByte(arr) {
		return arr.shift();
	}

	function readShort(arr) {
		return arr.shift() | (arr.shift() << 8);
	}

	function readLong(arr) {
		var n1 = readShort(arr),
			n2 = readShort(arr);

		// JavaScript can't handle bits in the position 32
		// we'll emulate this by removing the left-most bit (if it exists)
		// and add it back in via multiplication, which does work
		if (n2 > 32768) {
			n2 -= 32768;

			return ((n2 << 16) | n1) + 32768 * Math.pow(2, 16);
		}

		return (n2 << 16) | n1;
	}

	function readString(arr) {
		var charArr = [];

		// turn all bytes into chars until the terminating null
		while (arr[0] !== 0) {
			charArr.push(String.fromCharCode(arr.shift()));
		}

		// throw away terminating null
		arr.shift();

		// join all characters into a cohesive string
		return charArr.join('');
	}

	/*
	 * Reads n number of bytes and return as an array.
	 *
	 * @param arr- Array of bytes to read from
	 * @param n- Number of bytes to read
	 */
	function readBytes(arr, n) {
		var i, ret = [];
		for (i = 0; i < n; i += 1) {
			ret.push(arr.shift());
		}

		return ret;
	}

	/*
	 * ZIPs a file in GZIP format. The format is as given by the spec, found at:
	 * http://www.gzip.org/zlib/rfc-gzip.html
	 *
	 * Omitted parts in this implementation:
	 */
	function zip(data, options) {
		var flags = 0,
			level,
			crc, out = [];

		if (!options) {
			options = {};
		}
		level = options.level || DEFAULT_LEVEL;

		if (typeof data === 'string') {
			data = Array.prototype.map.call(data, function (char) {
				return char.charCodeAt(0);
			});
		}

		// magic number marking this file as GZIP
		putByte(ID1, out);
		putByte(ID2, out);

		putByte(compressionMethods['deflate'], out);

		if (options.name) {
			flags |= possibleFlags['FNAME'];
		}

		putByte(flags, out);
		putLong(options.timestamp || parseInt(Date.now() / 1000, 10), out);

		// put deflate args (extra flags)
		if (level === 1) {
			// fastest algorithm
			putByte(4, out);
		} else if (level === 9) {
			// maximum compression (fastest algorithm)
			putByte(2, out);
		} else {
			putByte(0, out);
		}

		// OS identifier
		putByte(osMap[os], out);

		if (options.name) {
			// ignore the directory part
			putString(options.name.substring(options.name.lastIndexOf('/') + 1), out);

			// terminating null
			putByte(0, out);
		}

		deflate.deflate(data, level).forEach(function (byte) {
			putByte(byte, out);
		});

		putLong(parseInt(crc32(data), 16), out);
		putLong(data.length, out);

		return out;
	}

	function unzip(data, options) {
		// start with a copy of the array
		var arr = Array.prototype.slice.call(data, 0),
			t,
			compressionMethod,
			flags,
			mtime,
			xFlags,
			key,
			os,
			crc,
			size,
			res;

		// check the first two bytes for the magic numbers
		if (readByte(arr) !== ID1 || readByte(arr) !== ID2) {
			throw 'Not a GZIP file';
		}

		t = readByte(arr);
		t = Object.keys(compressionMethods).some(function (key) {
			compressionMethod = key;
			return compressionMethods[key] === t;
		});

		if (!t) {
			throw 'Unsupported compression method';
		}

		flags = readByte(arr);
		mtime = readLong(arr);
		xFlags = readByte(arr);
		t = readByte(arr);
		Object.keys(osMap).some(function (key) {
			if (osMap[key] === t) {
				os = key;
				return true;
			}
		});

		// just throw away the bytes for now
		if (flags & possibleFlags['FEXTRA']) {
			t = readShort(arr);
			readBytes(arr, t);
		}

		// just throw away for now
		if (flags & possibleFlags['FNAME']) {
			readString(arr);
		}

		// just throw away for now
		if (flags & possibleFlags['FCOMMENT']) {
			readString(arr);
		}

		// just throw away for now
		if (flags & possibleFlags['FHCRC']) {
			readShort(arr);
		}
		
		if (compressionMethod === 'deflate') {
			// give deflate everything but the last 8 bytes
			// the last 8 bytes are for the CRC32 checksum and filesize
			res = inflate.inflate(arr.splice(0, arr.length - 8));
		}

		if (flags & possibleFlags['FTEXT']) {
			res = Array.prototype.map.call(res, function (byte) {
				return String.fromCharCode(byte);
			}).join('');
		}
	
		crc = readLong(arr);
		if (crc !== parseInt(crc32(res), 16)) {
			throw 'Checksum does not match';
		}

		size = readLong(arr);
		if (size !== res.length) {
			throw 'Size of decompressed file not correct';
		}

		return res;
	}

	return {
		zip: zip,
		unzip: unzip,
		get DEFAULT_LEVEL() {
			return DEFAULT_LEVEL;
		}
	};
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

define('gw/Layer/FitsRequest',["../Utils/ImageRequest", "../Utils/Constants", "../Gui/dialog/ErrorDialog", "../Utils/Proxy"], function(ImageRequest, Constants, ErrorDialog, Proxy) {
    /**************************************************************************************************************/

    /*
     *	Override send function to handle fits requests
     */
    ImageRequest.prototype.send = function(url, crossOrigin, noRequest) {
        var self = this;
        if (noRequest || url == null) {
            self.failCallback(self);
            return;
        }
        if (url.search("fits") > 0) {
            // Fits
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(e) {
                if (xhr && xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        if (xhr.response) {
                            self.image = xhr.response;
                            if (self.successCallback) {
                                self.successCallback(self);
                            }
                        }
                    } else {
                        if (xhr.status !== 0) {
                            // Fail
                            ErrorDialog.open(Constants.LEVEL.ERROR, "Error while loading " + url);
                            if (self.failCallback) {
                                self.failCallback(self);
                            }
                        }
                    }
                    xhr = null;
                }
            };

            xhr.onabort = function(e) {
                if (self.abortCallback) {
                    self.abortCallback(self);
                }
                self.xhr = null;
            };

            xhr.open("GET", Proxy.proxify(url));
            xhr.responseType = "arraybuffer";
            xhr.send();
            this.xhr = xhr;
        } else {
            this.image = new Image();
            this.image.aborted = false;
            this.image.crossOrigin = "";
            this.image.dataType = "byte";
            this.image.onload = function() {
                var isComplete =
                    self.image.naturalWidth !== 0 && self.image.complete;
                if (isComplete && !this.aborted) {
                    self.successCallback(self);
                }
            };
            this.image.onerror = function() {
                if (self.failCallback && !this.aborted) {
                    self.failCallback(self);
                }
            };
            this.image.src = Proxy.proxify(url);
        }
    };

    /**************************************************************************************************************/

    /*
     *	Override abort
     */
    ImageRequest.prototype.abort = function() {
        if (this.xhr) {
            this.xhr.abort();
        } else {
            if (this.abortCallback) {
                this.abortCallback(this);
            }
            this.image.aborted = true;
            this.image.src = "";
        }
    };

    /**************************************************************************************************************/
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/HipsFitsLayer',[
    "../Utils/Constants",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Tiling/HEALPixTiling",
    "./AbstractHipsLayer",
    "../Renderer/DynamicImage",
    "./FitsLoader",
    "gzip",
    "../Utils/ImageRequest",
    "./FitsRequest",
    "../Gui/dialog/ErrorDialog"
], function(
    Contants,
    Utils,
    Constants,
    HEALPixTiling,
    AbstractHipsLayer,
    DynamicImage,
    FitsLoader,
    gZip,
    ImageRequest,
    ErrorDialog
) {
    /**************************************************************************************************************/

    /**
     * HipsFits configuration
     * @typedef {AbstractHipsLayer.configuration} AbstractHipsLayer.hipsFits_configuration
     * @property {Function} onready - Callback function
     */

    /**
     * @name HipsFitsLayer
     * @class
     * This layer draws an Hips Fits Image
     * @augments AbstractHipsLayer
     * @param {Object} hipsMetadata - HIPS Metadata
     * @param {AbstractHipsLayer.hipsFits_configuration} options - HipsFits configuration
     * @memberof module:Layer
     * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
     */
    var HipsFitsLayer = function(hipsMetadata, options) {
        AbstractHipsLayer.prototype.constructor.call(
            this,
            hipsMetadata,
            options
        );

        this._ready = false;
        this.fitsSupported = true;

        // allsky
        this.levelZeroImage = null;

        // TODO use DynamicImage shaders by unifying shader programs between TileManager and ConvexPolygonRenderer
        //		* inverse Y coordinates, some var names refactor..
        this.rawFragShader = "precision lowp float; \n";
        this.rawFragShader += "varying vec2 texCoord;\n";
        this.rawFragShader += "uniform sampler2D colorTexture; \n";
        this.rawFragShader += "uniform float opacity; \n";
        this.rawFragShader += "uniform float inversed; \n";
        this.rawFragShader += "bool isnan(float val) {\n";
        this.rawFragShader +=
            "		return (val <= 0.0 || 0.0 <= val) ? ((val == 5e-324) ? true : false) : true;\n";
        this.rawFragShader += "}\n";
        this.rawFragShader += "void main(void)\n";
        this.rawFragShader += "{\n";
        this.rawFragShader +=
            "	vec4 color = texture2D(colorTexture, vec2(texCoord.x, (inversed == 1.) ? 1.0 - texCoord.y : texCoord.y));\n";
        this.rawFragShader +=
            "	gl_FragColor = vec4(color.r,color.g,color.b, color.a*opacity);\n";
        this.rawFragShader +=
            "	if (isnan( (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3. ) )\n";
        this.rawFragShader += "	{\n";
        this.rawFragShader += "		gl_FragColor.a = 0.;\n";
        this.rawFragShader += "	}\n";
        this.rawFragShader += "}\n";

        this.colormapFragShader = "precision lowp float; \n";
        this.colormapFragShader += "varying vec2 texCoord;\n";
        this.colormapFragShader += "uniform sampler2D colorTexture; \n";
        this.colormapFragShader += "uniform sampler2D colormap; \n";
        this.colormapFragShader += "uniform float min; \n";
        this.colormapFragShader += "uniform float max; \n";
        this.colormapFragShader += "uniform float opacity; \n";
        this.colormapFragShader += "bool isnan(float val) {\n";
        this.colormapFragShader +=
            "	return (val <= 0.0 || 0.0 <= val) ? false : true;\n";
        this.colormapFragShader += "}\n";
        this.colormapFragShader += "void main(void)\n";
        this.colormapFragShader += "{\n";
        this.colormapFragShader +=
            "	float i = texture2D(colorTexture,vec2(texCoord.x, 1.0 - texCoord.y)).r;\n";
        this.colormapFragShader +=
            "	float d = clamp( ( i - min ) / (max - min), 0.0, 1.0 );\n";
        this.colormapFragShader +=
            "	vec4 cmValue = texture2D(colormap, vec2(d,0.));\n";
        this.colormapFragShader +=
            "	gl_FragColor = vec4(cmValue.r,cmValue.g,cmValue.b, cmValue.a*opacity);\n";
        this.colormapFragShader += "	if (isnan( i ) )\n";
        this.colormapFragShader += "	{\n";
        this.colormapFragShader += "		 gl_FragColor.a = 0.;\n";
        this.colormapFragShader += "	}\n";
        this.colormapFragShader += "}\n";

        var self = this;

        this.customShader = {
            fragmentCode: this.rawFragShader,
            updateUniforms: function(gl, program) {
                // Level zero image is required to init uniforms
                gl.uniform1f(program.uniforms.inversed, self.inversed);
                if (self.levelZeroImage) {
                    gl.uniform1f(
                        program.uniforms.max,
                        self.levelZeroImage.tmax
                    );
                    gl.uniform1f(
                        program.uniforms.min,
                        self.levelZeroImage.tmin
                    );

                    gl.activeTexture(gl.TEXTURE1);
                    gl.bindTexture(
                        gl.TEXTURE_2D,
                        self.levelZeroImage.colormapTex
                    );
                    gl.uniform1i(program.uniforms.colormap, 1);
                    gl.uniform1f(program.uniforms.opacity, self.getOpacity());
                }
            }
        };

        // Request for level zero image
        this.imageRequest = new ImageRequest({
            successCallback: function() {
                var data, res;
                self._ready = true;

                if (self.format === "fits") {
                    // Unzip if g-zipped
                    try {
                        data = new Uint8Array(self.imageRequest.image);
                        res = gZip.unzip(data);
                        self.imageRequest.image = new Uint8Array(res).buffer;
                    } catch (err) {
                        if (err !== "Not a GZIP file") {
                            // G-zip error
                            this.failCallback();
                            return;
                        } else {
                            // Image isn't g-zipped, handle image as fits
                            data = null;
                        }
                    }

                    self.handleImage(self.imageRequest);
                    var fitsData = self.imageRequest.image;
                    if (self.globe) {
                        // Create level zero image
                        var gl = self.globe.getRenderContext().gl;
                        self.levelZeroImage = new DynamicImage(
                            self.globe.getRenderContext(),
                            fitsData.typedArray,
                            gl.LUMINANCE,
                            gl.FLOAT,
                            fitsData.width,
                            fitsData.height
                        );
                        self.getLevelZeroTexture = function() {
                            return self.levelZeroImage.texture;
                        };
                    }
                } else {
                    self.levelZeroImage = this.image;
                    self.getLevelZeroTexture = null;
                }

                // Call callback if set
                if (options.onready && options.onready instanceof Function) {
                    options.onready(self);
                }

                // Request a frame
                if (self.globe) {
                    self.globe.getRenderContext().requestFrame();
                }
            },
            /**
             * @fires Context#baseLayersError
             */
            failCallback: function() {
                if (self.globe) {
                    self.globe.publishEvent(
                        Constants.EVENT_MSG.BASE_LAYERS_ERROR,
                        self
                    );
                    self._ready = false;
                }
            },
            abortCallback: function(iq) {
                self._ready = false;
            }
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractHipsLayer, HipsFitsLayer);

    /**************************************************************************************************************/

    /**
     * Attach the Hips Fits layer to the globe
     * @function _attach
     * @memberof HipsFitsLayer.prototype
     * @param {AbstractGlobe} g Globe to attach
     * @private
     */
    HipsFitsLayer.prototype._attach = function(g) {
        AbstractHipsLayer.prototype._attach.call(this, g);

        // Enable float texture extension to have higher luminance range
        var gl = this.getGlobe().getRenderContext().gl;

        this.requestLevelZeroImage();
        var ext = gl.getExtension("OES_texture_float");

        if (!ext) {
            // TODO
            ErrorDialog.open(Constants.LEVEL.DEBUG, "HipsFitsLayer.js", "no OES_texture_float");
            this.fitsSupported = false;
            //return;
        }
    };

    /**************************************************************************************************************/

    /**
     * Detach the Hips Fits layer from the globe
     * @function _detach
     * @memberof HipsFitsLayer#
     * @private
     */
    HipsFitsLayer.prototype._detach = function() {
        // Abort image request if in progress
        if (!this._ready) {
            this.imageRequest.abort();
        }
        this._ready = false;
        this.disposeResources();

        AbstractHipsLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    /**
     * Get url from a given tile
     * @function getUrl
     * @memberof HipsFitsLayer#
     * @param {Tile} tile Tile object
     */
    HipsFitsLayer.prototype.getUrl = function(tile) {
        var url = this.baseUrl;

        url += "/Norder";
        url += tile.order;

        url += "/Dir";
        url += Math.floor(tile.pixelIndex / 10000.0) * 10000.0;

        url += "/Npix";
        url += tile.pixelIndex;
        url += "." + this.format;

        return this.allowRequest(url);
    };

    /**************************************************************************************************************/

    /**
     * Extracts fits data from levelZeroImage.pixels to fitsPixel according to pixel index
     * @function extractFitsData
     * @memberof HipsFitsLayer#
     * @param pi Pixel index
     * @param fitsPixel Resulting typed vector containing fits data
     * @param sx X-offset of fitsPixel
     * @param sy Y-offset of fitsPixel
     */
    HipsFitsLayer.prototype.extractFitsData = function(pi, fitsPixel, sx, sy) {
        var size = 64;
        var height = this.levelZeroImage.height;
        var width = this.levelZeroImage.width;
        var pixels = this.levelZeroImage.pixels;

        var startIndex =
            size * width * (28 - Math.floor(pi / 27)) + (pi % 27) * size;

        // Extract fits data
        var typedLine;
        for (var i = 0; i < size; i++) {
            typedLine = pixels.subarray(
                startIndex + i * width,
                startIndex + i * width + size
            );
            fitsPixel.set(typedLine, sy + i * 128 + sx);
        }
    };

    /**************************************************************************************************************/

    /**
     * Generates the level0 texture for the tiles
     * @function generateLevel0Textures
     * @memberof HipsFitsLayer#
     * @param tiles
     * @param tilePool
     */
    HipsFitsLayer.prototype.generateLevel0Textures = function(tiles, tilePool) {
        var fitsPixel;
        var pi, sx, sy;
        var i, tile;
        var imgData;
        if (this.format !== "fits") {
            // Create a canvas to build the texture
            var canvas = document.createElement("canvas");
            canvas.width = 128;
            canvas.height = 128;
            var context = canvas.getContext("2d");

            for (i = 0; i < tiles.length; i++) {
                tile = tiles[i];

                // Top left
                pi = tile.pixelIndex * 4;
                sx = (pi % 27) * 64;
                sy = Math.floor(pi / 27) * 64;
                context.drawImage(
                    this.levelZeroImage,
                    sx,
                    sy,
                    64,
                    64,
                    0,
                    0,
                    64,
                    64
                );

                // Top right
                pi = tile.pixelIndex * 4 + 2;
                sx = (pi % 27) * 64;
                sy = Math.floor(pi / 27) * 64;
                context.drawImage(
                    this.levelZeroImage,
                    sx,
                    sy,
                    64,
                    64,
                    64,
                    0,
                    64,
                    64
                );

                // Bottom left
                pi = tile.pixelIndex * 4 + 1;
                sx = (pi % 27) * 64;
                sy = Math.floor(pi / 27) * 64;
                context.drawImage(
                    this.levelZeroImage,
                    sx,
                    sy,
                    64,
                    64,
                    0,
                    64,
                    64,
                    64
                );

                // Bottom right
                pi = tile.pixelIndex * 4 + 3;
                sx = (pi % 27) * 64;
                sy = Math.floor(pi / 27) * 64;
                context.drawImage(
                    this.levelZeroImage,
                    sx,
                    sy,
                    64,
                    64,
                    64,
                    64,
                    64,
                    64
                );

                imgData = context.getImageData(0, 0, 128, 128);
                imgData.dataType = "byte";

                tile.texture = tilePool.createGLTexture(imgData);
                tile.imageSize = 128;
            }
        } else {
            for (i = 0; i < tiles.length; i++) {
                tile = tiles[i];
                fitsPixel = new Float32Array(128 * 128);

                // Top left
                pi = tile.pixelIndex * 4;
                this.extractFitsData(pi, fitsPixel, 0, 128 * 64);

                // Top right
                pi = tile.pixelIndex * 4 + 2;
                this.extractFitsData(pi, fitsPixel, 64, 128 * 64);

                // Bottom left
                pi = tile.pixelIndex * 4 + 1;
                this.extractFitsData(pi, fitsPixel, 0, 0);

                // Bottom right
                pi = tile.pixelIndex * 4 + 3;
                this.extractFitsData(pi, fitsPixel, 64, 0);

                imgData = {
                    typedArray: fitsPixel,
                    width: 128,
                    height: 128,
                    dataType: "float"
                };

                tile.texture = tilePool.createGLTexture(imgData);
                tile.imageSize = 128;
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Handles the fits image.
     * @function handleImage
     * @memberof HipsFitsLayer#
     * @param imgRequest
     */
    HipsFitsLayer.prototype.handleImage = function(imgRequest) {
        if (!(imgRequest.image instanceof Image)) {
            var fits = FitsLoader.parseFits(imgRequest.image);
            var fitsData = fits.getHDU().data;
            var bpe = fitsData.arrayType.BYTES_PER_ELEMENT;
            var float32array, float64array;
            var i;
            if (fitsData.arrayType.name === "Float64Array") {
                float64array = new Float64Array(
                    fitsData.view.buffer,
                    fitsData.begin,
                    fitsData.length / bpe
                ); // bpe = 8
                float32array = new Float32Array(fitsData.length / bpe);
                // Create Float32Array from Float64Array
                for (i = 0; i < float64array.length; i++) {
                    float32array[i] = float64array[i];
                }
            } else {
                float32array = new Float32Array(
                    fitsData.view.buffer,
                    fitsData.begin,
                    fitsData.length / bpe
                ); // with gl.FLOAT, bpe = 4
            }

            // // Handle different types/formats.. just in case.
            // var dataType;
            // var typedArray;
            // var gl = this.globe.getRenderContext().gl;
            // var glType;
            // if ( fitsData.arrayType.name == "Float32Array" )
            // {
            // 	typedArray = new Float32Array( fitsData.view.buffer, fitsData.begin, fitsData.length/fitsData.arrayType.BYTES_PER_ELEMENT );
            // 	dataType = "float";
            // 	glType = gl.FLOAT;
            // 	glFormat = gl.LUMINANCE;
            // }
            // else if ( fitsData.arrayType.name == "Uint8Array" )
            // {
            // 	typedArray = new Uint8Array( fitsData.view.buffer, fitsData.begin, fitsData.length/fitsData.arrayType.BYTES_PER_ELEMENT )
            // 	dataType = "int";
            // 	glType = gl.UNSIGNED_BYTE;
            // 	glFormat = gl.LUMINANCE;
            // }

            imgRequest.image = {
                typedArray: float32array,
                width: fitsData.width,
                height: fitsData.height,
                dataType: "float"
            };
        }
    };

    /**************************************************************************************************************/

    /**
     * Requests level zero image
     * @function requestLevelZeroImage
     * @memberof HipsFitsLayer#
     */
    HipsFitsLayer.prototype.requestLevelZeroImage = function() {
        // Set dataType always to jpg if fits isn't supported by graphic card
        if (!this.fitsSupported) {
            this.format = "jpg";
        }

        // Revert to raw rendering
        this.customShader.fragmentCode = this.rawFragShader;
        if (this.format === "fits") {
            this.inversed = 1.0;
        } else {
            this.inversed = 0.0;
        }

        var url = this.baseUrl + "/Norder3/Allsky." + this.format;
        this.imageRequest.send(url);
    };

    /**************************************************************************************************************/

    /**
     * Disposes the allocated resources
     * @function disposeResources
     * @memberof HipsFitsLayer#
     */
    HipsFitsLayer.prototype.disposeResources = function() {
        // Dispose level zero image & texture
        if (this.levelZeroImage && this.levelZeroImage.dispose) {
            this.levelZeroImage.dispose();
        }
        if (this.levelZeroTexture) {
            this.getGlobe()
                .getRenderContext()
                .gl.deleteTexture(this.levelZeroTexture);
        }

        this.levelZeroImage = null;
        this.levelZeroTexture = null;
    };

    /**************************************************************************************************************/

    return HipsFitsLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Layer/WMSElevationLayer',["../Utils/Utils", "./WMSLayer"], function(Utils, WMSLayer) {
    /**
     * WCSElevation configuration
     * @typedef {AbstractRasterLayer.wms_configuration} AbstractRasterLayer.wmsElevation_configuration
     * @property {int} [tilePixelSize = 33]
     */

    /**
     * @name WMSElevationLayer
     * @class
     *    Creates a layer for elevation data using WMS protocol based on a GeoTiling(4, 2)
     *    with a pixelSize = 33 by default. The only supported format is currently image/x-aaigrid.
     * @augments WMSLayer
     * @param {AbstractLayer.wmsElevation_configuration} options - WMSElevation configuration
     * @constructor
     * @memberof module:Layer
     */
    var WMSElevationLayer = function(options) {
        options.format = "image/x-aaigrid";
        options.tilePixelSize = options.tilePixelSize || 33;
        WMSLayer.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(WMSLayer, WMSElevationLayer);

    /**************************************************************************************************************/

    /**
     * Parse a elevation response
     * @function parseElevations
     * @memberof WMSElevationLayer#
     * @param {string} text Response as text
     * @return {float[]} Array of float
     */
    WMSElevationLayer.prototype.parseElevations = function(text) {
        var elevations = [];
        var lines = text.trim().split("\n");

        for (var i = 5; i < lines.length; i++) {
            var elts = lines[i].trim().split(/\s+/);
            for (var n = 0; n < elts.length; n++) {
                elevations.push(parseInt(elts[n], 10));
            }
        }

        return elevations;
    };

    /**************************************************************************************************************/

    return WMSElevationLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/RendererManager',["../Utils/Constants", "./RasterOverlayRenderer", "./GroundOverlayRenderer","../Gui/dialog/ErrorDialog"], function(
    Constants,
    RasterOverlayRenderer,
    GroundOverlayRenderer,
    ErrorDialog
) {
    /**************************************************************************************************************/

    /**
     @name RendererManager
     @class
         RendererManager constructor
     @param {AbstractGlobe} globe AbstractGlobe
     @constructor
     */
    var RendererManager = function(globe) {
        // Create the registered renderers
        this.renderers = [];
        for (var i = 0; i < RendererManager.factory.length; i++) {
            this.renderers.push(RendererManager.factory[i](globe));
        }

        // The array of renderables used during rendering
        this.renderables = [];

        // To uniquely identify buckets created by the renderers
        this.bucketId = 0;
    };

    /**************************************************************************************************************/

    /**
     The factory for renderers
     */
    RendererManager.factory = [];

    /**************************************************************************************************************/

    /**
     * Set the selected layer on the top.
     * @function setSelectedRasterBucket
     * @memberof RendererManager.prototype
     * @param selectedLayer Layer to draw on the top
     */
    RendererManager.prototype.setSelectedRasterBucket = function(selectedLayer) {
        var rendererIdx = this.renderers.length;
        while (rendererIdx--) {
            var renderer = this.renderers[rendererIdx];
            if (renderer instanceof RasterOverlayRenderer || renderer instanceof GroundOverlayRenderer) {
                var buckets = renderer.buckets;
                var bucketIdx = buckets.length;
                while (bucketIdx--) {
                    var bucket = buckets[bucketIdx];
                    var layer = bucket.layer;
                    if (
                        bucket.style.zIndex ==
                            Constants.DISPLAY.SELECTED_RASTER &&
                        bucket.style.zIndex <= Constants.DISPLAY.SELECTED_RASTER
                    ) {
                        bucket.style.zIndex = Constants.DISPLAY.DEFAULT_RASTER;
                    }
                    if (
                        layer.getID() === selectedLayer.getID() &&
                        bucket.style.zIndex <= Constants.DISPLAY.SELECTED_RASTER
                    ) {
                        bucket.style.zIndex = Constants.DISPLAY.SELECTED_RASTER;
                    }
                }
            }
        }
    };

    /**
     * Get a renderer
     * @function getRenderer
     * @memberof RendererManager.prototype
     * @param geometry
     * @param style
     * @return Renderer
     */
    RendererManager.prototype.getRenderer = function(geometry, style) {
        for (var i = 0; i < this.renderers.length; i++) {
            if (this.renderers[i].canApply(geometry.type, style)) {
                return this.renderers[i];
            }
        }

        return null;
    };

    /**************************************************************************************************************/

    /**
     *    Generate the tile data
     * @function generate
     * @memberof RendererManager.prototype
     * @param {Tile} tile Tile
     */
    RendererManager.prototype.generate = function(tile) {
        var i;
        if (!tile.parent) {
            for (i = 0; i < this.renderers.length; i++) {
                this.renderers[i].generateLevelZero(tile);
            }
        } else {
            var tileData = tile.parent.extension.renderer;
            if (tileData) {
                // delete renderer created at init time
                delete tile.extension.renderer;

                // Now generate renderables
                for (i = 0; i < tileData.renderables.length; i++) {
                    var renderable = tileData.renderables[i];
                    if (renderable.generateChild) {
                        renderable.generateChild(tile);
                    }
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to the renderer
     * @function addGeometry
     * @memberof RendererManager.prototype
     * @param layer
     * @param geometry
     * @param style
     */
    RendererManager.prototype.addGeometry = function(layer, geometry, style) {
        var renderer = this.getRenderer(geometry, style);
        if (renderer) {
            renderer.addGeometry(layer, geometry, style);
        } else {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "RendererManager.js", "No renderer for RendererManager");
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from the renderer
     * @function removeGeometry
     * @memberof RendererManager.prototype
     * @param geometry
     * @param layer
     * @return {Boolean}
     */
    RendererManager.prototype.removeGeometry = function(geometry, layer) {
        var bucket = geometry._bucket;
        if (bucket && bucket.layer === layer) {
            /*if (layer.type === "OpenSearch") {
             if (bucket.renderer.removeGeometryOneLevel(geometry) !== "undefined") {
             bucket.renderer.removeGeometryOneLevel(geometry);
             return true;
             }
             }*/
            bucket.renderer.removeGeometry(geometry);
            return true;
        }
        return false;
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to a tile
     * @function addGeometryToTile
     * @memberof RendererManager.prototype
     * @param layer
     * @param geometry
     * @param style
     * @param {Tile} tile Tile
     */
    RendererManager.prototype.addGeometryToTile = function(
        layer,
        geometry,
        style,
        tile
    ) {
        var renderer = this.getRenderer(geometry, style);
        renderer.addGeometryToTile(layer, geometry, style, tile);
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from a tile
     * @function removeGeometryFromTile
     * @memberof RendererManager.prototype
     * @param geometry
     * @param {Tile} tile Tile
     */
    RendererManager.prototype.removeGeometryFromTile = function(
        geometry,
        tile
    ) {
        var bucket = geometry._bucket;
        bucket.renderer.removeGeometryFromTile(geometry, tile, false);
    };

    /**************************************************************************************************************/

    /**
     * Function to sort with zIndex, then bucket
     */
    var renderableSort = function(r1, r2) {
        var zdiff = r1.bucket.style.zIndex - r2.bucket.style.zIndex;
        if (zdiff === 0) {
            return r1.bucket.id - r2.bucket.id;
        } else {
            return zdiff;
        }
    };

    /**************************************************************************************************************/

    /**
     * Render all
     * @function render
     * @memberof RendererManager.prototype
     */
    RendererManager.prototype.render = function() {
        // Add main renderables
        var i, j;
        for (j = 0; j < this.renderers.length; j++) {
            var buckets = this.renderers[j].buckets;
            for (i = 0; i < buckets.length; i++) {
                if (buckets[i].layer.isVisible() && buckets[i].mainRenderable) {
                    this.renderables.push(buckets[i].mainRenderable);
                }
            }
        }

        // Renderable sort
        this.renderables.sort(renderableSort);
        //var renderCall = 0;

        i = 0;
        while (i < this.renderables.length) {
            j = i + 1;
            var currentRenderer = this.renderables[i].bucket.renderer;
            while (
                j < this.renderables.length &&
                this.renderables[j].bucket.renderer === currentRenderer
            ) {
                j++;
            }

            //var minLevel =  (this.renderables[i].bucket.layer.minLevel) ? this.renderables[i].bucket.layer.minLevel : 0;
            //var processedLevel = this.renderables[i].bucket.renderer.tileManager.processedLevel;
            //if(minLevel <= processedLevel) {
            currentRenderer.render(this.renderables, i, j);
            //}
            //renderCall++;

            i = j;
        }

        //console.log( "# of render calls "  + renderCall );

        this.renderables.length = 0;
    };

    /**************************************************************************************************************/

    return RendererManager;
});

!function(t,e){"function"==typeof define&&define.amd?define('jsvotable',["jquery"],e):t.mylib=e(t.$)}(this,function(t){var e,n,r;return function(t){function o(t,e){return T.call(t,e)}function i(t,e){var n,r,o,i,s,a,u,c,p,f,l=e&&e.split("/"),h=m.map,d=h&&h["*"]||{};if(t&&"."===t.charAt(0))if(e){for(l=l.slice(0,l.length-1),t=l.concat(t.split("/")),c=0;c<t.length;c+=1)if("."===(f=t[c]))t.splice(c,1),c-=1;else if(".."===f){if(1===c&&(".."===t[2]||".."===t[0]))break;c>0&&(t.splice(c-1,2),c-=2)}t=t.join("/")}else 0===t.indexOf("./")&&(t=t.substring(2));if((l||d)&&h){for(n=t.split("/"),c=n.length;c>0;c-=1){if(r=n.slice(0,c).join("/"),l)for(p=l.length;p>0;p-=1)if((o=h[l.slice(0,p).join("/")])&&(o=o[r])){i=o,s=c;break}if(i)break;!a&&d&&d[r]&&(a=d[r],u=c)}!i&&a&&(i=a,s=u),i&&(n.splice(0,s,i),t=n.join("/"))}return t}function s(e,n){return function(){return h.apply(t,A.call(arguments,0).concat([e,n]))}}function a(t){return function(e){return i(e,t)}}function u(t){return function(e){b[t]=e}}function c(e){if(o(g,e)){var n=g[e];delete g[e],v[e]=!0,l.apply(t,n)}if(!o(b,e)&&!o(v,e))throw new Error("No "+e);return b[e]}function p(t){var e,n=t?t.indexOf("!"):-1;return n>-1&&(e=t.substring(0,n),t=t.substring(n+1,t.length)),[e,t]}function f(t){return function(){return m&&m.config&&m.config[t]||{}}}var l,h,d,y,b={},g={},m={},v={},T=Object.prototype.hasOwnProperty,A=[].slice;d=function(t,e){var n,r=p(t),o=r[0];return t=r[1],o&&(o=i(o,e),n=c(o)),o?t=n&&n.normalize?n.normalize(t,a(e)):i(t,e):(t=i(t,e),r=p(t),o=r[0],t=r[1],o&&(n=c(o))),{f:o?o+"!"+t:t,n:t,pr:o,p:n}},y={require:function(t){return s(t)},exports:function(t){var e=b[t];return void 0!==e?e:b[t]={}},module:function(t){return{id:t,uri:"",exports:b[t],config:f(t)}}},l=function(e,n,r,i){var a,p,f,l,h,m,T=[];if(i=i||e,"function"==typeof r){for(n=!n.length&&r.length?["require","exports","module"]:n,h=0;h<n.length;h+=1)if(l=d(n[h],i),"require"===(p=l.f))T[h]=y.require(e);else if("exports"===p)T[h]=y.exports(e),m=!0;else if("module"===p)a=T[h]=y.module(e);else if(o(b,p)||o(g,p)||o(v,p))T[h]=c(p);else{if(!l.p)throw new Error(e+" missing "+p);l.p.load(l.n,s(i,!0),u(p),{}),T[h]=b[p]}f=r.apply(b[e],T),e&&(a&&a.exports!==t&&a.exports!==b[e]?b[e]=a.exports:f===t&&m||(b[e]=f))}else e&&(b[e]=r)},e=n=h=function(e,n,r,o,i){return"string"==typeof e?y[e]?y[e](n):c(d(e,n).f):(e.splice||(m=e,n.splice?(e=n,n=r,r=null):e=t),n=n||function(){},"function"==typeof r&&(r=o,o=i),o?l(t,e,n,r):setTimeout(function(){l(t,e,n,r)},4),h)},h.config=function(t){return m=t,m.deps&&h(m.deps,m.callback),h},r=function(t,e,n){e.splice||(n=e,e=[]),o(b,t)||o(g,t)||(g[t]=[t,e,n])},r.amd={jQuery:!0}}(),r("../minify/almond",function(){}),r("utils",[],function(){var t={};return t.inherits=function(t,e){function n(){}n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e},t.makeHttpObject=function(){try{return new XMLHttpRequest}catch(t){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(t){}try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(t){}throw new Error("The object creation for making HTTP requests has failed.")},t.guid=function(){function t(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}return t()+t()+"-"+t()+"-"+t()+"-"+t()+"-"+t()+t()+t()},t.findValueByKeyword=function(t,e){var n=void 0;for(i=0;i<t.length;i++){var r=t[i];if(r[0]===e){n=r[1];break}}return n},t.parseXML=function(t){if(document.implementation&&document.implementation.createDocument)xmlDoc=(new DOMParser).parseFromString(t,"text/xml");else{if(!window.ActiveXObject)return alert("Your browser cannot handle this script"),null;xmlDoc=new ActiveXObject("Microsoft.XMLDOM"),xmlDoc.loadXML(t)}return xmlDoc},t}),r("cache",[],function(){var t=function(){this.nodeID={},this.nodeName={},this.warnings=[]};return t.prototype.getEltsByID=function(){return this.nodeID},t.prototype.getEltsByName=function(){return this.nodeName},t.prototype.getWarnings=function(){return this.warnings},t.prototype.addEntryID=function(t,e){this.nodeID[t]=e},t.prototype.addEntryName=function(t,e){this.nodeName.hasOwnProperty(t)?this.nodeName[t].push(e):(this.nodeName[t]=[],this.nodeName[t].push(e))},t.prototype.addWarning=function(t){this.warnings.push(t)},t}),r("abstractNode",["./utils","./cache"],function(t,e){var n=function(t,e){if(void 0===e)throw new Error("tagName is undefined for "+t);if(this.tagName=e,this.attributes={},null!=t&&1==t.nodeType){for(var n=0,o=t.attributes.length;n<o;n++){var i=t.attributes[n];this.attributes[i.name]=i.value}if(this.attributes.hasOwnProperty("ID")){var s=r.getInstance();s.addEntryID(this.attributes.ID,this)}if(this.attributes.hasOwnProperty("name")){var s=r.getInstance();s.addEntryName(this.attributes.name,this)}}};n.prototype.getAttributes=function(){return this.attributes},n.prototype.hasAttribute=function(t){return this.attributes.hasOwnProperty(t)},n.prototype.hasAttributes=function(){return 0!=Object.keys(this.attributes).length},n.prototype.getTagName=function(){return this.tagName},n.prototype.getCache=function(){return r.getInstance()};var r=function(){function t(){return new e}var n;return{getInstance:function(){return n||(n=t()),n}}}();return n}),r("constants",[],function(){var t=function(){};return t.API={version:"2.0.2"},t.TAG={BINARY:"BINARY",BINARY2:"BINARY2",COOSYS:"COOSYS",DATA:"DATA",DEFINITIONS:"DEFINITIONS",DESCRIPTION:"DESCRIPTION",FIELD:"FIELD",FIELDref:"FIELDref",FITS:"FITS",GROUP:"GROUP",INFO:"INFO",VOTABLE:"VOTABLE",LINK:"LINK",MAX:"MAX",MIN:"MIN",OPTION:"OPTION",PARAM:"PARAM",PARAMref:"PARAMref",RESOURCE:"RESOURCE",STREAM:"STREAM",TABLE:"TABLE",TABLEDATA:"TABLEDATA",TD:"TD",TR:"TR",VALUES:"VALUES"},t}),r("description",["./utils","./abstractNode","./constants"],function(t,e,n){var r=function(t){e.prototype.constructor.call(this,t,n.TAG.DESCRIPTION),this.value;var r=t.childNodes[0];null!=r&&3==r.nodeType&&(this.value=null==r.textContent?null:r.textContent.trim())};return t.inherits(e,r),r.prototype.getContent=function(){return this.value},r}),r("fieldref",["./utils","./abstractNode","./constants"],function(t,e,n){var r=function(t){e.prototype.constructor.call(this,t,n.TAG.FIELDref)};return t.inherits(e,r),r.prototype.ref=function(){return this.attributes.ref},r.prototype.ucd=function(){return this.attributes.ucd},r.prototype.utype=function(){return this.attributes.utype},r}),r("paramref",["./utils","./abstractNode","./constants"],function(t,e,n){var r=function(t){e.prototype.constructor.call(this,t,n.TAG.PARAMref)};return t.inherits(e,r),r.prototype.ref=function(){return this.attributes.ref},r.prototype.ucd=function(){return this.attributes.ucd},r.prototype.utype=function(){return this.attributes.utype},r}),r("min",["./utils","./abstractNode","./constants"],function(t,e,n){var r=function(t){e.prototype.constructor.call(this,t,n.TAG.MIN)};return t.inherits(e,r),r.prototype.value=function(){return this.attributes.value},r.prototype.inclusive=function(){return this.attributes.inclusive},r}),r("max",["./utils","./abstractNode","./constants"],function(t,e,n){var r=function(t){e.prototype.constructor.call(this,t,n.TAG.MAX)};return t.inherits(e,r),r.prototype.value=function(){return this.attributes.value},r.prototype.inclusive=function(){return this.attributes.inclusive},r}),r("option",["./utils","./abstractNode","./constants"],function(t,e,n){var r=function(t){e.prototype.constructor.call(this,t,n.TAG.OPTION);var r=this;this.options=o(r,t)},o=function(t,e){for(var o=[],i=0;null!=e&&i<e.childNodes.length;i++){var s=e.childNodes[i];if(1==s.nodeType){var a=s.localName;a==n.TAG.OPTION?o.push(new r(s)):t.getCache().addWarning("unknown element "+a+" in Option node")}}return o};return t.inherits(e,r),r.prototype.name=function(){return this.attributes.name},r.prototype.value=function(){return this.attributes.value},r.prototype.getOptions=function(){return this.options},r}),r("values",["./utils","./abstractNode","./min","./max","./option","./constants"],function(t,e,n,r,o,i){var s=function(t){e.prototype.constructor.call(this,t,i.TAG.VALUES);var n=this,r=a(n,t);this.min=r[0],this.max=r[1],this.options=r[2]},a=function(t,e){for(var s,a,u=[],c=0;null!=e&&c<e.childNodes.length;c++){var p=e.childNodes[c];if(1==p.nodeType){var f=p.localName;switch(f){case i.TAG.MIN:s=new n(p);break;case i.TAG.MAX:a=new r(p);break;case i.TAG.OPTION:u.push(new o(p));break;default:t.getCache().addWarning("unknown element "+f+" in Values node")}}}return[s,a,u]};return t.inherits(e,s),s.prototype.ID=function(){return this.attributes.ID},s.prototype.type=function(){return this.attributes.type},s.prototype.null=function(){return this.attributes.null},s.prototype.ref=function(){return this.attributes.ref},s.prototype.getMin=function(){return this.min},s.prototype.getMax=function(){return this.max},s.prototype.getOptions=function(){return this.options},s}),r("link",["./utils","./abstractNode","./constants"],function(t,e,n){var r=function(t){e.prototype.constructor.call(this,t,n.TAG.LINK)};return t.inherits(e,r),r.prototype.ID=function(){return this.attributes.ID},r.prototype.content_role=function(){return this.attributes["content-role"]},r.prototype.content_type=function(){return this.attributes["content-type"]},r.prototype.title=function(){return this.attributes.title},r.prototype.value=function(){return this.attributes.value},r.prototype.href=function(){return this.attributes.href},r.prototype.gref=function(){return this.attributes.gref},r.prototype.action=function(){return this.attributes.action},r}),r("field",["./utils","./abstractNode","./description","./values","./link","./constants"],function(t,e,n,r,o,i){var s=function(t){e.prototype.constructor.call(this,t,i.TAG.FIELD);var n=this,r=a(n,t);this.description=r[0],this.values=r[1],this.links=r[2]},a=function(t,e){for(var s,a,u=[],c=0;null!=e&&c<e.childNodes.length;c++){var p=e.childNodes[c];if(1==p.nodeType){var f=p.localName;switch(f){case i.TAG.DESCRIPTION:s=new n(p);break;case i.TAG.VALUES:a=new r(p);break;case i.TAG.LINK:u.push(new o(p));break;default:t.getCache().addWarning("unknown element "+f+" in Field node")}}}return[s,a,u]};return t.inherits(e,s),s.prototype.ID=function(){return this.attributes.ID},s.prototype.unit=function(){return this.attributes.unit},s.prototype.datatype=function(){return this.attributes.datatype},s.prototype.precision=function(){return this.attributes.precision},s.prototype.width=function(){return this.attributes.width},s.prototype.xtype=function(){return this.attributes.xtype},s.prototype.ref=function(){return this.attributes.ref},s.prototype.name=function(){return this.attributes.name},s.prototype.ucd=function(){return this.attributes.ucd},s.prototype.utype=function(){return this.attributes.utype},s.prototype.arraysize=function(){return this.attributes.arraysize},s.prototype.type=function(){return this.attributes.type},s.prototype.getDescription=function(){return this.description},s.prototype.getValues=function(){return this.values},s.prototype.getLinks=function(){return this.links},s}),r("param",["./utils","./field","./constants"],function(t,e,n){var r=function(t){e.prototype.constructor.call(this,t,n.TAG.PARAM)};return t.inherits(e,r),r.prototype.value=function(){return this.attributes.value},r}),r("group",["./utils","./abstractNode","./description","./fieldref","./paramref","./param","./constants"],function(t,e,n,r,o,i,s){var a=function(t){e.prototype.constructor.call(this,t,s.TAG.GROUP);var n=this,r=u(n,t);this.description=r[0],this.fieldrefs=r[1],this.paramrefs=r[2],this.params=r[3],this.groups=r[4]},u=function(t,e){for(var u,c=[],p=[],f=[],l=[],h=0;null!=e&&h<e.childNodes.length;h++){var d=e.childNodes[h];if(1==d.nodeType){var y=d.localName;switch(y){case s.TAG.DESCRIPTION:u=new n(d);break;case s.TAG.FIELDref:c.push(new r(d));break;case s.TAG.PARAMref:p.push(new o(d));break;case s.TAG.PARAM:f.push(new i(d));break;case s.TAG.GROUP:l.push(new a(d));break;default:t.getCache().addWarning("unknown element "+y+" in Group node")}}}return[u,c,p,f,l]};return t.inherits(e,a),a.prototype.ID=function(){return this.attributes.ID},a.prototype.name=function(){return this.attributes.name},a.prototype.ref=function(){return this.attributes.ref},a.prototype.ucd=function(){return this.attributes.ucd},a.prototype.utype=function(){return this.attributes.utype},a.prototype.getDescription=function(){return this.description},a.prototype.getFieldrefs=function(){return this.fieldrefs},a.prototype.getParamrefs=function(){return this.paramrefs},a.prototype.getParams=function(){return this.params},a.prototype.getGroups=function(){return this.groups},a}),r("coosys",["./utils","./abstractNode","./constants"],function(t,e,n){var r=function(t){e.prototype.constructor.call(this,t,n.TAG.COOSYS);var r=this;this.value=o(r,t)};t.inherits(e,r);var o=function(t,e){for(var n,r=0;null!=e&&r<e.childNodes.length;r++){var o=e.childNodes[r];null!=o&&3==o.nodeType?n=null==o.textContent?null:o.textContent.trim():t.getCache().addWarning("unknown element "+o+" in Coosys node")}return n};return r.prototype.ID=function(){return this.attributes.ID},r.prototype.equinox=function(){return this.attributes.equinox},r.prototype.epoch=function(){return this.attributes.epoch},r.prototype.system=function(){return this.attributes.system},r.prototype.getContent=function(){return this.value},r}),r("definitions",["./utils","./abstractNode","./group","./param","./coosys","./constants"],function(t,e,n,r,o,i){var s=function(t){e.prototype.constructor.call(this,t,i.TAG.DEFINITIONS);var n=this,r=a(n,t);this.coosys=r[0],this.param=r[1]},a=function(t,e){for(var n=[],s=[],a=0;null!=e&&a<e.childNodes.length;a++){var u=e.childNodes[a];if(1==u.nodeType){var c=u.localName;switch(c){case i.TAG.COOSYS:n.push(new o(u));break;case i.TAG.PARAM:s.push(new r(u));break;default:t.getCache().addWarning("unknown element "+c+" in Definitions node")}c==i.TAG.COOSYS?n.push(new o(u)):c==i.TAG.PARAM?s.push(new r(u)):t.getCache().addWarning("unknown element "+c+" in Definitions node")}}return[n,s]};return t.inherits(e,s),s.prototype.getCoosyss=function(){return this.coosys},s.prototype.getParams=function(){return this.param},s}),r("info",["./utils","./abstractNode","./constants"],function(t,e,n){var r=function(t){e.prototype.constructor.call(this,t,n.TAG.INFO);var r=t.childNodes[0];null!=r&&3==r.nodeType&&(this.val=null==r.textContent?null:r.textContent.trim())};return r.prototype.name=function(){return this.attributes.name},r.prototype.value=function(){return this.attributes.value},r.prototype.ID=function(){return this.attributes.ID},r.prototype.unit=function(){return this.attributes.unit},r.prototype.xtype=function(){return this.attributes.xtype},r.prototype.ref=function(){return this.attributes.ref},r.prototype.ucd=function(){return this.attributes.ucd},r.prototype.utype=function(){return this.attributes.utype},r.prototype.getContent=function(){return this.val},r}),r("td",["./utils","./abstractNode","./constants"],function(t,e,n){var r=function(t,r){e.prototype.constructor.call(this,t,n.TAG.TD),this.value=null==r?null==t.textContent?"":t.textContent.trim():null==r?"":r.trim()};return t.inherits(e,r),r.prototype.encoding=function(){return this.attributes.encoding},r.prototype.getContent=function(){return this.value},r}),r("tr",["./utils","./abstractNode","./td","./constants"],function(t,e,n,r){var o=function(t,o){if(e.prototype.constructor.call(this,t,r.TAG.TR),null==o){var s=this;this.tds=i(s,t)}else{this.tds=[];for(var a=0;a<o.length;a++)this.tds.push(new n(null,o[a]))}},i=function(t,e){for(var o=[],i=0;null!=e&&i<e.childNodes.length;i++){var s=e.childNodes[i];if(1==s.nodeType){var a=s.localName;a==r.TAG.TD?o.push(new n(s)):t.getCache().addWarning("unknown element "+a+" in Tr node")}}return o};return t.inherits(e,o),o.prototype.ID=function(){return this.attributes.ID},o.prototype.getTds=function(){return this.tds},o}),r("abstractData",["./utils","./abstractNode"],function(t,e){var n=function(t,n){e.prototype.constructor.call(this,t,n)};return t.inherits(e,n),n}),r("tabledata",["./utils","./tr","./abstractData","./constants"],function(t,e,n,r){var o=function(t,o){if(n.prototype.constructor.call(this,t,r.TAG.TABLEDATA),null==o){var s=this;this.trs=i(s,t)}else{this.trs=[];for(var a=0;a<o.length;a++)this.trs.push(new e(null,o[a]))}},i=function(t,n){for(var o=[],i=0;null!=n&&i<n.childNodes.length;i++){var s=n.childNodes[i];if(1==s.nodeType){var a=s.localName;a==r.TAG.TR?o.push(new e(s)):t.getCache().addWarning("unknown element "+a+" in TableData node")}}return o};return t.inherits(n,o),o.prototype.getTrs=function(){return this.trs},o}),r("converter/base64",[],function(){function t(t){"use strict";var e,n,r;return e=new ArrayBuffer(2),n=new DataView(e),r=t.join(""),n.setUint16(0,parseInt(r,2)),n.getInt16(0)}function e(t){"use strict";var e,n,r;return e=new ArrayBuffer(4),n=new DataView(e),r=t.join(""),n.setUint32(0,parseInt(r,2)),n.getInt32(0)}function n(t){"use strict";var e,n,r;return e=new ArrayBuffer(4),n=new DataView(e),r=t.join(""),n.setUint32(0,parseInt(r,2)),n.getFloat32(0)}function r(t){"use strict";var e,n,r;return e=new ArrayBuffer(8),n=new DataView(e),r=t.slice(0,32).join(""),n.setUint32(0,parseInt(r,2)),r="",r=t.slice(32,64).join(""),n.setUint32(4,parseInt(r,2)),n.getFloat64(0)}function o(t){"use strict";var e,n,r;return e=new ArrayBuffer(1),n=new DataView(e),r=t.join(""),n.setUint8(0,parseInt(r,2)),n.getUint8(0)}function i(t){"use strict";var e,n,r,i,s;for(e=t.length/8,n=[],s="",i=0,r=0;r<e;r+=1)n=t.slice(i,i+8),s=s.concat(String.fromCharCode(o(n))),n=[],i+=8;return s}function s(t){"use strict";var e,n,r;return e=new ArrayBuffer(4),n=new DataView(e),r=t.join(""),n.setUint32(0,parseInt(r,2)),n.getUint32(0)}function a(t){var e;return t>64&&t<91?e=t-65:t>96&&t<123?e=t-71:t>47&&t<58?e=t+4:43===t?e=62:47===t&&(e=63),e}var u={short:16,int:32,float:32,double:64,unsignedByte:8},c=function(t){this.ptrStream=0,this.bufferTabBits=[],this.fields=t};return c.prototype.computeDataSize=function(t,e,n){var r=0;if("char"===t)if(/\*/.test(this.fields[e].arraysize())){var o=this.streamB64(32,n);r=8*s(o),o=[]}else r=8*this.fields[e].arraysize();else r=u[t];return r},c.prototype.streamB64=function(t,e){for(var n=[],r=this.bufferTabBits.length,o=Math.ceil((t-r)/6),i=0;i<r;i+=1)n.push(this.bufferTabBits[i]);this.bufferTabBits=[];for(var i=0;i<o;i+=1){if(10==e.charCodeAt(this.ptrStream))i-=1;else for(var s=a(e.charCodeAt(this.ptrStream)),u=32;u>0;u>>=1)n.length!==t?n.push((s&u)===u?"1":"0"):this.bufferTabBits.push((s&u)===u?"1":"0");this.ptrStream+=1}return n},c.prototype.decodeValue=function(s,a,u,c){var p,f=[];switch("NULL"!=s&&(f=this.streamB64(a,c)),s){case"short":p=t(f);break;case"int":p=e(f);break;case"float":p=n(f),p=p.toFixed(this.fields[u].precision());break;case"double":p=r(f),p=p.toFixed(this.fields[u].precision());break;case"unsignedByte":p=o(f);break;case"char":p=i(f);break;case"NULL":p="NULL";break}return"NaN"!==p&&"NULL"!==p&&0!==p||(p=""),p},c.prototype.decode=function(t){var e=[],n=0,r=t.length,o=this.fields.length,i=[];do{var s=this.fields[n].datatype(),a=this.computeDataSize(s,n,t);0==a&&(s="NULL");var u=this.decodeValue(s,a,n,t);i.push(u),n===o-1?(n=0,e.push(i),i=[]):n+=1}while(this.ptrStream<r);return e},c}),r("stream",["./utils","./abstractNode","./converter/base64","./tabledata","./constants"],function(t,e,n,r,o){var i=function(t){e.prototype.constructor.call(this,t,o.TAG.STREAM),this.value=t.textContent};return t.inherits(e,i),i.prototype.type=function(){return this.attributes.type},i.prototype.href=function(){return this.attributes.href},i.prototype.actuate=function(){return this.attributes.actuate},i.prototype.encoding=function(){return this.attributes.encoding},i.prototype.expires=function(){return this.attributes.expires},i.prototype.rights=function(){return this.attributes.rights},i.prototype.getContent=function(t,e){var o;if(null!=t&&t){var i=new n(e);o=new r(null,i.decode(this.value))}else o=this.value;return o},i}),r("binary",["./utils","./stream","./abstractData","./constants"],function(t,e,n,r){var o=function(t){n.prototype.constructor.call(this,t,r.TAG.BINARY),this.stream=i(t)},i=function(t){for(var n,o=0;null!=t&&o<t.childNodes.length;o++){var i=t.childNodes[o];if(1==i.nodeType){if(i.localName!=r.TAG.STREAM)throw new Error("Unknown element");n=new e(i)}}return n};return t.inherits(n,o),o.prototype.getStream=function(){return this.stream},o}),r("binary2",["./utils","./stream","./abstractData","./constants"],function(t,e,n,r){var o=function(t){n.prototype.constructor.call(this,t,r.TAG.BINARY2);var e=this;this.stream=i(e,t)},i=function(t,e){for(var n,o=0;null!=e&&o<e.childNodes.length;o++){var i=e.childNodes[o];if(1==i.nodeType){var s=i.localName;s==r.TAG.STREAM?n=new Definitions(i):t.getCache().addWarning("unknown element "+s+" in Binary2 node")}}return n};return t.inherits(n,o),o.prototype.getStream=function(){return this.stream},o}),r("fits",["./utils","./abstractData","./stream","./constants"],function(t,e,n,r){var o=function(t){e.prototype.constructor.call(this,t,r.TAG.FITS);var n=this;this.stream=i(n,t)},i=function(t,e){for(var n,o=0;null!=e&&o<e.childNodes.length;o++){var i=e.childNodes[o];if(1==i.nodeType){var s=i.localName;s==r.TAG.STREAM?n=new Definitions(i):t.getCache().addWarning("unknown element "+s+" in Fits node")}}return n};return t.inherits(e,o),o.prototype.getStream=function(){return this.stream},o.prototype.extnum=function(){return this.attributes.extnum},o}),r("data",["./utils","./abstractNode","./tabledata","./binary","./binary2","./fits","./info","./constants"],function(t,e,n,r,o,i,s,a){var u=function(t){e.prototype.constructor.call(this,t,a.TAG.DATA);var n=this,r=c(n,t);this.data=r[0],this.infos=r[1]},c=function(t,e){for(var u,c=[],p=0;null!=e&&p<e.childNodes.length;p++){var f=e.childNodes[p];if(1==f.nodeType){var l=f.localName;switch(l){case a.TAG.TABLEDATA:u=new n(f);break;case a.TAG.BINARY:u=new r(f);break;case a.TAG.BINARY2:u=new o(f);break;case a.TAG.FITS:u=new i(f);break;case a.TAG.INFO:c.push(new s(f));break;default:t.getCache().addWarning("unknown element "+l+" in Data node")}}}return[u,c]};return t.inherits(e,u),u.prototype.getData=function(){return this.data},u.prototype.getDataImplementationName=function(){return this.data.getTagName()},u.prototype.getInfos=function(){return this.infos},u}),r("table",["./utils","./abstractNode","./description","./field","./param","./group","./link","./data","./info","./constants"],function(t,e,n,r,o,i,s,a,u,c){var p=function(t){e.prototype.constructor.call(this,t,c.TAG.TABLE);var n=this,r=f(n,t);this.fields=r[0],this.params=r[1],this.groups=r[2],this.links=r[3],this.data=r[4],this.description=r[5],this.infos=r[6]},f=function(t,e){for(var p,f,l=[],h=[],d=[],y=[],b=[],g=0;null!=e&&g<e.childNodes.length;g++){var m=e.childNodes[g];if(1==m.nodeType){var v=m.localName;switch(v){case c.TAG.DESCRIPTION:f=new n(m);break;case c.TAG.FIELD:l.push(new r(m));break;case c.TAG.PARAM:h.push(new o(m));break;case c.TAG.GROUP:d.push(new i(m));break;case c.TAG.LINK:y.push(new s(m));break;case c.TAG.DATA:p=new a(m);break;case c.TAG.INFO:b.push(new u(m));break;default:t.getCache().addWarning("unknown element "+v+" in Table node")}}}return[l,h,d,y,p,f,b]};return t.inherits(e,p),p.prototype.ID=function(){return this.attributes.ID},p.prototype.name=function(){return this.attributes.name},p.prototype.ref=function(){return this.attributes.ref},p.prototype.ucd=function(){return this.attributes.ucd},p.prototype.utype=function(){return this.attributes.utype},p.prototype.nrows=function(){return this.attributes.nrows},p.prototype.getFields=function(){return this.fields},p.prototype.getParams=function(){return this.params},p.prototype.getGroups=function(){return this.groups},p.prototype.getLinks=function(){return this.links},p.prototype.getData=function(){return this.data},p.prototype.getInfos=function(){return this.infos},p.prototype.getDescription=function(){return this.description},p}),r("resource",["./utils","./abstractNode","./description","./info","./table","./link","./coosys","./param","./group","./constants"],function(t,e,n,r,o,i,s,a,u,c){var p=function(t){e.prototype.constructor.call(this,t,c.TAG.RESOURCE);var n=this,r=f(n,t);this.description=r[0],this.infos=r[1],this.coosyss=r[2],this.params=r[3],this.groups=r[4],this.abstractSequences=r[5]},f=function(t,e){for(var f,l=[],h=[],d=[],y=[],b=[],g=0,m=0,v=0;null!=e&&v<e.childNodes.length;v++){var T=e.childNodes[v];if(1==T.nodeType){var A=T.localName;switch(A){case c.TAG.DESCRIPTION:f=new n(T),m++;break;case c.TAG.INFO:l.push(new r(T)),m++;break;case c.TAG.COOSYS:h.push(new s),m++;break;case c.TAG.GROUP:d.push(new u),m++;break;case c.TAG.PARAM:y.push(new a),m++;break;default:g=v}}if(0!=g)break}m>g&&(g=m);for(var v=g;null!=e&&v<e.childNodes.length;v++){var N={},w=[],I=[],T=e.childNodes[v];if(1==T.nodeType){var A=T.localName;switch(A){case c.TAG.LINK:w.push(new i(T));break;case c.TAG.TABLE:N.TABLE=new o(T),0!=w.length&&(N.LINKS=w,b.push(N.LINKS),N.LINKS=[],w=[]),0!=I.length&&(N.INFOS=I,b.push(N.INFOS),N.INFOS=[],I=[]),b.push(N.TABLE);break;case c.TAG.RESOURCE:N.RESOURCE=new p(T),0!=w.length&&(N.LINKS=w,b.push(N.LINKS),N.LINKS=[],w=[]),0!=I.length&&(N.INFOS=I,b.push(N.INFOS),N.INFOS=[],I=[]),b.push(N.RESOURCE);break;case c.TAG.INFO:I.push(new r(T)),v==e.childNodes.length-1&&b.push(I);break;default:t.getCache().addWarning("Unkknown element "+A+" in RESOURCE node")}}}return[f,l,h,y,d,b]};return t.inherits(e,p),p.prototype.ID=function(){return this.attributes.ID},p.prototype.name=function(){return this.attributes.name},p.prototype.utype=function(){return this.attributes.utype},p.prototype.type=function(){return this.attributes.type},p.prototype.getDescription=function(){return this.description},p.prototype.getInfos=function(){return this.infos},p.prototype.getCoosyss=function(){return this.coosyss},p.prototype.getGroups=function(){return this.groups},p.prototype.getParams=function(){return this.params},p.prototype.getResourcesOrTables=function(){return this.abstractSequences},p}),r("converter/geojson",["../utils","../constants"],function(t,e){function n(t){var e={type:"FeatureCollection",features:[]},n=function(t){var e,n=t.getDefinitions();return null!=n&&(e=n.getCoosyss()[0]),null!=t.getCoosyss()[0]&&(e=t.getCoosyss()[0]),e}(t);null!=n&&(e.crs={type:"name",properties:{name:n}});for(var o=[],i=t.getResources(),s=0;s<i.length;s++)r(i[s],o);return e.features=o,e}function r(t,n){for(var i=t.getResourcesOrTables(),s=0;s<i.length;s++){var a=i[s];a.getTagName()==e.TAG.RESOURCE?r(a,n):a.getTagName()==e.TAG.TABLE&&o(a,n)}}function o(t,n){var r,o=t.getFields(),s=t.getData(),a=t.getInfos();switch(s.getDataImplementationName()){case e.TAG.TABLEDATA:var u=s.getData();r=u.getTrs();break;case e.TAG.BINARY:var c=s.getData(),u=c.getStream().getContent(!0,o);r=u.getTrs();break;case e.TAG.BINARY2:throw new Error("Binary2 not implemented");break;case e.TAG.FITS:throw new Error("Fits not implemented");break;default:throw new Error("Type of data not implemented for "+t)}i(o,a,r,n)}function i(t,e,n,r){for(var o=0;o<n.length;o++){var i=n[o].getTds();r.push(s(t,e,i))}}function s(e,n,r){function o(t,e){return 0!=t.filter(function(t){return t===e}).length}for(var i={type:"Feature",geometry:null,properties:{}},s={},p=0;p<r.length;p++){var f=r[p],l=e[p],h=l.getValues(),d=null!=h?h.null():null,y=l.ucd(),b=l.datatype(),g=f.getContent(),m=l.name();if(o(u,y))s.RA=Number.parseFloat(g),s.COOSYS=l.ref();else if(o(c,y))s.DEC=Number.parseFloat(g);else if(o(a,y))s.ID=g;else{var v=i.properties;g!=d&&(v[m]=function(t,e){var n;switch(e){case"short":case"int":case"long":n=Number.parseInt(t);break;case"float":case"double":n=Number.parseFloat(t);break;default:n=t}return n}(g,b))}}s.hasOwnProperty("ID")||(s.ID=t.guid());for(var p=0;p<n.length;p++){var T=n[p];v[T.name()]=T.value()}!function(t){if(!(t.hasOwnProperty("RA")&&t.hasOwnProperty("DEC")&&t.hasOwnProperty("COOSYS")&&t.hasOwnProperty("ID")))throw new Error("core metadata missing "+JSON.stringify(t))}(s);var A={type:"Point",coordinates:[s.RA,s.DEC],crs:{type:"name",properties:{name:s.COOSYS}}};return i.geometry=A,i}var a=["meta.record","meta.id;meta.main","VOX:Image_Titleq"],u=["pos.eq.ra;meta.main","POS_EQ_RA_MAIN"],c=["pos.eq.dec;meta.main","POS_EQ_DEC_MAIN"],p=function(t){this.votable=t,this.featureCollection=n(this.votable)};return p.prototype.getGeoJSon=function(t){var e=!1|t;return JSON.stringify(this.featureCollection,null,e)},p}),r("votable",["./utils","./abstractNode","./definitions","./info","./resource","./description","./coosys","./group","./param","./converter/geojson","./constants"],function(t,e,n,r,o,i,s,a,u,c,p){function f(t){if(null==t)throw new Error("xml cannot be null");if("string"==typeof t){t=(new DOMParser).parseFromString(t,"application/xml")}else if(null==t.documentElement)throw new Error("This object is not supported");if(t.documentElement.localName!=p.TAG.VOTABLE)throw new Error("This input is not a VOTable");return t}var l=function(t){t=f(t);var n=t.documentElement;e.prototype.constructor.call(this,n,p.TAG.VOTABLE);var r=this,o=h(r,n);this.definitions=o[0],this.infos=o[1],this.resources=o[2],this.description=o[3],this.coosyss=o[4],this.groups=o[5],this.params=o[6]},h=function(t,e){for(var c,f,l=e,h=[],d=[],y=[],b=[],g=[],m=0;m<l.childNodes.length;m++){var v=l.childNodes[m];if(1==v.nodeType){var T=v.localName;switch(T){case p.TAG.DEFINITIONS:c=new n(v);break;case p.TAG.INFO:h.push(new r(v));break;case p.TAG.RESOURCE:d.push(new o(v));break;case p.TAG.DESCRIPTION:f=new i(v);break;case p.TAG.COOSYS:y.push(new s(v));break;case p.TAG.GROUP:b.push(new a(v));break;case p.TAG.PARAM:g.push(new u(v));break;default:t.getCache().addWarning("unknown element "+T+" in Votable node")}}}return[c,h,d,f,y,b,g]};return t.inherits(e,l),l.prototype.ID=function(){return this.attributes.ID},l.prototype.version=function(){return this.attributes.version},l.prototype.getInfos=function(){return this.infos},l.prototype.getDefinitions=function(){return this.definitions},l.prototype.getResources=function(){return this.resources},l.prototype.getCoosyss=function(){return this.coosyss},l.prototype.getGroups=function(){return this.groups},l.prototype.getParams=function(){return this.params},l.prototype.getDescription=function(){return this.description},l.prototype.getVotableEltByID=function(t){return this.getCache().getEltsByID()[t]},l.prototype.getVotableEltsByName=function(t){return this.getCache().getEltsByName()[t]},l.prototype.convertToGeoJSon=function(t){return new c(this).getGeoJSon(t)},l}),r("JsVotable",["./votable","./binary","./binary2","./coosys","./data","./definitions","./description","./field","./fieldref","./fits","./group","./info","./link","./max","./min","./option","./param","./paramref","./resource","./stream","./table","./tabledata","./td","./tr","./values","./constants"],function(t,e,n,r,o,i,s,a,u,c,p,f,l,h,d,y,b,g,m,v,T,A,N,w,I,D){var O={};return O.Constants=D,O.Votable=t,O.Binary=e,O.Binary2=n,O.Coosys=r,O.Data=o,O.Definitions=i,O.Description=s,O.Field=a,O.Fieldref=u,O.Fits=c,O.Group=p,O.Info=f,O.Link=l,O.Max=h,O.Min=d,O.Option=y,O.Param=b,O.Paramref=g,O.Resource=m,O.Stream=v,O.Table=T,O.TableData=A,O.Td=N,O.Tr=w,O.Values=I,O.version={major:2,minor:0,patch:2,date:"2019-02-15",toString:function(){return this.major+"."+this.minor+"."+this.patch}},window.JsVotable=O,O}),n(["JsVotable"]),r("jquery",function(){return t}),n("JsVotable")});
!function(t,e){"function"==typeof define&&define.amd?define('jscsv',["jquery"],e):t.mylib=e(t.$)}(this,function(t){var e,n,r;return function(t){function i(t,e){return w.call(t,e)}function o(t,e){var n,r,i,o,u,s,f,c,l,a,p=e&&e.split("/"),h=y.map,g=h&&h["*"]||{};if(t&&"."===t.charAt(0))if(e){for(p=p.slice(0,p.length-1),t=p.concat(t.split("/")),c=0;c<t.length;c+=1)if("."===(a=t[c]))t.splice(c,1),c-=1;else if(".."===a){if(1===c&&(".."===t[2]||".."===t[0]))break;c>0&&(t.splice(c-1,2),c-=2)}t=t.join("/")}else 0===t.indexOf("./")&&(t=t.substring(2));if((p||g)&&h){for(n=t.split("/"),c=n.length;c>0;c-=1){if(r=n.slice(0,c).join("/"),p)for(l=p.length;l>0;l-=1)if((i=h[p.slice(0,l).join("/")])&&(i=i[r])){o=i,u=c;break}if(o)break;!s&&g&&g[r]&&(s=g[r],f=c)}!o&&s&&(o=s,u=f),o&&(n.splice(0,u,o),t=n.join("/"))}return t}function u(e,n){return function(){return h.apply(t,j.call(arguments,0).concat([e,n]))}}function s(t){return function(e){return o(e,t)}}function f(t){return function(e){v[t]=e}}function c(e){if(i(m,e)){var n=m[e];delete m[e],b[e]=!0,p.apply(t,n)}if(!i(v,e)&&!i(b,e))throw new Error("No "+e);return v[e]}function l(t){var e,n=t?t.indexOf("!"):-1;return n>-1&&(e=t.substring(0,n),t=t.substring(n+1,t.length)),[e,t]}function a(t){return function(){return y&&y.config&&y.config[t]||{}}}var p,h,g,d,v={},m={},y={},b={},w=Object.prototype.hasOwnProperty,j=[].slice;g=function(t,e){var n,r=l(t),i=r[0];return t=r[1],i&&(i=o(i,e),n=c(i)),i?t=n&&n.normalize?n.normalize(t,s(e)):o(t,e):(t=o(t,e),r=l(t),i=r[0],t=r[1],i&&(n=c(i))),{f:i?i+"!"+t:t,n:t,pr:i,p:n}},d={require:function(t){return u(t)},exports:function(t){var e=v[t];return void 0!==e?e:v[t]={}},module:function(t){return{id:t,uri:"",exports:v[t],config:a(t)}}},p=function(e,n,r,o){var s,l,a,p,h,y,w=[];if(o=o||e,"function"==typeof r){for(n=!n.length&&r.length?["require","exports","module"]:n,h=0;h<n.length;h+=1)if(p=g(n[h],o),"require"===(l=p.f))w[h]=d.require(e);else if("exports"===l)w[h]=d.exports(e),y=!0;else if("module"===l)s=w[h]=d.module(e);else if(i(v,l)||i(m,l)||i(b,l))w[h]=c(l);else{if(!p.p)throw new Error(e+" missing "+l);p.p.load(p.n,u(o,!0),f(l),{}),w[h]=v[l]}a=r.apply(v[e],w),e&&(s&&s.exports!==t&&s.exports!==v[e]?v[e]=s.exports:a===t&&y||(v[e]=a))}else e&&(v[e]=r)},e=n=h=function(e,n,r,i,o){return"string"==typeof e?d[e]?d[e](n):c(g(e,n).f):(e.splice||(y=e,n.splice?(e=n,n=r,r=null):e=t),n=n||function(){},"function"==typeof r&&(r=i,i=o),i?p(t,e,n,r):setTimeout(function(){p(t,e,n,r)},4),h)},h.config=function(t){return y=t,y.deps&&h(y.deps,y.callback),h},r=function(t,e,n){e.splice||(n=e,e=[]),i(v,t)||i(m,t)||(m[t]=[t,e,n])},r.amd={jQuery:!0}}(),r("../minify/almond",function(){}),r("csv",[],function(){function t(t){if(null==t)throw new Error("csv cannot be null");if("string"!=typeof t)throw new Error("This object is not supported")}function e(t,e,i){for(var o=t.split("\n"),u=0,s=0;s<o.length&&n(o[s],e,i.name);s++)u++;return r(o,u,e,i)}function n(t,e,n){return t.startsWith(u)||0==t.length||n.toString()==t.split(e).toString()}function r(t,e,n,r){for(var o=[],u=e;u<t.length;u++)0!==t[u].length&&o.push(i(t[u],n,r));return o}function i(t,e,n){for(var r={},i=t.split(e),u=0;u<i.length;u++)r[n.name[u]]=o(i[u],n.datatype[u]);return r}function o(t,e){var n;switch(e){case"short":case"int":case"long":n=Number.parseInt(t);break;case"float":case"double":n=Number.parseFloat(t);break;default:n=t}return n}var u="#",s=function(n,r,i){t(n),this.store=e(n,r,i)};return s.prototype.getStore=function(){return this.store},s.prototype.getGeoJSon=function(t,e){for(var n=t.RA,r=t.DEC,i=t.ID,o=[],u=0;u<this.store.length;u++){var s={type:"Feature",id:this.store[u][i],geometry:{type:"Point",coordinates:[this.store[u][n],this.store[u][r]],crs:{type:"name",properties:{name:e}}}},f=JSON.parse(JSON.stringify(this.store[u]));delete f[n],delete f[r],delete f[i],s.properties=f,o.push(s)}return{type:"FeatureCollection",features:o}},s}),r("JsCsv",["./csv"],function(t){var e={};return e.Csv=t,e.version={major:1,minor:1,patch:4,date:"2019-02-15",toString:function(){return this.major+"."+this.minor+"."+this.patch}},window.JsCsv=e,e}),n(["JsCsv"]),r("jquery",function(){return t}),n("JsCsv")});
/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/Layer/HipsCatLayer',[
    "./AbstractHipsLayer",
    "../Renderer/FeatureStyle",
    "../Renderer/RendererManager",
    "../Utils/Utils",
    "../Renderer/RendererTileData",
    "../Tiling/Tile",
    "jsvotable",
    "jscsv",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "../Utils/Proxy"
], function(
    AbstractHipsLayer,
    FeatureStyle,
    RendererManager,
    Utils,
    RendererTileData,
    Tile,
    JsVotable,
    CSV,
    Constants,
    ErrorDialog,
    Proxy
) {
    /**************************************************************************************************************/

    function _setDefaultOptions(options) {
        options.icon = options.icon || "css/images/star16x16.png";
        options.background = false;
        options.category = options.category || "Catalog";
        options.pickable = options.pickable || true;
        return options;
    }

    /**
     * Hips catalogue configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.hipsCat_configuration
     * @property {string} serviceUrl - Endpoint to reach the Hips catalogue
     * @property {int} [minOrder = 2] - min order
     * @property {int} [maxRequests = 4] - Max requests in parallel
     * @property {boolean} [invertY = false]
     */

    /**
     * Create a HIPS catalogue
     * @param {AbstractLayer.hipsCat_configuration} options - Hip catalogue configuration
     * @constructor
     * @memberof module:Layer
     * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
     */
    var HipsCatLayer = function(hipsMetadata, options) {
        AbstractHipsLayer.prototype.constructor.call(
            this,
            hipsMetadata,
            _setDefaultOptions(options)
        );
        var i;
        var propertiesObj = new Properties(
            this.allowRequest(options.baseUrl) + "/properties"
        );
        var properties = propertiesObj.getProperties();
        var hips_order = properties.hips_order;
        this.serviceUrl = this.allowRequest(options.baseUrl);
        this.minOrder = options.minOrder || 2;
        this.maxOrder = Number.parseInt(hips_order, 10);
        this.maxRequests = options.maxRequests || 4;
        this.invertY = options.invertY || false;
        var xhr = new XMLHttpRequest();
        xhr.open("GET", Proxy.proxify(this.allowRequest(options.baseUrl + "/metadata.xml")), false);
        xhr.setRequestHeader("Accept", "application/xml");
        xhr.send(null);
        var jsVotable = new JsVotable.Votable(xhr.responseXML);
        var resource = jsVotable.getResources()[0];
        var table = resource.getResourcesOrTables()[0];
        this.fields = table.getFields();
        this.raColNumber = null;
        this.decColNumber = null;
        this.sourceId = null;
        for (i = 0; i < this.fields.length; i++) {
            var ucd = this.fields[i].ucd();
            if (ucd === "pos.eq.ra;meta.main") {
                this.raColNumber = this.fields[i].name();
            } else if (ucd === "pos.eq.dec;meta.main") {
                this.decColNumber = this.fields[i].name();
            } else if (ucd === "meta.id;meta.main") {
                this.sourceId = this.fields[i].name();
            }
        }

        this.extId = "hipsCat";

        // Used for picking management
        this.features = [];
        // Counter set, indicates how many times the feature has been requested
        this.featuresSet = {};

        // Maximum two requests for now
        this.freeRequests = [];
        this.tilesToLoad = [];

        // Build the request objects
        for (i = 0; i < this.maxRequests; i++) {
            xhr = new XMLHttpRequest();
            this.freeRequests.push(xhr);
        }
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractHipsLayer, HipsCatLayer);

    /**************************************************************************************************************/

    /**
     * Parse properties file of the Hips catalogue
     * @param url
     * @constructor
     */
    var Properties = function(url) {
        this.properties = {};
        var i;
        var xhr = new XMLHttpRequest();
        xhr.open("GET", Proxy.proxify(url), false);
        xhr.setRequestHeader("Accept", "text/plain");
        xhr.send();
        var content = xhr.responseText;
        content.trim();
        var lines = content.split("\n");
        for (i = 0; lines !== null && i < lines.length; i++) {
            var line = lines[i];
            if (line !== null && (line.indexOf("#") > -1 || !line.trim())) {
                continue;
            }
            var keywordValue = line.split("=");
            var keyword = keywordValue[0].replace(/^\s+|\s+$/g, "");
            var value = keywordValue[1].replace(/^\s+|\s+$/g, "");
            this.properties[keyword] = value;
        }
    };

    /**
     * Returns the properties
     * @return {{}}
     */
    Properties.prototype.getProperties = function() {
        return this.properties;
    };

    /**
     * Attaches the layer to the globe
     * @param g The globe
     * @private
     */
    HipsCatLayer.prototype._attach = function(g) {
        AbstractHipsLayer.prototype._attach.call(this, g);
        this.extId += this.id;
        g.getTileManager().addPostRenderer(this);
    };

    /**************************************************************************************************************/

    /**
     * Detaches the layer from the globe
     * @private
     */
    HipsCatLayer.prototype._detach = function() {
        this.getGlobe()
            .getTileManager()
            .removePostRenderer(this);
        AbstractHipsLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    /**
     * Launches request to the HipsCatLayer service
     * @param tile
     * @param url
     * @fires Context#startLoad
     * @fires Context#endLoad
     * @fires Context#features:added
     */
    HipsCatLayer.prototype.launchRequest = function(tile, url) {
        var tileData = tile.extension[this.extId];
        var index = null;

        if (this.freeRequests.length === 0) {
            return;
        }

        // Set that the tile is loading its data for HipsCatLayer
        tileData.state = HipsCatLayer.TileState.LOADING;

        // Pusblish the start load event, only if there is no pending requests
        if (this.maxRequests === this.freeRequests.length) {
            this.getGlobe().publishEvent(
                Constants.EVENT_MSG.LAYER_START_LOAD,
                this
            );
        }

        var xhr = this.freeRequests.pop();
        var self = this;
        xhr.open("GET", Proxy.proxify(url));
        xhr.setRequestHeader("Accept", "application/xml");
        xhr.send(null);
        xhr.onreadystatechange = function(e) {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    var response = {};
                    var headerInfo = {
                        name: [],
                        datatype: []
                    };
                    self.fields.forEach(function(field) {
                        headerInfo.name.push(field.name());
                        headerInfo.datatype.push(field.datatype());
                    });
                    var csv = new CSV.Csv(xhr.response, "\t", headerInfo);
                    var geoJson = csv.getGeoJSon(
                        {
                            RA: self.raColNumber,
                            DEC: self.decColNumber,
                            ID: self.sourceId
                        },
                        "Equatorial"
                    );
                    var features = geoJson.features;
                    response.features = features;
                    response.totalResults = features.length;

                    //var response = JSON.parse(xhr.response);

                    tileData.complete =
                        response.totalResults === response.features.length;

                    //self.updateFeatures(response.features);

                    var i;
                    for (i = response.features.length - 1; i >= 0; i--) {
                        var feature = response.features[i];
                        // Eliminate already added features from response
                        var alreadyAdded = self.featuresSet.hasOwnProperty(
                            feature.id
                        );
                        if (alreadyAdded) response.features.splice(i, 1);

                        feature.properties.style = this.style;
                        self.addFeature(feature, tile);
                    }
                    self.globe.refresh();

                    // Publish event that layer have received new features
                    if (
                        response.hasOwnProperty(features) &&
                        response.features.length > 0
                    ) {
                        self.globe.publishEvent(
                            Constants.EVENT_MSG.FEATURED_ADDED,
                            { layer: self, features: response.features }
                        );
                    }
                } else if (xhr.status >= 400) {
                    tileData.complete = true;
                }

                tileData.state = HipsCatLayer.TileState.LOADED;
                self.freeRequests.push(xhr);

                // Publish the end load event, only if there is no pending requests
                if (self.maxRequests === self.freeRequests.length) {
                    self.globe.publishEvent(
                        Constants.EVENT_MSG.LAYER_END_LOAD,
                        self
                    );
                }
            }
        };
    };

    /**************************************************************************************************************/

    /**
     * Adds feature to the layer and to the tile extension
     * @param feature
     * @param tile
     */
    HipsCatLayer.prototype.addFeature = function(feature, tile) {
        var tileData = tile.extension[this.extId];
        var featureData;

        // Add feature if it doesn't exist
        if (!this.featuresSet.hasOwnProperty(feature.id)) {
            this.features.push(feature);
            featureData = {
                index: this.features.length - 1,
                tiles: [tile]
            };
            this.featuresSet[feature.id] = featureData;
        } else {
            featureData = this.featuresSet[feature.id];

            // Store the tile
            featureData.tiles.push(tile);

            // Always use the base feature to manage geometry indices
            feature = this.features[featureData.index];
        }

        // Add feature id
        tileData.featureIds.push(feature.id);

        // Set the identifier on the geometry
        feature.geometry.gid = feature.id;

        // Add to renderer
        //this.addFeatureToRenderer(feature, tile);

        // MS: Feature could be added from ClusterOpenSearch which have features with different styles
        var style = feature.properties.style
            ? feature.properties.style
            : this.style;

        this.getGlobe()
            .getRendererManager()
            .addGeometryToTile(this, feature.geometry, style, tile);
    };

    /**************************************************************************************************************/

    /**
     * Removes feature from Dynamic HipsCatLayer layer
     * @param identifier
     * @param tile
     */
    HipsCatLayer.prototype.removeFeature = function(identifier, tile) {
        var featureIt = this.featuresSet[identifier];

        if (!featureIt) {
            return;
        }

        // Remove tile from array
        var tileIndex = featureIt.tiles.indexOf(tile);
        if (tileIndex >= 0) {
            featureIt.tiles.splice(tileIndex, 1);
        } else {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "HipsCatLayer internal error : tile not found when removing feature");
        }

        if (featureIt.tiles.length === 0) {
            // Remove it from the set
            delete this.featuresSet[identifier];

            // Remove it from the array by swapping it with the last feature to optimize removal.
            var lastFeature = this.features.pop();
            if (featureIt.index < this.features.length) {
                // Set the last feature at the position of the removed feature
                this.features[featureIt.index] = lastFeature;
                // Update its index in the Set.
                this.featuresSet[lastFeature.id].index = featureIt.index;
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Modifies feature style
     * @param feature
     * @param style
     */
    HipsCatLayer.prototype.modifyFeatureStyle = function(feature, style) {
        feature.properties.style = style;
        var featureData = this.featuresSet[feature.id];
        if (featureData) {
            var i;
            for (i = 0; i < featureData.tiles.length; i++) {
                var tile = featureData.tiles[i];
                this.getGlobe()
                    .getRendererManager()
                    .removeGeometryFromTile(feature.geometry, tile);
                this.getGlobe()
                    .getRendererManager()
                    .addGeometryToTile(this, feature.geometry, style, tile);
            }
        }
    };

    HipsCatLayer.TileState = {
        LOADING: 0,
        LOADED: 1,
        NOT_LOADED: 2,
        INHERIT_PARENT: 3
    };

    /**************************************************************************************************************/

    /**
     * Generates the tile data
     * @param tile
     */
    HipsCatLayer.prototype.generate = function(tile) {
        if (this.minOrder <= tile.order && tile.order <= this.maxOrder) {
            tile.extension[this.extId] = new OSData(this, tile, null);
        }
    };

    /**************************************************************************************************************/

    /**
     * HipsCatLayer renderable
     * @param layer
     * @param tile
     * @param p
     * @constructor
     */
    var OSData = function(layer, tile, p) {
        this.layer = layer;
        this.parent = p;
        this.tile = tile;
        this.featureIds = []; // exclusive parameter to remove from layer
        this.state = HipsCatLayer.TileState.NOT_LOADED;
        this.complete = false;
        this.childrenCreated = false;
    };

    /**************************************************************************************************************/

    /**
     * Traverse
     * @param tile
     */
    OSData.prototype.traverse = function(tile) {
        var i;
        if (!this.layer.isVisible()) return;

        if (tile.state !== Tile.State.LOADED) return;

        // Check if the tile need to be loaded
        if (this.state === HipsCatLayer.TileState.NOT_LOADED) {
            this.layer.tilesToLoad.push(this);
        }

        // Create children if needed
        if (
            this.state === HipsCatLayer.TileState.LOADED &&
            !this.complete &&
            tile.state === Tile.State.LOADED &&
            tile.children &&
            !this.childrenCreated
        ) {
            for (i = 0; i < 4; i++) {
                if (!tile.children[i].extension[this.layer.extId])
                    tile.children[i].extension[this.layer.extId] = new OSData(
                        this.layer,
                        tile.children[i],
                        this
                    );
            }
            this.childrenCreated = true;

            // HACK : set renderable to have children
            var renderables = tile.extension.renderer
                ? tile.extension.renderer.renderables
                : [];
            for (i = 0; i < renderables.length; i++) {
                if (renderables[i].bucket.layer === this.layer)
                    renderables[i].hasChildren = true;
            }
        }
    };

    /**************************************************************************************************************/
    /**
     * Disposes renderable data from tile
     * @param renderContext
     * @param tilePool
     */
    OSData.prototype.dispose = function(renderContext, tilePool) {
        var i;
        if (this.parent && this.parent.childrenCreated) {
            this.parent.childrenCreated = false;
            // HACK : set renderable to not have children!
            var renderables = this.parent.tile.extension.renderer
                ? this.parent.tile.extension.renderer.renderables
                : [];
            for (i = 0; i < renderables.length; i++) {
                if (renderables[i].bucket.layer === this.layer)
                    renderables[i].hasChildren = false;
            }
        }

        for (i = 0; i < this.featureIds.length; i++) {
            this.layer.removeFeature(this.featureIds[i], this.tile);
        }
        this.tile = null;
        this.parent = null;
    };

    /**************************************************************************************************************/

    /**
     * Builds URL
     * @param tile
     * @return {*}
     */
    HipsCatLayer.prototype.buildUrl = function(tile) {
        var url;
        if (tile.order <= 0) {
            url = this.serviceUrl + "/Norder" + tile.order + "/Allsky.xml";
        } else {
            url = this.serviceUrl;

            url += "/Norder";
            url += tile.order;

            url += "/Dir";
            var indexDirectory = Math.floor(tile.pixelIndex / 10000) * 10000;
            url += indexDirectory;

            url += "/Npix";
            url += tile.pixelIndex;
            url += ".tsv";
        }
        return url;
    };

    /**
     * Get Tile URL.
     * @param tile
     * @returns {*}
     */
    HipsCatLayer.prototype.getUrl = function(tile) {
        return this.allowRequest(this.buildUrl(tile));
    };

    /**************************************************************************************************************/

    /**
     * Internal function to sort tiles
     * @param t1
     * @param t2
     * @return {number}
     * @private
     */
    function _sortTilesByDistance(t1, t2) {
        return t1.tile.distance - t2.tile.distance;
    }

    /**
     * Render function
     *
     * @param tiles The array of tiles to render
     */
    HipsCatLayer.prototype.render = function(tiles) {
        var i;
        if (!this.visible) return;

        // Sort tiles
        this.tilesToLoad.sort(_sortTilesByDistance);

        // Load data for the tiles if needed
        for (
            i = 0;
            i < this.tilesToLoad.length && this.freeRequests.length > 0;
            i++
        ) {
            var tile = this.tilesToLoad[i].tile;
            var url = this.buildUrl(tile);
            if (url) {
                this.launchRequest(tile, url);
            }
        }

        this.tilesToLoad.length = 0;
    };

    /*************************************************************************************************************/

    return HipsCatLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Layer/GeoJsonLayer',[
    "../Utils/Utils",
    "./AbstractVectorLayer",
    "../Utils/Constants"
], function(Utils, AbstractVectorLayer, Constants) {
    /**
     * @name GeoJsonLayer
     * @class
     *    Create a layer to display vector data in GeoJSON format.
     * @augments AbstractVectorLayer
     * @param {AbstractLayer.geojson_configuration} options - GeoJsonLayer configuration
     * @constructor
     * @memberof module:Layer
     */
    var GeoJsonLayer = function(options) {
        AbstractVectorLayer.prototype.constructor.call(
            this,
            Constants.LAYER.GeoJSON,
            options
        );
        this.gid = 0;
    };

    /**
     * Check if the GeoJSon has a valid geometry attribute
     * @param {Object} feature - GeoJSON feature
     * @throws {RangeError} Invalid GeoJson
     * @private
     */
    function _checkValidGeoJson(feature) {
        var geometry = feature.geometry;
        if (!geometry || !geometry.type) {
            throw new RangeError("Invalid GeoJson", "GeoJsonLayer.js");
        }
    }

    /**
     * Set the global crs when the geometry has not crs.
     * If no globalCrs, then WGS84 is set
     * @param {Object} feature - GeoJSON feature
     * @param {Object} globalCrs - GeoJSON crs element
     * @returns {Object} the feature
     * @private
     */
    function _setCrs(feature, globalCrs) {
        if (!feature.geometry.crs) {
            feature.geometry.crs = globalCrs
                ? globalCrs
                : {
                    type: "name",
                    properties: {
                        name: Constants.CRS.WGS84
                    }
                };
        }
        return feature;
    }

    /**
     * Sets an unique ID of the GeoJSON geometry
     * @param {Object} feature - GeoJSON feature
     * @returns {Object} GeoJSON feature
     * @private
     */
    function _setID(feature) {
        feature.geometry.gid = this.ID + "_GeoJSON_" + this.gid;
        this.gid++;
        return feature;
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractVectorLayer, GeoJsonLayer);

    /**************************************************************************************************************/

    /**
     * Adds a feature collection, in GeoJSON format
     * @function addFeatureCollection
     * @memberof GeoJsonLayer#
     * @param {GeoJSON} featureCollection Feature Collection
     * @throws {ReferenceError} Error, featureCollection is null
     */
    GeoJsonLayer.prototype.addFeatureCollection = function(featureCollection) {
        // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
        if (featureCollection == null) {
            throw new ReferenceError(
                "Error, featureCollection is null",
                "GeoJsonLayer.js"
            );
        }

        var defaultCrs = {
            type: "name",
            properties: {
                name: Constants.CRS.WGS84
            }
        };

        //check if crs is global at the featureCollection
        var crs = featureCollection.crs ? featureCollection.crs : defaultCrs;

        var features = featureCollection.features;
        if (features) {
            for (var i = 0; i < features.length; i++) {
                this.addFeature(features[i], crs);
            }
        }
    };

    /**
     * Set data type of the GeoJSON : Point or LineString
     * @param feature
     * @memberof GeoJsonLayer#
     * @private
     */
    GeoJsonLayer.prototype._setDataType = function(feature) {
        if (!this.datatype) {
            if (feature.geometry.type.startsWith(Constants.GEOMETRY.Point)) {
                this.dataType = Constants.GEOMETRY.Point;
            } else {
                this.dataType = Constants.GEOMETRY.LineString;
            }
        }
    };

    /**************************************************************************************************************/
    /**
     * Add a feature to the layer
     * @function addFeature
     * @memberof GeoJsonLayer.prototype
     * @param {GeoJSON} feature Feature
     */
    GeoJsonLayer.prototype.addFeature = function(feature, globalCrs) {
        //feature.properties.style = this.style;
        _checkValidGeoJson.call(this, feature);

        feature = _setCrs.call(this, feature, globalCrs);

        feature = _setID.call(this, feature);

        this._setDataType(feature);

        AbstractVectorLayer.prototype.addFeature.call(this, feature);
    };

    return GeoJsonLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Layer/OpenSearch/OpenSearchRequestPool',["../../Utils/Constants","../../Gui/dialog/ErrorDialog","../../Utils/Proxy", "./OpenSearchUtils"], function(Constants, ErrorDialog, Proxy, OpenSearchUtils) {
    /**
     * @name OpenSearchRequestPool
     * @class
     * This class manages the request pool of OpenSearch
     * @memberof module:Layer
     */
    var OpenSearchRequestPool = function() {
        this.maxRunningRequests = 4;
        this.maxPoolingRequests = 50;

        // Running requests
        this.runningRequests = [];

        // Atomic management when reseting
        this.resetMode = false;

        // Pooling requests
        this.freeRequests = [];
        this.poolingRequests = [];
        this.awaitingRequests = [];

        this.layers = [];

        // Build all free requests
        for (var i = 0; i < this.maxPoolingRequests; i++) {
            var xhr = new XMLHttpRequest();
            xhr.numRequest = i;
            this.freeRequests.push(xhr);
        }

        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[New] " + this.getPoolsStatus());
    };

    /**************************************************************************************************************/

    /**
     * Return the pool status
     * @function getPoolStatus
     * @memberof OpenSearchRequestPool#
     * @return {string} Pool status
     */

    OpenSearchRequestPool.prototype.getPoolsStatus = function() {
        var message = "";
        message +=
            "Run : " +
            this.runningRequests.length +
            "/" +
            this.maxRunningRequests +
            " , ";
        message +=
            "Wait : " +
            this.poolingRequests.length +
            "/" +
            this.maxPoolingRequests;
        return message;
    };

    /**************************************************************************************************************/

    /**
     * Get a free request
     * @function getFreeRequest
     * @memberof OpenSearchRequestPool#
     * @return {Object} Free request
     */

    OpenSearchRequestPool.prototype.getFreeRequest = function() {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[getFreeRequest]");

        if (this.freeRequests.length === 0) {
            // Take oldest request in pool and use it
            var xhr = this.poolingRequests.splice(0, 1)[0];
            ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "Oldest pooling request cancel and reused");
            return xhr;
        } else {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "Take one request from pool");
            return this.freeRequests.pop();
        }
    };

    /**************************************************************************************************************/

    /**
     * Add a query to the pool
     *  Note : Query is ALWAYS ADDED at the end of the pool, the it's a FILO queue
     * @function addQuery
     * @memberof OpenSearchRequestPool#
     * @param {string} url Url query to get
     * @param {Tile} tile Tile associated with the query
     * @param {Layer} layer
     */
    OpenSearchRequestPool.prototype.addQuery = function(url, tile, layer) {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[addQuery]");
        if (this.resetMode === true) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "addQuery halt, reset mode");
            return;
        }

        var key = tile.getKey();

        // Add layer to list
        if (typeof this.layers[layer.getID()] === "undefined") {
            this.layers[layer.getID()] = layer;
        }

        // First check if query is style wanted
        if (this.isQueryStillWanted(key, layer.getID(), url)) {
            // Query still in pool or running, so do not add it again
            return;
        }

        // get query slot
        var xhr = this.getFreeRequest();

        // set value for managing
        var self = this;

        // Associate the key
        xhr.key = key;
        xhr.layer = layer;
        xhr.url = url;

        // The server sometimes times out (e.g. too many requests)
        // In this case, finish the request and retry later.
        xhr.ontimeout = function()  {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSeachRequestPool", "Server Timeout, resend later");
            self.manageFinishedRequest(xhr);
            self.poolingRequests.push(xhr);
        };

        xhr.onabort = function() {
            ErrorDialog.open(Constants.LEVEL.ERROR, "OpenSearchRequestPool", "Request aborted");
            self.manageFinishedRequest(xhr);
        };

        xhr.onerror = function() {
            ErrorDialog.open(Constants.LEVEL.ERROR, "OpenSearchRequestPool", "Request error: " + xhr.status);
            self.manageFinishedRequest(xhr);
        };

        xhr.onload = function() {
            if (xhr.status === 200 && xhr.response !== null) {
                const response = JSON.parse(xhr.response);
                var nbFeaturesTotalPerTile = response.properties.totalResults;
                //TODO cache : degrade resolution
                //xhr.layer.cache.storeInCache(url, response.features, nbFeaturesTotalPerTile);
                xhr.layer.computeFeaturesResponse(response.features, tile, nbFeaturesTotalPerTile);
            } else if (xhr.status >= 400) {
                //tileData.complete = true;
                ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", xhr.responseText);
                return;
            }
            self.manageFinishedRequest(xhr);
        };

        xhr.open("GET", Proxy.proxify(url));
        xhr.setRequestHeader("Accept", "application/json");

        // Add request to pooling (last position)
        this.poolingRequests.push(xhr);

        // Check if request can be done
        this.checkPool();
    };

    /**
     * Check for each layer if there is remaining load needed
     * Check if there is any remaining query in the pool
     * @function checkPool
     * @memberof OpenSearchRequestPool#
     */
    OpenSearchRequestPool.prototype.checkEachLayerFinished = function() {
        for (var key in this.layers) {
            var current = this.layers[key];
            for (var i = 0; i < this.runningRequests.length; i++) {
                if (
                    typeof this.runningRequests[i].layer !== "undefined" &&
                    this.runningRequests[i].layer.getID() === key
                ) {
                    return;
                }
            }
            for (i = 0; i < this.poolingRequests.length; i++) {
                if (
                    typeof this.poolingRequests[i].layer !== "undefined" &&
                    this.poolingRequests[i].layer.getID() === key
                ) {
                    return;
                }
            }
            // no request running, stop ihm indicator
            current
                .getGlobe()
                .publishEvent(Constants.EVENT_MSG.LAYER_END_LOAD, current);
        }
    };

    /**************************************************************************************************************/

    /**
     * Check if there is any remaining query in the pool
     * @function checkPool
     * @memberof OpenSearchRequestPool#
     */
    OpenSearchRequestPool.prototype.checkPool = function() {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[checkPool]" + this.getPoolsStatus());

        if (this.resetMode === true) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "checkPool halt, reset mode");
            return;
        }

        if (this.runningRequests.length === this.maxRunningRequests) {
            // Running pool is full, wait for a free slot
            ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "no running slot available, wait");
            return;
        }

        this.checkEachLayerFinished();

        // There is at least one slot free
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "before : " + this.getPoolsStatus());

        // Remove it from pool
        var xhr = this.poolingRequests.pop();

        if (typeof xhr !== "undefined") {
            // Place it into running
            this.runningRequests.push(xhr);

            // Start ihm indicator
            xhr.layer.getGlobe().publishEvent(Constants.EVENT_MSG.LAYER_START_LOAD, xhr.layer);

            // Launch request
            xhr.send();

            ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "after : " + this.getPoolsStatus());

            // check for another request
            this.checkPool();
        }
    };

    /**************************************************************************************************************/

    /**
     * Manage data returned by a query
     * @function manageFinishedRequest
     * @memberof OpenSearchRequestPool#
     * @param {Object} xhr Query
     */
    OpenSearchRequestPool.prototype.manageFinishedRequest = function(xhr) {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[manageFinishedRequest]");
        if (this.resetMode === true) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "manageFinishedRequest halt, reset mode");
            return;
        }
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "before : " + this.getPoolsStatus());

        // Get index of ended request
        var index = -1;
        for (var i = 0; i < this.runningRequests.length; i++) {
            if (this.runningRequests[i].numRequest === xhr.numRequest) {
                index = i;
            }
        }

        // Remove the query
        if (index >= -1) {
            this.runningRequests.splice(index, 1);
        }

        // Set it into pool
        this.freeRequests.push(xhr);

        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "after : " + this.getPoolsStatus());

        this.checkPool();
    };

    /**************************************************************************************************************/

    /**
     * Check if query (based on bound) is still wanted (in pool or running)
     * @function isQueryStillWanted
     * @memberof OpenSearchRequestPool#
     * @param {string} key Key of the query
     * @return {Boolean} true if query is still in pool
     */
    OpenSearchRequestPool.prototype.isQueryStillWanted = function(key, layerID, url) {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[isQueryStillWanted]");
        for (var i = 0; i < this.runningRequests.length; i++) {
            // Recheck if runningRequests is modified outside
            if (
                typeof this.runningRequests[i] !== "undefined" &&
                this.runningRequests[i].key === key &&
                this.runningRequests[i].layer.getID() === layerID &&
                this.runningRequests[i].url === url
            ) {
                return true;
            }
        }
        for (i = 0; i < this.poolingRequests.length; i++) {
            // Recheck if poolingRequests is modified outside
            if (
                typeof this.poolingRequests[i] !== "undefined" &&
                this.poolingRequests[i].key === key &&
                this.poolingRequests[i].url === url
            ) {
                return true;
            }
        }
        return false;
    };

    /**************************************************************************************************************/

    /**
     * Reset the pool
     * @function reset
     * @memberof OpenSearchRequestPool#
     */
    OpenSearchRequestPool.prototype.resetPool = function() {
        this.resetMode = true;
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[resetPool]");
        this.removeRunningQueries();
        this.removePoolQueries();
        this.resetMode = false;
    };

    /**************************************************************************************************************/

    /**
     * Remove running queries
     * @function removeRunningQueries
     * @memberof OpenSearchRequestPool#
     */
    OpenSearchRequestPool.prototype.removeRunningQueries = function() {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[removeRunningQueries]");
        var xhr = this.runningRequests.pop();
        while (xhr !== null && typeof xhr !== "undefined") {
            xhr.abort();
            this.freeRequests.push(xhr);
            xhr = this.runningRequests.pop();
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove pool queries
     * @function removePoolQueries
     * @memberof OpenSearchRequestPool#
     */
    OpenSearchRequestPool.prototype.removePoolQueries = function() {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[removePoolQueries]");
        var xhr = this.poolingRequests.pop();
        while (xhr !== null && typeof xhr !== "undefined") {
            this.freeRequests.push(xhr);
            xhr = this.poolingRequests.pop();
        }
    };

    /*************************************************************************************************************/

    return OpenSearchRequestPool;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name LayerFactory
 * @class
 * Factory to create a layer
 * @memberof module:Layer
 */
define('gw/Layer/LayerFactory',[
    "jquery",
    "../Utils/Constants",
    "./WMSLayer",
    "./WMTSLayer",
    "./WCSElevationLayer",
    "./VectorLayer",
    "./AtmosphereLayer",
    "./BingLayer",
    "./GroundOverlayLayer",
    "./OSMLayer",
    "./TileWireframeLayer",
    "./CoordinateGridLayer",
    "./HipsFitsLayer",
    "./HipsGraphicLayer",
    "./MocLayer",
    "./OpenSearchLayer",
    "./WMSElevationLayer",
    "./HipsMetadata",
    "./HipsCatLayer",
    "./GeoJsonLayer",
    "./OpenSearch/OpenSearchRequestPool"
], function(
    $,
    Constants,
    WMSLayer,
    WMTSLayer,
    WCSElevationLayer,
    VectorLayer,
    AtmosphereLayer,
    BingLayer,
    GroundOverlayLayer,
    OSMLayer,
    TileWireframeLayer,
    CoordinateGridLayer,
    HipsFitsLayer,
    HipsGraphicLayer,
    MocLayer,
    OpenSearchLayer,
    WMSElevationLayer,
    HipsMetadata,
    HipsCatLayer,
    GeoJsonLayer,
    OpenSearchRequestPool
) {
    this.openSearchRequestPool = new OpenSearchRequestPool();

    function createHips(hipsMetadata, options) {
        var hipsProperties;
        if (typeof hipsMetadata === "undefined") {
            hipsProperties = new HipsMetadata(options.baseUrl);
        } else if (hipsMetadata instanceof HipsMetadata) {
            hipsProperties = hipsMetadata;
        } else {
            hipsProperties = new HipsMetadata();
            hipsProperties.setMetadata(hipsMetadata);
        }

        var metadata = hipsProperties.getHipsMetadata();

        var formats = options.hasOwnProperty("hips_tile_format")
            ? options.hips_tile_format
            : metadata.hips_tile_format;
        var dataProducts = options.hasOwnProperty("dataproduct_type")
            ? options.dataproduct_type
            : metadata.dataproduct_type;

        var layer;

        switch (dataProducts) {
        case hipsProperties.DataProductType.catalog:
            layer = createHipsCats(metadata, options);
            break;
        case hipsProperties.DataProductType.cube:
            throw new RangeError(
                "Hips : cannot handle cube dataproduct",
                "LayerFactor.js"
            );
        case hipsProperties.DataProductType.image:
            options.category = options.hasOwnProperty("category")
                ? options.category
                : "Image";
            var hasPNG =
                    $.inArray(hipsProperties.HipsTileFormat.png, formats) !==
                    -1;
            var hasJPEG =
                    $.inArray(hipsProperties.HipsTileFormat.jpeg, formats) !==
                    -1;
            var hasFits =
                    $.inArray(hipsProperties.HipsTileFormat.fits, formats) !==
                    -1;
            if (options.format) {
                switch (options.format) {
                case hipsProperties.HipsTileFormat.png:
                    layer = createHipsGraphic(metadata, options);
                    break;
                case "jpg":
                    layer = createHipsGraphic(metadata, options);
                    break;
                case hipsProperties.HipsTileFormat.fits:
                    layer = createHipsFits(metadata, options);
                    break;
                default:
                    // try to get one by default => try jpeg ... maybe I am lucky
                    layer = createHipsGraphic(metadata, options);
                }
            } else {
                if (hasPNG) {
                    options.format = hipsProperties.HipsTileFormat.png;
                    layer = createHipsGraphic(metadata, options);
                } else if (hasJPEG) {
                    options.format = "jpg"; // the right extension should be "jpeg" but jpg is used
                    layer = createHipsGraphic(metadata, options);
                } else if (hasFits) {
                    options.format = hipsProperties.HipsTileFormat.fits;
                    layer = createHipsFits(metadata, options);
                } else {
                    // try to get one by default => it happens for old Hips version ... maybe I am lucky
                    options.format = "jpg";
                    layer = createHipsGraphic(metadata, options);
                }
            }
            break;
        case hipsProperties.DataProductType.meta:
            throw new RangeError(
                "Hips : cannot handle META dataproduct",
                "LayerFactor.js"
            );
        default:
            throw new RangeError(
                "Hips : Unknown dataproduct type",
                "LayerFactor.js"
            );
        }
        //if(fileExists(options.baseUrl+"/Moc.fits") === 200) {
        //    options.serviceUrl = options.baseUrl+"/Moc.fits";
        //    layer.services.push(this.createMoc(options));
        //}
        return layer;
    }

    function createHipsFits(hipsMetadata, options) {
        return new HipsFitsLayer(hipsMetadata, options);
    }

    function createHipsGraphic(hipsMetadata, options) {
        return new HipsGraphicLayer(hipsMetadata, options);
    }

    function createHipsCats(hipsMetadata, options) {
        return new HipsCatLayer(hipsMetadata, options);
    }

    /**
         Create and get a MOC Layer
         @function createMoc
         @private
         @memberof LayerFactory.prototype
         @param options Configuration properties for the MOC layer. See {@link MocLayer} for properties
         @return {MocLayer} layer
         */
    function createMoc(options) {
        options.style.fill = true;
        options.style.fillColor[3] = 0.3; // make transparent
        var layer = new MocLayer(options);
        layer.dataType = "line";
        return layer;
    }

    /**
         Create and get an OpenSearch Layer
         @function createOpenSearch
         @private
         @memberof LayerFactory.prototype
         @param options Configuration properties for the OpenSearch layer. See {@link OpenSearchLayer} for properties
         @return {OpenSearchLayer} layer
         */
    function createOpenSearch(options) {
        options.openSearchRequestPool = this.openSearchRequestPool;
        var layer = new OpenSearchLayer(options);
        if (options.displayProperties) {
            layer.displayProperties = options.displayProperties;
        }
        layer.pickable = options.hasOwnProperty("pickable")
            ? options.pickable
            : true;
        return layer;
    }

    return {
        /**
         * Factory for Layer.
         * @param {Object} options - See the base properties {@link AbstractLayer.configuration} and specific properties for specific layers
         * @param {string} options.type - one of the following value {@link LAYER}
         * @return {AbstractLayer} - Object to handle Layer
         * @alias module:Layer.LayerFactory.create
         * @throws RangeError - "Unable to create the layer"
         * @see {@link module:Layer.AtmosphereLayer AtmosphereLayer} : A layer to create an atmosphere on a planet.
         * @see {@link module:Layer.BingLayer BingLayer}: The Microsoft service proving a WMTS server.
         * @see {@link module:Layer.CoordinateGridLayer CoordinateGridLayer} : A layer to create a grid on the sky
         * @see {@link module:Layer.GeoJsonLayer GeoJSONLayer} : A layer to add a GeoJSON on the globe
         * @see {@link module:Layer.GroundOverlayLayer GroundOverlayLayer} : A layer to draw an image overlay draped onto the terrain
         * @see {@link module:Layer.HipsCatLayer HipsCatLayer} : A layer to draw a HIPS catalogue
         * @see {@link module:Layer.HipsFitsLayer HipsFitsLayer} : A layer to draw an Hips Fits
         * @see {@link module:Layer.HipsGraphicLayer HipsGraphicLayer} : A layer to draw a Hips JPEG/PNG
         * @see {@link module:Layer.MocLayer MocLayer} : A layer to draw a multi-order-coverage index
         * @see {@link module:Layer.OpenSearchLayer OpenSearchLayer} : A layer to draw the result from an open search service
         * @see {@link module:Layer.OSMLayer OSMLayer} : A layer to display data coming from OpenStreetMap server
         * @see {@link module:Layer.TileWireframeLayer TileWireframeLayer} : A layer to draw a grid on the planet
         * @see {@link module:Layer.VectorLayer VectorLayer} : A layer to draw a vector
         * @see {@link module:Layer.WCSElevationLayer WCSElevationLayer} : A layer to draw the elevation
         * @see {@link module:Layer.WMSElevationLayer WMSElevationLayer} : A layer to draw the elevation
         * @see {@link module:Layer.AsynchroneWMSLayer AsynchroneWMSLayer} : A layer to draw images coming from the WMS server (asynchrone loading to manage GetCapabilities)
         * @see {@link module:Layer.WMSLayer WMSLayer} : A layer to draw images coming from the WMS server
         * @see {@link module:Layer.WMTSLayer WMTSLayer} : A layer to draw predefined tiles coming from a WMTS server
         */
        create: function(options) {
            var layer;
            switch (options.type) {
            case Constants.LAYER.WMS:
                layer = new WMSLayer(options);
                break;
            case Constants.LAYER.WMTS:
                layer = new WMTSLayer(options);
                break;
            case Constants.LAYER.WMSElevation:
                layer = new WMSElevationLayer(options);
                break;
            case Constants.LAYER.WCSElevation:
                layer = new WCSElevationLayer(options);
                break;
            case Constants.LAYER.GeoJSON:
                layer = new GeoJsonLayer(options);
                layer.pickable = options.hasOwnProperty("pickable")
                    ? options.pickable
                    : true;
                break;
            case Constants.LAYER.Vector:
                layer = new VectorLayer(options);
                layer.pickable = options.hasOwnProperty("pickable")
                    ? options.pickable
                    : true;
                layer.deletable = options.hasOwnProperty("deletable")
                    ? options.deletable
                    : false;
                break;
            case Constants.LAYER.Atmosphere:
                layer = new AtmosphereLayer(options);
                break;
            case Constants.LAYER.Bing:
                layer = new BingLayer(options);
                break;
            case Constants.LAYER.GroundOverlay:
                layer = new GroundOverlayLayer(options);
                break;
            case Constants.LAYER.OSM:
                layer = new OSMLayer(options);
                break;
            case Constants.LAYER.HipsGrid:
            case Constants.LAYER.TileWireframe:
                layer = new TileWireframeLayer(options);
                break;
            case Constants.LAYER.HipsCat:
                layer = new HipsCatLayer(options.hipsMetadata, options);
                break;
            case Constants.LAYER.CoordinateGrid:
                layer = new CoordinateGridLayer(options);
                break;
            case Constants.LAYER.Hips:
                layer = createHips(options.hipsMetadata, options);
                break;
            case Constants.LAYER.Moc:
                layer = createMoc(options);
                break;
            case Constants.LAYER.OpenSearch:
                layer = createOpenSearch(options);
                break;
            default:
                throw new RangeError(
                    "Unable to create the layer " + options.type,
                    "LayerFactor.js"
                );
            }
            return layer;
        }
    };
});

/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Registry/AbstractRegistryHandler',[
    "underscore-min",
    "../Layer/LayerFactory",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function(_, LayerFactory, Constants, ErrorDialog) {
    /**
     * @name AbstractRegistryHandler
     * @class
     *  Abstract Registry Handler
     * @param {object} options
     * @implements {RegistryHandler}
     */

    var AbstractRegistryHandler = function() {
        this.next = {
            handleRequest: function(layerDescription, callback, fallback) {
                ErrorDialog.open(
                    Constants.LEVEL.DEBUG,
                    "AbstractRegistryHandler.js",
                    "All strategies exhausted."
                );
            }
        };
    };

    /**
     * @function setNext
     * @memberof AbstractRegistryHandler#
     */
    AbstractRegistryHandler.prototype.setNext = function(next) {
        this.next = next;
        return next;
    };

    /**
     * @function handleRequest
     * @memberof AbstractRegistryHandler#
     */

    AbstractRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {};

    /**
     * Handles pending layers.
     * @function _handlePendingLayers
     * @memberof AbstractRegistryHandler#
     * @param {Layer[]} pendingLayers Pending layers
     * @param {Layer[]} List pf layers
     */

    AbstractRegistryHandler.prototype._handlePendingLayers = function(
        pendingLayers,
        layers
    ) {
        //TODO : I loose the callback of pendingLayers
        for (var i = 0; i < layers.length && pendingLayers.length !== 0; i++) {
            var layer = layers[i];
            if (pendingLayers.length != 0 && layer.isBackground()) {
                var j = pendingLayers.length;
                while (j > 0) {
                    j--;
                    var pendingLayerDescription = pendingLayers[j];
                    try {
                        layers.push(
                            LayerFactory.create(pendingLayerDescription)
                        );
                        pendingLayers.splice(j, 1);
                    } catch (RangeError) {
                        ErrorDialog.open(Constants.LEVEL.DEBUG, "Failed to create layer", RangeError.message);
                    }
                }
                break;
            }
        }
    };

    return AbstractRegistryHandler;
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('wms-capabilities',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.WMSCapabilities = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

module.exports = require('./src/wms');

},{"./src/wms":6}],2:[function(require,module,exports){
"use strict";

/**
 * @enum {Number}
 */
module.exports = {
  ELEMENT: 1,
  ATTRIBUTE: 2,
  TEXT: 3,
  CDATA_SECTION: 4,
  ENTITY_REFERENCE: 5,
  ENTITY: 6,
  PROCESSING_INSTRUCTION: 7,
  COMMENT: 8,
  DOCUMENT: 9,
  DOCUMENT_TYPE: 10,
  DOCUMENT_FRAGMENT: 11,
  NOTATION: 12
};

},{}],3:[function(require,module,exports){
"use strict";

/**
 * Returns true if the specified value is not undefined.
 *
 * @param {?} val Variable to test.
 * @return {Boolean} Whether variable is defined.
 */
module.exports = function isDef(val) {
  return val !== void 0;
};

},{}],4:[function(require,module,exports){
"use strict";

/**
 * Adds a key-value pair to the object/map/hash if it doesn't exist yet.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {String} key The key to add.
 * @param {V} value The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
module.exports = function(obj, key, value) {
  return key in obj ? obj[key] : (obj[key] = value);
};

},{}],5:[function(require,module,exports){
"use strict";

var isDef = require('./isdef');

/**
 * Make sure we trim BOM and NBSP
 * @type {RegExp}
 */
var TRIM_RE = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

/**
 * Repeats a string n times.
 * @param {String} string The string to repeat.
 * @param {Number} length The number of times to repeat.
 * @return {String} A string containing {@code length} repetitions of
 *     {@code string}.
 */
function repeat(string, length) {
  return new Array(length + 1).join(string);
}

module.exports = {

  /**
   * @param  {String} str
   * @return {String}
   */
  trim: function(str) {
    return str.replace(TRIM_RE, '');
  },

  /**
   * Pads number to given length and optionally rounds it to a given precision.
   * For example:
   * <pre>padNumber(1.25, 2, 3) -> '01.250'
   * padNumber(1.25, 2) -> '01.25'
   * padNumber(1.25, 2, 1) -> '01.3'
   * padNumber(1.25, 0) -> '1.25'</pre>
   *
   * @param {Number} num The number to pad.
   * @param {Number} length The desired length.
   * @param {Number=} opt_precision The desired precision.
   * @return {String} {@code num} as a string with the given options.
   */
  padNumber: function(num, length, opt_precision) {
    var s = isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
    var index = s.indexOf('.');
    if (index == -1) {
      index = s.length;
    }
    return repeat('0', Math.max(0, length - index)) + s;
  }

};

},{"./isdef":3}],6:[function(require,module,exports){
"use strict";

var XMLParser = require('./xml_parser');
var isDef = require('./utils/isdef');
var nodeTypes = require('./node_types');
var setIfUndefined = require('./utils/setifundefined');
var XSD = require('./xsd');
var XLink = require('./xlink');

/**
 * WMS Capabilities parser
 *
 * @param {String=} xmlString
 * @constructor
 */
function WMS(xmlString) {

  /**
   * @type {String}
   */
  this.version = undefined;

  /**
   * @type {XMLParser}
   */
  this._parser = new XMLParser();

  /**
   * @type {String=}
   */
  this._data = xmlString;
};

/**
 * Shortcut
 * @type {Function}
 */
var makePropertySetter = XMLParser.makeObjectPropertySetter;

/**
 * @param {String} xmlString
 * @return {WMS}
 */
WMS.prototype.data = function(xmlString) {
  this._data = xmlString;
  return this;
};

/**
 * @param  {String=} xmlString
 * @return {Object}
 */
WMS.prototype.toJSON = function(xmlString) {
  xmlString = xmlString || this._data;
  return this.parse(xmlString);
};

/**
 * @return {String} xml
 */
WMS.prototype.parse = function(xmlString) {
  return this._readFromDocument(this._parser.toDocument(xmlString));
};

/**
 * @param  {Document} doc
 * @return {Object}
 */
WMS.prototype._readFromDocument = function(doc) {
  for (var node = doc.firstChild; node; node = node.nextSibling) {
    if (node.nodeType == nodeTypes.ELEMENT) {
      return this.readFromNode(node);
    }
  }
  return null;
};

/**
 * @param  {DOMNode} node
 * @return {Object}
 */
WMS.prototype.readFromNode = function(node) {
  this.version = node.getAttribute('version');
  var wmsCapabilityObject = XMLParser.pushParseAndPop({
    'version': this.version
  }, WMS.PARSERS, node, []);

  return wmsCapabilityObject || null;
};

/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Attribution object.
 */
WMS._readAttribution = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.ATTRIBUTION_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @return {ol.Extent} Bounding box object.
 */
WMS._readBoundingBoxExtent = function(node) {
	var readDecimalString = XSD.readDecimalString;

	return [
	  readDecimalString(node.getAttribute('minx')),
	  readDecimalString(node.getAttribute('miny')),
	  readDecimalString(node.getAttribute('maxx')),
	  readDecimalString(node.getAttribute('maxy'))
	];
}

/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object} Bounding box object.
 */
WMS._readBoundingBox = function(node, objectStack) {
  var extent = WMS._readBoundingBoxExtent(node);
  var readDecimalString = XSD.readDecimalString;

  var resolutions = [
    readDecimalString(node.getAttribute('resx')),
    readDecimalString(node.getAttribute('resy'))
  ];

  return {
    'crs': node.getAttribute('CRS') || node.getAttribute('SRS'),
    'extent': extent,
    'res': resolutions
  };
};

/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.Extent|undefined} Bounding box object.
 */
WMS._readLatLonBoundingBox = function(node, objectStack) {
  var extent = WMS._readBoundingBoxExtent(node);

  if (!isDef(extent[0]) || !isDef(extent[1]) ||
    !isDef(extent[2]) || !isDef(extent[3])) {
    return undefined;
  }

  return extent;
};


/**
 * @privat
 * @param  {Node} node  Node
 * @param  {Arra.<Object>} objectStack Object stack
 * @return {Object}
 */
WMS._readScaleHint = function(node, objectStack) {
  var min = parseFloat(node.getAttribute('min'));
  var max = parseFloat(node.getAttribute('max'));

  return {
    min: min,
    max: max
  };
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.Extent|undefined} Bounding box object.
 */
WMS._readEXGeographicBoundingBox = function(node, objectStack) {
  var geographicBoundingBox = XMLParser.pushParseAndPop({},
    WMS.EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS,
    node, objectStack);
  if (!isDef(geographicBoundingBox)) {
    return undefined;
  }

  var westBoundLongitude = /** @type {number|undefined} */
    (geographicBoundingBox['westBoundLongitude']);
  var southBoundLatitude = /** @type {number|undefined} */
    (geographicBoundingBox['southBoundLatitude']);
  var eastBoundLongitude = /** @type {number|undefined} */
    (geographicBoundingBox['eastBoundLongitude']);
  var northBoundLatitude = /** @type {number|undefined} */
    (geographicBoundingBox['northBoundLatitude']);

  if (!isDef(westBoundLongitude) || !isDef(southBoundLatitude) ||
    !isDef(eastBoundLongitude) || !isDef(northBoundLatitude)) {
    return undefined;
  }

  return [
    westBoundLongitude, southBoundLatitude,
    eastBoundLongitude, northBoundLatitude
  ];
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Capability object.
 */
WMS._readCapability = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.CAPABILITY_PARSERS, node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Service object.
 */
WMS._readService = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.SERVICE_PARSERS, node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Contact information object.
 */
WMS._readContactInformation = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.CONTACT_INFORMATION_PARSERS,
    node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Contact person object.
 */
WMS._readContactPersonPrimary = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.CONTACT_PERSON_PARSERS,
    node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Contact address object.
 */
WMS._readContactAddress = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.CONTACT_ADDRESS_PARSERS,
    node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Array.<string>|undefined} Format array.
 */
WMS._readException = function(node, objectStack) {
  return XMLParser.pushParseAndPop(
    [], WMS.EXCEPTION_PARSERS, node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Layer object.
 */
WMS._readCapabilityLayer = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.LAYER_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Layer object.
 */
WMS._readLayer = function(node, objectStack) {
  var parentLayerObject = /**  @type {Object.<string,*>} */
    (objectStack[objectStack.length - 1]);

  var layerObject = /**  @type {Object.<string,*>} */
    (XMLParser.pushParseAndPop({}, WMS.LAYER_PARSERS,
      node, objectStack));

  if (!isDef(layerObject)) {
    return undefined;
  }

  var queryable = XSD.readBooleanString(node.getAttribute('queryable'));
  if (!isDef(queryable)) {
    queryable = parentLayerObject['queryable'];
  }
  layerObject['queryable'] = isDef(queryable) ? queryable : false;

  var cascaded = XSD.readNonNegativeIntegerString(node.getAttribute('cascaded'));
  if (!isDef(cascaded)) {
    cascaded = parentLayerObject['cascaded'];
  }
  layerObject['cascaded'] = cascaded;

  var opaque = XSD.readBooleanString(node.getAttribute('opaque'));
  if (!isDef(opaque)) {
    opaque = parentLayerObject['opaque'];
  }
  layerObject['opaque'] = isDef(opaque) ? opaque : false;

  var noSubsets = XSD.readBooleanString(node.getAttribute('noSubsets'));
  if (!isDef(noSubsets)) {
    noSubsets = parentLayerObject['noSubsets'];
  }
  layerObject['noSubsets'] = isDef(noSubsets) ? noSubsets : false;

  var fixedWidth = XSD.readDecimalString(node.getAttribute('fixedWidth'));
  if (!isDef(fixedWidth)) {
    fixedWidth = parentLayerObject['fixedWidth'];
  }
  layerObject['fixedWidth'] = fixedWidth;

  var fixedHeight = XSD.readDecimalString(node.getAttribute('fixedHeight'));
  if (!isDef(fixedHeight)) {
    fixedHeight = parentLayerObject['fixedHeight'];
  }
  layerObject['fixedHeight'] = fixedHeight;

  // See 7.2.4.8
  var addKeys = ['Style', 'CRS', 'AuthorityURL'];
  for (var i = 0, len = addKeys.length; i < len; i++) {
    var key = addKeys[i];
    var parentValue = parentLayerObject[key];
    if (isDef(parentValue)) {
      var childValue = setIfUndefined(layerObject, key, []);
      childValue = childValue.concat(parentValue);
      layerObject[key] = childValue;
    }
  }

  var replaceKeys = ['EX_GeographicBoundingBox', 'BoundingBox', 'Dimension',
    'Attribution', 'MinScaleDenominator', 'MaxScaleDenominator'
  ];
  for (var i = 0, len = replaceKeys.length; i < len; i++) {
    var key = replaceKeys[i];
    var childValue = layerObject[key];
    if (!isDef(childValue)) {
      var parentValue = parentLayerObject[key];
      layerObject[key] = parentValue;
    }
  }

  return layerObject;
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object} Dimension object.
 */
WMS._readDimension = function(node, objectStack) {
  var dimensionObject = {
    'name': node.getAttribute('name'),
    'units': node.getAttribute('units'),
    'unitSymbol': node.getAttribute('unitSymbol'),
    'default': node.getAttribute('default'),
    'multipleValues': XSD.readBooleanString(node.getAttribute('multipleValues')),
    'nearestValue': XSD.readBooleanString(node.getAttribute('nearestValue')),
    'current': XSD.readBooleanString(node.getAttribute('current')),
    'values': XSD.readString(node)
  };
  return dimensionObject;
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Online resource object.
 */
WMS._readFormatOnlineresource = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.FORMAT_ONLINERESOURCE_PARSERS,
    node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Request object.
 */
WMS._readRequest = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.REQUEST_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} DCP type object.
 */
WMS._readDCPType = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.DCPTYPE_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} HTTP object.
 */
WMS._readHTTP = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.HTTP_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Operation type object.
 */
WMS._readOperationType = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.OPERATIONTYPE_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Online resource object.
 */
WMS._readSizedFormatOnlineresource = function(node, objectStack) {
  var formatOnlineresource = WMS._readFormatOnlineresource(node, objectStack);
  if (isDef(formatOnlineresource)) {
    var readNonNegativeIntegerString = XSD.readNonNegativeIntegerString;
    var size = [
      readNonNegativeIntegerString(node.getAttribute('width')),
      readNonNegativeIntegerString(node.getAttribute('height'))
    ];
    formatOnlineresource['size'] = size;
    return formatOnlineresource;
  }
  return undefined;
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Authority URL object.
 */
WMS._readAuthorityURL = function(node, objectStack) {
  var authorityObject = WMS._readFormatOnlineresource(node, objectStack);
  if (isDef(authorityObject)) {
    authorityObject['name'] = node.getAttribute('name');
    return authorityObject;
  }
  return undefined;
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Metadata URL object.
 */
WMS._readMetadataURL = function(node, objectStack) {
  var metadataObject = WMS._readFormatOnlineresource(node, objectStack);
  if (isDef(metadataObject)) {
    metadataObject['type'] = node.getAttribute('type');
    return metadataObject;
  }
  return undefined;
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Style object.
 */
WMS._readStyle = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.STYLE_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Array.<string>|undefined} Keyword list.
 */
WMS._readKeywordList = function(node, objectStack) {
  return XMLParser.pushParseAndPop(
    [], WMS.KEYWORDLIST_PARSERS, node, objectStack);
};

/**
 * @const
 * @type {Array.<string>}
 */
WMS.NAMESPACE_URIS = [
  null,
  'http://www.opengis.net/wms'
];

/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Service': makePropertySetter(WMS._readService),
    'Capability': makePropertySetter(WMS._readCapability)
  });

/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.CAPABILITY_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Request': makePropertySetter(WMS._readRequest),
    'Exception': makePropertySetter(WMS._readException),
    'Layer': makePropertySetter(WMS._readCapabilityLayer)
  });

/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.SERVICE_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Name': makePropertySetter(XSD.readString),
    'Title': makePropertySetter(XSD.readString),
    'Abstract': makePropertySetter(XSD.readString),
    'KeywordList': makePropertySetter(WMS._readKeywordList),
    'OnlineResource': makePropertySetter(XLink.readHref),
    'ContactInformation': makePropertySetter(WMS._readContactInformation),
    'Fees': makePropertySetter(XSD.readString),
    'AccessConstraints': makePropertySetter(XSD.readString),
    'LayerLimit': makePropertySetter(XSD.readNonNegativeInteger),
    'MaxWidth': makePropertySetter(XSD.readNonNegativeInteger),
    'MaxHeight': makePropertySetter(XSD.readNonNegativeInteger)
  });

/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.CONTACT_INFORMATION_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'ContactPersonPrimary': makePropertySetter(WMS._readContactPersonPrimary),
    'ContactPosition': makePropertySetter(XSD.readString),
    'ContactAddress': makePropertySetter(WMS._readContactAddress),
    'ContactVoiceTelephone': makePropertySetter(XSD.readString),
    'ContactFacsimileTelephone': makePropertySetter(XSD.readString),
    'ContactElectronicMailAddress': makePropertySetter(XSD.readString)
  });

/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.CONTACT_PERSON_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'ContactPerson': makePropertySetter(XSD.readString),
    'ContactOrganization': makePropertySetter(XSD.readString)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.CONTACT_ADDRESS_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'AddressType': makePropertySetter(XSD.readString),
    'Address': makePropertySetter(XSD.readString),
    'City': makePropertySetter(XSD.readString),
    'StateOrProvince': makePropertySetter(XSD.readString),
    'PostCode': makePropertySetter(XSD.readString),
    'Country': makePropertySetter(XSD.readString)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.EXCEPTION_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Format': XMLParser.makeArrayPusher(XSD.readString)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.LAYER_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Name': makePropertySetter(XSD.readString),
    'Title': makePropertySetter(XSD.readString),
    'Abstract': makePropertySetter(XSD.readString),
    'KeywordList': makePropertySetter(WMS._readKeywordList),
    'CRS': XMLParser.makeObjectPropertyPusher(XSD.readString),
	  'SRS': XMLParser.makeObjectPropertyPusher(XSD.readString),
    'EX_GeographicBoundingBox': makePropertySetter(WMS._readEXGeographicBoundingBox),
	  'LatLonBoundingBox': makePropertySetter(WMS._readLatLonBoundingBox),
    'BoundingBox': XMLParser.makeObjectPropertyPusher(WMS._readBoundingBox),
    'Dimension': XMLParser.makeObjectPropertyPusher(WMS._readDimension),
    'Attribution': makePropertySetter(WMS._readAttribution),
    'AuthorityURL': XMLParser.makeObjectPropertyPusher(WMS._readAuthorityURL),
    'Identifier': XMLParser.makeObjectPropertyPusher(XSD.readString),
    'MetadataURL': XMLParser.makeObjectPropertyPusher(WMS._readMetadataURL),
    'DataURL': XMLParser.makeObjectPropertyPusher(WMS._readFormatOnlineresource),
    'FeatureListURL': XMLParser.makeObjectPropertyPusher(WMS._readFormatOnlineresource),
    'Style': XMLParser.makeObjectPropertyPusher(WMS._readStyle),
    'MinScaleDenominator': makePropertySetter(XSD.readDecimal),
    'MaxScaleDenominator': makePropertySetter(XSD.readDecimal),
    'ScaleHint': makePropertySetter(WMS._readScaleHint),
    'Layer': XMLParser.makeObjectPropertyPusher(WMS._readLayer)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.ATTRIBUTION_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Title': makePropertySetter(XSD.readString),
    'OnlineResource': makePropertySetter(XLink.readHref),
    'LogoURL': makePropertySetter(WMS._readSizedFormatOnlineresource)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS =
  XMLParser.makeParsersNS(WMS.NAMESPACE_URIS, {
    'westBoundLongitude': makePropertySetter(
      XSD.readDecimal),
    'eastBoundLongitude': makePropertySetter(
      XSD.readDecimal),
    'southBoundLatitude': makePropertySetter(
      XSD.readDecimal),
    'northBoundLatitude': makePropertySetter(
      XSD.readDecimal)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.REQUEST_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'GetCapabilities': makePropertySetter(
      WMS._readOperationType),
    'GetMap': makePropertySetter(
      WMS._readOperationType),
    'GetFeatureInfo': makePropertySetter(
      WMS._readOperationType)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.OPERATIONTYPE_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Format': XMLParser.makeObjectPropertyPusher(XSD.readString),
    'DCPType': XMLParser.makeObjectPropertyPusher(
      WMS._readDCPType)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.DCPTYPE_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'HTTP': makePropertySetter(
      WMS._readHTTP)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.HTTP_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Get': makePropertySetter(
      WMS._readFormatOnlineresource),
    'Post': makePropertySetter(
      WMS._readFormatOnlineresource)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.STYLE_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Name': makePropertySetter(XSD.readString),
    'Title': makePropertySetter(XSD.readString),
    'Abstract': makePropertySetter(XSD.readString),
    'LegendURL': XMLParser.makeObjectPropertyPusher(WMS._readSizedFormatOnlineresource),
    'StyleSheetURL': makePropertySetter(WMS._readFormatOnlineresource),
    'StyleURL': makePropertySetter(WMS._readFormatOnlineresource)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.FORMAT_ONLINERESOURCE_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Format': makePropertySetter(XSD.readString),
    'OnlineResource': makePropertySetter(XLink.readHref)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.KEYWORDLIST_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Keyword': XMLParser.makeArrayPusher(XSD.readString)
  });

module.exports = WMS;

},{"./node_types":2,"./utils/isdef":3,"./utils/setifundefined":4,"./xlink":7,"./xml_parser":8,"./xsd":9}],7:[function(require,module,exports){
"use strict";

/**
 * @const
 * @type {string}
 */
var NAMESPACE_URI = 'http://www.w3.org/1999/xlink';

module.exports = {

  /**
   * @param {Node} node Node.
   * @return {Boolean|undefined} Boolean.
   */
  readHref: function(node) {
    return node.getAttributeNS(NAMESPACE_URI, 'href');
  }
};

},{}],8:[function(require,module,exports){
"use strict";

var isDef = require('./utils/isdef');
var setIfUndefined = require('./utils/setifundefined');
var nodeTypes = require('./node_types');

/**
 * XML DOM parser
 * @constructor
 */
function XMLParser() {

  /**
   * @type {DOMParser}
   */
  this._parser = new DOMParser();
};

/**
 * @param  {String} xmlstring
 * @return {Document}
 */
XMLParser.prototype.toDocument = function(xmlstring) {
  return this._parser.parseFromString(xmlstring, 'application/xml');
};

/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */
XMLParser.getAllTextContent = function(node, normalizeWhitespace) {
  return XMLParser.getAllTextContent_(node, normalizeWhitespace, []).join('');
};


/**
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array.<String|string>} accumulator Accumulator.
 * @private
 * @return {Array.<String|string>} Accumulator.
 */
XMLParser.getAllTextContent_ = function(node, normalizeWhitespace, accumulator) {
  if (node.nodeType === nodeTypes.CDATA_SECTION ||
    node.nodeType === nodeTypes.TEXT) {
    if (normalizeWhitespace) {
      // FIXME understand why goog.dom.getTextContent_ uses String here
      accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      accumulator.push(node.nodeValue);
    }
  } else {
    var n;
    for (n = node.firstChild; n; n = n.nextSibling) {
      XMLParser.getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
  }
  return accumulator;
};

/**
 * @param {Object.<string, Object.<string, XMLParser.Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} bind The object to use as `this`.
 */
XMLParser.parseNode = function(parsersNS, node, objectStack, bind) {
  for (var n = XMLParser.firstElementChild(node); n; n = XMLParser.nextElementSibling(n)) {
    var namespaceURI = n.namespaceURI || null;
    var parsers = parsersNS[namespaceURI];
    if (isDef(parsers)) {
      var parser = parsers[n.localName];
      if (isDef(parser)) {
        parser.call(bind, n, objectStack);
      }
    }
  }
};

/**
 * Mostly for node.js
 * @param  {Node} node
 * @return {Node}
 */
XMLParser.firstElementChild = function(node) {
  var firstElementChild = node.firstElementChild || node.firstChild;
  while (firstElementChild && firstElementChild.nodeType !== nodeTypes.ELEMENT) {
    firstElementChild = firstElementChild.nextSibling;
  }
  return firstElementChild;
};

/**
 * Mostly for node.js
 * @param  {Node} node
 * @return {Node}
 */
XMLParser.nextElementSibling = function(node) {
  var nextElementSibling = node.nextElementSibling || node.nextSibling;
  while (nextElementSibling && nextElementSibling.nodeType !== nodeTypes.ELEMENT) {
    nextElementSibling = nextElementSibling.nextSibling;
  }
  return nextElementSibling;
};

/**
 * @param {Array.<string>} namespaceURIs Namespace URIs.
 * @param {Object.<string, XMLParser.Parser>} parsers Parsers.
 * @param {Object.<string, Object.<string, XMLParser.Parser>>=} opt_parsersNS
 *     ParsersNS.
 * @return {Object.<string, Object.<string, XMLParser.Parser>>} Parsers NS.
 */
XMLParser.makeParsersNS = function(namespaceURIs, parsers, opt_parsersNS) {
  return /** @type {Object.<string, Object.<string, XMLParser.Parser>>} */ (
    XMLParser.makeStructureNS(namespaceURIs, parsers, opt_parsersNS));
};

/**
 * Creates a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array.<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object.<string, T>=} opt_structureNS Namespaced structure to add to.
 * @return {Object.<string, T>} Namespaced structure.
 * @template T
 */
XMLParser.makeStructureNS = function(namespaceURIs, structure, opt_structureNS) {
  /**
   * @type {Object.<string, *>}
   */
  var structureNS = isDef(opt_structureNS) ? opt_structureNS : {};
  var i, ii;
  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
    structureNS[namespaceURIs[i]] = structure;
  }
  return structureNS;
};

/**
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {XMLParser.Parser} Parser.
 * @template T
 */
XMLParser.makeObjectPropertySetter = function(valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function(node, objectStack) {
      var value = valueReader.call(isDef(opt_this) ? opt_this : this,
        node, objectStack);
      if (isDef(value)) {
        var object = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        var property = isDef(opt_property) ? opt_property : node.localName;
        object[property] = value;
      }
    });
};

/**
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {Function} Parser.
 * @template T
 */
XMLParser.makeObjectPropertyPusher = function(valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function(node, objectStack) {
      var value = valueReader.call(isDef(opt_this) ? opt_this : this,
        node, objectStack);

      if (isDef(value)) {
        var object = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        var property = isDef(opt_property) ? opt_property : node.localName;
        var array = setIfUndefined(object, property, []);
        array.push(value);
      }
    });
};

/**
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {Function} Parser.
 * @template T
 */
XMLParser.makeArrayPusher = function(valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function(node, objectStack) {
      var value = valueReader.call(isDef(opt_this) ? opt_this : this,
        node, objectStack);
      if (isDef(value)) {
        var array = objectStack[objectStack.length - 1];
        array.push(value);
      }
    });
};

/**
 * @param {Object}                                     object Object.
 * @param {Object.<String, Object.<String, Function>>} parsersNS Parsers by namespace.
 * @param {Node}                                       node Node.
 * @param {Array.<*>}                                  objectStack Object stack.
 * @param {*=}                                         bind The object to use as `this`.
 * @return {Object|undefined} Object.
 */
XMLParser.pushParseAndPop = function(object, parsersNS, node, objectStack, bind) {
  objectStack.push(object);
  XMLParser.parseNode(parsersNS, node, objectStack, bind);
  return objectStack.pop();
};

module.exports = XMLParser;

},{"./node_types":2,"./utils/isdef":3,"./utils/setifundefined":4}],9:[function(require,module,exports){
"use strict";

var isDef = require('./utils/isdef');
var string = require('./utils/string');
var XMLParser = require('./xml_parser');

var XSD = {};

/**
 * @const
 * @type {string}
 */
XSD.NAMESPACE_URI = 'http://www.w3.org/2001/XMLSchema';

/**
 * @param {Node} node Node.
 * @return {boolean|undefined} Boolean.
 */
XSD.readBoolean = function(node) {
  var s = XMLParser.getAllTextContent(node, false);
  return XSD.readBooleanString(s);
};

/**
 * @param {string} string String.
 * @return {boolean|undefined} Boolean.
 */
XSD.readBooleanString = function(string) {
  var m = /^\s*(true|1)|(false|0)\s*$/.exec(string);
  if (m) {
    return isDef(m[1]) || false;
  } else {
    return undefined;
  }
};


/**
 * @param {Node} node Node.
 * @return {number|undefined} DateTime in seconds.
 */
XSD.readDateTime = function(node) {
  var s = XMLParser.getAllTextContent(node, false);
  var re = /^\s*(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(Z|(?:([+\-])(\d{2})(?::(\d{2}))?))\s*$/;
  var m = re.exec(s);
  if (m) {
    var year = parseInt(m[1], 10);
    var month = parseInt(m[2], 10) - 1;
    var day = parseInt(m[3], 10);
    var hour = parseInt(m[4], 10);
    var minute = parseInt(m[5], 10);
    var second = parseInt(m[6], 10);
    var dateTime = Date.UTC(year, month, day, hour, minute, second) / 1000;
    if (m[7] != 'Z') {
      var sign = m[8] == '-' ? -1 : 1;
      dateTime += sign * 60 * parseInt(m[9], 10);
      if (isDef(m[10])) {
        dateTime += sign * 60 * 60 * parseInt(m[10], 10);
      }
    }
    return dateTime;
  } else {
    return undefined;
  }
};


/**
 * @param {Node} node Node.
 * @return {number|undefined} Decimal.
 */
XSD.readDecimal = function(node) {
  var s = XMLParser.getAllTextContent(node, false);
  return XSD.readDecimalString(s);
};


/**
 * @param {string} string String.
 * @return {number|undefined} Decimal.
 */
XSD.readDecimalString = function(string) {
  // FIXME check spec
  var m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
  if (m) {
    return parseFloat(m[1]);
  } else {
    return undefined;
  }
};


/**
 * @param {Node} node Node.
 * @return {number|undefined} Non negative integer.
 */
XSD.readNonNegativeInteger = function(node) {
  var s = XMLParser.getAllTextContent(node, false);
  return XSD.readNonNegativeIntegerString(s);
};


/**
 * @param {string} string String.
 * @return {number|undefined} Non negative integer.
 */
XSD.readNonNegativeIntegerString = function(string) {
  var m = /^\s*(\d+)\s*$/.exec(string);
  if (m) {
    return parseInt(m[1], 10);
  } else {
    return undefined;
  }
};


/**
 * @param {Node} node Node.
 * @return {string|undefined} String.
 */
XSD.readString = function(node) {
  var s = XMLParser.getAllTextContent(node, false);
  return string.trim(s);
};


/**
 * @param {Node} node Node to append a TextNode with the boolean to.
 * @param {boolean} bool Boolean.
 */
XSD.writeBooleanTextNode = function(node, bool) {
  XSD.writeStringTextNode(node, (bool) ? '1' : '0');
};


/**
 * @param {Node} node Node to append a TextNode with the dateTime to.
 * @param {number} dateTime DateTime in seconds.
 */
XSD.writeDateTimeTextNode = function(node, dateTime) {
  var date = new Date(dateTime * 1000);
  var string = date.getUTCFullYear() + '-' +
    string.padNumber(date.getUTCMonth() + 1, 2) + '-' +
    string.padNumber(date.getUTCDate(), 2) + 'T' +
    string.padNumber(date.getUTCHours(), 2) + ':' +
    string.padNumber(date.getUTCMinutes(), 2) + ':' +
    string.padNumber(date.getUTCSeconds(), 2) + 'Z';
  node.appendChild(XMLParser.DOCUMENT.createTextNode(string));
};


/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} decimal Decimal.
 */
XSD.writeDecimalTextNode = function(node, decimal) {
  var string = decimal.toPrecision();
  node.appendChild(XMLParser.DOCUMENT.createTextNode(string));
};


/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} nonNegativeInteger Non negative integer.
 */
XSD.writeNonNegativeIntegerTextNode = function(node, nonNegativeInteger) {
  var string = nonNegativeInteger.toString();
  node.appendChild(XMLParser.DOCUMENT.createTextNode(string));
};


/**
 * @param {Node} node Node to append a TextNode with the string to.
 * @param {string} string String.
 */
XSD.writeStringTextNode = function(node, string) {
  node.appendChild(XMLParser.DOCUMENT.createTextNode(string));
};

module.exports = XSD;

},{"./utils/isdef":3,"./utils/string":5,"./xml_parser":8}]},{},[1])(1)
});
/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Registry/WMSServer',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "xmltojson",
    "../Layer/LayerFactory",
    "wms-capabilities"
], function($, _, Utils, XmlToJson, LayerFactory, WMSCapabilities) {
    /**
     * @class
     * Creates an instance of WMS server
     * A WMS server exposes a set of {@link WMSLayer WMS} layers.
     * @param {Options} options Options
     * @param {string} [options.baseUrl] Base URL of the getCapabilities
     * @param {string} [options.getCapabilities] GetCapabilities
     * @memberof module:Registry
     * @constructor
     */
    var WMSServer = function(options) {
        if (options.getCapabilities) {
            options.baseUrl = Utils.computeBaseUrlFromCapabilities(
                options.getCapabilities,
                ["service", "request", "version"]
            );
        } else if (options.baseUrl) {
            options.getCapabilities = WMSServer.getCapabilitiesFromBaseURl(
                options.baseUrl,
                options
            );
        } else {
            throw new ReferenceError(
                "No URL to access to the server is defined",
                "WMSLayer.js"
            );
        }
        this.options = options;
    };

    /**
     * Skip when the current layer is not included in the list of defined layers (layersFromConf)
     * @param {string[]} layersFromConf List of user-defined layer
     * @param {string} currentLayer
     * @returns {boolean} true wen the currentLayer is not included in the list of user-defined layers otherwise false
     * @function _mustBeSkipped
     * @memberof WMSServer#
     * @private
     */

    function _mustBeSkipped(layersFromConf, currentLayerName) {
        return (
            layersFromConf.length !== 0 &&
            !_.contains(layersFromConf, currentLayerName)
        );
    }

    /**
     * Capabilities has a group ?
     * @param {string} jsonLayer layer
     * @returns  {boolean} true when layers are grouped otherwise false
     * @function _hasGroup
     * @memberof WMSServer#
     * @private
     */
    function _hasGroup(jsonLayer) {
        return Array.isArray(jsonLayer.Layer);
    }

    /**
     * Computes attribution from capabilities
     * @param {string} layerDescription User-defined layer description
     * @param {string} jsonLayers Metadata on the layers
     * @param {string} jsonLayer layer description from capabilities
     * @function _computeAttribution
     * @memberof WMSServer#
     * @private
     */
    function _computeAttribution(layerDescription, jsonLayers, jsonLayer) {
        var attribution, logo, title;
        if (layerDescription.attribution) {
            attribution = layerDescription.attribution;
        } else if (jsonLayer.Attribution != null) {
            logo =
                jsonLayer.Attribution.LogoURL != null
                    ? "<img src='" +
                      jsonLayer.Attribution.LogoURL.OnlineResource +
                      "' height='25px'/> "
                    : "";
            title =
                jsonLayer.Attribution.Title != null
                    ? jsonLayer.Attribution.Title
                    : "";
            attribution = logo + title;
        } else if (jsonLayers.Attribution != null) {
            logo =
                jsonLayers.Attribution.LogoURL != null
                    ? "<img src='" +
                      jsonLayers.Attribution.LogoURL.OnlineResource +
                      "' height='25px'/> "
                    : "";
            title =
                jsonLayers.Attribution.Title != null
                    ? jsonLayers.Attribution.Title
                    : "";
            attribution = logo + title;
        } else {
            attribution = null;
        }
        return attribution;
    }

    /**
     * Computes copyright
     * @param {string} layerDescription User-defined layer description
     * @param {string} jsonLayers Metadata on the layers
     * @param {string} jsonLayer layer description from capabilities
     * @function _computeCopyrightURL
     * @memberof WMSServer#
     * @private
     */
    function _computeCopyrightURL(layerDescription, jsonLayers, jsonLayer) {
        var copyrightURL;
        if (layerDescription.copyrightUrl) {
            copyrightURL = layerDescription.copyrightUrl;
        } else if (jsonLayer.Attribution != null) {
            copyrightURL =
                jsonLayer.Attribution.OnlineResource != null
                    ? jsonLayer.Attribution.OnlineResource
                    : "";
        } else if (jsonLayers.Attribution != null) {
            copyrightURL =
                jsonLayers.Attribution.OnlineResource != null
                    ? jsonLayers.Attribution.OnlineResource
                    : "";
        } else {
            copyrightURL = "";
        }
        return copyrightURL;
    }

    /**
     * Computes the bbox center.
     * if bbox is null then center is defined as [0,0, 100000]
     * @param {bbox_type|null} bbox
     * @returns {center_type} the central position of the camera and the distance from which the bbox is embedded
     * @function _computeCenterBbox
     * @memberof WMSServer#
     * @private
     */

    function _computeCenterBbox(bbox) {
        var centerLong = 0.5 * (bbox[0] + bbox[2]);
        var centerLat = 0.5 * (bbox[1] + bbox[3]);
        var deltaLong = bbox[2] - bbox[0];
        if (deltaLong > 180) {
            deltaLong = 180;
        }
        var deltaLat = bbox[3] - bbox[1];
        var delta = deltaLong > deltaLat ? deltaLat : deltaLong;
        return [centerLong, centerLat];
    }

    /**
     * Converts a bbox string to an array of float.
     * @param {string[]} jsonBbox. bbox as string. First element is the lower left corner. 2nd element is the upper right corner
     * @returns {bbox_type} bbox as an array
     * @function _bbox
     * @memberof WMSServer#
     * @private
     */

    function _bbox(jsonLayer) {
        var bbox = jsonLayer.EX_GeographicBoundingBox;
        var result;
        if (bbox == null) {
            result = [-180, -90, 180, 90];
        } else {
            var long1 = bbox[0] > 180 ? bbox[0] - 360 : bbox[0];
            var long2 = bbox[2] > 180 ? bbox[2] - 360 : bbox[2];
            result = [long1, bbox[1], long2, bbox[3]];
        }
        return result;
    }

    /**
     * Boox for grouped layer
     * @param {string} jsonLayer layer from capabilities
     * @returns  {bbox_type} bbox as an array
     * @function _bboxGroup
     * @memberof WMSServer#
     * @private
     */
    function _bboxGroup(jsonLayer) {
        var result;
        if (_hasGroup.call(this, jsonLayer)) {
            var layer, layerBbox;
            var minLong = 180,
                maxLong = -180,
                minLat = 90,
                maxLat = -90;
            for (var i = 0; i < jsonLayer.Layer.length; i++) {
                layer = jsonLayer.Layer[i];
                layerBbox = _bbox.call(this, layer);
                minLong = Math.min(minLong, layerBbox[0]);
                minLat = Math.min(minLat, layerBbox[1]);
                maxLong = Math.max(maxLong, layerBbox[2]);
                maxLat = Math.max(maxLat, layerBbox[3]);
            }
            result = [minLong, minLat, maxLong, maxLat];
        } else {
            result = _bbox.call(this, jsonLayer);
        }
        return result;
    }

    /**
     * Returns the metadata
     * @param {metadata~requestCallback} callback
     * @param {serverLayerFallback} fallback
     * @function getMetadata
     * @memberof WMSServer#
     */

    WMSServer.prototype.getMetadata = function(callback, fallback) {
        var self = this;
        Utils.requestUrl(
            this.options.getCapabilities,
            "text",
            "application/xml",
            {},
            function(response) {
                var metadata = new WMSCapabilities().parse(response);
                callback(self.options, metadata);
            },
            function(e) {
                if (fallback) {
                    e.setLayerDescription(self.options);
                    fallback(e);
                }
            }
        );
    };

    /**
     * The dimension.
     * @typedef {Object} dimension_type
     * @property {string} units - Units of the dimension.
     * @property {string} unitSymbol - Unit symbol.
     * @property {string} default - default value.
     * @property {string} multipleValues - multiples values.
     * @property {string} nearestValue - nearest vlaue.
     * @property {string} value - value.
     */

    /**
     * Parses the dimension from capabilities
     * @param {Array.<dimension_type>} dimension
     * @returns {{}} a hash of name => dimension
     * @function _parseDimension
     * @memberof WMSServer#
     * @private
     */
    function _parseDimension(dimension) {
        if (dimension == null) {
            return null;
        }
        var dim = {};
        for (var i = 0; i < dimension.length; i++) {
            var currentDim = dimension[i];
            var myDim = {
                units: currentDim.units,
                unitSymbol: currentDim.unitSymbol,
                default: currentDim.default,
                multipleValues: currentDim.multipleValues,
                nearestValue: currentDim.nearestValue,
                value: currentDim.values
            };
            dim[currentDim.name] = myDim;
        }
        return dim;
    }

    /**
     * Create a layer
     * @param {*} layerDescription
     * @param {*} jsonLayers
     * @param {*} jsonLayer
     * @returns {Layer} the layer
     * @function _createLayer
     * @memberof WMSServer#
     * @private
     */
    function _createLayer(layerDescription, jsonLayers, jsonLayer) {
        var attribution = [];
        if (_hasGroup.call(this, jsonLayer)) {
            for (var i = 0; i < jsonLayer.Layer.length; i++) {
                var layer = jsonLayer.Layer[i];
                attribution.push(
                    _computeAttribution.call(
                        this,
                        layerDescription,
                        jsonLayers,
                        layer
                    )
                );
            }
        } else {
            attribution.push(
                _computeAttribution.call(
                    this,
                    layerDescription,
                    jsonLayers,
                    jsonLayer
                )
            );
        }
        var copyrightURL = _computeCopyrightURL.call(
            this,
            layerDescription,
            jsonLayers,
            jsonLayer
        );
        var bbox = _bboxGroup.call(this, jsonLayer);
        var center = _computeCenterBbox.call(this, bbox);
        var layerDesc = Object.assign({}, layerDescription, {});
        
        layerDesc.name = layerDescription.name || jsonLayer.Title;
        layerDesc.format = layerDescription.format || "image/png";
        layerDesc.layers = jsonLayer.Name;
        layerDesc.description =
            layerDescription.description || jsonLayer.Abstract != null
                ? jsonLayer.Abstract
                : jsonLayers.Abstract;
        layerDesc.attribution = attribution.join("<br/>");
        layerDesc.copyrightUrl = copyrightURL;
        layerDesc.autoFillTimeTravel = layerDescription.autoFillTimeTravel;
        layerDesc.properties = {
            initialRa: center[0],
            initialDec: center[1],
            bbox: bbox
        };
        layerDesc.dimension = _parseDimension.call(this, jsonLayer.Dimension);
        layerDesc.metadataAPI = jsonLayer;

        return LayerFactory.create(layerDesc);
    }

    /**
     * Create layers
     * @param {*} layerDescription
     * @param {*} layersFromConf
     * @param {*} jsonLayers
     * @function _createLayers
     * @memberof WMSServer#
     * @private
     */
    function _createLayers(layerDescription, layersFromConf, jsonLayers) {
        var layers = [];
        for (var i = 0; i < jsonLayers.Layer.length; i++) {
            var jsonLayer = jsonLayers.Layer[i];
            if (jsonLayer.Layer != null) {
                layers = layers.concat(
                    _createLayers(layerDescription, layersFromConf, jsonLayer)
                );
            }
            if (_mustBeSkipped.call(this, layersFromConf, jsonLayer.Name)) {
                continue;
            }
            layers.push(
                _createLayer.call(this, layerDescription, jsonLayers, jsonLayer)
            );
        }
        return layers;
    }

    /**
     * Create WMS layers from WMS capabilities
     * @param {serverLayerCallback} callback
     * @param {serverLayerFallback} fallback
     * @function createLayers
     * @memberof WMSServer#
     */

    WMSServer.prototype.createLayers = function(callback, fallback) {
        this.getMetadata(function(layerDescription, metadata) {
            var layersFromConf = layerDescription.hasOwnProperty("layers")
                ? layerDescription.layers.trim().split(/\s*,\s*/)
                : [];
            var jsonLayers = metadata.Capability.Layer;
            var layers = _createLayers(
                layerDescription,
                layersFromConf,
                jsonLayers
            );
            callback(layers);
        }, fallback);
    };

    /**
     * Returns the capabilities
     * @param {string} baseUrl GetCapabilities URL
     * @param {Object} options
     * @param {string} [options.version = 1.0.0] WCS version
     * @function getCapabilitiesFromBaseURL
     * @memberof WMSServer#
     * @returns {string} describeCoverage URL
     */
    WMSServer.getCapabilitiesFromBaseURl = function(baseUrl, options) {
        var getCapabilitiesUrl = baseUrl;
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "service",
            "WMS"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "request",
            "getCapabilities"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.3.0"
        );
        return getCapabilitiesUrl;
    };

    return WMSServer;
});

/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Registry/WMSServerRegistryHandler',[
    "../Utils/Utils",
    "./AbstractRegistryHandler",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "./WMSServer"
], function(Utils, AbstractRegistryHandler, Constants, ErrorDialog, WMSServer) {
    /**
     * @class
     * Creates a WMS handler to create {@link WMSLayer WMS layers}
     * @param {*} pendingLayers
     * @augments AbstractRegistryHandler
     * @memberof module:Registry
     * @constructor
     * @see {@link WMSServer}
     */
    var WMSServerRegistryHandler = function(pendingLayers) {
        AbstractRegistryHandler.prototype.constructor.call();
        this.pendingLayers = pendingLayers;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRegistryHandler, WMSServerRegistryHandler);

    /**************************************************************************************************************/

    /**
     * @function handleRequest
     * @memberof WMSServerRegistryHandler#
     */

    WMSServerRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {
        try {
            if (layerDescription.type === Constants.LAYER.WMS) {
                var wmsServer = new WMSServer(
                    layerDescription
                );
                var self = this;
                wmsServer.createLayers(function(layers) {
                    //TODO : I loose the callback of pendingLayers
                    self._handlePendingLayers(self.pendingLayers, layers);
                    callback(layers);
                }, fallback);
            } else {
                this.next.handleRequest(layerDescription, callback, fallback);
            }
        } catch (e) {
            if (fallback) {
                fallback(e);
            } else {
                ErrorDialog.open(Constants.LEVEL.DEBUG, "WMSServerRegistryHandler.js", e);
            }
        }
    };

    return WMSServerRegistryHandler;
});

/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Registry/WMTSServer',[
    "underscore-min",
    "../Utils/Utils",
    "xmltojson",
    "./WMTSMetadata",
    "../Layer/LayerFactory"
], function(_, Utils, XmlToJson, WMTSMetadata, LayerFactory) {
    /**
     * @class
     * Creates an instance of WMTS server
     * A WMTS server exposes a set of {@link WMTSLayer WMTS} layers.
     * @param {Options} options Options
     * @param {string} [options.baseUrl] Base URL of the getCapabilities
     * @param {string} [options.getCapabilities] GetCapabilities
     * @memberof module:Registry
     */
    var WMTSServer = function(options) {
        if (options.getCapabilities) {
            options.baseUrl = Utils.computeBaseUrlFromCapabilities(
                options.getCapabilities,
                ["service", "request", "version"]
            );
        } else if (options.baseUrl) {
            options.getCapabilities = WMTSServer.getCapabilitiesFromBaseURl(
                options.baseUrl,
                options
            );
        } else {
            throw new ReferenceError(
                "No URL to access to the server is defined",
                "WMSLayer.js"
            );
        }
        this.options = options;
    };

    /**
     * Skip when the current layer is not included in the list of defined layers (layersFromConf)
     * @param {string[]} layersFromConf List of user-defined layer
     * @param {string} currentLayer
     * @returns {boolean} true wen the currentLayer is not included in the list of user-defined layers otherwise false
     * @function _mustBeSkipped
     * @memberof WMTSServer#
     * @private
     */

    function _mustBeSkipped(layersFromConf, currentLayer) {
        return (
            (layersFromConf.length !== 0 &&
                !_.contains(layersFromConf, currentLayer.identifier)) ||
            !_.contains(currentLayer.tileMatrixSetLink, "WGS84")
        );
    }

    /**
     * Returns the metadata
     * @param {metadata~requestCallback} callback
     * @param {serverLayerFallback} fallback
     * @function getMetadata
     * @memberof WMTSServer#
     */

    WMTSServer.prototype.getMetadata = function(callback, fallback) {
        var self = this;
        Utils.requestUrl(
            this.options.getCapabilities,
            "text",
            "application/xml",
            {},
            function(response) {
                var myOptions = {
                    mergeCDATA: true,
                    xmlns: false,
                    attrsAsObject: false,
                    childrenAsArray: false
                };
                var result = XmlToJson.parseString(response, myOptions);
                var metadata = new WMTSMetadata(result);
                callback(self.options, metadata);
            },
            function(e) {
                if (fallback) {
                    e.setLayerDescription(self.options);
                    fallback(e);
                }
            }
        );
    };

    /**
     * Create WMS layers from WMS capabilities
     * @param {serverLayerCallback} callback
     * @param {serverLayerFallback} fallback
     * @function createLayers
     * @memberof WMTSServer#
     */

    WMTSServer.prototype.createLayers = function(callback, fallback) {
        this.getMetadata(function(layerDescription, metadata) {
            var layersFromConf = layerDescription.hasOwnProperty("layers")
                ? layerDescription.layers.trim().split(/\s*,\s*/)
                : [];
            var jsonLayers = metadata.contents;
            var layers = [];
            for (var i = 0; i < jsonLayers.layers.length; i++) {
                var jsonLayer = jsonLayers.layers[i];
                if (_mustBeSkipped.call(this, layersFromConf, jsonLayer)) {
                    continue;
                }
                var attribution;
                if (layerDescription.attribution) {
                    attribution = layerDescription.attribution;
                } else {
                    attribution = null;
                }

                var copyrightURL = null;

                var layerDesc = Object.assign({}, layerDescription, {});
                layerDesc.name = layerDescription.name || jsonLayer.identifier;
                layerDesc.format = layerDescription.format || "image/png";
                layerDesc.layers = jsonLayer.title;
                layerDesc.description =
                    layerDescription.description || jsonLayer.abstract != null
                        ? jsonLayer.abstract
                        : jsonLayers.abstract;
                layerDesc.attribution = attribution;
                layerDesc.copyrightUrl = copyrightURL;

                var layer = LayerFactory.create(layerDesc);
                layers.push(layer);
            }
            callback(layers);
        }, fallback);
    };

    /**
     * Returns the capabilities
     * @param {string} baseUrl GetCapabilities URL
     * @param {Object} options
     * @param {string} [options.version = 1.0.0] WCS version
     * @function getCapabilitiesFromBaseURL
     * @memberof WMTServer#
     * @returns {string} describeCoverage URL
     */

    WMTSServer.getCapabilitiesFromBaseURl = function(baseUrl, options) {
        var getCapabilitiesUrl = baseUrl;
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "service",
            "WMTS"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "request",
            "getCapabilities"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.0.0"
        );
        return getCapabilitiesUrl;
    };

    return WMTSServer;
});

/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Registry/WMTSServerRegistryHandler',[
    "../Utils/Utils",
    "./AbstractRegistryHandler",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "./WMTSServer"
], function(Utils, AbstractRegistryHandler, Constants, ErrorDialog, WMTSServer) {
    /**
     * Creates a WMTS handler to create {@link WMTSLayer WMTS layers}
     * @param {*} pendingLayers
     * @augments AbstractRegistryHandler
     * @memberof module:Registry
     * @see {@link WMTSServer}
     * @constructor
     */
    var WMTSServerRegistryHandler = function(
        pendingLayers
    ) {
        AbstractRegistryHandler.prototype.constructor.call();
        this.pendingLayers = pendingLayers;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRegistryHandler, WMTSServerRegistryHandler);

    /**************************************************************************************************************/

    /**
     * @function handleRequest
     * @memberof WMTSServerRegistryHandler#
     */

    WMTSServerRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {
        try {
            if (layerDescription.type === Constants.LAYER.WMTS) {
                var wmtsServer = new WMTSServer(
                    layerDescription
                );
                var self = this;
                wmtsServer.createLayers(function(layers) {
                    //TODO : I loose the callback of pendingLayers
                    self._handlePendingLayers(self.pendingLayers, layers);
                    callback(layers);
                }, fallback);
            } else {
                this.next.handleRequest(layerDescription, callback, fallback);
            }
        } catch (e) {
            if (fallback) {
                fallback(e);
            } else {
                ErrorDialog.open(Constants.LEVEL.DEBUG, "WMTSServerRegistryHandler.js", e);
            }
        }
    };

    return WMTSServerRegistryHandler;
});

/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Registry/WCSServer',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "xmltojson",
    "../Layer/LayerFactory"
], function($, _, Utils, XmlToJson, LayerFactory, WCS) {
    /**
     * @class
     * Creates an instance of WCS server
     * A WCS server exposes a set of {@link WCSElevationLayer WCS} layers.
     * @param {Options} options Options
     * @param {string} [options.baseUrl] Base URL of the getCapabilities
     * @param {string} [options.getCapabilities] GetCapabilities
     * @constructor
     * @memberof module:Registry
     */
    var WCSServer = function(options) {
        if (options.getCapabilities) {
            options.baseUrl = Utils.computeBaseUrlFromCapabilities(
                options.getCapabilities,
                ["service", "request", "version"]
            );
        } else if (options.baseUrl) {
            options.getCapabilities = WCSServer.getCapabilitiesFromBaseURL(
                options.baseUrl,
                options
            );
        } else {
            throw new ReferenceError(
                "No URL to access to the server is defined",
                "WCSServer.js"
            );
        }
        options.describeCoverage = WCSServer.describeCoverageFromBaseURL(
            options.baseUrl,
            options
        );
        this.options = options;
    };

    /**
     * Skip when the current layer is not included in the list of defined layers (layersFromConf)
     * @param {string[]} layersFromConf List of user-defined layer
     * @param {string} currentLayer
     * @returns {boolean} true wen the currentLayer is not included in the list of user-defined layers otherwise false
     * @function _mustBeSkipped
     * @memberof WCSServer#
     * @private
     */
    function _mustBeSkipped(layersFromConf, currentLayer) {
        return (
            layersFromConf.length !== 0 &&
            !_.contains(layersFromConf, currentLayer.name._text)
        );
    }

    /**
     * Converts a bbox string to an array of float.
     * @param {string[]} jsonBbox. bbox as string. First element is the lower left corner. 2nd element is the upper right corner
     * @returns {bbox_type} bbox as an array
     * @function _bbox
     * @memberof WCSServer#
     * @private
     */
    function _bbox(jsonBbox) {
        var pos = jsonBbox.pos;
        var pos1 = pos[0]._text.split(" ");
        var pos2 = pos[1]._text.split(" ");
        return [
            parseFloat(pos1[0]),
            parseFloat(pos1[1]),
            parseFloat(pos2[0]),
            parseFloat(pos2[1])
        ];
    }

    /**
     * @typedef bbox_type
     * @type {array}
     * @property {string} 0 longitude in degee of the lower left corner.
     * @property {string} 1 latitude in degee of the lower left corner.
     * @property {string} 2 longitude in degee of the upper right corner.
     * @property {string} 3 latitude in degee of the upper right corner.
     */

    /**
     * @typedef center_type
     * @type {array}
     * @property {string} 0 longitude in degee.
     * @property {string} 1 latitude in degee.
     * @property {string} 2 distance from ground in meter.
     */

    /**
     * Computes the bbox center.
     * if bbox is null then center is defined as [0,0, 100000]
     * @param {bbox_type|null} bbox
     * @returns {center_type} the central position of the camera and the distance from which the bbox is embedded
     * @function _computeCenterBbox
     * @memberof WCSServer#
     * @private
     */
    function _computeCenterBbox(bbox) {
        var center;
        if (bbox == null) {
            center = [0, 0, 100000];
        } else {
            var centerLong = 0.5 * (bbox[0] + bbox[2]);
            var centerLat = 0.5 * (bbox[1] + bbox[3]);
            var deltaLong = bbox[2] - bbox[0];
            if (deltaLong > 180) {
                deltaLong = 180;
            }
            var deltaLat = bbox[3] - bbox[1];
            var delta = deltaLong > deltaLat ? deltaLat : deltaLong;
            var distance = (Math.abs(delta) * 3000000) / 180;
            center = [centerLong, centerLat, distance];
        }
        return center;
    }

    /**
     * Returns the time values seprated with a comma.
     * @param {*} lonlat
     * @returns {string} time seprated by a value
     * @function _timeVal
     * @memberof WCSServer#
     * @private
     */
    function _timeVal(lonlat) {
        var values;
        if (lonlat.timePosition == null) {
            values = null;
        } else {
            var timeArr = [];
            var time = lonlat.timePosition;
            for (var i = 0; i < time.length; i++) {
                timeArr.push(time[i]._text);
            }
            values = timeArr.join(",");
        }
        return values;
    }

    /**
     * Returns the metadata
     * @param {metadata~requestCallback} callback
     * @param {serverLayerFallback} fallback
     * @function getMetadata
     * @memberof WCSServer#
     */

    WCSServer.prototype.getMetadata = function(callback, fallback) {
        var self = this;
        Utils.requestUrl(
            this.options.getCapabilities,
            "text",
            "application/xml",
            {},
            function(response) {
                var myOptions = {
                    mergeCDATA: true,
                    xmlns: false,
                    attrsAsObject: false,
                    childrenAsArray: false
                };
                var metadata = XmlToJson.parseString(response, myOptions);
                callback(self.options, metadata);
            },
            function(e) {
                if (fallback) {
                    e.setLayerDescription(self.options);
                    fallback(e);
                }
            }
        );
    };

    /**
     * Returns the coverage
     * @param {*} callback
     * @param {*} fallback
     * @function getCoverage
     * @memberof WCSServer#
     */

    WCSServer.prototype.getCoverage = function(callback, fallback) {
        var self = this;
        Utils.requestUrl(
            this.options.describeCoverage,
            "text",
            "application/xml",
            {},
            function(response) {
                var myOptions = {
                    mergeCDATA: true,
                    xmlns: false,
                    attrsAsObject: false,
                    childrenAsArray: false
                };
                var metadata = XmlToJson.parseString(response, myOptions);
                callback(self.options, metadata);
            },
            function(e) {
                if (fallback) {
                    e.setLayerDescription(self.options);
                    fallback(e);
                }
            }
        );
    };

    /**
     * This callback creates the layers from the WCS capabilities.
     * @callback metadata~requestCallback
     * @param {string} layerDescription layerDescription
     * @param {string} metadata WCS capabiilties
     */

    /**
     * Create WCS layers from WCS capabilities
     * @param {serverLayerCallback} callback
     * @param {serverLayerFallback} fallback
     * @function createLayers
     * @memberof WCSServer#
     */
    WCSServer.prototype.createLayers = function(callback, fallback) {
        this.getMetadata(function(layerDescription, metadata) {
            // extracts layers from layer description if set
            var layersFromConf = layerDescription.hasOwnProperty("layers")
                ? layerDescription.layers.trim().split(/\s*,\s*/)
                : [];

            // retrieves the list of layers from capabilities
            var jsonLayers = [];
            var contentMetadata = metadata.WCS_Capabilities.ContentMetadata;
            if (Array.isArray(contentMetadata.CoverageOfferingBrief)) {
                jsonLayers = contentMetadata.CoverageOfferingBrief;
            } else {
                jsonLayers.push(contentMetadata);
            }

            // iter on each layer
            var layers = [];
            for (var i = 0; i < jsonLayers.length; i++) {
                // get a layer
                var jsonLayer = jsonLayers[i].CoverageOfferingBrief;
                if (_mustBeSkipped.call(this, layersFromConf, jsonLayer)) {
                    continue;
                }

                // get attribution
                var attribution;
                if (layerDescription.attribution) {
                    attribution = layerDescription.attribution;
                } else {
                    attribution = null;
                }

                // no copyright information from WCS capabilities
                var copyrightURL = null;

                // clone the layerDescription and fill it
                var layerDesc = Object.assign({}, layerDescription, {});
                layerDesc.name = layerDescription.name || jsonLayer.label._text;
                layerDesc.format = layerDescription.format;
                layerDesc.layers = jsonLayer.name._text;
                layerDesc.description = layerDescription.description;
                layerDesc.attribution = attribution;
                layerDesc.copyrightUrl = copyrightURL;
                var bbox = _bbox.call(this, jsonLayer.lonLatEnvelope);
                var center = _computeCenterBbox.call(this, bbox);
                layerDesc.properties = {
                    initialRa: center[0],
                    initialDec: center[1],
                    initialFov: center[2],
                    bbox: bbox
                };

                // extract time capabilities and fillt the layer description
                var timeValue = _timeVal.call(this, jsonLayer.lonLatEnvelope);
                layerDesc.dimension = {};
                if (timeValue != null) {
                    layerDesc.dimension.time = {
                        units: "ISO8601",
                        unitSymbol: null,
                        default: null,
                        multipleValues: null,
                        nearestValue: null,
                        current: null,
                        value: timeValue
                    };
                }

                layerDesc.metadataAPI = jsonLayer;

                // get the first value of the time range
                if (
                    layerDesc.dimension.time &&
                    layerDesc.dimension.time.value != null
                ) {
                    layerDesc.time = layerDesc.dimension.time.value.split(
                        ","
                    )[0];
                }

                // create the layer
                var layer = LayerFactory.create(layerDesc);
                layers.push(layer);
            }
            callback(layers);
        }, fallback);
    };

    /**
     * Returns the capabilities
     * @param {string} baseUrl GetCapabilities URL
     * @param {Object} options
     * @param {string} [options.version = 1.0.0] WCS version
     * @function getCapabilitiesFromBaseURL
     * @memberof WCSServer#
     * @returns {string} describeCoverage URL
     */
    WCSServer.getCapabilitiesFromBaseURL = function(baseUrl, options) {
        var getCapabilitiesUrl = baseUrl;
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "service",
            "WCS"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "request",
            "getCapabilities"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.0.0"
        );
        return getCapabilitiesUrl;
    };

    /**
     * Describes the coverage
     * @param {string} baseUrl describeCoverage URL
     * @param {Object} options Options
     * @param {string} [options.version = 1.0.0] WCS version
     * @function describeCoverageFromBaseURL
     * @memberof WCSServer#
     * @returns {string} describeCoverage URL
     */
    WCSServer.describeCoverageFromBaseURL = function(baseUrl, options) {
        var describeCoverageUrl = baseUrl;
        describeCoverageUrl = Utils.addParameterTo(
            describeCoverageUrl,
            "service",
            "WCS"
        );
        describeCoverageUrl = Utils.addParameterTo(
            describeCoverageUrl,
            "request",
            "describeCoverage"
        );
        describeCoverageUrl = Utils.addParameterTo(
            describeCoverageUrl,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.0.0"
        );
        return describeCoverageUrl;
    };

    return WCSServer;
});

/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Registry/WCSServerRegistryHandler',[
    "underscore-min",
    "../Utils/Utils",
    "./AbstractRegistryHandler",
    "../Utils/Constants",
    "./WCSServer",
    "../Gui/dialog/ErrorDialog"
], function(
    _,
    Utils,
    AbstractRegistryHandler,
    Constants,
    WCSServer,
    ErrorDialog
) {
    /**
     * @class
     * Creates a WCS Server Handler
     * @param {*} layers
     * @param {*} pendingLayers
     * @augments AbstractRegistryHandler
     * @memberof module:Registry
     * @constructor
     */
    var WCSServerRegistryHandler = function(
        layers,
        pendingLayers
    ) {
        AbstractRegistryHandler.prototype.constructor.call();
        this.layers = layers;
        this.pendingLayers = pendingLayers;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRegistryHandler, WCSServerRegistryHandler);

    /**************************************************************************************************************/

    /**
     * Moves an elements of the array to another index
     * @param {Array} array array
     * @param {number} from index where the element to move is located
     * @param {number} to index where the element must be gone.
     * @function _moveArrayEltFromTo
     * @memberof WCSServerRegistryHandler#
     * @private
     */
    function _moveArrayEltFromTo(array, from, to) {
        var extracted = array.splice(from, 1)[0];
        array.splice(to, 0, extracted);
    }

    /**
     * Destroys the TileWireFrame if it exists and returns its layer description.
     * @param layers list of layers to load
     * @function _destroyTileWireFrame
     * @memberof WCSServerRegistryHandler#
     * @private
     */
    function _destroyTileWireFrame(layers) {
        var i, layerDescription;
        var isFound = false;
        for (i = 0; i < layers.length; i++) {
            var layer = layers[i];
            if (layer.getType() === Constants.LAYER.TileWireframe) {
                isFound = true;
                break;
            }
        }
        if (isFound) {
            var layerToRemove = layers[i];
            layerDescription = layerToRemove.options;
            layerToRemove._detach();
            layers.splice(i, 1);
        }
        return layerDescription;
    }

    /**
     * Moves the TileWireFrameLayer to render at this end.
     * @param layers layers to render
     * @param AbstractRegistryHandler Registry
     * @param callback callback
     * @param fallback fallback
     * @function _moveTileWireFrameLayer
     * @memberof WCSServerRegistryHandler#
     * @private
     */
    function _moveTileWireFrameLayer(
        layers,
        AbstractRegistryHandler,
        callback,
        fallback
    ) {
        var layerDescription = _destroyTileWireFrame(layers);
        if (layerDescription) {
            AbstractRegistryHandler.next.handleRequest(
                layerDescription,
                callback,
                fallback
            );
        }
    }

    /**
     * @function handleRequest
     * @memberof WCSServerRegistryHandler#
     */

    WCSServerRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {
        try {
            if (layerDescription.type === Constants.LAYER.WCSElevation) {
                var wcsServer = new WCSServer(
                    layerDescription
                );
                var self = this;
                wcsServer.createLayers(function(layers) {
                    //TODO : I loose the callback of pendingLayers
                    self._handlePendingLayers(self.pendingLayers, layers);
                    callback(layers);
                    _moveTileWireFrameLayer(
                        self.layers,
                        self,
                        callback,
                        fallback
                    );
                }, fallback);
            } else {
                this.next.handleRequest(layerDescription, callback, fallback);
            }
        } catch (e) {
            if (fallback) {
                fallback(e);
            } else {
                ErrorDialog.open(Constants.LEVEL.DEBUG, e);
            }
        }
    };

    return WCSServerRegistryHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Layer/OpenSearch/OpenSearchParam',["./OpenSearchUtils"], function(OpenSearchUtils) {
    /**
     * @name OpenSearchParam
     * @class
     * All informations describing a parameter in an OpenSearch form
     * @param {Object} a json object describing the param
     * @memberof module:Layer
     */
    var OpenSearchParam = function(paramJson) {
        // init all values
        this.name = null; // Name of parameters
        this.value = null; // Value identifying the parameters
        this.title = null; // Title of parameter (for display)
        this.minInclusive = null; // (Level 1 Control - Number) Min value inclusive
        this.maxInclusive = null; // (Level 1 Control - Number) Max value inclusive
        this.pattern = null; // (Level 1 Control - String) Pattern
        this.options = null; // List of values if list provided
        this.currentValue = null; // Value to pass to parameter
        this.defaultValue = null; // Default value
        this.displayValue = ""; // Display value

        this.parseJson(paramJson);
    };

    /**************************************************************************************************************/

    /**
     * Parse Json
     * @function parseJson
     * @memberof OpenSearchParam#
     * @param {Object} paramJson Json object
     */

    OpenSearchParam.prototype.parseJson = function(paramJson) {
        this.name = OpenSearchUtils.getAttributeValue(paramJson, "name");
        this.name = this.name.replace(/\./g, "_");
        this.value = OpenSearchUtils.getAttributeValue(paramJson, "value");
        this.title = OpenSearchUtils.getAttributeValue(paramJson, "title");
        this.minInclusive = OpenSearchUtils.getAttributeValue(
            paramJson,
            "minInclusive"
        );
        this.maxInclusive = OpenSearchUtils.getAttributeValue(
            paramJson,
            "maxInclusive"
        );
        this.pattern = OpenSearchUtils.getAttributeValue(paramJson, "pattern");

        if (this.pattern === null) {
            this.patternAttribute = "";
        } else {
            this.patternAttribute = "pattern=\"" + this.pattern + "\" ";
        }

        if (paramJson.Option !== undefined) {
            this.options = [];
            if (paramJson.Option.length !== undefined) {
                for (var i = 0; i < paramJson.Option.length; i++) {
                    this.options.push(
                        OpenSearchUtils.getAttributeValue(
                            paramJson.Option[i],
                            "value"
                        )
                    );
                }
            } else {
                this.options.push(
                    OpenSearchUtils.getAttributeValue(paramJson.Option, "value")
                );
            }
        }

        if (this.options !== null) {
            this.type = "options";
        } else if (this.minInclusive !== null || this.maxInclusive !== null) {
            this.type = "number";
            if (this.title === null) {
                this.title = "";
            }
            if (this.maxInclusive === null) {
                this.title += "( >= " + this.minInclusive + " )";
            } else if (this.minInclusive === null) {
                this.title += "( <= " + this.maxInclusive + " )";
            } else {
                this.title +=
                    "( between " +
                    this.minInclusive +
                    " and " +
                    this.maxInclusive +
                    " )";
            }
        } else if (this.value.startsWith("{time:") === true) {
            this.type = "datetime";
        } else {
            this.type = "text";
        }

        if (this.title === null) {
            this.titleAttribute = "";
        } else {
            this.titleAttribute = "title=\"" + this.title + "\" ";
        }
    };

    /**************************************************************************************************************/

    /**
     * Return string representation
     * @function toString
     * @memberof OpenSearchParam#
     * @return {string} String representation
     */

    OpenSearchParam.prototype.toString = function() {
        var res = "";

        if (this.name !== null) {
            res += "     name : " + this.name + "\n";
        }

        if (this.value !== null) {
            res += "     value : " + this.value + "\n";
        }

        if (this.title !== null) {
            res += "     title : " + this.title + "\n";
        }

        if (this.minInclusive !== null) {
            res += "     minInclusive : " + this.minInclusive + "\n";
        }

        if (this.maxInclusive !== null) {
            res += "     maxInclusive : " + this.maxInclusive + "\n";
        }

        if (this.pattern !== null) {
            res += "     pattern : " + this.pattern + "\n";
        }

        if (this.options != null) {
            res += "     options : ";
            for (var i = 0; i < this.options.length; i++) {
                res += this.options[i] + ", ";
            }
            res += "\n";
        }
        return res;
    };

    /**************************************************************************************************************/

    /**
     * Get current value transformed (from IHM to Request)
     * @function currentValueTransformed
     * @memberof OpenSearchParam#
     * @return {string} Current value transformed
     */

    OpenSearchParam.prototype.currentValueTransformed = function() {
        // Only for date time, all other : no change
        if (this.type !== "datetime") {
            return this.currentValue;
        }

        if (
            this.currentValue === null ||
            typeof this.currentValue === "undefined"
        ) {
            return this.currentValue;
        }

        var deb = this.currentValue.substr(0, 10);
        var fin = this.currentValue.substr(-5);
        var res = deb + "T" + fin + ":00.00";
        return res;
    };

    /*************************************************************************************************************/

    return OpenSearchParam;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Layer/OpenSearch/OpenSearchForm',["jquery","underscore-min","./OpenSearchParam", "./OpenSearchUtils"], function(
    $,
    _,
    OpenSearchParam,
    OpenSearchUtils
) {
    /**
     * @name OpenSearchForm
     * @class
     * All informations describing an OpenSearch form
     * @param {Object} paramsJson a json object describing the form
     * @param {string} type form to load (application/json or application/atom+xml)
     * @memberof module:Layer
     */
    var OpenSearchForm = function(paramsJson, type) {
        // init all values
        this.type = null; // type of form (only application/json supported)
        this.template = null; // url template with params
        this.parameters = []; // list of params

        this.ignoredParameters = [];
        this.ignoredParameters.push("searchTerms");
        this.ignoredParameters.push("count");
        this.ignoredParameters.push("startIndex");
        this.ignoredParameters.push("startPage");
        this.ignoredParameters.push("language");
        this.ignoredParameters.push("inputEncoding");
        this.ignoredParameters.push("outputEncoding");

        var elts = _parseJson.call(this, paramsJson, type, this.ignoredParameters);
        if (elts !== null) {
            this.type = elts.type;
            this.template = elts.template;
            this.parameters = elts.parameters;
        } 
    };

    /**
     * Parse the json
     * @param {Object} paramsJson Parameteres
     * @param {string} type Type
     * @param {Array} ignoredParameters parameters to ignore    
     * @return {{type:string, template:Object, parameters:OpenSearchParam[]}|null} 
     * @private
     */
    function _parseJson(paramsJson, type, ignoredParameters) {
        var elts;
        if (Array.isArray(paramsJson)) {
            // Management of an array
            for (var i = 0; i < paramsJson.length; i++) {
                elts = _parseUrl.call(this, paramsJson[i], type, ignoredParameters);
                if(elts !== null) {
                    break;
                } else {
                    elts = null;
                }
            }
        } else {
            elts = _parseUrl.call(this, paramsJson, type, ignoredParameters);
        }
        return elts;
    }    

    /**
     * Parse url for request
     * @param {Objet} urlJson Json urls founded
     * @param {type} type Url type searched
     * @param {Array} ignoredParameters parameters to ignore
     * @return {{type:string, template:Object, parameters:OpenSearchParam[]}|null} 
     * @private     
     */
    function _parseUrl(urlJson, type, ignoredParameters) {
        var elts;
        var typeValue = OpenSearchUtils.getAttributeValue(urlJson, "type");
        if (typeValue !== type) {
            // Not the good type, do not take it into account
            elts = null;
        } else {
            elts = {
                type : typeValue,
                template : OpenSearchUtils.getAttributeValue(urlJson, "template"),
                parameters : _parseParameters.call(this, urlJson.Parameter, ignoredParameters)
            };
        }
        return elts;
    }

    /**
     * Parses parameters
     * @param {Objer[]} listParameters list of Opensearch parameters
     * @param {String[]} ignoredParameters parameters to not parse
     * @return {OpenSearchParam[]} List of OpenSearch parameters 
     * @private
     */
    function _parseParameters(listParameters, ignoredParameters) {
        var parameters = [];
        if (Array.isArray(listParameters)) {
            for (var i = 0; i < listParameters.length; i++) {
                var param = new OpenSearchParam(listParameters[i]);
                param.isDisplayed = true;
                for (var j = 0; j < ignoredParameters.length; j++) {
                    if (param.value === "{" + ignoredParameters[j] + "}") {
                        param.isDisplayed = false;
                    }
                }
                if (param.value.startsWith("{geo:")) {
                    param.isDisplayed = false;
                }
                parameters.push(param);
            }
        } else {
            parameters.push(new OpenSearchParam(listParameters));
        }
        return parameters;
    }


    /**
     * Get a string representation of the form
     * @function toString
     * @memberof OpenSearchForm#
     * @return {string} String representation of the form
     */
    OpenSearchForm.prototype.toString = function() {
        var res = "";
        res += "  type : " + this.type + "\n";
        res += "  template : " + this.template + "\n";
        res += "  parameters :\n";
        for (var i = 0; i < this.parameters.length; i++) {
            res += this.parameters[i].toString() + "\n";
        }
        return res;
    };

    OpenSearchForm.prototype.setParametersValueFrom = function(properties) {
        _.each(this.parameters, function(parameter) {
            Object.keys(properties).forEach(function(key,index) {
                if(parameter.name === "p_"+key) {
                    parameter.value = index[key];
                }
            });        
        }); 

    };

    /**
     * Update form parameters from GUI form
     * @function updateFromGUI
     * @memberof OpenSearchForm#
     */
    OpenSearchForm.prototype.updateFromGUI = function() {
        for (var i = 0; i < this.parameters.length; i++) {
            var param = this.parameters[i];
            var val = $("#p_" + param.name).val();
            if (val !== "") {
                param.currentValue = val;
            } else {
                param.currentValue = null;
            }
        }
    };

    /*************************************************************************************************************/

    return OpenSearchForm;
});

define('gw/Registry/OpenSearchServer',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "xmltojson",
    "../Layer/LayerFactory",
    "../Layer/OpenSearch/OpenSearchUtils",
    "../Layer/OpenSearch/OpenSearchForm"
], function($, _, Utils, XmlToJson, LayerFactory, OpenSearchUtils, OpenSearchForm) {

    /**
     * @class
     * Creates an instance of WMS server
     * A WMS server exposes a set of {@link OpenSearchLayer open search} layers.
     * @param {Options} options Options
     * @param {string} [options.baseUrl] Base URL of the getCapabilities
     * @param {string} [options.getCapabilities] GetCapabilities
     * @memberof module:Registry
     * @constructor
     */
    var OpenSearchServer = function(options) {
        // when url contains .xml, it means that the XML descriptor is there
        if (options.baseUrl && options.baseUrl.indexOf(".xml")!== -1) {
            options.getCapabilities = options.baseUrl;
        }

        if (!options.getCapabilities) {
            throw new ReferenceError(
                "No URL to access to the server is defined",
                "OpenSearchServer.js"
            );
        }
        this.options = options;
    };

    /**
     * Create layer
     * @param {*} layerDescription
     * @param {*} jsonLayer
     * @function _createLayer
     * @memberof OpenSearchServer#
     * @private
     */
    function _createLayer(layerDescription, openSearchRoot) {
        var layerDesc = Object.assign({}, layerDescription, {});
        layerDesc.name = layerDescription.name || OpenSearchUtils.getValue(openSearchRoot, "ShortName");
        layerDesc.description = layerDescription.description || OpenSearchUtils.getValue(openSearchRoot, "Description");
        layerDesc.attribution = layerDescription.attribution || OpenSearchUtils.getValue(openSearchRoot, "Attribution");

        layerDesc.properties = {};
        layerDesc.properties.longName = OpenSearchUtils.getValue(openSearchRoot, "LongName");
        layerDesc.properties.syndicationRight = OpenSearchUtils.getValue(openSearchRoot, "SyndicationRight");
        layerDesc.properties.developper = OpenSearchUtils.getValue(openSearchRoot, "Developper");

        var urls = openSearchRoot.Url;
        layerDesc.services = {};
        layerDesc.services.queryForm = new OpenSearchForm(urls, "application/json");
        OpenSearchUtils.initNavigationValues(
            layerDesc.services.queryForm
        );

        return LayerFactory.create(layerDesc);
    }    

    /**
     * Create WMS layers from WMS capabilities
     * @param {serverLayerCallback} callback
     * @param {serverLayerFallback} fallback
     * @function createLayers
     * @memberof OpenSearchServer#
     */

    OpenSearchServer.prototype.createLayers = function(callback, fallback) {
        this.getMetadata(function(layerDescription, metadata) {
            var layers = [];
            var jsonLayer = metadata.OpenSearchDescription;
            var layer = _createLayer(
                layerDescription,
                jsonLayer
            );
            layers.push(layer);
            callback(layers);
        }, fallback);
    };    

    OpenSearchServer.prototype.getMetadata = function(callback, fallback) {
        var self = this;
        Utils.requestUrl(
            this.options.getCapabilities,
            "text",
            "application/xml",
            {},
            function(response) {
                var myOptions = {
                    mergeCDATA: true,
                    xmlns: false,
                    attrsAsObject: false,
                    childrenAsArray: false
                };
                var metadata = XmlToJson.parseString(response, myOptions);                
                callback(self.options, metadata);
            },
            function(e) {
                if (fallback) {
                    e.setLayerDescription(self.options);
                    fallback(e);
                }
            }
        );
    };    

    return OpenSearchServer;
});
/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Registry/OpenSearchRegistryHandler',[
    "../Utils/Utils",
    "./AbstractRegistryHandler",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "./OpenSearchServer"
], function(Utils, AbstractRegistryHandler, Constants, ErrorDialog, OpenSearchServer) {

    /**
     * @class
     * Creates an OpenSearch handler to create {@link OpenSearchServer OpenSearch layers}
     * @param {*} pendingLayers
     * @augments AbstractRegistryHandler
     * @memberof module:Registry
     * @constructor
     * @see {@link WMSServer}
     */    
    var OpenSearchRegistryHandler = function(pendingLayers) {
        AbstractRegistryHandler.prototype.constructor.call();
        this.pendingLayers = pendingLayers;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRegistryHandler, OpenSearchRegistryHandler);

    /**************************************************************************************************************/    

    /**
     * @function handleRequest
     * @memberof OpenSearchRegistryHandler#
     */

    OpenSearchRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {
        try {
            if (layerDescription.type === Constants.LAYER.OpenSearch) {
                var openSearchServer = new OpenSearchServer(
                    layerDescription
                );
                var self = this;
                openSearchServer.createLayers(function(layers) {
                    //TODO : I loose the callback of pendingLayers
                    self._handlePendingLayers(self.pendingLayers, layers);
                    callback(layers);
                }, fallback);
            } else {
                this.next.handleRequest(layerDescription, callback, fallback);
            }
        } catch (e) {
            if (fallback) {
                fallback(e);
            } else {
                ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRegistryHandler.js", e);
            }
        }
    };

    return OpenSearchRegistryHandler;

});
/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Registry/PendingLayersRegistryHandler',[
    "../Utils/Utils",
    "./AbstractRegistryHandler",
    "../Utils/Constants"
], function(Utils, AbstractRegistryHandler, Constants) {
    /**
     * Creates a pending layer handler
     * @param {*} pendingLayers
     * @param {*} layers
     * @constructor
     * @augments AbstractRegistryHandler
     * @memberof module:Registry
     * @constructor
     */
    var PendingLayersRegistryHandler = function(pendingLayers, layers) {
        AbstractRegistryHandler.prototype.constructor.call();
        this.layers = layers;
        this.pendingLayers = pendingLayers;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRegistryHandler, PendingLayersRegistryHandler);

    /**************************************************************************************************************/

    /**
     * Check whether a layerbackground is already loaded.
     * @returns {boolean} true when the layer background is already defined otherwise false
     * @function hasLayerBackground
     * @memberof PendingLayersRegistryHandler#
     */
    PendingLayersRegistryHandler.prototype.hasLayerBackground = function() {
        var hasBackground = false;
        for (var i = 0; i < this.layers.length; i++) {
            var layer = this.layers[i];
            if (layer.isBackground()) {
                hasBackground = true;
                break;
            }
        }
        return hasBackground;
    };

    /**
     * @function handleRequest
     * @memberof PendingLayersRegistryHandler#
     */

    PendingLayersRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {
        if (
            (layerDescription.type === Constants.LAYER.Atmosphere ||
                layerDescription.type === Constants.LAYER.TileWireframe) &&
            !this.hasLayerBackground()
        ) {
            this.pendingLayers.push(layerDescription);
        } else {
            this.next.handleRequest(layerDescription, callback, fallback);
        }
    };

    return PendingLayersRegistryHandler;
});

/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/**
 * This package allow to call a registry of layers so that to create {@link Layer layers} from this registry. For this,
 * a set of handler is defined according to a chain of responsibility pattern.
 * <ul>
 *     <li>{@link module:Registry.LayerRegistryHandler LayerRegistryHandler}: Creates a simple {@link Layer} from {@link LayerFactory}</li>
 *     <li>{@link module:Registry.PendingLayersRegistryHandler PendingLayersRegistryHandler} : Create a pool of pending layer description.
 * In some cases, layer must declare in a certain order. To avoid an error, some layers has set as pending the time to have the required layer</li>
 *     <li>{@link module:Registry.WCSServerRegistryHandler WCSServerRegistryHandler} : Creates {@link WCSElevationLayer WCS layers} from {@link WCSServer}</li>
 *     <li>{@link module:Registry.WMSServerRegistryHandler WMSServerRegistryHandler} : Creates {@link WMSLayer WMS layers} from {@link WMSServer}</li>
 *     <li>{@link module:Registry.WMTSServerRegistryHandler WMTSServerRegistryHandler} : Creates {@link WMTSLayer WMTS layers} from {@link WMTSServer}</li>
 * </ul>
 *
 * The client can handle all this classes by the use of its {@link Registry interface}.
 *
 * @module Registry
 * @implements {RegistryHandler}
 */
define('gw/Registry/LayerRegistryHandler',[
    "../Utils/Utils",
    "./AbstractRegistryHandler",
    "../Layer/LayerFactory",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function(
    Utils,
    AbstractRegistryHandler,
    LayerFactory,
    Constants,
    ErrorDialog
) {
    /**
     * @class
     * This handler processes the layerdescription as a simple {@link LayerFactory}
     * @param {string[]} pendingLayers List of pending layer description
     * @augments AbstractRegistryHandler
     * @constructor
     * @memberof module:Registry
     */
    var LayerRegistryHandler = function(pendingLayers) {
        AbstractRegistryHandler.prototype.constructor.call();
        this.pendingLayers = pendingLayers;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRegistryHandler, LayerRegistryHandler);

    /**************************************************************************************************************/

    /**
     * @function handleRequest
     * @memberof LayerRegistryHandler#
     */

    LayerRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {
        var layers = [];
        try {
            var layer = LayerFactory.create(layerDescription);
            layers.push(layer);
            this._handlePendingLayers(this.pendingLayers, layers);
            callback(layers);
        } catch (e) {
            if (e instanceof RangeError && this.next != null) {
                this.next.handleRequest(layerDescription, callback, fallback);
            } else if (fallback) {
                fallback(e);
            } else {
                ErrorDialog.open(
                    Constants.LEVEL.DEBUG,
                    "Unknown error in LayerRegistryHanlder",
                    e
                );
            }
        }
    };

    return LayerRegistryHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Compass module : map control with "north" component
 */
define('gw/Services/CompassCore',["jquery", "../Utils/Constants"], function($, Constants) {
    const MAX_ROTATION = 360;

    /**
     *    Private variables
     */
    var parentElement = null;
    var ctx = null;
    var crs = null;
    var svgDoc = null;

    /**************************************************************************************************************/

    /**
     * Aligns with north.
     * @param {object} event
     * @private
     */
    function _alignWithNorth(event) {
        var coordinateSystem = ctx.getCoordinateSystem();
        var radius = coordinateSystem.getGeoide().getRadius();

        // scale the up direction to the sphere's surface in order to have the right value after projection.
        var up = [0, 0, radius];

        var temp = [];
        coordinateSystem.from3DToGeo(up, temp);
        temp = coordinateSystem.convert(
            temp,
            coordinateSystem.getGeoideName(),
            crs
        );
        coordinateSystem.fromGeoTo3D(temp, up);
        ctx.getNavigation().moveUpTo(up);
    }

    /**************************************************************************************************************/

    function updateNorthPlanet() {
        var navigation = ctx.getNavigation();
        var currentHeading = navigation.getHeading();

        var upHeading = 0;
        var degNorth =
            (currentHeading - upHeading + MAX_ROTATION) % MAX_ROTATION;

        var northText = svgDoc.getElementById("NorthText");
        northText.setAttribute("transform", "rotate(" + degNorth + " 40 40)");
    }

    function updateNorthAzimuth() {
        var navigation = ctx.getNavigation();
        var currentHeading = navigation.getHeading();

        var upHeading = 0;
        var degNorth =
            (upHeading - currentHeading + MAX_ROTATION) % MAX_ROTATION;

        var northText = svgDoc.getElementById("NorthText");
        northText.setAttribute("transform", "rotate(" + degNorth + " 40 40)");
    }

    function updateNorthSky() {
        var geo = [];
        var coordinateSystem = ctx.getCoordinateSystem();
        var center = ctx.getNavigation().center3d
            ? ctx.getNavigation().center3d
            : (center = ctx.getNavigation().geoCenter);
        coordinateSystem.from3DToGeo(center, geo);
        geo = coordinateSystem.convert(
            geo,
            crs,
            coordinateSystem.getGeoideName()
        );

        var LHV = [];
        coordinateSystem.getLHVTransform(geo, LHV);

        var temp = [];
        var north = [LHV[4], LHV[5], LHV[6]];
        var vertical = [LHV[8], LHV[9], LHV[10]];

        var up = vec3.create(ctx.getNavigation().up);
        vec3.scale(up, coordinateSystem.getGeoide().getRadius());

        coordinateSystem.from3DToGeo(up, temp);
        temp = coordinateSystem.convert(
            temp,
            crs,
            coordinateSystem.getGeoideName()
        );
        coordinateSystem.fromGeoTo3D(temp, up);
        vec3.normalize(up);
        // Find angle between up and north
        var cosNorth =
            vec3.dot(up, north) / (vec3.length(up) * vec3.length(north));
        var radNorth = Math.acos(cosNorth);

        if (isNaN(radNorth)) {
            return;
        }
        var degNorth = (radNorth * 180) / Math.PI;

        // Find sign between up and north
        var sign;
        vec3.cross(up, north, temp);
        sign = vec3.dot(temp, [vertical[0], vertical[1], vertical[2]]);
        if (sign < 0) {
            degNorth *= -1;
        }

        var northText = svgDoc.getElementById("NorthText");
        northText.setAttribute("transform", "rotate(" + degNorth + " 40 40)");
    }

    /**
     * Function updating the north position on compass
     */
    function updateNorth() {
        var mode = ctx.getMode();
        switch (mode) {
        case Constants.CONTEXT.Sky:
            updateNorthSky();
            break;
        case Constants.CONTEXT.Planet:
            updateNorthPlanet();
            break;
        case Constants.CONTEXT.Ground:
            updateNorthAzimuth();
            break;
        default:
            throw new RangeError(
                "CompassCore is not supported for this context",
                "CompassCore.js"
            );
        }
    }

    /**************************************************************************************************************/

    /**
     *    Remove compass element
     *
     */
    function remove() {
        document.getElementById(parentElement).innerHTML = "";
    }

    /**************************************************************************************************************/

    return {
        init: function(options) {
            parentElement = options.element;
            //ctx = options.ctx;
            //crs = ctx.getCoordinateSystem().getGeoideName();
            //svgDoc = options.svgDoc;
        },
        setSvg: function(svg) {
            svgDoc = svg;
        },
        setCtx: function(context) {
            ctx = context;
            crs = context.getCoordinateSystem().getGeoideName();
        },
        updateNorth: updateNorth,
        _alignWithNorth: _alignWithNorth,
        remove: remove
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Compass module : map control with "north" composant
 */
define('gw/Gui/Compass',[
    "jquery",
    "../Utils/Constants",
    "../Services/CompassCore",
    "../Utils/Utils"
], function($, Constants, CompassCore, Utils) {
    const COMPASS_SVG =
        "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjw/eG1sLXN0eWxlc2hlZXQgdHlwZT0idGV4dC9jc3MiIGhyZWY9ImNvbXBhc3MuY3NzIj8+PHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgd2lkdGg9IjUyMCIKICAgaGVpZ2h0PSI1MjAiCiAgIGlkPSJzdmcyIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlua3NjYXBlOnZlcnNpb249IjAuNDguMSByOTc2MCIKICAgc29kaXBvZGk6ZG9jbmFtZT0iY29tcGFzc05vcnRoMi5zdmciCiAgIHZpZXdCb3g9Ii0yMjAgLTIyMCA1MjAgNTIwIj4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE0NSI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGUgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGRlZnMKICAgICBpZD0iZGVmczQzIj4KICAgIDxyYWRpYWxHcmFkaWVudAogICAgICAgaWQ9ImdyYWQxIgogICAgICAgY3g9IjAiCiAgICAgICBjeT0iMCIKICAgICAgIHI9IjIwNyIKICAgICAgIGZ4PSIwIgogICAgICAgZnk9IjAiCiAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgIDxzdG9wCiAgICAgICAgIG9mZnNldD0iMC43NSIKICAgICAgICAgaWQ9InN0b3A2IgogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjojZmZmZmZmO3N0b3Atb3BhY2l0eTowIiAvPgogICAgICA8c3RvcAogICAgICAgICBvZmZzZXQ9IjAuOTQ5OTk5OTkiCiAgICAgICAgIGlkPSJzdG9wOCIKICAgICAgICAgc3R5bGU9InN0b3AtY29sb3I6I2ZmOTkwMDtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3AKICAgICAgICAgb2Zmc2V0PSIxMDAlIgogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjpyZ2IoMjU1LCAyNTUsIDI1NSk7c3RvcC1vcGFjaXR5OjAiCiAgICAgICAgIGlkPSJzdG9wMTAiIC8+CiAgICA8L3JhZGlhbEdyYWRpZW50PgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEiCiAgICAgb2JqZWN0dG9sZXJhbmNlPSIxMCIKICAgICBncmlkdG9sZXJhbmNlPSIxMCIKICAgICBndWlkZXRvbGVyYW5jZT0iMTAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEyODAiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAwMCIKICAgICBpZD0ibmFtZWR2aWV3NDEiCiAgICAgc2hvd2dyaWQ9ImZhbHNlIgogICAgIGlua3NjYXBlOnpvb209IjAuNDEzMTgxODMiCiAgICAgaW5rc2NhcGU6Y3g9IjEwMy43NDIwNiIKICAgICBpbmtzY2FwZTpjeT0iNDguNTQ5MDc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIwIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNCIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9IkVhc3QiCiAgICAgc2hvd2d1aWRlcz0idHJ1ZSIKICAgICBpbmtzY2FwZTpndWlkZS1iYm94PSJ0cnVlIj4KICAgIDxpbmtzY2FwZTpncmlkCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBpZD0iZ3JpZDMwMTAiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiCiAgICAgICBzbmFwdmlzaWJsZWdyaWRsaW5lc29ubHk9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPGcKICAgICBpZD0iT3V0ZXJDaXJjbGUiCiAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMS4xNDI4MTM4LDAsMCwxLjEwNTc4OCwwLjMwODI3MzYsNC42MTQ3ODQpIj4KICAgIDxnCiAgICAgICBpZD0iZzMyNjciCiAgICAgICBzdHlsZT0ib3BhY2l0eTowLjYiPgogICAgICA8Y2lyY2xlCiAgICAgICAgIHNvZGlwb2RpOnJ5PSIyMDciCiAgICAgICAgIHNvZGlwb2RpOnJ4PSIyMDciCiAgICAgICAgIHNvZGlwb2RpOmN5PSIwIgogICAgICAgICBzb2RpcG9kaTpjeD0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIGN4PSIwIgogICAgICAgICBkPSJtIDIwNywwIGMgMCwxMTQuMzIyOTQgLTkyLjY3NzA2LDIwNyAtMjA3LDIwNyAtMTE0LjMyMjk0LDAgLTIwNywtOTIuNjc3MDYgLTIwNywtMjA3IDAsLTExNC4zMjI5NCA5Mi42NzcwNiwtMjA3IDIwNywtMjA3IDExNC4zMjI5NCwwIDIwNyw5Mi42NzcwNiAyMDcsMjA3IHoiCiAgICAgICAgIGlkPSJjaXJjbGUyNCIKICAgICAgICAgcj0iMjA3IgogICAgICAgICBzdHlsZT0ib3BhY2l0eTowLjc1O2ZpbGw6dXJsKCNncmFkMSkiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMTA1MjI3OSwwLDAsMS4xMDUyMjc5LDM0LDMyKSIgLz4KICAgIDwvZz4KICAgIDxnCiAgICAgICBpZD0iZzE4IgogICAgICAgc3R5bGU9InN0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxMCIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuOTY1NTg4OTksMCwwLDAuOTcxMzI0MTUsMzQsMzIpIj4KICAgICAgPGNpcmNsZQogICAgICAgICByPSIyMTEiCiAgICAgICAgIGlkPSJjaXJjbGUyMCIKICAgICAgICAgZD0ibSAyMTEsMCBjIDAsMTE2LjUzMjA4IC05NC40Njc5MiwyMTEgLTIxMSwyMTEgLTExNi41MzIwOCwwIC0yMTEsLTk0LjQ2NzkyIC0yMTEsLTIxMSAwLC0xMTYuNTMyMDggOTQuNDY3OTIsLTIxMSAyMTEsLTIxMSAxMTYuNTMyMDgsMCAyMTEsOTQuNDY3OTIgMjExLDIxMSB6IgogICAgICAgICBjeD0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgc29kaXBvZGk6cng9IjIxMSIKICAgICAgICAgc29kaXBvZGk6cnk9IjIxMSIgLz4KICAgIDwvZz4KICA8L2c+CiAgPGcKICAgICBpZD0iU291dGgiCiAgICAgY2xhc3M9ImFycm93IgogICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM5LjU3ODM4MywzNi45NzA0MzUpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ciCiAgICAgICBkPSJNIDM5LjQxNiw5NS4xNiBDIDMzLjY1LDEwMy45NSAzMC43NiwxMTAuNSAyOC45MywxMTcuMTggMTUuMjQsMTEzLjQzIDEzLjU0LDEyNy4xNSAyMy4wNCwxMzEgMTMuNzEsMTQ1LjggNy44NCwxNzMuOTMgMCwyMTIgTCAwLDEwMyBhIDEwMywxMDMgMCAwIDAgMzkuNDE2LC03Ljg0IHoiIC8+CiAgICA8dXNlCiAgICAgICBoZWlnaHQ9IjQ0MCIKICAgICAgIHdpZHRoPSI0NDAiCiAgICAgICB5PSIwIgogICAgICAgeD0iMCIKICAgICAgIGlkPSJzb3V0aCIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwxLDIsMCkiCiAgICAgICB4bGluazpocmVmPSIjSGFsZkFycm93IiAvPgogIDwvZz4KICA8ZwogICAgIGlkPSJFYXN0IgogICAgIGNsYXNzPSJhcnJvdyIKICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLDEsLTEsMCwzOC44MDYyMSwzNy4yMjA0MjkpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ctNiIKICAgICAgIGQ9Ik0gMzkuNDE2LDk1LjE2IEMgMzMuNjUsMTAzLjk1IDMwLjc2LDExMC41IDI4LjkzLDExNy4xOCAxNS4yNCwxMTMuNDMgMTMuNTQsMTI3LjE1IDIzLjA0LDEzMSAxMy43MSwxNDUuOCA3Ljg0LDE3My45MyAwLDIxMiBMIDAsMTAzIGEgMTAzLDEwMyAwIDAgMCAzOS40MTYsLTcuODQgeiIgLz4KICAgIDx1c2UKICAgICAgIGhlaWdodD0iNDQwIgogICAgICAgd2lkdGg9IjQ0MCIKICAgICAgIHk9IjAiCiAgICAgICB4PSIwIgogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZiIKICAgICAgIGlkPSJzb3V0aC01IgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEsMCwwLDEsMiwwKSIKICAgICAgIHhsaW5rOmhyZWY9IiNIYWxmQXJyb3ctNiIgLz4KICA8L2c+CiAgPGcKICAgICBpZD0iTm9ydGgiCiAgICAgY2xhc3M9ImFycm93IgogICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwtMSw0MS45MDI3OCw0My43ODMzNzYpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ctNi0wIgogICAgICAgZD0iTSAzOS40MTYsOTUuMTYgQyAzMy42NSwxMDMuOTUgMzAuNzYsMTEwLjUgMjguOTMsMTE3LjE4IDE1LjI0LDExMy40MyAxMy41NCwxMjcuMTUgMjMuMDQsMTMxIDEzLjcxLDE0NS44IDcuODQsMTczLjkzIDAsMjEyIEwgMCwxMDMgYSAxMDMsMTAzIDAgMCAwIDM5LjQxNiwtNy44NCB6IiAvPgogICAgPHVzZQogICAgICAgaGVpZ2h0PSI0NDAiCiAgICAgICB3aWR0aD0iNDQwIgogICAgICAgeT0iMCIKICAgICAgIHg9IjAiCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmIgogICAgICAgaWQ9InNvdXRoLTUtNiIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwxLDIsMCkiCiAgICAgICB4bGluazpocmVmPSIjSGFsZkFycm93LTYtMCIgLz4KICA8L2c+CiAgPGcKICAgICBpZD0iV2VzdCIKICAgICBjbGFzcz0iYXJyb3ciCiAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwxLDAsMzcuMzc0NzU4LDM5LjU0NzAyMykiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7c3Ryb2tlOiNmZmZmZmY7c3Ryb2tlLXdpZHRoOjEiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgaWQ9IkhhbGZBcnJvdy02LTAtNSIKICAgICAgIGQ9Ik0gMzkuNDE2LDk1LjE2IEMgMzMuNjUsMTAzLjk1IDMwLjc2LDExMC41IDI4LjkzLDExNy4xOCAxNS4yNCwxMTMuNDMgMTMuNTQsMTI3LjE1IDIzLjA0LDEzMSAxMy43MSwxNDUuOCA3Ljg0LDE3My45MyAwLDIxMiBMIDAsMTAzIGEgMTAzLDEwMyAwIDAgMCAzOS40MTYsLTcuODQgeiIgLz4KICAgIDx1c2UKICAgICAgIGhlaWdodD0iNDQwIgogICAgICAgd2lkdGg9IjQ0MCIKICAgICAgIHk9IjAiCiAgICAgICB4PSIwIgogICAgICAgaWQ9InNvdXRoLTUtNi0yIgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEsMCwwLDEsMiwwKSIKICAgICAgIHhsaW5rOmhyZWY9IiNIYWxmQXJyb3ctNi0wLTUiIC8+CiAgPC9nPgogIDx0ZXh0CiAgICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgICBzdHlsZT0iZm9udC1zaXplOjkwcHg7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpib2xkO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1hbGlnbjpzdGFydDtsaW5lLWhlaWdodDoxMjkuOTk5OTk1MjMlO2xldHRlci1zcGFjaW5nOjBweDt3b3JkLXNwYWNpbmc6MHB4O3dyaXRpbmctbW9kZTpsci10Yjt0ZXh0LWFuY2hvcjpzdGFydDtmaWxsOiNmZjdmMmE7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7Zm9udC1mYW1pbHk6VGltZXMgTmV3IFJvbWFuOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246J1RpbWVzIE5ldyBSb21hbiwgQm9sZCciCiAgICAgeD0iMTkuMjU0ODc1IgogICAgIHk9Ii0xNjMuMDY2NzYiCiAgICAgaWQ9Ik5vcnRoVGV4dCIKICAgICBzb2RpcG9kaTpsaW5lc3BhY2luZz0iMTMwJSIKICAgICB0cmFuc2Zvcm09InNjYWxlKDEuMDA4MzY2NSwwLjk5MTcwMjkyKSI+PHRzcGFuCiAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgaWQ9InRzcGFuMzAyNCIKICAgICAgIHg9IjE5LjI1NDg3NSIKICAgICAgIHk9Ii0xNjMuMDY2NzYiCiAgICAgICBzdHlsZT0iZm9udC1zaXplOjgwcHg7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpib2xkO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1hbGlnbjpzdGFydDtsaW5lLWhlaWdodDoxMjkuOTk5OTk1MjMlO3dyaXRpbmctbW9kZTpsci10Yjt0ZXh0LWFuY2hvcjpzdGFydDtmaWxsOiNmZjdmMmE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjFweDtmb250LWZhbWlseTpUaW1lcyBOZXcgUm9tYW47LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjonVGltZXMgTmV3IFJvbWFuLCBCb2xkJyI+TjwvdHNwYW4+PC90ZXh0PgogIDxnCiAgICAgaWQ9IklubmVyQ2lyY2xlIgogICAgIHN0eWxlPSJvcGFjaXR5OjAuNiIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzOS4yNjA3MjYsNDEuMjEwMTIxKSI+CiAgICA8ZwogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6OCIKICAgICAgIGlkPSJnNyI+CiAgICAgIDxjaXJjbGUKICAgICAgICAgc29kaXBvZGk6cng9Ijc1IgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIGN4PSIwIgogICAgICAgICBkPSJNIDc1LDAgQyA3NSw0MS40MjEzNTYgNDEuNDIxMzU2LDc1IDAsNzUgLTQxLjQyMTM1Niw3NSAtNzUsNDEuNDIxMzU2IC03NSwwIGMgMCwtNDEuNDIxMzU2IDMzLjU3ODY0NCwtNzUgNzUsLTc1IDQxLjQyMTM1NiwwIDc1LDMzLjU3ODY0NCA3NSw3NSB6IgogICAgICAgICBpZD0iY2lyY2xlOSIKICAgICAgICAgcj0iNzUiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBzb2RpcG9kaTpyeT0iNzUiIC8+CiAgICA8L2c+CiAgICA8ZwogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzFiMWIxYjtzdHJva2Utd2lkdGg6MSIKICAgICAgIGlkPSJnMTEiPgogICAgICA8Y2lyY2xlCiAgICAgICAgIHNvZGlwb2RpOnJ5PSI3MSIKICAgICAgICAgc29kaXBvZGk6cng9IjcxIgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgc29kaXBvZGk6Y3g9IjAiCiAgICAgICAgIGN5PSIwIgogICAgICAgICBjeD0iMCIKICAgICAgICAgZD0iTSA3MSwwIEMgNzEsMzkuMjEyMjE3IDM5LjIxMjIxNyw3MSAwLDcxIC0zOS4yMTIyMTcsNzEgLTcxLDM5LjIxMjIxNyAtNzEsMCBjIDAsLTM5LjIxMjIxNyAzMS43ODc3ODMsLTcxIDcxLC03MSAzOS4yMTIyMTcsMCA3MSwzMS43ODc3ODMgNzEsNzEgeiIKICAgICAgICAgaWQ9ImNpcmNsZTEzIgogICAgICAgICByPSI3MSIgLz4KICAgICAgPGNpcmNsZQogICAgICAgICBzb2RpcG9kaTpyeT0iNzkiCiAgICAgICAgIHNvZGlwb2RpOnJ4PSI3OSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjAiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBjeT0iMCIKICAgICAgICAgY3g9IjAiCiAgICAgICAgIGQ9Ik0gNzksMCBDIDc5LDQzLjYzMDQ5NSA0My42MzA0OTUsNzkgMCw3OSAtNDMuNjMwNDk1LDc5IC03OSw0My42MzA0OTUgLTc5LDAgYyAwLC00My42MzA0OTUgMzUuMzY5NTA1LC03OSA3OSwtNzkgNDMuNjMwNDk1LDAgNzksMzUuMzY5NTA1IDc5LDc5IHoiCiAgICAgICAgIGlkPSJjaXJjbGUxNSIKICAgICAgICAgcj0iNzkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K";

    /**
     * Create a compass Widget
     * @param options
     * @throws {ReferenceError} can't get the div to insert the compass
     * @throws {ReferenceError} Can't get the element name
     * @constructor
     * @fires Context#modifiedNavigation
     */
    var Compass = function(options) {
        /**
         *    Private variables
         */
        this.svgDoc = null;
        this.panFactor = options.panFactor ? options.panFactor : 30;
        this.parentElement = options.element;
        this.ctx = null;
        this.isMobile = options.isMobile;
        this.options = options;

        this._lastMouseX = -1;
        this._lastMouseY = -1;
        this._balanceX = -1;
        this._balanceY = -1;
        this._dx = 0;
        this._dy = 0;
        this.dragging = false;

        this.east = null;
        this.west = null;
        this.south = null;
        this.north = null;
        this.northText = null;
        this.outerCircle = null;

        //var self = this;

        // Add compass object to parent element
        // Don't use <object> HTML tag due to cross-origin nature of svg
        if (this.parentElement == null) {
            throw new ReferenceError(
                "Can't get the element name from the options parameters"
            );
        } else if (document.getElementById(this.parentElement) === null) {
            throw new ReferenceError(
                "can't get the Div " +
                    this.parentElement +
                    " to insert the compass"
            );
        } else {
            // OK
        }

        this.init();
    };

    /**************************************************************************************************************/

    /**
     * Handles mouse down event.
     * @param {Event} event
     * @param {Compass} self
     * @private
     */
    function _handleMouseDown(event, self) {
        if (event.type.search("touch") >= 0) {
            event.layerX = event.changedTouches[0].clientX;
            event.layerY = event.changedTouches[0].clientY;
            self._balanceX = event.layerX;
            self._balanceY = event.layerY;
        } else {
            self._balanceX = 0;
            self._balanceY = 0;
        }

        self.dragging = true;
        var _outerCircleRadius =
            self.outerCircle.ownerSVGElement.clientWidth / 2;
        self._lastMouseX = event.layerX - self._balanceX - _outerCircleRadius;
        self._lastMouseY = event.layerY - self._balanceY - _outerCircleRadius;
        self._dx = 0;
        self._dy = 0;
    }

    /**
     * Handles mouse move event.
     * @param {Event} event
     * @param {Compass} self
     * @private
     */
    function _handleMouseMove(event, self) {
        if (event.type.search("touch") >= 0) {
            event.layerX = event.changedTouches[0].clientX - self._balanceX;
            event.layerY = event.changedTouches[0].clientY - self._balanceY;
        }

        if (!self.dragging) {
            return;
        }
        var _outerCircleRadius =
            self.outerCircle.ownerSVGElement.clientWidth / 2;
        var c =
            self._lastMouseX * (event.layerY - _outerCircleRadius) -
            self._lastMouseY * (event.layerX - _outerCircleRadius); // c>0 -> clockwise, counterclockwise otherwise

        self.ctx.getNavigation().rotate(c, 0);

        self._lastMouseX = event.layerX - _outerCircleRadius;
        self._lastMouseY = event.layerY - _outerCircleRadius;

        CompassCore.updateNorth();
    }

    /**
     * Handles mouse up event.
     * @param {Event} event
     * @param {Compass} self
     * @private
     */
    function _handleMouseUp(event, self) {
        event.preventDefault();
        self.dragging = false;
        // TODO add inertia
    }

    /**
     * Updates north compass from east move.
     * @param {Compass} self
     * @private
     */
    function _updateNorthFromEast(self) {
        self.ctx.getNavigation().pan(self.panFactor, 0.0);
        CompassCore.updateNorth();
    }

    /**
     * Updates north compass from west move.
     * @param {Compass} self
     * @private
     */
    function _updateNorthFromWest(self) {
        self.ctx.getNavigation().pan(-self.panFactor, 0.0);
        CompassCore.updateNorth();
    }

    /**
     * Updates north compass from north move.
     * @param {Compass} self
     * @private
     */
    function _updateNorthFromNorth(self) {
        self.ctx.getNavigation().pan(0, self.panFactor);
        CompassCore.updateNorth();
    }

    /**
     * Updates north compass from south move.
     * @param {Compass} self
     * @private
     */
    function _updateNorthFromSouth(self) {
        self.ctx.getNavigation().pan(0, -self.panFactor);
        CompassCore.updateNorth();
    }

    /**
     * Init compass.
     */
    Compass.prototype.init = function() {
        CompassCore.init({
            element: this.parentElement
        });
    };

    /**
     *    Remove compass element
     */
    Compass.prototype.remove = CompassCore.remove;
    Compass.prototype.setCtx = CompassCore.setCtx;
    Compass.prototype.setSvg = CompassCore.setSvg;

    /**************************************************************************************************************/

    /**
     * Attachs the compass to the context.
     * @function attachTo
     * @memberof Compass#
     */
    Compass.prototype.attachTo = function(context) {
        var self = this;
        this.ctx = context;
        this.setCtx(context);
        $.get(
            COMPASS_SVG,
            function(response) {
                // Import contents of the svg document into this document
                self.svgDoc = document.importNode(
                    response.documentElement,
                    true
                );
                self.ctx = context;
                /* Svg interactive elements */
                self.east = self.svgDoc.getElementById("East"); //get the inner element by id
                self.west = self.svgDoc.getElementById("West"); //get the inner element by id
                self.south = self.svgDoc.getElementById("South"); //get the inner element by id
                self.north = self.svgDoc.getElementById("North"); //get the inner element by id
                self.northText = self.svgDoc.getElementById("NorthText");
                self.outerCircle = self.svgDoc.getElementById("OuterCircle");

                // Update width/height
                self.svgDoc.height.baseVal.value = 100;
                self.svgDoc.width.baseVal.value = 100;

                // Append the imported SVG root element to the appropriate HTML element
                document.getElementById(self.parentElement).innerHTML =
                    "<div id=\"objectCompass\"></div>";
                $("#objectCompass").append(self.svgDoc);

                self.setSvg(self.svgDoc);
                //self.setCtx(self.ctx);

                self.options.svgDoc = self.svgDoc;

                //self.attachTo(self.ctx);
                self.svgDoc.addEventListener("mousedown", function(event) {
                    _handleMouseDown(event, self);
                });

                self.svgDoc.addEventListener("mousemove", function(event) {
                    _handleMouseMove(event, self);
                });

                self.svgDoc.addEventListener("mouseup", function(event) {
                    _handleMouseUp(event, self);
                });

                self.east.addEventListener("click", function() {
                    _updateNorthFromEast(self);
                });

                self.west.addEventListener("click", function() {
                    _updateNorthFromWest(self);
                });

                self.north.addEventListener("click", function() {
                    _updateNorthFromNorth(self);
                });

                self.south.addEventListener("click", function() {
                    _updateNorthFromSouth(self);
                });

                self.northText.addEventListener(
                    "click",
                    CompassCore._alignWithNorth
                );

                if (self.isMobile) {
                    var passiveSupported = Utils.isPassiveSupported();
                    self.svgDoc.addEventListener(
                        "touchstart",
                        function(event) {
                            _handleMouseDown(event, self);
                        },
                        passiveSupported ? { passive: true } : false
                    );
                    self.svgDoc.addEventListener("touchup", function(event) {
                        _handleMouseUp(event, self);
                    });
                    self.svgDoc.addEventListener(
                        "touchmove",
                        function(event) {
                            _handleMouseMove(event, self);
                        },
                        passiveSupported ? { passive: true } : false
                    );
                    self.northText.addEventListener(
                        "touchstart",
                        CompassCore._alignWithNorth,
                        passiveSupported ? { passive: true } : false
                    );
                }

                // Update fov when moving
                self.ctx.subscribe(
                    Constants.EVENT_MSG.NAVIGATION_MODIFIED,
                    CompassCore.updateNorth
                );
                self.ctx.subscribe(
                    Constants.EVENT_MSG.CRS_MODIFIED,
                    CompassCore.updateNorth
                );

                // Publish modified event to update compass north
                $("#" + self.parentElement).css("display", "block");
            },
            "xml"
        );
    };

    /**
     * Detaches the tracker from the context.
     * @function detach
     * @memberof Compass#
     */
    Compass.prototype.detach = function() {
        var self = this;
        this.svgDoc.removeEventListener("mousedown", function(event) {
            _handleMouseDown(event, self);
        });

        this.svgDoc.removeEventListener("mousemove", function(event) {
            _handleMouseMove(event, self);
        });

        this.svgDoc.removeEventListener("mouseup", function(event) {
            _handleMouseUp(event, self);
        });

        this.east.removeEventListener("click", function() {
            _updateNorthFromEast(self);
        });

        this.west.removeEventListener("click", function() {
            _updateNorthFromWest(self);
        });

        this.north.removeEventListener("click", function() {
            _updateNorthFromNorth(self);
        });

        this.south.removeEventListener("click", function() {
            _updateNorthFromSouth(self);
        });

        this.northText.removeEventListener(
            "click",
            CompassCore._alignWithNorth
        );

        if (this.isMobile) {
            var passiveSupported = Utils.isPassiveSupported();
            this.svgDoc.removeEventListener("touchstart", function(event) {
                _handleMouseDown(event, self);
            });
            this.svgDoc.removeEventListener("touchup", function(event) {
                _handleMouseUp(event, self);
            });
            this.svgDoc.removeEventListener(
                "touchmove",
                function(event) {
                    _handleMouseMove(event, self);
                },
                passiveSupported ? { passive: true } : false
            );
            this.northText.removeEventListener(
                "touchstart",
                CompassCore._alignWithNorth,
                passiveSupported ? { passive: true } : false
            );
        }
        // Update fov when moving
        this.ctx.unsubscribe(
            Constants.EVENT_MSG.NAVIGATION_MODIFIED,
            CompassCore.updateNorth
        );
        this.ctx.unsubscribe(
            Constants.EVENT_MSG.CRS_MODIFIED,
            CompassCore.updateNorth
        );
        this.ctx = null;
    };

    /**
     * Destroys the elements.
     * @function destroy
     * @memberof Compass#
     */
    Compass.prototype.destroy = function() {
        this.detach();
        this.remove();
        this.svgDoc = null;
        this.panFactor = null;
        this.parentElement = null;
        this.ctx = null;
        this.isMobile = null;

        this._lastMouseX = -1;
        this._lastMouseY = -1;
        this._balanceX = -1;
        this._balanceY = -1;
        this._dx = 0;
        this._dy = 0;
        this.dragging = false;

        this.east = null;
        this.west = null;
        this.south = null;
        this.north = null;
        this.northText = null;
        this.outerCircle = null;
    };

    return Compass;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Gui/Tracker/AbstractTracker',["jquery", "../../Utils/Utils", "../dialog/ErrorDialog"], function(
    $,
    Utils,
    ErrorDialog
) {
    /**
     * @name AbstractTracker
     * @class
     *    Abstract class for tracker (position, elevation...)
     * @param {Object} options
     * @param {string} options.element DIV ID where the element is inserted
     * @param {string} [options.position] position of thetracker
     * @throws {ReferenceError} Can't get the Div to insert the tracker
     * @throws {ReferenceError} Can't get the element name
     * @implements {Tracker}
     */
    var AbstractTracker = function(options) {
        this.options = options;
        this.context = null;
        this.navigation = null;
        this.element = options.element;
        if (this.element == null) {
            throw new ReferenceError(
                "Can't get the element name from the options parameters"
            );
        } else if (document.getElementById(this.element) == null) {
            throw new ReferenceError(
                "Can' get the div " +
                    this.element +
                    " in the web page to insert " +
                    this.constructor.name
            );
        } else {
            document.getElementById(this.element).innerHTML = "";
            if (options.position) {
                $("#" + this.element).css(options.position, "2px");
            }
        }
    };

    /**
     * Returns the navigation.
     * @function _getNavigation
     * @memberof AbstractTracker#
     * @private
     */
    AbstractTracker.prototype._getNavigation = function() {
        return this.navigation;
    };

    /**
     * Sets the navigation
     * @function _setNavigation
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype._setNavigation = function(navigation) {
        this.navigation = navigation;
    };

    /**
     * Returns the globe.
     * @function _getGlobe
     * @memberof AbstractTracker#
     * @private
     */
    AbstractTracker.prototype._getGlobe = function() {
        return this.globe;
    };

    /**
     * Sets the globe
     * @function _setGlobe
     * @memberof AbstractTracker#
     * @private
     */
    AbstractTracker.prototype._setGlobe = function(globe) {
        this.globe = globe;
    };

    /**
     * Returns the DIV element in which the result is written.
     * @function _getElement
     * @memberof AbstractTracker#
     * @private
     */
    AbstractTracker.prototype._getElement = function() {
        return this.element;
    };

    /**
     * Updates the tracker.
     * @function update
     * @memberof AbstractTracker#
     * @abstract
     */
    AbstractTracker.prototype.update = function(event) {
        throw new SyntaxError(
            "update from AbstractTracker not implemented",
            "AbstractTracker.js"
        );
    };

    /**
     * @function compute
     * @memberof AbstractTracker#
     * @abstract
     */
    AbstractTracker.prototype.compute = function(geoPosition) {
        throw new SyntaxError(
            "compute from AbstractTracker not implemented",
            "AbstractTracker.js"
        );
    };

    /**
     * @function attachTo
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype.attachTo = function(context) {
        this._setGlobe(context._getGlobe());
        this._setNavigation(context.getNavigation());
        this._getGlobe()
            .getRenderContext()
            .canvas.addEventListener("mousemove", this.update);
        if (this.options.isMobile) {
            var passiveSupported = Utils.isPassiveSupported();
            this._getGlobe()
                .getRenderContext()
                .canvas.addEventListener(
                    "touchmove",
                    this.update,
                    passiveSupported ? { passive: true } : false
                );
        }
    };

    /**
     * @function detach
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype.detach = function() {
        document.getElementById(this._getElement()).innerHTML = "";
        this._getGlobe()
            .getRenderContext()
            .canvas.removeEventListener("mousemove", this.update);
        if (this.options.isMobile) {
            this._getGlobe()
                .getRenderContext()
                .canvas.removeEventListener("touchmove", this.update);
        }
    };

    /**
     * @function destroy
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype.destroy = function() {
        document.getElementById(this._getElement()).innerHTML = "";
        this.element = null;
        this.options = null;
        // we do do not destroy the globe now. It will be destroyed later on in the context
    };

    return AbstractTracker;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Error dialog module
 */
define('gw/Gui/dialog/CrsDialog',["jquery", "jquery.ui"], function($) {
    // The main div for error
    var crsInfo =
        "<div id=\"crsInfo\" style=\"text-align: left\" title=\"Coordinate Reference System information\"></div>";

    // Create the div, use jQuery UI dialog

    var $text = "";

    var $crsInfo = $(crsInfo)
        .appendTo("body")
        .dialog({
            autoOpen: false,
            width: 500,
            minHeight: 300,
            maxHeight: 500,
            dialogClass: "crsBox"
            //beforeClose: function( event, ui ) { $text = ""; }
        });
    var $active = false;

    return {
        /**
         *    Open dialog
         *
         *    @param html HTML text
         */
        open: function(crs) {
            if (this.isActive()) {
                this.destroy();
            }
            var geoBound = crs.getGeoBound();
            $text +=
                "<p align='center'><u><i><b>" +
                crs.getName() +
                " CRS description </b></i></u></p>";
            $text += "<p align='justify'>" + crs.getDescription() + "</p>";
            $text +=
                "<table>" +
                "<caption><i>Sphere parameters</i></caption>" +
                "<tr><th>Parameter</th><th>Value</th></tr>" +
                "<tr><td>Projection</td><td>" +
                (crs.isProjected() ? crs.getProjection().getName() : "3D") +
                "</td></tr>" +
                "<tr><td>radius (meters)</td><td>" +
                crs.getGeoide().getRealPlanetRadius() +
                "</td></tr>" +
                "<tr><td>" +
                crs.getLongitudeLabel() +
                "</td><td>[" +
                geoBound.getWest() +
                "&deg; , " +
                geoBound.getEast() +
                "&deg;]</td></tr>" +
                "<tr><td>" +
                crs.getLatitudeLabel() +
                "</td><td>[" +
                geoBound.getSouth() +
                "&deg; , " +
                geoBound.getNorth() +
                "&deg;]</td></tr>" +
                "</table>";
            $crsInfo.on("dialogclose", function(event) {
                $active = false;
            });
        },
        view: function() {
            $crsInfo.html($text).dialog("open");

            $crsInfo.scrollTop(5000);
            $active = true;
        },
        hide: function() {
            $crsInfo.dialog("close");
            $active = false;
        },
        isActive: function() {
            return $active;
        },
        destroy: function() {
            this.hide();
            $text = "";
            $active = false;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/**
 * Tracker to display on the screen :
 * <ul>
 *     <li>{@link module:Tracker.PositionTracker PositionTracker}: Displays the coordinates</li>
 *     <li>{@link module:Tracker.ElevationTracker ElevationTracker} : Displays the elevation</li>
 * </ul>
 *
 * See {@tutorial getting-started-tracker} for an example of tracker position.
 *
 * @module Tracker
 * @implements {Tracker}
 *
 */
define('gw/Gui/Tracker/PositionTracker',[
    "jquery",
    "./AbstractTracker",
    "../dialog/CrsDialog",
    "../../Utils/Utils"
], function($, AbstractTracker, CrsDialog, Utils) {
    var self;
    var posTrackerInfoHTML = "<input type=\"button\" id=\"posTrackerInfoButton\"/>";

    /**
     * @name PositionTracker
     * @class
     *    Position Tracker
     * @augments AbstractTracker
     * @param {AbstractTracker_position_configuration} options - Position tracker configuration
     * @constructor
     * @memberof module:Tracker
     */
    var PositionTracker = function(options) {
        AbstractTracker.prototype.constructor.call(this, options);
    };
    /**************************************************************************************************************/

    Utils.inherits(AbstractTracker, PositionTracker);

    /**************************************************************************************************************/

    /**
     * @function update
     * @memberof PositionTracker#
     */
    PositionTracker.prototype.update = function(event) {
        if (event.type.search("touch") >= 0) {
            event.clientX = event.changedTouches[0].clientX;
            event.clientY = event.changedTouches[0].clientY;
        }

        if (document.getElementById(self._getElement())) {
            var $crsInfo = $("#" + self._getElement() + "Info");
            var geoPos = self
                ._getGlobe()
                .getLonLatFromPixel(event.clientX, event.clientY);
            if (geoPos) {
                var astro = self.compute([geoPos[0], geoPos[1]]);
                document.getElementById(self._getElement()).innerHTML =
                    astro[0] + " x " + astro[1];
                if ($crsInfo.css("display") == "none") {
                    $crsInfo.show();
                }
            } else {
                document.getElementById(self._getElement()).innerHTML = "";
                if ($crsInfo.css("display") != "none") {
                    $crsInfo.hide();
                }
            }
        }
    };

    /**
     * @function compute
     * @memberof PositionTracker#
     */
    PositionTracker.prototype.compute = function(geoPosition) {
        return this._getGlobe()
            .getCoordinateSystem()
            .formatCoordinates([geoPosition[0], geoPosition[1]]);
    };

    /**
     * Attachs the tracker to the context.
     *
     * Attachs the tracker to the context by calling the attachTo method from the AbstractTracker. Then, the CrsDialog
     * is filled with Crs information. Finally, the onClick event is set to get the Crs information. The onClick event
     * is enabled on the <i>#posTrackerInfoButton</i> ID
     *
     * @function attachTo
     * @memberof PositionTracker#
     * @param {Context} context context
     * @see {@link CrsDialog}
     * @see {@link AbstrackTracker#attachTo}
     */
    PositionTracker.prototype.attachTo = function(context) {
        AbstractTracker.prototype.attachTo.call(this, context);
        var $posTrackerInfo = $(posTrackerInfoHTML).appendTo(
            "#" + this._getElement() + "Info"
        );
        CrsDialog.open(context._getGlobe().getCoordinateSystem());
        $("#posTrackerInfoButton").on("click", function() {
            if (CrsDialog.isActive() === true) {
                CrsDialog.hide();
            } else {
                CrsDialog.view();
            }
        });
        self = this;
    };

    /**
     * Detaches the tracker.
     *
     * Detaches the tracker from the glob by calling the detach method from the AbstractTracker. Then, the onClick
     * event is removed and the CrsDialog is destroyed as well.
     *
     * @function detach
     * @memberof PositionTracker#
     */
    PositionTracker.prototype.detach = function() {
        $("#posTrackerInfoButton").off("click");
        $("#" + this._getElement() + "Info").empty();
        CrsDialog.destroy();
        AbstractTracker.prototype.detach.call(this);
        self = null;
    };

    /**
     * Destroys the position tracker.
     * @function destroy
     * @memberof AbstractTracker.prototype
     */
    PositionTracker.prototype.destroy = function() {
        this.detach(this);
        AbstractTracker.prototype.destroy.call(this);
        self = null;
    };

    /**************************************************************************************************************/

    return PositionTracker;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Gui/Tracker/ElevationTracker',[
    "jquery",
    "./AbstractTracker",
    "../../Utils/Utils",
    "../../Utils/Numeric"
], function($, AbstractTracker, Utils, Numeric) {
    var self;

    /**
     * @name ElevationTracker
     * @class
     *   Elevation Tracker
     * @augments AbstractTracker
     * @param {AbstractTracker_elevation_configuration} options - Elevation tracker configuration
     * @constructor
     * @memberof module:Tracker
     */
    var ElevationTracker = function(options) {
        AbstractTracker.prototype.constructor.call(this, options);
        this.scale = null;
        if (options.elevationLayer != null) {
            this.scale = options.elevationLayer.getScale();
        }
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractTracker, ElevationTracker);

    /**************************************************************************************************************/

    /**
     * Sets the scale layer taken from the elevationLayer
     * @param {WCSElevationLayer}elevationLayer
     */
    ElevationTracker.prototype.setScaleLayer = function(elevationLayer) {
        this.scale = elevationLayer.getScale();
        this.options.elevationLayer = elevationLayer;
    };

    /**
     * @function update
     * @memberof AbstractTracker.prototype
     */
    ElevationTracker.prototype.update = function(event) {
        if (event.type.search("touch") >= 0) {
            event.clientX = event.changedTouches[0].clientX;
            event.clientY = event.changedTouches[0].clientY;
        }
        if (document.getElementById(self._getElement()) && self.options.elevationLayer && self.options.elevationLayer.isRequested()) {
            var geoPos = self
                ._getGlobe()
                .getLonLatFromPixel(event.clientX, event.clientY);
            if (geoPos && self.scale) {
                var elevation = self.compute([geoPos[0], geoPos[1]]);
                document.getElementById(self._getElement()).innerHTML =
                    "Elevation : " +
                    Numeric.roundNumber(elevation / self.scale, 0) +
                    " meters";
            } else {
                document.getElementById(self._getElement()).innerHTML = "";
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * @function compute
     * @memberof ElevationTracker#
     */
    ElevationTracker.prototype.compute = function(geoPosition) {
        return this._getGlobe().getElevation(geoPosition[0], geoPosition[1]);
    };

    /**
     * @function attachTo
     * @memberof ElevationTracker#
     */
    ElevationTracker.prototype.attachTo = function(context) {
        AbstractTracker.prototype.attachTo.call(this, context);
        self = this;
    };

    /**
     * @function detach
     * @memberof ElevationTracker#
     */
    ElevationTracker.prototype.detach = function() {
        AbstractTracker.prototype.detach.call(this);
        self = null;
    };

    /**
     * @function destroy
     * @memberof ElevationTracker#
     */
    ElevationTracker.prototype.destroy = function() {
        this.detach.call(this);
        AbstractTracker.prototype.destroy.call(this);
        this.scale = null;
        self = null;
    };

    /**************************************************************************************************************/

    return ElevationTracker;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Utils/AttributionHandler',[],function() {
    /**
     * Default div ID for attribution.
     */
    const ATTIBUTION_ID_DEFAULT = "attribution";

    /**
     * Create HTML attribution.
     */
    function _createHTMLAttribution(layer) {
        var attribution;
        var title = layer.getAck() != null ? layer.getAck() : "";
        if (
            layer.getCopyrightUrl() !== "" &&
            layer.getCopyrightUrl() !== undefined
        ) {
            attribution =
                "<a class=\"whiteLink\" href=\"" +
                layer.getCopyrightUrl() +
                "\" target=\"_blank\" title=\"" +
                title +
                "\">" +
                layer.getAttribution() +
                "</a>";
        } else {
            attribution = layer.getAttribution();
        }
        return attribution;
    }

    /**
        @name AttributionHandler
        @class
        Manage the attributions
        @param {Globe} globe Globe
        @param options Configuration properties
        <ul>
        <li>element : the HTML element to show attributions, can be a string (the ID) or the DOM element itself</li>
        </ul>
    */
    var AttributionHandler = function(globe, options) {
        // Search for the element to use
        var elt = options ? options.element : undefined;
        if (elt) {
            if (typeof elt === "string") {
                this.element = document.getElementById(elt);
            } else {
                this.element = elt;
            }
            if (this.element && !elt.hasOwnProperty(this.element)) {
                this.element.id = ATTIBUTION_ID_DEFAULT;
            }
        }

        // Only add the attribution handler to the globe if element is not null
        if (this.element) {
            globe.attributionHandler = this;
        }
    };

    /**
     * Remove attribution from HTML
     * @function removeAttribution
     * @memberof AttributionHandler.prototype
     * @param {Layer} layer Layer
     */
    AttributionHandler.prototype.removeAttribution = function(layer) {
        if (this.element) {
            var div = document.getElementById(this.element.id + "_" + layer.id);
            if (div) {
                this.element.removeChild(div);
            }
        }
    };

    /**
     * Add attribution in HTML
     * @function addAttribution
     * @memberof AttributionHandler.prototype
     * @param {Layer} layer Layer
     */
    AttributionHandler.prototype.addAttribution = function(layer) {
        if (this.element) {
            var div = document.createElement("div");
            div.innerHTML = _createHTMLAttribution.call(this, layer);
            div.id = this.element.id + "_" + layer.id;

            if (layer.id === 0) {
                // Background layer
                this.element.insertBefore(div, this.element.firstChild);
            } else {
                this.element.appendChild(div);
            }
        }
    };

    /**
     * Enables all HTML attribution.
     * @function enable
     * @memberof AttributionHandler.prototype
     * @param {Layer} layer Layer
     */
    AttributionHandler.prototype.enable = function(layer) {
        if (this.element && layer && layer.isVisible()) {
            var div = document.getElementById(this.element.id + "_" + layer.id);
            if (div) {
                div.style.display = "block";
            }
        }
    };

    /**
     * Disables all HTML attribution.
     * @function disable
     * @memberof AttributionHandler.prototype
     * @param {Layer} layer Layer
     */
    AttributionHandler.prototype.disable = function(layer) {
        if (this.element && layer && layer.isVisible()) {
            var div = document.getElementById(this.element.id + "_" + layer.id);
            if (div) {
                div.style.display = "none";
            }
        }
    };

    /**
     * Toggle attribution
     * @function toggleAttribution
     * @memberof AttributionHandler.prototype
     * @param {Layer} layer Layer
     */
    AttributionHandler.prototype.toggleAttribution = function(layer) {
        if (this.element) {
            var div = document.getElementById(this.element.id + "_" + layer.id);
            if (div) {
                this.removeAttribution(layer);
            } else {
                this.addAttribution(layer);
            }
        }
    };

    /**************************************************************************************************************/

    return AttributionHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/VectorRenderer',[
    "./RendererTileData",
    "../Tiling/Tile",
    "../Utils/Utils",
    "../Utils/UtilsIntersection"
], function(RendererTileData, Tile, Utils, UtilsIntersection) {
    /**************************************************************************************************************/

    /**
  @name VectorRenderer
  @class
	  VectorRenderer constructor
  @param {AbstractGlobe} globe AbstractGlobe
  @constructor
  */
    var VectorRenderer = function(globe) {
        this.tileManager = globe.tileManager;
        this.globe = globe;
        this.buckets = [];
        this.maxTilePerGeometry = 100;
        this.levelZeroTiledGeometries = [];
    };

    /**************************************************************************************************************/

    /**
     * Find a compatible bucket
     * @function findBucket
     * @memberof VectorRenderer.prototype
     * @param layer
     * @param style
     * @return {Bucket} Bucket
     */
    VectorRenderer.prototype.findBucket = function(layer, style) {
        // Find an existing bucket for the given style
        for (var i = 0; i < this.buckets.length; i++) {
            var bucket = this.buckets[i];
            if (bucket.layer === layer && bucket.isCompatible(style)) {
                return bucket;
            }
        }

        return null;
    };

    /**************************************************************************************************************/

    /**
     * Generate the level zero for a tile
     * @function generateLevelZero
     * @memberof VectorRenderer.prototype
     * @param {Tile} tile Tile
     */
    VectorRenderer.prototype.generateLevelZero = function(tile) {
        for (var i = 0; i < this.levelZeroTiledGeometries.length; i++) {
            var geometry = this.levelZeroTiledGeometries[i];

            // Check that the geometry is on this tile
            var isFound = false;
            for (var n = 0; n < geometry._tileIndices.length && !isFound; n++) {
                var t = this.tileManager.level0Tiles[geometry._tileIndices[n]];
                isFound = t === tile;
            }

            // Found the tile, so add it
            if (isFound) {
                this._addGeometryToTile(geometry._bucket, geometry, tile);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Recursively add a geometry to a tile
     * @function _recursiveAddGeometryToTile
     * @memberof VectorRenderer.prototype
     * @param {Bucket} bucket Bucket
     * @param geometry
     * @param {Tile} tile Tile
     * @private
     */
    VectorRenderer.prototype._recursiveAddGeometryToTile = function(
        bucket,
        geometry,
        tile
    ) {
        var renderable = this._addGeometryToTile(bucket, geometry, tile);

        if (renderable && renderable.generateChild && tile.children) {
            for (var i = 0; i < 4; i++) {
                if (tile.children[i].state === Tile.State.LOADED) {
                    renderable.hasChildren = true;
                    this._recursiveAddGeometryToTile(
                        bucket,
                        geometry,
                        tile.children[i]
                    );
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to a vector renderer
     * @function addGeometry
     * @memberof VectorRenderer.prototype
     * @param layer
     * @param geometry
     * @param style
     */
    VectorRenderer.prototype.addGeometry = function(layer, geometry, style) {
        var bucket = this.getOrCreateBucket(layer, geometry, style);
        geometry._bucket = bucket;
        var tileIndices =
            this.maxTilePerGeometry > 0
                ? this.tileManager.tiling.getOverlappedLevelZeroTiles(geometry)
                : null;
        if (tileIndices && tileIndices.length < this.maxTilePerGeometry) {
            // Add geometry to each tile in range
            for (var i = 0; i < tileIndices.length; i++) {
                var tile = this.tileManager.level0Tiles[tileIndices[i]];
                if (
                    tile &&
                    typeof tile !== "undefined" &&
                    tile.state === Tile.State.LOADED
                ) {
                    this._recursiveAddGeometryToTile(bucket, geometry, tile);
                }
            }

            geometry._tileIndices = tileIndices;
            this.levelZeroTiledGeometries.push(geometry);
        } else {
            // Attach to mainRenderable
            if (!bucket.mainRenderable) {
                bucket.mainRenderable = bucket.createRenderable();
            }
            bucket.mainRenderable.add(geometry);
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from a vector renderer
     * @function removeGeometry
     * @memberof VectorRenderer.prototype
     * @param geometry
     * @private
     */
    VectorRenderer.prototype.removeGeometry = function(geometry) {
        var tileIndices = geometry._tileIndices;

        if (tileIndices) {
            // Remove from tile
            for (var i = 0; i < tileIndices.length; i++) {
                var tile = this.tileManager.level0Tiles[tileIndices[i]];
                this.removeGeometryFromTile(geometry, tile);
            }
            // Remove from geometry arrays
            this.levelZeroTiledGeometries.splice(
                this.levelZeroTiledGeometries.indexOf(geometry),
                1
            );

            geometry._tileIndices = null;
        } else {
            var bucket = geometry._bucket;
            if (bucket.mainRenderable) {
                var numGeometries = bucket.mainRenderable.remove(geometry);
                if (numGeometries === 0) {
                    bucket.mainRenderable.dispose(this.renderContext);
                    bucket.mainRenderable = null;
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Get or create a bucket for the given configuration
     * @function getOrCreateBucket
     * @memberof VectorRenderer.prototype
     * @param layer
     * @param geometry
     * @param style
     * @return {Bucket} Bucket
     */
    VectorRenderer.prototype.getOrCreateBucket = function(
        layer,
        geometry,
        style
    ) {
        // Then find an existing bucket
        var bucket = this.findBucket(layer, style);
        if (!bucket) {
            bucket = this.createBucket(layer, style);
            bucket.renderer = this;
            bucket.id = this.globe.getRendererManager().bucketId++;
            this.buckets.push(bucket);
        }
        return bucket;
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to a tile
     * @function addGeometryToTile
     * @memberof VectorRenderer.prototype
     * @param layer
     * @param geometry
     * @param style
     * @param {Tile} tile Tile
     */
    VectorRenderer.prototype.addGeometryToTile = function(
        layer,
        geometry,
        style,
        tile
    ) {
        var bucket = this.getOrCreateBucket(layer, geometry, style);
        geometry._bucket = bucket;
        return this._addGeometryToTile(bucket, geometry, tile);
    };

    /**************************************************************************************************************/

    /**
     * Internal method to add a geometry to a tile
     * @function _addGeometryToTile
     * @memberof VectorRenderer.prototype
     * @param {Bucket} bucket Buckeont
     * @param geometry
     * @param {Tile} tile Tile
     * @private
     */
    VectorRenderer.prototype._addGeometryToTile = function(
        bucket,
        geometry,
        tile
    ) {
        var tileData = tile.extension.renderer;
        if (!tileData) {
            tileData = tile.extension.renderer = new RendererTileData(
                this.globe.getRendererManager()
            );
        }

        var renderable = tileData.getRenderable(bucket);
        var needsToAdd = false;
        if (!renderable) {
            renderable = bucket.createRenderable();
            needsToAdd = true;
        }
        if (renderable.add(geometry, tile)) {
            if (needsToAdd) {
                tileData.renderables.push(renderable);
            }
            return renderable;
        }

        return null;
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from a tile (recursive)
     * @function _removeGeometryFromTile
     * @memberof VectorRenderer.prototype
     * @param geometry
     * @param {Bound} bbox Bbox of geometry
     * @param {Tile} tile Tile
     * @param {Integer} level Level
     * @private
     */
    VectorRenderer.prototype._removeGeometryFromTile = function(
        geometry,
        bbox,
        tile,
        level
    ) {
        var maxLevel = 0;
        if (
            bbox !== null &&
            UtilsIntersection.boundsIntersects(bbox, tile.bound) === false
        ) {
            return maxLevel;
        }

        var tileData = null;
        if (tile && tile.extension) {
            tileData = tile.extension.renderer;
        }

        if (tileData) {
            var i = 0;
            while (i < tileData.renderables.length) {
                var renderable = tileData.renderables[i];
                var renderer = renderable.bucket.renderer;
                if (renderer === this) {
                    // Remove renderable
                    var numGeometries = renderable.remove(geometry);
                    if (numGeometries === 0) {
                        tileData.renderables.splice(i, 1);
                    } else {
                        i++;
                    }

                    // Remove geometry from children if needed
                    if (renderable.hasChildren === true && tile.children) {
                        for (var n = 0; n < 4; n++) {
                            if (tile.children[n].state === Tile.State.LOADED) {
                                var levelReturned = this._removeGeometryFromTile(
                                    geometry,
                                    bbox,
                                    tile.children[n],
                                    level + 1
                                );
                                if (levelReturned > maxLevel) {
                                    maxLevel = levelReturned;
                                }
                            }
                        }
                    }
                } else {
                    i++;
                }
            }
        }
        return maxLevel;
    };

    /**
     * Remove a geometry from a tile
     * @function removeGeometryFromTile
     * @memberof VectorRenderer.prototype
     * @param geometry
     * @param {Tile} tile Tile
     */
    VectorRenderer.prototype.removeGeometryFromTile = function(geometry, tile) {
        var bbox = null;
        if (!geometry.type === "Point") {
            bbox = Utils.getBBox(geometry);
        }
        // var startDate = new Date();
        this._removeGeometryFromTile(geometry, bbox, tile, 0);
        // var endDate = new Date();
        // console.log("Delta remove : "+(endDate*1.0 - startDate*1.0)+"ms with "+maxLevel+" levels");
    };

    /**************************************************************************************************************/

    return VectorRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/PointRenderer',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./VectorRenderer",
    "./RendererManager",
    "./FeatureStyle",
    "./Program",
    "./GeoBound",
    "../Utils/Proxy"
], function(
    Utils,
    Constants,
    VectorRenderer,
    RendererManager,
    FeatureStyle,
    Program,
    GeoBound,
    Proxy
) {
    /**************************************************************************************************************/

    /**
         Basic module to generate texture from text
         */
    var Text = (function() {
        var fontSize = 18;
        var margin = 1;
        var canvas2d = null;

        var initialize = function() {
            canvas2d = document.createElement("canvas");
            canvas2d.width = 512;
            canvas2d.height = fontSize + 2 * margin;
        };

        var generateImageData = function(text, textColor) {
            if (!canvas2d) {
                initialize();
            }

            var fillColor = textColor;
            if (!fillColor) {
                fillColor = "#fff";
            } else {
                if (fillColor instanceof Array) {
                    fillColor = FeatureStyle.fromColorToString(textColor);
                }
            }

            var ctx = canvas2d.getContext("2d");
            ctx.clearRect(0, 0, canvas2d.width, canvas2d.height);
            ctx.fillStyle = fillColor;
            ctx.font = fontSize + "px sans-serif";
            ctx.textBaseline = "top";
            ctx.shadowColor = "#000";
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            ctx.shadowBlur = 2;
            ctx.fillText(text, margin, margin);
            //ctx.lineWidth = 1.0;
            //ctx.strokeText(text, margin, margin);

            var metrics = ctx.measureText(text);
            return ctx.getImageData(
                0,
                0,
                Math.floor(metrics.width) + 2 * margin,
                canvas2d.height
            );
        };

        return { generateImageData: generateImageData };
    })();

    /**************************************************************************************************************/

    /**
         @name PointRenderer
         @class
             POI Renderer constructor
         @param {AbstractGlobe} globe AbstractGlobe
         @augments VectorRenderer
         @constructor
         */
    var PointRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);

        // Store object for rendering
        this.renderContext = globe.tileManager.renderContext;
        this.tileConfig = globe.tileManager.tileConfig;

        // For stats
        this.numberOfRenderPoints = 0;

        var vertexShader =
            "attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n";
        vertexShader += "uniform mat4 viewProjectionMatrix; \n";
        vertexShader += "uniform vec3 poiPosition; // world position \n";
        vertexShader += "uniform vec2 poiScale; // x,y scale \n";
        vertexShader += "uniform vec2 tst; \n";
        vertexShader += "\n";
        vertexShader += "varying vec2 texCoord; \n";
        vertexShader += "\n";
        vertexShader += "void main(void)  \n";
        vertexShader += "{ \n";
        vertexShader +=
            "	// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n";
        vertexShader += "	texCoord = vertex.xy + vec2(0.5) + tst; \n";
        vertexShader += "	// Invert y \n";
        vertexShader += "	texCoord.y = 1.0 - texCoord.y; \n";
        vertexShader += "	\n";
        vertexShader += "	// Compute poi position in clip coordinate \n";
        vertexShader +=
            "	gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n";
        vertexShader +=
            "	gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n";
        vertexShader += "} \n";

        var fragmentShader = "precision lowp float; \n";
        fragmentShader += "varying vec2 texCoord; \n";
        fragmentShader += "uniform sampler2D texture; \n";
        fragmentShader += "uniform float alpha; \n";
        fragmentShader += "uniform vec3 color; \n";
        fragmentShader += "\n";
        fragmentShader += "void main(void) \n";
        fragmentShader += "{ \n";
        fragmentShader +=
            "	vec4 textureColor = texture2D(texture, texCoord); \n";
        fragmentShader +=
            "	gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n";
        fragmentShader += "	if (gl_FragColor.a <= 0.0) discard; \n";
        fragmentShader += "} \n";

        this.program = new Program(this.renderContext);
        this.program.createFromSource(vertexShader, fragmentShader);

        var vertices = new Float32Array([
            -0.5,
            -0.5,
            0.0,
            0.5,
            -0.5,
            0.0,
            0.5,
            0.5,
            0.0,
            -0.5,
            0.5,
            0.0
        ]);

        var gl = this.renderContext.gl;
        this.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        this.defaultTexture = null;
    };

    Utils.inherits(VectorRenderer, PointRenderer);

    /**************************************************************************************************************/

    /**
     * Build a default texture
     * @function _buildDefaultTexture
     * @memberof PointRenderer.prototype
     * @param {Bucket} bucket Bucket
     * @private
     */
    PointRenderer.prototype._buildDefaultTexture = function(bucket) {
        if (!this.defaultTexture) {
            var gl = this.renderContext.gl;
            this.defaultTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
            var whitePixel = new Uint8Array([255, 255, 255, 255]);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                1,
                1,
                0,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                whitePixel
            );
        }

        bucket.texture = this.defaultTexture;
        bucket.textureWidth = 10;
        bucket.textureHeight = 10;
    };

    /**************************************************************************************************************/
    /**
     * Build a texture from an image and store in a bucket
     * @function _buildTextureFromImage
     * @memberof PointRenderer.prototype
     * @param {Bucket} bucket Bucket
     * @param image
     * @private
     */
    PointRenderer.prototype._buildTextureFromImage = function(bucket, image) {
        bucket.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(
            image
        );
        bucket.textureWidth = image.width;
        bucket.textureHeight = image.height;
    };

    /**************************************************************************************************************/

    /**
         @name PointRenderable
         @class
             Renderable constructor for Point
         @param {Bucket} bucket Bucket
         @constructor
         */
    var PointRenderable = function(bucket) {
        this.bucket = bucket;
        this.points = [];
        this.geometries = [];
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to the renderable
     * @function add
     * @memberof PointRenderable.prototype
     * @param geometry
     * @return {Boolean} If the geometry has been successfully added to the renderable
     */
    PointRenderable.prototype.add = function(geometry, stockGeometry) {
        // TODO: Find a better way to access to coordinate system
        var coordinateSystem = this.bucket.layer
            .getGlobe()
            .getCoordinateSystem();
        var posGeo = geometry.coordinates.slice(0);

        if (stockGeometry !== false) {
            this.geometries.push(geometry);
        }

        posGeo = coordinateSystem.convert(
            posGeo,
            geometry.crs.properties.name,
            coordinateSystem.getGeoideName()
        );

        var csBound = new GeoBound(
            coordinateSystem.getGeoBound().getWest(),
            coordinateSystem.getGeoBound().getSouth(),
            coordinateSystem.getGeoBound().getEast(),
            coordinateSystem.getGeoBound().getNorth()
        );

        if (csBound.isPointInside(posGeo)) {
            const globe = this.bucket.renderer.globe;

            const altitude = globe.isSky()
                ? 0.0
                : coordinateSystem.getElevation(globe, geometry) + 200;
            posGeo.push(altitude);

            var pos3d = coordinateSystem.get3DFromWorld(posGeo);
            var vertical = coordinateSystem.getVerticalAt3D(pos3d);

            var found = false;
            for (var j = 0; j < this.points.length; ++j) {
                if (this.points[j].geometry === geometry) {
                    found = true;
                }
            }
            if (!found) {
                this.points.push({

                    pos3d: pos3d,
                    vertical: vertical,
                    geometry: geometry
                });
            }

            return true;
        } else {
            return false;
        }
    };

    /**************************************************************************************************************/

    PointRenderable.prototype.updateElevations = function() {
        this.points = [];
        for (var i = 0; i < this.geometries.length; i++) {
            this.add(this.geometries[i], false);
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from the renderable
     * @function remove
     * @memberof PointRenderable.prototype
     * @param geometry
     * @return {Integer} Number of points after remove
     */
    PointRenderable.prototype.remove = function(geometry) {
        for (var j = 0; j < this.points.length; j++) {
            if (this.points[j].geometry === geometry) {
                this.points.splice(j, 1);
                return this.points.length;
            }
        }
        return this.points.length;
    };

    /**************************************************************************************************************/

    /**
     * Dispose the renderable
     * @function dispose
     * @memberof PointRenderable.prototype
     * @param renderContext
     */
    PointRenderable.prototype.dispose = function(renderContext) {
        // Nothing to do
    };

    /**************************************************************************************************************/

    /**
         @name PointBucket
         @class
             Bucket constructor for PointRenderer
         @param layer
         @param style
         @constructor
         */
    var PointBucket = function(layer, style) {
        this.layer = layer;
        this.style = new FeatureStyle(style);
        this.renderer = null;
        this.texture = null;
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof PointBucket.prototype
     * @return {PointRenderable} Renderable
     */
    PointBucket.prototype.createRenderable = function() {
        return new PointRenderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Check if a bucket is compatible
     * @function isCompatible
     * @memberof PointBucket.prototype
     * @param style
     * @return {Boolean} Is compatible ?
     */
    PointBucket.prototype.isCompatible = function(style) {
        return (
            this.style.iconUrl === style.iconUrl &&
            this.style.icon === style.icon &&
            this.style.label === style.label
        );
    };

    /**************************************************************************************************************/

    /**
     * Create bucket to render a point
     * @function createBucket
     * @memberof PointRenderer.prototype
     * @param layer
     * @param style
     * @return {PointBucket} Bucket
     */
    PointRenderer.prototype.createBucket = function(layer, style) {
        // Create a bucket
        var bucket = new PointBucket(layer, style);

        // Initialize bucket : create the texture
        if (style.label) {
            var imageData = Text.generateImageData(
                style.label,
                style.textColor
            );
            this._buildTextureFromImage(bucket, imageData);
        } else if (style.iconUrl) {
            var image = new Image();
            image.crossOrigin = "";
            var self = this;
            image.onload = function() {
                self._buildTextureFromImage(bucket, image);
                self.renderContext.requestFrame();
            };
            image.onerror = function() {
                self._buildDefaultTexture(bucket);
            };
            image.src = Proxy.proxify(style.iconUrl);
        } else if (style.icon) {
            this._buildTextureFromImage(bucket, style.icon);
        } else {
            this._buildDefaultTexture(bucket);
        }

        return bucket;
    };

    /**************************************************************************************************************/

    /**
     * Render all the POIs
     * @function render
     * @memberof PointRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    PointRenderer.prototype.render = function(renderables, start, end) {
        this.numberOfRenderPoints = 0;

        var renderContext = this.renderContext;
        var gl = this.renderContext.gl;

        // TODO
        //var level = renderContext.renderers[0].tileManager.visibleTiles[0].level;
        //if(level < 5) {
        //    return;
        //}
        // end todo

        // Setup states
        // gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Setup program
        this.program.apply();

        // The shader only needs the viewProjection matrix, use modelViewMatrix as a temporary storage
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            renderContext.modelViewMatrix
        );
        gl.uniformMatrix4fv(
            this.program.uniforms.viewProjectionMatrix,
            false,
            renderContext.modelViewMatrix
        );
        gl.uniform1i(this.program.uniforms.texture, 0);

        // Compute eye direction from inverse view matrix
        mat4.inverse(renderContext.viewMatrix, renderContext.modelViewMatrix);
        var camZ = [
            renderContext.modelViewMatrix[8],
            renderContext.modelViewMatrix[9],
            renderContext.modelViewMatrix[10]
        ];
        vec3.normalize(camZ);
        vec3.scale(camZ, this.tileConfig.cullSign, camZ);

        // Compute pixel size vector to offset the points from the earth
        var pixelSizeVector = renderContext.computePixelSizeVector();

        // Warning : use quoted strings to access properties of the attributes, to work correclty in advanced mode with closure compiler
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(
            this.program.attributes.vertex,
            3,
            gl.FLOAT,
            false,
            0,
            0
        );
        var scale;
        var currentBucket = null;
        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            // renderable.updateElevations();
            var bucket = renderable.bucket;

            if (renderable.points.length === 0) {
                continue;
            }

            if (bucket !== currentBucket) {
                // Bind point texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, bucket.texture);

                // 2.0 * because normalized device coordinates goes from -1 to 1
                scale = [
                    (2.0 * bucket.textureWidth) / renderContext.canvas.width,
                    (2.0 * bucket.textureHeight) / renderContext.canvas.height
                ];
                gl.uniform2fv(this.program.uniforms.poiScale, scale);
                gl.uniform2fv(this.program.uniforms.tst, [
                    0.5 / bucket.textureWidth,
                    0.5 / bucket.textureHeight
                ]);
            }

            for (var i = 0; i < renderable.points.length; i++) {
                // Poi culling
                var worldPoi = renderable.points[i].pos3d;
                var poiVec = renderable.points[i].vertical;
                scale =
                    bucket.textureHeight *
                    (pixelSizeVector[0] * worldPoi[0] +
                        pixelSizeVector[1] * worldPoi[1] +
                        pixelSizeVector[2] * worldPoi[2] +
                        pixelSizeVector[3]);
                scale *= this.tileConfig.cullSign;
                var scaleInKm =
                    (scale /
                        this.globe
                            .getCoordinateSystem()
                            .getGeoide()
                            .getHeightScale()) *
                    0.001;
                if (scaleInKm > bucket.style.pointMaxSize) {
                    continue;
                }

                if (
                    vec3.dot(poiVec, camZ) > 0 &&
                    renderContext.worldFrustum.containsSphere(
                        worldPoi,
                        scale
                    ) >= 0
                ) {
                    var x = poiVec[0] * scale + worldPoi[0];
                    var y = poiVec[1] * scale + worldPoi[1];
                    var z = poiVec[2] * scale + worldPoi[2];

                    gl.uniform3f(this.program.uniforms.poiPosition, x, y, z);
                    gl.uniform1f(
                        this.program.uniforms.alpha,
                        bucket.layer.getOpacity()
                    );
                    var color = bucket.style.getFillColor();
                    gl.uniform3f(
                        this.program.uniforms.color,
                        color[0],
                        color[1],
                        color[2]
                    );

                    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

                    this.numberOfRenderPoints++;
                }
            }
        }

        //    gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof PointRenderer.prototype
     * @param type
     * @param style
     * @return {Boolean} Can apply ?
     */
    PointRenderer.prototype.canApply = function(type, style) {
        return type === Constants.GEOMETRY.Point && style.iconUrl === null;
    };

    /**************************************************************************************************************/

    // Register the renderer
    RendererManager.factory.push(function(globe) {
        return new PointRenderer(globe);
    });

    return PointRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/BatchRenderable',[],function() {
    /**
 @name BatchRenderable
 @class
  Base renderable
 @constructor
 */
    var BatchRenderable = function(bucket) {
        this.bucket = bucket;
        this.vertexBuffer = null;
        this.indexBuffer = null;
        this.vertices = [];
        this.triIndices = [];
        this.lineIndices = [];
        this.geometryInfos = [];
        this.bufferDirty = true;
        this.vertexSize = 3;
        this.indexType = 0;
        this.vertexBufferShared = false;
    };

    /**
   Remove a geometry from the renderable
   @function remove
   @memberof BatchRenderable.prototype
   @param {JSON} geometry Geometry
 */
    BatchRenderable.prototype.remove = function(geometry) {
        var fiIndex = -1;

        // Find the feature
        var vertexIt = 0;
        var lineIndexIt = 0;
        var triIndexIt = 0;
        var n;
        for (var i = 0; i < this.geometryInfos.length; i++) {
            var fi = this.geometryInfos[i];
            if (fi.geometry === geometry) {
                // Remove feature from vertex and index buffer
                this.vertices.splice(vertexIt, fi.vertexCount);
                this.lineIndices.splice(lineIndexIt, fi.lineIndexCount);
                this.triIndices.splice(triIndexIt, fi.triIndexCount);

                // Update index buffer
                var vertexOffset = fi.vertexCount / this.vertexSize;
                for (n = lineIndexIt; n < this.lineIndices.length; n++) {
                    this.lineIndices[n] -= vertexOffset;
                }
                for (n = triIndexIt; n < this.triIndices.length; n++) {
                    this.triIndices[n] -= vertexOffset;
                }
                fiIndex = i;

                break;
            }

            vertexIt += fi.vertexCount;
            lineIndexIt += fi.lineIndexCount;
            triIndexIt += fi.triIndexCount;
        }

        if (fiIndex >= 0) {
            this.bufferDirty = true;

            // Remove the feature from the infos array
            this.geometryInfos.splice(fiIndex, 1);

            return this.vertices.length;
        } else {
            return this.vertices.length;
        }
    };

    /**
   Add a feature to the renderable
   @function add
   @memberof BatchRenderable.prototype
   @param {JSON} geometry Geometry
   @param {?} tile Tile
 */
    BatchRenderable.prototype.add = function(geometry, tile) {
        var hasTile = typeof tile !== "undefined";

        this.tile = tile;

        // Store previous number of vertices/indices needed for "after-build" computation
        var numVertices = this.vertices.length;
        var numLineIndices = this.lineIndices.length;
        var numTriIndices = this.triIndices.length;

        var geometryInTile = hasTile === false;
        if (hasTile === true) {
            geometryInTile = this.build(geometry, tile);
        }
        if (geometryInTile) {
            this.geometryInfos.push({
                geometry: geometry,
                vertexCount: this.vertices.length - numVertices,
                lineIndexCount: this.lineIndices.length - numLineIndices,
                triIndexCount: this.triIndices.length - numTriIndices
            });
            this.bufferDirty = true;
            return true;
        } else {
            // Feature not in the tile
            return false;
        }
    };

    /**
   Dispose graphics data
   @function dispose
   @memberof BatchRenderable.prototype
   @param {renderContext} renderContext Render context
 */
    BatchRenderable.prototype.dispose = function(renderContext) {
        if (typeof renderContext === "undefined") {
            return;
        }

        var gl = renderContext.gl;

        if (this.indexBuffer) {
            gl.deleteBuffer(this.indexBuffer);
        }
        this.indexBuffer = null;
        if (this.vertexBuffer && !this.vertexBufferShared) {
            gl.deleteBuffer(this.vertexBuffer);
            this.vertexBuffer = null;
        }
    };

    /**
   Must be call before rendering
   @function bindBuffers
   @memberof BatchRenderable.prototype
   @param {renderContext} renderContext Render context
 */
    BatchRenderable.prototype.bindBuffers = function(renderContext) {
        var gl = renderContext.gl;

        if (this.bufferDirty) {
            this.dispose(renderContext);

            // Create vertex buffer if needed
            if (this.vertexBuffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            } else {
                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array(this.vertices),
                    gl.STATIC_DRAW
                );
            }

            // Create index buffer
            this.indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

            var indices = this.triIndices;
            if (this.triIndices.length > 0) {
                if (this.lineIndices.length > 0) {
                    indices = this.triIndices.concat(this.lineIndices);
                } else {
                    indices = this.triIndices;
                }
            } else {
                indices = this.lineIndices;
            }

            var vertexCount = this.vertices.length / this.vertexSize;
            if (vertexCount > 65535) {
                gl.bufferData(
                    gl.ELEMENT_ARRAY_BUFFER,
                    new Uint32Array(indices),
                    gl.STATIC_DRAW
                );
                this.indexType = gl.UNSIGNED_INT;
            } else {
                gl.bufferData(
                    gl.ELEMENT_ARRAY_BUFFER,
                    new Uint16Array(indices),
                    gl.STATIC_DRAW
                );
                this.indexType = gl.UNSIGNED_SHORT;
            }
            this.bufferDirty = false;
        } else {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        }
    };

    /**************************************************************************************************************/

    return BatchRenderable;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/TiledVectorRenderable',[
    "../Utils/Utils",
    "../Renderer/BatchRenderable",
    "../Utils/Constants"
], function(Utils, BatchRenderable, Constants) {
    /**************************************************************************************************************/

    /** @constructor
     *    TiledVectorRenderable constructor
     */
    var TiledVectorRenderable = function(bucket) {
        BatchRenderable.prototype.constructor.call(this, bucket);

        this.tile = null;
        // The tiled vector renderable always has a children
        this.hasChildren = true;
    };

    /**************************************************************************************************************/

    Utils.inherits(BatchRenderable, TiledVectorRenderable);

    /**************************************************************************************************************/

    /**
     * Initialize a child renderable
     */
    TiledVectorRenderable.prototype.initChild = function(i, j) {
        var child = new TiledVectorRenderable(this.bucket);
        child.tile = this.tile;
        child.vertexBufferShared = true;
        child.vertexBuffer = this.vertexBuffer;
        child.vertices = this.vertices;
        child.buildChildrenIndices(this, j * 2 + i);
        return child;
    };

    /**************************************************************************************************************/

    /**
     * Generate a child renderable
     */
    TiledVectorRenderable.prototype.generateChild = function(tile) {
        for (var j = 0; j < this.geometryInfos.length; j++) {
            this.bucket.renderer._addGeometryToTile(
                this.bucket,
                this.geometryInfos[j].geometry,
                tile
            );
        }
    };

    /**************************************************************************************************************/

    /**
     * Build children indices.
     * Children indices are used to render a tile children when it is not completely loaded.
     */
    TiledVectorRenderable.prototype.buildChildrenIndices = function(
        parent,
        index
    ) {
        var n;
        var vertexOffset1, vertexOffset2, vertexOffset3;
        var x1, x2, x3, i;
        var y1, y2, y3, j;
        for (n = 0; n < parent.triIndices.length; n += 3) {
            vertexOffset1 = 3 * parent.triIndices[n];
            vertexOffset2 = 3 * parent.triIndices[n + 1];
            vertexOffset3 = 3 * parent.triIndices[n + 2];

            x1 = parent.vertices[vertexOffset1];
            x2 = parent.vertices[vertexOffset2];
            x3 = parent.vertices[vertexOffset3];

            i = 0;
            if (
                x1 > 0 ||
                (x1 === 0 && x2 > 0) ||
                (x1 === 0 && x2 === 0 && x3 > 0)
            ) {
                i = 1;
            }

            y1 = parent.vertices[vertexOffset1 + 1];
            y2 = parent.vertices[vertexOffset2 + 1];
            y3 = parent.vertices[vertexOffset3 + 1];

            j = 1;
            if (
                y1 > 0 ||
                (y1 === 0 && y2 > 0) ||
                (y1 === 0 && y2 === 0 && y3 > 0)
            ) {
                j = 0;
            }

            if (index === 2 * j + i) {
                this.triIndices.push(
                    parent.triIndices[n],
                    parent.triIndices[n + 1],
                    parent.triIndices[n + 2]
                );
            }
        }
        for (n = 0; n < parent.lineIndices.length / 2; n++) {
            vertexOffset1 = 3 * parent.lineIndices[2 * n];
            vertexOffset2 = 3 * parent.lineIndices[2 * n + 1];

            x1 = parent.vertices[vertexOffset1];
            x2 = parent.vertices[vertexOffset2];

            i = 0;
            if (x1 > 0 || (x1 === 0 && x2 > 0)) {
                i = 1;
            }

            y1 = parent.vertices[vertexOffset1 + 1];
            y2 = parent.vertices[vertexOffset2 + 1];

            j = 1;
            if (y1 > 0 || (y1 === 0 && y2 > 0)) {
                j = 0;
            }

            if (index === 2 * j + i) {
                this.lineIndices.push(
                    parent.lineIndices[2 * n],
                    parent.lineIndices[2 * n + 1]
                );
            }
        }
    };

    /**************************************************************************************************************/

    /**
     *    Add a feature to the renderable
     *    @return    Boolean indicating if geometry intersects the given tile
     */
    TiledVectorRenderable.prototype.build = function(geometry, tile) {
        this.tile = tile;
        var i, j;
        var tileInRange;
        if (
            typeof this.bucket.layer.minLevel === "undefined" ||
            typeof this.bucket.layer.maxLevel === "undefined"
        ) {
            tileInRange = true;
        } else {
            tileInRange =
                this.bucket.layer.minLevel <= tile.level &&
                tile.level <= this.bucket.layer.maxLevel;
        }

        if (tileInRange) {
            var coords = geometry.coordinates;
            switch (geometry.type) {
            case Constants.GEOMETRY.LineString:
                this.buildVerticesAndIndices(tile, coords);
                break;
            case Constants.GEOMETRY.Polygon:
                for (i = 0; i < coords.length; i++) {
                    this.buildVerticesAndIndices(tile, coords[i]);
                }
                break;
            case Constants.GEOMETRY.MultiLineString:
                for (i = 0; i < coords.length; i++) {
                    this.buildVerticesAndIndices(tile, coords[i]);
                }
                break;
            case Constants.GEOMETRY.MultiPolygon:
                for (j = 0; j < coords.length; j++) {
                    for (i = 0; i < coords[j].length; i++) {
                        this.buildVerticesAndIndices(tile, coords[j][i]);
                    }
                }
                break;
            }
        }
        return tile.geoBound.intersectsGeometry(geometry);
    };

    /**************************************************************************************************************/

    return TiledVectorRenderable;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/TiledVectorRenderer',[
    "../Utils/Utils",
    "../Renderer/VectorRenderer",
    "../Renderer/Program"
], function(Utils, VectorRenderer, Program) {
    /**************************************************************************************************************/

    /** @constructor
     TiledVectorRenderer constructor
     */
    var TiledVectorRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);

        var vertexShader = "attribute vec3 vertex; \n";
        vertexShader += "uniform float zOffset; \n";
        vertexShader += "uniform mat4 modelViewMatrix;\n";
        vertexShader += "uniform mat4 projectionMatrix;\n";
        vertexShader += "\n";
        vertexShader += "void main(void)  \n";
        vertexShader += "{ \n";
        vertexShader +=
            "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex.x, vertex.y, vertex.z + zOffset, 1.0); \n";
        vertexShader += "} \n";

        var fragmentShader = "#ifdef GL_ES \n";
        fragmentShader += "precision highp float; \n";
        fragmentShader += "#endif \n";
        fragmentShader += "uniform vec4 color; \n";
        fragmentShader += "\n";
        fragmentShader += "void main(void) \n";
        fragmentShader += "{ \n";
        fragmentShader += "	gl_FragColor = color; \n";
        fragmentShader += "} \n";

        this.program = new Program(this.tileManager.renderContext);
        this.program.createFromSource(vertexShader, fragmentShader);
    };

    Utils.inherits(VectorRenderer, TiledVectorRenderer);

    /**************************************************************************************************************/

    /**
     Render all redenrable on the given tiles
     */
    TiledVectorRenderer.prototype.render = function(renderables, start, end) {
        var renderContext = this.tileManager.renderContext;
        var gl = renderContext.gl;
        var modelViewMatrix = mat4.create();

        // Setup program
        this.program.apply();

        gl.depthFunc(gl.LEQUAL);
        // Do not write into z-buffer : the tiled vector are clamped to terrain, so the z of terrain should not change
        gl.depthMask(false);
        gl.uniformMatrix4fv(
            this.program.uniforms.projectionMatrix,
            false,
            renderContext.projectionMatrix
        );

        var currentStyle = null;

        for (var n = start; n < end; n++) {
            var renderable = renderables[n];

            var tile = renderable.tile;

            mat4.multiply(
                renderContext.viewMatrix,
                tile.matrix,
                modelViewMatrix
            );
            gl.uniformMatrix4fv(
                this.program.uniforms.modelViewMatrix,
                false,
                modelViewMatrix
            );
            gl.uniform1f(this.program.uniforms.zOffset, tile.radius * 0.0007);

            currentStyle = renderable.bucket.style;

            renderable.bindBuffers(renderContext);

            gl.vertexAttribPointer(
                this.program.attributes.vertex,
                3,
                gl.FLOAT,
                false,
                0,
                0
            );

            if (renderable.triIndices.length > 0) {
                gl.uniform4f(
                    this.program.uniforms.color,
                    currentStyle.fillColor[0],
                    currentStyle.fillColor[1],
                    currentStyle.fillColor[2],
                    currentStyle.fillColor[3] *
                        renderable.bucket.layer.getOpacity()
                );
                gl.drawElements(
                    gl.TRIANGLES,
                    renderable.triIndices.length,
                    renderable.indexType,
                    0
                );
            }

            if (renderable.lineIndices.length > 0) {
                gl.lineWidth(currentStyle.strokeWidth);
                gl.uniform4f(
                    this.program.uniforms.color,
                    currentStyle.strokeColor[0],
                    currentStyle.strokeColor[1],
                    currentStyle.strokeColor[2],
                    currentStyle.strokeColor[3] *
                        renderable.bucket.layer.getOpacity()
                );
                var size = renderable.indexType === gl.UNSIGNED_INT ? 4 : 2;
                gl.drawElements(
                    gl.LINES,
                    renderable.lineIndices.length,
                    renderable.indexType,
                    renderable.triIndices.length * size
                );
            }
        }

        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
    };

    /**************************************************************************************************************/

    return TiledVectorRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/LineStringRenderable',[
    "../Utils/Constants",
    "../Utils/Utils",
    "./FeatureStyle",
    "./RendererManager",
    "../Tiling/TiledVectorRenderable",
    "../Tiling/TiledVectorRenderer",
    "../Utils/Numeric"
], function(
    Constants,
    Utils,
    FeatureStyle,
    RendererManager,
    TiledVectorRenderable,
    TiledVectorRenderer,
    Numeric
) {
    /**************************************************************************************************************/

    /**
         @name LineRenderer
         @class
             LineStringRenderable manages lineString data to be rendered on a tile.
         @augments TiledVectorRenderable
         @param {Bucket} bucket Bucket
         @constructor
         */

    var LineStringRenderable = function(bucket) {
        TiledVectorRenderable.prototype.constructor.call(this, bucket);
    };

    /**************************************************************************************************************/

    // Inheritance
    Utils.inherits(TiledVectorRenderable, LineStringRenderable);

    /**************************************************************************************************************/

    /**************************************************************************************************************/

    /**
     * Check if a geometry crosses the date line
     * @function _fixDateLine
     * @memberof LineStringRenderable.prototype
     * @param {Tile} tile Tile
     * @param coords
     * @return {Array} Lines
     * @private
     */
    LineStringRenderable.prototype._fixDateLine = function(tile, coords) {
        var newCoords = [];
        var lines = [newCoords];
        for (var n = 0; n < coords.length - 1; n++) {
            newCoords.push(coords[n]);

            var x1 = coords[n][0];
            var y1 = coords[n][1];
            var x2 = coords[n + 1][0];
            var y2 = coords[n + 1][1];
            if (Math.abs(x2 - x1) > 180) {
                if (x1 < 0) {
                    x1 += 360;
                }
                if (x2 < 0) {
                    x2 += 360;
                }

                var t = (180 - x1) / (x2 - x1);
                if (t > 0 && t < 1) {
                    var y = y1 + t * (y2 - y1);
                    var x = coords[n][0] > 0 ? 180 : -180;
                    newCoords.push([x, y]);
                    newCoords = [[-x, y]];
                    lines.push(newCoords);
                }
            }
        }
        newCoords.push(coords[coords.length - 1]);
        //newCoords.push( coords[0] );

        return lines;
    };

    /**
     * Build vertices and indices from the coordinates.
     * Clamp a line string on a tile
     * @function buildVerticesAndIndices
     * @memberof LineStringRenderable.prototype
     * @param {Tile} tile Tile
     * @param coords
     */
    LineStringRenderable.prototype.buildVerticesAndIndices = function(
        tile,
        coords
    ) {
        if (coords.length === 0) {
            return;
        }

        // Fix date line for coordinates first
        var coordinates = this._fixDateLine(tile, coords);

        for (var i = 0; i < coordinates.length; i++) {
            this._buildVerticesAndIndices(tile, coordinates[i]);
        }
    };

    /**
     * Build vertices and indices from the coordinates.
     * Clamp a line string on a tile
     * @function _buildVerticesAndIndices
     * @memberof LineStringRenderable.prototype
     * @param {Tile} tile Tile
     * @param coords
     * @private
     */
    LineStringRenderable.prototype._buildVerticesAndIndices = function(
        tile,
        coords
    ) {
        var size = tile.config.tesselation;
        var vs = tile.config.vertexSize;

        coords.push(coords[coords.length - 1]);
        // Convert lon/lat coordinates to tile coordinates (between [0,size-1] inside the tile)
        var tileCoords = tile.lonlat2tile(coords);

        for (var i = 0; i < coords.length - 1; i++) {
            var u1 = tileCoords[i][0];
            var v1 = tileCoords[i][1];

            var u2 = tileCoords[i + 1][0];
            var v2 = tileCoords[i + 1][1];

            var intersections = [];
            var n, v, res, u;
            var vertexOffset, x, y, z;
            // Intersect the segment with the tile grid

            // First intersect with columns
            // uStart, uEnd represent a range of the tile columns that the segement can intersect
            var uStart = Math.max(-1, Math.min(u1, u2));
            var uEnd = Math.min(size - 1, Math.max(u1, u2));
            for (n = Math.floor(uStart) + 1; n < Math.floor(uEnd) + 1; n++) {
                u = n;
                res = Numeric.lineIntersection(
                    u1,
                    v1,
                    u2,
                    v2,
                    u,
                    0.0,
                    u,
                    size - 1
                );
                if (
                    res[0] > 0.0 &&
                    res[0] < 1.0 &&
                    res[1] >= 0.0 &&
                    res[1] <= 1.0
                ) {
                    v = res[1] * (size - 1);
                    var vFloor = Math.floor(v);
                    var vFrac = v - vFloor;
                    vertexOffset = vs * (vFloor * size + n);
                    x =
                        (1.0 - vFrac) * tile.vertices[vertexOffset] +
                        vFrac * tile.vertices[vertexOffset + vs * size];
                    y =
                        (1.0 - vFrac) * tile.vertices[vertexOffset + 1] +
                        vFrac * tile.vertices[vertexOffset + vs * size + 1];
                    z =
                        (1.0 - vFrac) * tile.vertices[vertexOffset + 2] +
                        vFrac * tile.vertices[vertexOffset + vs * size + 2];
                    intersections.push([res[0], x, y, z]);
                }
            }

            // Then intersect with rows
            // vStart, vEnd represent a range of the tile rows that the segement can intersect
            var vStart = Math.max(-1, Math.min(v1, v2));
            var vEnd = Math.min(size - 1, Math.max(v1, v2));
            for (n = Math.floor(vStart) + 1; n < Math.floor(vEnd) + 1; n++) {
                v = n;
                res = Numeric.lineIntersection(
                    u1,
                    v1,
                    u2,
                    v2,
                    0.0,
                    v,
                    size - 1,
                    v
                );
                if (
                    res[0] > 0.0 &&
                    res[0] < 1.0 &&
                    res[1] >= 0.0 &&
                    res[1] <= 1.0
                ) {
                    u = res[1] * (size - 1);
                    var uFloor = Math.floor(u);
                    var uFrac = u - uFloor;
                    vertexOffset = vs * (n * size + uFloor);
                    x =
                        (1.0 - uFrac) * tile.vertices[vertexOffset] +
                        uFrac * tile.vertices[vertexOffset + vs];
                    y =
                        (1.0 - uFrac) * tile.vertices[vertexOffset + 1] +
                        uFrac * tile.vertices[vertexOffset + vs + 1];
                    z =
                        (1.0 - uFrac) * tile.vertices[vertexOffset + 2] +
                        uFrac * tile.vertices[vertexOffset + vs + 2];
                    intersections.push([res[0], x, y, z]);
                }
            }
            // Sort intersections found on the segment
            intersections.sort(function(a, b) {
                return a[0] > b[0];
            });

            // Build the vertices from the intersections found
            var startIndex = this.vertices.length / 3;
            var vec;
            if (u1 >= 0.0 && u1 <= size - 1 && v1 >= 0.0 && v1 <= size - 1) {
                vec = tile.computePosition(u1, v1);
                this.vertices.push(vec[0]);
                this.vertices.push(vec[1]);
                this.vertices.push(vec[2]);
            }

            for (n = 0; n < intersections.length; n++) {
                this.vertices.push(intersections[n][1]);
                this.vertices.push(intersections[n][2]);
                this.vertices.push(intersections[n][3]);
            }

            if (u2 >= 0.0 && u2 <= size - 1 && v2 >= 0.0 && v2 <= size - 1) {
                vec = tile.computePosition(u2, v2);
                this.vertices.push(vec[0]);
                this.vertices.push(vec[1]);
                this.vertices.push(vec[2]);
            }

            var endIndex = this.vertices.length / 3;

            for (n = startIndex; n < endIndex - 1; n++) {
                this.lineIndices.push(n);
                this.lineIndices.push(n + 1);
            }
        }
    };

    /**************************************************************************************************************/

    /**
 @name LineStringRenderer
 @class
	LineStringRenderer manages lineString data to be rendered on a tile.
 @augments TiledVectorRenderer
 @param {Planet} planet Planet
 @constructor
 */

    var LineStringRenderer = function(globe) {
        TiledVectorRenderer.prototype.constructor.call(this, globe);
    };

    // Inheritance
    Utils.inherits(TiledVectorRenderer, LineStringRenderer);

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof LineStringRenderer.prototype
     * @param type
     * @param style
     * @return {Boolean} Can apply ?
     */
    LineStringRenderer.prototype.canApply = function(type, style) {
        if (this.globe.isSky()) {
            return false;
        }

        if (!style.onTerrain) {
            return false;
        }

        const result =
            (type === Constants.GEOMETRY.LineString ||
                type === Constants.GEOMETRY.MultiLineString ||
                (!style.fill &&
                    (type === Constants.GEOMETRY.Polygon ||
                        type === Constants.GEOMETRY.MultiPolygon))) &&
            !style.gradientLength;
        return result;
    };
    /**************************************************************************************************************/
    /**
  @name LineStringBucket
  @class
 	  Bucket constructor for LineStringRenderer
  @param layer
	@param style
  @constructor
  */
    var LineStringBucket = function(layer, style) {
        this.layer = layer;
        this.style = new FeatureStyle(style);
        this.renderer = null;
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof LineStringBucket.prototype
     * @return {LineStringRenderable} Renderable
     */
    LineStringBucket.prototype.createRenderable = function() {
        return new LineStringRenderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Check if a bucket is compatible
     * @function isCompatible
     * @memberof LineStringBucket.prototype
     * @param style
     * @return {Boolean} Is compatible ?
     */
    LineStringBucket.prototype.isCompatible = function(style) {
        var result =
            this.style.strokeColor[0] === style.strokeColor[0] &&
            this.style.strokeColor[1] === style.strokeColor[1] &&
            this.style.strokeColor[2] === style.strokeColor[2] &&
            this.style.strokeColor[3] === style.strokeColor[3] &&
            this.style.strokeWidth === style.strokeWidth;
        return result;
    };

    /**************************************************************************************************************/

    /**
     * Get or create a bucket to store a feature with the given style
     * @function createBucket
     * @memberof LineStringRenderer.prototype
     * @param layer
     * @param style
     * @return {LineStringBucket} Bucket
     */
    LineStringRenderer.prototype.createBucket = function(layer, style) {
        // Create a bucket
        return new LineStringBucket(layer, style);
    };

    /**************************************************************************************************************/

    // Register the renderer
    RendererManager.factory.push(function(globe) {
        return new LineStringRenderer(globe);
    });

    return LineStringRenderable;
});

// jshint ignore: start
define('gw/Renderer/pnltri',[],function() {
    // pnltri.js / raw.github.com/jahting/pnltri.js/master/LICENSE
    /**
     * @author jahting / http://www.ameco.tv/
     *
     *	(Simple) Polygon Near-Linear Triangulation
     *	  with fast ear-clipping for polygons without holes
     *
     */

    var PNLTRI = { REVISION: "2.1.1" };

    //	#####  Global Constants  #####

    //	#####  Global Variables  #####

    /**
     * @author jahting / http://www.ameco.tv/
     */

    PNLTRI.Math = {
        random: Math.random, // function to use for random number generation

        // generate random ordering in place:
        //	Fisher-Yates shuffle
        array_shuffle: function(inoutArray) {
            for (var i = inoutArray.length - 1; i > 0; i--) {
                var j = Math.floor(PNLTRI.Math.random() * (i + 1));
                var tmp = inoutArray[i];
                inoutArray[i] = inoutArray[j];
                inoutArray[j] = tmp;
            }
            return inoutArray;
        },

        //	like compare (<=>)
        //		yA > yB resp. xA > xB: 1, equal: 0, otherwise: -1
        compare_pts_yx: function(inPtA, inPtB) {
            var deltaY = inPtA.y - inPtB.y;
            if (deltaY < PNLTRI.Math.EPSILON_N) {
                return -1;
            } else if (deltaY > PNLTRI.Math.EPSILON_P) {
                return 1;
            } else {
                var deltaX = inPtA.x - inPtB.x;
                if (deltaX < PNLTRI.Math.EPSILON_N) {
                    return -1;
                } else if (deltaX > PNLTRI.Math.EPSILON_P) {
                    return 1;
                } else {
                    return 0;
                }
            }
        },

        ptsCrossProd: function(inPtVertex, inPtFrom, inPtTo) {
            // two vectors: ( v0: inPtVertex -> inPtFrom ), ( v1: inPtVertex -> inPtTo )
            // CROSS_SINE: sin(theta) * len(v0) * len(v1)
            return (
                (inPtFrom.x - inPtVertex.x) * (inPtTo.y - inPtVertex.y) -
                (inPtFrom.y - inPtVertex.y) * (inPtTo.x - inPtVertex.x)
            );
            // <=> crossProd( inPtFrom-inPtVertex, inPtTo-inPtVertex )
            // == 0: colinear (angle == 0 or 180 deg == PI rad)
            // > 0:  v1 lies left of v0, CCW angle from v0 to v1 is convex ( < 180 deg )
            // < 0:  v1 lies right of v0, CW angle from v0 to v1 is convex ( < 180 deg )
        }
    };

    // precision of floating point arithmetic
    //	PNLTRI.Math.EPSILON_P = Math.pow(2,-32);	// ~ 0.0000000001
    PNLTRI.Math.EPSILON_P = Math.pow(2, -43); // ~ 0.0000000000001
    PNLTRI.Math.EPSILON_N = -PNLTRI.Math.EPSILON_P;

    //	Problem with EPSILON-compares:
    //	- especially when there is a x-coordinate ordering on equal y-coordinates
    //		=> either NO EPSILON-compares on y-coordinates, since almost equal y
    //			can have very different x - so they are not nearly close
    //		or EPSILON must be bigger: Solution so far.
    /**
     * @author jahting / http://www.ameco.tv/
     */

    PNLTRI.PolygonData = function(inPolygonChainList) {
        // list of polygon vertices
        //	.x, .y: coordinates
        this.vertices = [];

        // list of polygon segments, original polygons ane holes
        //	and additional ones added during the subdivision into
        //	uni-y-monotone polygons (s. this.monoSubPolyChains)
        //	doubly linked by: snext, sprev
        this.segments = [];
        this.diagonals = [];

        // for the ORIGINAL polygon chains
        this.idNextPolyChain = 0;
        //	for each original chain: lies the polygon inside to the left?
        //	"true": winding order is CCW for a contour or CW for a hole
        //	"false": winding order is CW for a contour or CCW for a hole
        this.PolyLeftArr = [];

        // indices into this.segments: at least one for each monoton chain for the polygon
        //  these subdivide the polygon into uni-y-monotone polygons, that is
        //  polygons that have only one segment between ymax and ymin on one side
        //  and the other side has monotone increasing y from ymin to ymax
        // the monoSubPolyChains are doubly linked by: mnext, mprev
        this.monoSubPolyChains = [];

        // list of triangles: each 3 indices into this.vertices
        this.triangles = [];

        // initialize optional polygon chains
        if (inPolygonChainList) {
            for (var i = 0, j = inPolygonChainList.length; i < j; i++) {
                this.addPolygonChain(inPolygonChainList[i]);
            }
        }
    };

    PNLTRI.PolygonData.prototype = {
        constructor: PNLTRI.PolygonData,

        /*	Accessors  */

        nbVertices: function() {
            return this.vertices.length;
        },
        getSegments: function() {
            return this.segments;
        },
        getFirstSegment: function() {
            return this.segments[0];
        },
        getMonoSubPolys: function() {
            return this.monoSubPolyChains;
        },
        getTriangles: function() {
            return this.triangles.concat();
        },

        nbPolyChains: function() {
            return this.idNextPolyChain;
        },

        // for the polygon data AFTER triangulation
        //	returns an Array of flags, one flag for each polygon chain:
        //		lies the inside of the polygon to the left?
        //		"true" implies CCW for contours and CW for holes
        get_PolyLeftArr: function() {
            return this.PolyLeftArr.concat();
        },
        set_PolyLeft_wrong: function(inChainId) {
            this.PolyLeftArr[inChainId] = false;
        },

        /*	Helper  */

        // checks winding order by calculating the area of the polygon
        isClockWise: function(inStartSeg) {
            var cursor = inStartSeg,
                doubleArea = 0;
            do {
                doubleArea +=
                    (cursor.vFrom.x - cursor.vTo.x) *
                    (cursor.vFrom.y + cursor.vTo.y);
                cursor = cursor.snext;
            } while (cursor != inStartSeg);
            return doubleArea < 0;
        },

        /*	Operations  */

        appendVertexEntry: function(inVertexX, inVertexY) {
            // private
            var vertex = {
                id: this.vertices.length, // vertex id, representing input sequence
                x: inVertexX, // coordinates
                y: inVertexY
            };
            this.vertices.push(vertex);
            return vertex;
        },

        createSegmentEntry: function(inVertexFrom, inVertexTo) {
            // private
            return {
                chainId: this.idNextPolyChain,
                // end points of segment
                vFrom: inVertexFrom, // -> start point entry in vertices
                vTo: inVertexTo, // -> end point entry in vertices
                // upward segment? (i.e. vTo > vFrom) !!! only valid for sprev,snext NOT for mprev,mnext !!!
                upward:
                    PNLTRI.Math.compare_pts_yx(inVertexTo, inVertexFrom) == 1,
                // doubly linked list of original polygon chains (not the monoChains !)
                sprev: null, // previous segment
                snext: null, // next segment
                //
                //	for performance reasons:
                //	 initialization of all fields added later
                //
                // for trapezoids
                rootFrom: null, // root of partial tree where vFrom is located
                rootTo: null, // root of partial tree where vTo is located
                is_inserted: false, // already inserted into QueryStructure ?
                // for assigning depth: trapezoids
                trLeft: null, // one trapezoid bordering on the left of this segment
                trRight: null, // one trapezoid bordering on the right of this segment
                // for monochains
                mprev: null, // doubly linked list for monotone chains (sub-polygons)
                mnext: null,
                marked: false // already visited during unique monoChain identification ?
            };
        },

        appendSegmentEntry: function(inSegment) {
            // private
            this.segments.push(inSegment);
            return inSegment;
        },

        appendDiagonalsEntry: function(inDiagonal) {
            // <<<<<	public
            this.diagonals.push(inDiagonal);
            return inDiagonal;
        },

        addVertexChain: function(inRawPointList) {
            // private

            function verts_equal(inVert1, inVert2) {
                return (
                    Math.abs(inVert1.x - inVert2.x) < PNLTRI.Math.EPSILON_P &&
                    Math.abs(inVert1.y - inVert2.y) < PNLTRI.Math.EPSILON_P
                );
            }

            function verts_colinear_chain(inVert1, inVert2, inVert3) {
                if (
                    Math.abs(
                        PNLTRI.Math.ptsCrossProd(inVert2, inVert1, inVert3)
                    ) > PNLTRI.Math.EPSILON_P
                )
                    return false;
                // only real sequences, not direction reversals
                var low, middle, high;
                if (Math.abs(inVert1.y - inVert2.y) < PNLTRI.Math.EPSILON_P) {
                    // horizontal line
                    middle = inVert2.x;
                    if (inVert1.x < inVert3.x) {
                        low = inVert1.x;
                        high = inVert3.x;
                    } else {
                        low = inVert3.x;
                        high = inVert1.x;
                    }
                } else {
                    middle = inVert2.y;
                    if (inVert1.y < inVert3.y) {
                        low = inVert1.y;
                        high = inVert3.y;
                    } else {
                        low = inVert3.y;
                        high = inVert1.y;
                    }
                }
                return (
                    low - middle < PNLTRI.Math.EPSILON_P &&
                    middle - high < PNLTRI.Math.EPSILON_P
                );
            }

            var newVertices = [];
            var newVertex, acceptVertex, lastIdx;
            for (var i = 0; i < inRawPointList.length; i++) {
                newVertex = this.appendVertexEntry(
                    inRawPointList[i].x,
                    inRawPointList[i].y
                );
                // suppresses zero-length segments
                acceptVertex = true;
                lastIdx = newVertices.length - 1;
                if (lastIdx >= 0) {
                    if (verts_equal(newVertex, newVertices[lastIdx])) {
                        acceptVertex = false;
                    } else if (lastIdx > 0) {
                        if (
                            verts_colinear_chain(
                                newVertices[lastIdx - 1],
                                newVertices[lastIdx],
                                newVertex
                            )
                        ) {
                            newVertices.pop();
                        }
                    }
                }
                if (acceptVertex) newVertices.push(newVertex);
            }
            // compare last vertices to first: suppresses zero-length and co-linear segments
            lastIdx = newVertices.length - 1;
            if (
                lastIdx > 0 &&
                verts_equal(newVertices[lastIdx], newVertices[0])
            ) {
                newVertices.pop();
                lastIdx--;
            }
            if (lastIdx > 1) {
                if (
                    verts_colinear_chain(
                        newVertices[lastIdx - 1],
                        newVertices[lastIdx],
                        newVertices[0]
                    )
                ) {
                    newVertices.pop();
                    lastIdx--;
                }
                if (
                    lastIdx > 1 &&
                    verts_colinear_chain(
                        newVertices[lastIdx],
                        newVertices[0],
                        newVertices[1]
                    )
                ) {
                    newVertices.shift();
                }
            }

            return newVertices;
        },

        addPolygonChain: function(inRawPointList) {
            // <<<<<< public

            // vertices
            var newVertices = this.addVertexChain(inRawPointList);
            if (newVertices.length < 3) {
                console.log("Polygon has < 3 vertices!", newVertices);
                return 0;
            }

            // segments
            var saveSegListLength = this.segments.length;
            //
            var segment, firstSeg, prevSeg;
            for (var i = 0; i < newVertices.length - 1; i++) {
                segment = this.createSegmentEntry(
                    newVertices[i],
                    newVertices[i + 1]
                );
                if (prevSeg) {
                    segment.sprev = prevSeg;
                    prevSeg.snext = segment;
                } else {
                    firstSeg = segment;
                }
                prevSeg = segment;
                this.appendSegmentEntry(segment);
            }
            // close polygon
            segment = this.createSegmentEntry(
                newVertices[newVertices.length - 1],
                newVertices[0]
            );
            segment.sprev = prevSeg;
            prevSeg.snext = segment;
            this.appendSegmentEntry(segment);
            firstSeg.sprev = segment;
            segment.snext = firstSeg;

            this.PolyLeftArr[this.idNextPolyChain++] = true;
            return this.segments.length - saveSegListLength;
        },

        /* Monotone Polygon Chains */

        // Generate the uni-y-monotone sub-polygons from
        //	the trapezoidation of the polygon.

        create_mono_chains: function() {
            // <<<<<< public
            var newMono, newMonoTo, toFirstOutSeg, fromRevSeg;
            for (var i = 0, j = this.segments.length; i < j; i++) {
                newMono = this.segments[i];
                if (this.PolyLeftArr[newMono.chainId]) {
                    // preserve winding order
                    newMonoTo = newMono.vTo; // target of segment
                    newMono.mprev = newMono.sprev; // doubly linked list for monotone chains (sub-polygons)
                    newMono.mnext = newMono.snext;
                } else {
                    // reverse winding order
                    newMonoTo = newMono.vFrom;
                    newMono = newMono.snext;
                    newMono.mprev = newMono.snext;
                    newMono.mnext = newMono.sprev;
                }
                if ((fromRevSeg = newMono.vFrom.lastInDiag)) {
                    // assignment !
                    fromRevSeg.mnext = newMono;
                    newMono.mprev = fromRevSeg;
                    newMono.vFrom.lastInDiag = null; // cleanup
                }
                if ((toFirstOutSeg = newMonoTo.firstOutDiag)) {
                    // assignment !
                    toFirstOutSeg.mprev = newMono;
                    newMono.mnext = toFirstOutSeg;
                    newMonoTo.firstOutDiag = null; // cleanup
                }
            }
        },

        // For each monotone polygon, find the ymax (to determine the two
        // y-monotone chains) and skip duplicate monotone polygons

        unique_monotone_chains_max: function() {
            // <<<<<< public

            function find_monotone_chain_max(frontMono) {
                var frontPt, firstPt, ymaxPt;

                var monoPosmax = frontMono;
                firstPt = ymaxPt = frontMono.vFrom;

                frontMono.marked = true;
                frontMono = frontMono.mnext;
                while ((frontPt = frontMono.vFrom)) {
                    // assignment !
                    if (frontMono.marked) {
                        if (frontPt == firstPt) break; // mono chain completed
                        console.log(
                            "ERR unique_monotone: segment in two chains",
                            firstPt,
                            frontMono
                        );
                        return null;
                    } else {
                        /*					if ( frontPt == firstPt ) {			// check for robustness
						console.log("ERR unique_monotone: point double", firstPt, frontMono );
					}		*/
                        frontMono.marked = true;
                    }
                    if (PNLTRI.Math.compare_pts_yx(frontPt, ymaxPt) == 1) {
                        ymaxPt = frontPt;
                        monoPosmax = frontMono;
                    }
                    frontMono = frontMono.mnext;
                }
                return monoPosmax;
            }

            var frontMono, monoPosmax;

            // assumes attribute "marked" is NOT yet "true" for any mono chain segment
            this.monoSubPolyChains = [];
            // loop through all original segments
            for (var i = 0, j = this.segments.length; i < j; i++) {
                frontMono = this.segments[i];
                if (frontMono.marked) continue; // already in a processed mono chain
                monoPosmax = find_monotone_chain_max(frontMono);
                if (monoPosmax) this.monoSubPolyChains.push(monoPosmax);
            }
            // loop through all additional segments (diagonals)			// TODO: Testcase for mono chain without original segments !!!
            /*		for ( var i = 0, j = this.diagonals.length; i < j; i++ ) {
			frontMono = this.diagonals[i];
			if ( frontMono.marked )		continue;		// already in a processed mono chain
			monoPosmax = find_monotone_chain_max( frontMono );
			if ( monoPosmax )	this.monoSubPolyChains.push( monoPosmax );
		}	*/
            return this.monoSubPolyChains;
        },

        /* Triangles */

        clearTriangles: function() {
            this.triangles = [];
        },

        addTriangle: function(inVert1, inVert2, inVert3) {
            this.triangles.push([inVert1.id, inVert2.id, inVert3.id]);
        }
    };

    /**
     * Simple Polygon Triangulation by Ear Clipping
     *
     * description of technique employed:
     *	http://www.siggraph.org/education/materials/HyperGraph/scanline/outprims/polygon1.htm
     *
     * This code is a quick port of code written in C++ which was submitted to
     *	flipcode.com by John W. Ratcliff  // July 22, 2000
     * See original code and more information here:
     *	http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
     *
     * ported to actionscript by Zevan Rosser
     *	http://actionsnippet.com/?p=1462
     *
     * ported to javascript by Joshua Koo
     *	http://www.lab4games.net/zz85/blog
     *
     * adapted to doubly linked list by Juergen Ahting
     *	http://www.ameco.tv
     *
     */

    PNLTRI.EarClipTriangulator = function(inPolygonData) {
        this.polyData = inPolygonData;
    };

    PNLTRI.EarClipTriangulator.prototype = {
        constructor: PNLTRI.EarClipTriangulator,

        // triangulates first doubly linked segment list in this.polyData
        //	algorithm uses ear-clipping and runs in O(n^2) time

        triangulate_polygon_no_holes: function() {
            function isEarAt(vertex) {
                var prevX = vertex.mprev.vFrom.x;
                var prevY = vertex.mprev.vFrom.y;

                var vertX = vertex.vFrom.x;
                var vertY = vertex.vFrom.y;

                var nextX = vertex.mnext.vFrom.x;
                var nextY = vertex.mnext.vFrom.y;

                var vnX = nextX - vertX,
                    vnY = nextY - vertY;
                var npX = prevX - nextX,
                    npY = prevY - nextY;
                var pvX = vertX - prevX,
                    pvY = vertY - prevY;

                // concave angle at vertex -> not an ear to cut off
                if (PNLTRI.Math.EPSILON_P > pvX * vnY - vnX * pvY) return false;

                // check whether any other point lieas within the triangle abc
                var vStop = vertex.mprev.mprev;
                var vOther = vertex.mnext;
                while (vOther != vStop) {
                    vOther = vOther.mnext;
                    var otherX = vOther.vFrom.x;
                    var otherY = vOther.vFrom.y;

                    var poX = otherX - prevX,
                        poY = otherY - prevY;
                    // just in case there are several vertices with the same coordinate
                    if (poX === 0 && poY === 0) continue; // vOther == vertex.mprev
                    var voX = otherX - vertX,
                        voY = otherY - vertY;
                    if (voX === 0 && voY === 0) continue; // vOther == vertex
                    var noX = otherX - nextX,
                        noY = otherY - nextY;
                    if (noX === 0 && noY === 0) continue; // vOther == vertex.mnext

                    // if vOther is inside triangle abc -> not an ear to cut off
                    if (
                        vnX * voY - vnY * voX >= PNLTRI.Math.EPSILON_N &&
                        pvX * poY - pvY * poX >= PNLTRI.Math.EPSILON_N &&
                        npX * noY - npY * noX >= PNLTRI.Math.EPSILON_N
                    )
                        return false;
                }
                return true;
            }

            var myPolyData = this.polyData;
            var startSeg = myPolyData.getFirstSegment();

            // create a counter-clockwise ordered doubly linked list (monoChain links)

            var cursor = startSeg;
            if (myPolyData.isClockWise(startSeg)) {
                do {
                    // reverses chain order
                    cursor.mprev = cursor.snext;
                    cursor.mnext = cursor.sprev;
                    cursor = cursor.sprev;
                } while (cursor != startSeg);
                myPolyData.set_PolyLeft_wrong(0);
            } else {
                do {
                    cursor.mprev = cursor.sprev;
                    cursor.mnext = cursor.snext;
                    cursor = cursor.snext;
                } while (cursor != startSeg);
            }

            //  remove all vertices except 2, creating 1 triangle every time

            var vertex = startSeg;
            var fullLoop = vertex; // prevent infinite loop on "defective" polygons

            while (vertex.mnext != vertex.mprev) {
                if (isEarAt(vertex)) {
                    // found a triangle ear to cut off
                    this.polyData.addTriangle(
                        vertex.mprev.vFrom,
                        vertex.vFrom,
                        vertex.mnext.vFrom
                    );
                    // remove vertex from the remaining chain
                    vertex.mprev.mnext = vertex.mnext;
                    vertex.mnext.mprev = vertex.mprev;
                    vertex = vertex.mnext;
                    fullLoop = vertex; // reset error detection
                } else {
                    vertex = vertex.mnext;
                    // loop?: probably non-simple polygon -> stop with error
                    if (vertex == fullLoop) return false;
                }
            }

            return true;
        }

        /*	// takes one element of a double linked segment list
	//	works on array of vertices

	triangulate_polygon_no_holes: function () {
		var startSeg = this.polyData.getFirstSegment();

		function vertList( inStartSeg ) {
			var verts = [];
			// we want a counter-clockwise polygon in verts
			var doubleArea = 0.0;
			var cursor = inStartSeg;
			var p,q;
			var idx = 0;
			do {
				p = cursor.sprev.vFrom;
				q = cursor.vFrom;
				doubleArea += p.x * q.y - q.x * p.y;
				verts[idx++] = q;
				cursor = cursor.snext;
			} while ( cursor != inStartSeg );
			if ( doubleArea < 0.0 ) {
				verts = verts.reverse();
				var tmp = verts.pop();
				verts.unshift( tmp );
			}
			return	verts;
		}

		function snip( verts, u, v, w, n ) {

			var ax = verts[ u ].x;
			var ay = verts[ u ].y;

			var bx = verts[ v ].x;
			var by = verts[ v ].y;

			var cx = verts[ w ].x;
			var cy = verts[ w ].y;

			if ( PNLTRI.Math.EPSILON_P > ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			var p, px, py;

			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			for ( p = 0; p < n; p ++ ) {

				px = verts[ p ].x
				py = verts[ p ].y

				apx = px - ax;  apy = py - ay;
					if ( ( apx == 0 ) && ( apy == 0 ) )		continue;
				bpx = px - bx;  bpy = py - by;
					if ( ( bpx == 0 ) && ( bpy == 0 ) )		continue;
				cpx = px - cx;  cpy = py - cy;
					if ( ( cpx == 0 ) && ( cpy == 0 ) )		continue;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= PNLTRI.Math.EPSILON_N ) &&
					 ( bCROSScp >= PNLTRI.Math.EPSILON_N ) &&
					 ( cCROSSap >= PNLTRI.Math.EPSILON_N ) ) return false;

			}

			return true;

		};

		var result = [];

		var	verts = vertList( startSeg );

		var n = verts.length;
		var nv = n;

		var u, v, w;

		//  remove nv - 2 vertices, creating 1 triangle every time

		var count = 2 * nv;   // error detection

		for ( v = nv - 1; nv > 2; ) {

			// if we loop, it is probably a non-simple polygon

			if ( ( count -- ) <= 0 )	return false;

			// three consecutive vertices in current polygon, <u,v,w>

			u = v; 	 	if ( nv <= u ) u = 0;     // previous
			v = u + 1;  if ( nv <= v ) v = 0;     // new v
			w = v + 1;  if ( nv <= w ) w = 0;     // next

			if ( snip( verts, u, v, w, nv ) ) {

				// output Triangle

				this.polyData.addTriangle( verts[ u ], verts[ v ], verts[ w ] );

				// remove v from the remaining polygon

				var s, t;

				for ( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv --;

				v --;
				if ( v < 0 )	v = nv-1;

				// reset error detection counter

				count = 2 * nv;

			}

		}

		return true;

	},		*/
    };

    /**
     * @author jahting / http://www.ameco.tv/
     *
     *	Algorithm to create the trapezoidation of a polygon with holes
     *	 according to Seidel's algorithm [Sei91]
     */

    PNLTRI.Trapezoid = function(inHigh, inLow, inLeft, inRight) {
        this.vHigh = inHigh
            ? inHigh
            : { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY };
        this.vLow = inLow
            ? inLow
            : { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY };

        this.lseg = inLeft;
        this.rseg = inRight;

        //	this.uL = null;				// -> Trapezoid: upper left neighbor
        //	this.uR = null;				// -> Trapezoid: upper right neighbor
        //	this.dL = null;				// -> Trapezoid: lower left neighbor
        //	this.dR = null;				// -> Trapezoid: lower right neighbor

        //	this.sink = null;			// link to corresponding SINK-Node in QueryStructure

        //	this.usave = null;			// temp: uL/uR, preserved for next step
        //	this.uleft = null;			// temp: from uL? (true) or uR (false)

        this.depth = -1; // no depth assigned yet

        this.monoDone = false; // monotonization: done with trying to split this trapezoid ?
    };

    PNLTRI.Trapezoid.prototype = {
        constructor: PNLTRI.Trapezoid,

        clone: function() {
            var newTrap = new PNLTRI.Trapezoid(
                this.vHigh,
                this.vLow,
                this.lseg,
                this.rseg
            );

            newTrap.uL = this.uL;
            newTrap.uR = this.uR;

            newTrap.dL = this.dL;
            newTrap.dR = this.dR;

            newTrap.sink = this.sink;

            return newTrap;
        },

        splitOffLower: function(inSplitPt) {
            var trLower = this.clone(); // new lower trapezoid

            this.vLow = trLower.vHigh = inSplitPt;

            // L/R unknown, anyway changed later
            this.dL = trLower; // setBelow
            trLower.uL = this; // setAbove
            this.dR = trLower.uR = null;

            // setAbove
            if (trLower.dL) trLower.dL.uL = trLower; // dL always connects to uL
            if (trLower.dR) trLower.dR.uR = trLower; // dR always connects to uR

            return trLower;
        }
    };

    /*==============================================================================
 *
 *============================================================================*/

    // PNLTRI.qsCounter = 0;

    PNLTRI.QsNode = function(inTrapezoid) {
        //	this.qsId = PNLTRI.qsCounter++;				// Debug only
        // Only SINK-nodes are created directly.
        // The others originate from splitting trapezoids
        // - by a horizontal line: SINK-Node -> Y-Node
        // - by a segment: SINK-Node -> X-Node
        this.trap = inTrapezoid;
        inTrapezoid.sink = this;
    };

    PNLTRI.QsNode.prototype = {
        constructor: PNLTRI.QsNode
    };

    /*==============================================================================
 *
 *============================================================================*/

    PNLTRI.QueryStructure = function(inPolygonData) {
        // initialise the query structure and trapezoid list
        var initialTrap = new PNLTRI.Trapezoid(null, null, null, null);
        this.trapArray = [];
        this.appendTrapEntry(initialTrap);

        //	PNLTRI.qsCounter = 0;
        this.root = new PNLTRI.QsNode(initialTrap);

        if (inPolygonData) {
            /*
		 * adds and initializes specific attributes for all segments
		 *	// -> QueryStructure: roots of partial tree where vertex is located
		 *	rootFrom, rootTo:	for vFrom, vTo
		 *	// marker
		 *	is_inserted:	already inserted into QueryStructure ?
		 */
            var segListArray = inPolygonData.getSegments();
            for (var i = 0; i < segListArray.length; i++) {
                segListArray[i].rootFrom = segListArray[i].rootTo = this.root;
                segListArray[i].is_inserted = false;
            }
        }
    };

    PNLTRI.QueryStructure.prototype = {
        constructor: PNLTRI.QueryStructure,

        getRoot: function() {
            return this.root;
        },

        appendTrapEntry: function(inTrapezoid) {
            inTrapezoid.trapID = this.trapArray.length; // for Debug
            this.trapArray.push(inTrapezoid);
        },
        cloneTrap: function(inTrapezoid) {
            var trap = inTrapezoid.clone();
            this.appendTrapEntry(trap);
            return trap;
        },

        splitNodeAtPoint: function(inNode, inPoint, inReturnUpper) {
            // inNode: SINK-Node with trapezoid containing inPoint
            var trUpper = inNode.trap; // trUpper: trapezoid includes the point
            if (trUpper.vHigh == inPoint) return inNode; // (ERROR) inPoint is already inserted
            if (trUpper.vLow == inPoint) return inNode; // (ERROR) inPoint is already inserted
            var trLower = trUpper.splitOffLower(inPoint); // trLower: new lower trapezoid
            this.appendTrapEntry(trLower);

            // SINK-Node -> Y-Node
            inNode.yval = inPoint;
            inNode.trap = null;

            inNode.right = new PNLTRI.QsNode(trUpper); // Upper trapezoid sink
            inNode.left = new PNLTRI.QsNode(trLower); // Lower trapezoid sink

            return inReturnUpper ? trUpper.sink : trLower.sink;
        },

        /*
	 * Mathematics & Geometry helper methods
	 */

        fpEqual: function(inNum0, inNum1) {
            return Math.abs(inNum0 - inNum1) < PNLTRI.Math.EPSILON_P;
        },

        // Checks, whether the vertex inPt is to the left of line segment inSeg.
        //	Returns:
        //		>0: inPt is left of inSeg,
        //		<0: inPt is right of inSeg,
        //		=0: inPt is co-linear with inSeg
        //
        //	ATTENTION: always viewed from -y, not as if moving along the segment chain !!

        is_left_of: function(inSeg, inPt, inBetweenY) {
            var retVal;
            var dXfrom = inSeg.vFrom.x - inPt.x;
            var dXto = inSeg.vTo.x - inPt.x;
            var dYfromZero = this.fpEqual(inSeg.vFrom.y, inPt.y);
            if (this.fpEqual(inSeg.vTo.y, inPt.y)) {
                if (dYfromZero) return 0; // all points on a horizontal line
                retVal = dXto;
            } else if (dYfromZero) {
                retVal = dXfrom;
                /*		} else if ( inBetweenY && ( dXfrom * dXto > 0 ) ) {
			// both x-coordinates of inSeg are on the same side of inPt
			if ( Math.abs( dXto ) >= PNLTRI.Math.EPSILON_P )	return	dXto;
			retVal = dXfrom;	*/
            } else {
                if (inSeg.upward) {
                    return PNLTRI.Math.ptsCrossProd(
                        inSeg.vFrom,
                        inSeg.vTo,
                        inPt
                    );
                } else {
                    return PNLTRI.Math.ptsCrossProd(
                        inSeg.vTo,
                        inSeg.vFrom,
                        inPt
                    );
                }
            }
            if (Math.abs(retVal) < PNLTRI.Math.EPSILON_P) return 0;
            return retVal;
        },

        /*
	 * Query structure main methods
	 */

        //	This method finds the Nodes in the QueryStructure corresponding
        //   to the trapezoids that contain the endpoints of inSegment,
        //	 starting from Nodes rootFrom/rootTo and replacing them with the results.

        segNodes: function(inSegment) {
            this.ptNode(inSegment, true);
            this.ptNode(inSegment, false);
        },

        // TODO: may need to prevent infinite loop in case of messed up
        //	trapezoid structure (s. test_add_segment_special_6)

        ptNode: function(inSegment, inUseFrom) {
            var ptMain, ptOther, qsNode;
            if (inUseFrom) {
                ptMain = inSegment.vFrom;
                ptOther = inSegment.vTo; // used if ptMain is not sufficient
                qsNode = inSegment.rootFrom;
            } else {
                ptMain = inSegment.vTo;
                ptOther = inSegment.vFrom;
                qsNode = inSegment.rootTo;
            }
            var compPt, compRes;
            var isInSegmentShorter;

            while (qsNode) {
                if (qsNode.yval) {
                    // Y-Node: horizontal line
                    // 4 times as often as X-Node
                    qsNode =
                        PNLTRI.Math.compare_pts_yx(
                            ptMain == qsNode.yval // is the point already inserted ?
                                ? ptOther
                                : ptMain,
                            qsNode.yval
                        ) == -1
                            ? qsNode.left
                            : qsNode.right; // below : above
                } else if (qsNode.seg) {
                    // X-Node: segment (~vertical line)
                    // 0.8 to 1.5 times as often as SINK-Node
                    if (
                        ptMain == qsNode.seg.vFrom ||
                        ptMain == qsNode.seg.vTo
                    ) {
                        // the point is already inserted
                        if (this.fpEqual(ptMain.y, ptOther.y)) {
                            // horizontal segment
                            if (
                                !this.fpEqual(
                                    qsNode.seg.vFrom.y,
                                    qsNode.seg.vTo.y
                                )
                            ) {
                                qsNode =
                                    ptOther.x < ptMain.x
                                        ? qsNode.left
                                        : qsNode.right; // left : right
                            } else {
                                // co-linear horizontal reversal: test_add_segment_special_7
                                if (ptMain == qsNode.seg.vFrom) {
                                    // connected at qsNode.seg.vFrom
                                    //								console.log("ptNode: co-linear horizontal reversal, connected at qsNode.seg.vFrom", inUseFrom, inSegment, qsNode )
                                    isInSegmentShorter = inSegment.upward
                                        ? ptOther.x >= qsNode.seg.vTo.x
                                        : ptOther.x < qsNode.seg.vTo.x;
                                    qsNode = (isInSegmentShorter
                                        ? inSegment.sprev.upward
                                        : qsNode.seg.snext.upward)
                                        ? qsNode.right
                                        : qsNode.left; // above : below
                                } else {
                                    // connected at qsNode.seg.vTo
                                    //								console.log("ptNode: co-linear horizontal reversal, connected at qsNode.seg.vTo", inUseFrom, inSegment, qsNode );
                                    isInSegmentShorter = inSegment.upward
                                        ? ptOther.x < qsNode.seg.vFrom.x
                                        : ptOther.x >= qsNode.seg.vFrom.x;
                                    qsNode = (isInSegmentShorter
                                        ? inSegment.snext.upward
                                        : qsNode.seg.sprev.upward)
                                        ? qsNode.left
                                        : qsNode.right; // below : above
                                }
                            }
                            continue;
                        } else {
                            compRes = this.is_left_of(
                                qsNode.seg,
                                ptOther,
                                false
                            );
                            if (compRes === 0) {
                                // co-linear reversal (not horizontal)
                                //	a co-linear continuation would not reach this point
                                //  since the previous Y-node comparison would have led to a sink instead
                                //							console.log("ptNode: co-linear, going back on previous segment", ptMain, ptOther, qsNode );
                                // now as we have two consecutive co-linear segments we have to avoid a cross-over
                                //	for this we need the far point on the "next" segment to the SHORTER of our two
                                //	segments to avoid that "next" segment to cross the longer of our two segments
                                if (ptMain == qsNode.seg.vFrom) {
                                    // connected at qsNode.seg.vFrom
                                    //								console.log("ptNode: co-linear, going back on previous segment, connected at qsNode.seg.vFrom", ptMain, ptOther, qsNode );
                                    isInSegmentShorter = inSegment.upward
                                        ? ptOther.y >= qsNode.seg.vTo.y
                                        : ptOther.y < qsNode.seg.vTo.y;
                                    compRes = isInSegmentShorter
                                        ? this.is_left_of(
                                            qsNode.seg,
                                            inSegment.sprev.vFrom,
                                            false
                                        )
                                        : -this.is_left_of(
                                            qsNode.seg,
                                            qsNode.seg.snext.vTo,
                                            false
                                        );
                                } else {
                                    // connected at qsNode.seg.vTo
                                    //								console.log("ptNode: co-linear, going back on previous segment, connected at qsNode.seg.vTo", ptMain, ptOther, qsNode );
                                    isInSegmentShorter = inSegment.upward
                                        ? ptOther.y < qsNode.seg.vFrom.y
                                        : ptOther.y >= qsNode.seg.vFrom.y;
                                    compRes = isInSegmentShorter
                                        ? this.is_left_of(
                                            qsNode.seg,
                                            inSegment.snext.vTo,
                                            false
                                        )
                                        : -this.is_left_of(
                                            qsNode.seg,
                                            qsNode.seg.sprev.vFrom,
                                            false
                                        );
                                }
                            }
                        }
                    } else {
                        /*					if ( ( PNLTRI.Math.compare_pts_yx( ptMain, qsNode.seg.vFrom ) *			// TODO: Testcase
							PNLTRI.Math.compare_pts_yx( ptMain, qsNode.seg.vTo )
						   ) == 0 ) {
						console.log("ptNode: Pts too close together#2: ", ptMain, qsNode.seg );
					}		*/
                        compRes = this.is_left_of(qsNode.seg, ptMain, true);
                        if (compRes === 0) {
                            // touching: ptMain lies on qsNode.seg but is none of its endpoints
                            //	should happen quite seldom
                            compRes = this.is_left_of(
                                qsNode.seg,
                                ptOther,
                                false
                            );
                            if (compRes === 0) {
                                // co-linear: inSegment and qsNode.seg
                                //	includes case with ptOther connected to qsNode.seg
                                var tmpPtOther = inUseFrom
                                    ? inSegment.sprev.vFrom
                                    : inSegment.snext.vTo;
                                compRes = this.is_left_of(
                                    qsNode.seg,
                                    tmpPtOther,
                                    false
                                );
                            }
                        }
                    }
                    if (compRes > 0) {
                        qsNode = qsNode.left;
                    } else if (compRes < 0) {
                        qsNode = qsNode.right;
                    } else {
                        // ???	TODO - not reached with current tests
                        //				possible at all ?
                        return qsNode;
                        // qsNode = qsNode.left;		// left
                        // qsNode = qsNode.right;		// right
                    }
                } else {
                    // SINK-Node: trapezoid area
                    // least often
                    if (!qsNode.trap) {
                        console.log("ptNode: unknown type", qsNode);
                    }
                    if (inUseFrom) {
                        inSegment.rootFrom = qsNode;
                    } else {
                        inSegment.rootTo = qsNode;
                    }
                    return qsNode;
                }
            } // end while - should not exit here
        },

        // Add a new segment into the trapezoidation and update QueryStructure and Trapezoids
        // 1) locates the two endpoints of the segment in the QueryStructure and inserts them
        // 2) goes from the high-end trapezoid down to the low-end trapezoid
        //		changing all the trapezoids in between.
        // Except for the high-end and low-end no new trapezoids are created.
        // For all in between either:
        // - the existing trapezoid is restricted to the left of the new segment
        //		and on the right side the trapezoid from above is extended downwards
        // - or the other way round:
        //	 the existing trapezoid is restricted to the right of the new segment
        //		and on the left side the trapezoid from above is extended downwards

        add_segment: function(inSegment) {
            var scope = this;

            // functions handling the relationship to the upper neighbors (uL, uR)
            //	of trNewLeft and trNewRight

            function fresh_seg_or_upward_cusp() {
                // trCurrent has at most 1 upper neighbor
                //	and should also have at least 1, since the high-point trapezoid
                //	has been split off another one, which is now above
                var trUpper = trCurrent.uL || trCurrent.uR;

                // trNewLeft and trNewRight CANNOT have been extended from above
                if (trUpper.dL && trUpper.dR) {
                    // upward cusp: top forms a triangle

                    // ATTENTION: the decision whether trNewLeft or trNewRight is the
                    //	triangle trapezoid formed by the two segments has already been taken
                    //	when selecting trCurrent as the left or right lower neighbor to trUpper !!

                    if (trCurrent == trUpper.dL) {
                        //	*** Case: FUC_UC_LEFT; prev: ----
                        // console.log( "fresh_seg_or_upward_cusp: upward cusp, new seg to the left!" );
                        //		  upper
                        //   -------*-------
                        //		   + \
                        //	  NL  +   \
                        //		 +	NR \
                        //		+		\
                        trNewRight.uL = null; // setAbove; trNewRight.uR, trNewLeft unchanged
                        trUpper.dL = trNewLeft; // setBelow; dR: unchanged, NEVER null
                    } else {
                        //	*** Case: FUC_UC_RIGHT; prev: ----
                        // console.log( "fresh_seg_or_upward_cusp: upward cusp, new seg from the right!" );
                        //		  upper
                        //   -------*-------
                        //		   / +
                        //		  /   +	 NR
                        //		 /	NL +
                        //		/		+
                        trNewLeft.uR = null; // setAbove; trNewLeft.uL, trNewRight unchanged
                        trUpper.dR = trNewRight; // setBelow; dL: unchanged, NEVER null
                    }
                } else {
                    //	*** Case: FUC_FS; prev: "splitOffLower"
                    // console.log( "fresh_seg_or_upward_cusp: fresh segment, high adjacent segment still missing" );
                    //		  upper
                    //   -------*-------
                    //		   +
                    //	  NL  +
                    //		 +	NR
                    //		+
                    trNewRight.uL = null; // setAbove; trNewLeft unchanged, set by "splitOffLower"
                    trNewRight.uR = trUpper;
                    trUpper.dR = trNewRight; // setBelow; trUpper.dL unchanged, set by "splitOffLower"
                }
            }

            function continue_chain_from_above() {
                // trCurrent has at least 2 upper neighbors
                if (trCurrent.usave) {
                    // 3 upper neighbors (part II)
                    if (trCurrent.uleft) {
                        //	*** Case: CC_3UN_LEFT; prev: 1B_3UN_LEFT
                        // console.log( "continue_chain_from_above: 3 upper neighbors (part II): u0a, u0b, uR(usave)" );
                        // => left gets one, right gets two of the upper neighbors
                        // !! trNewRight cannot have been extended from above
                        //		and trNewLeft must have been !!
                        //		   +		/
                        //	  C.uL  + C.uR / C.usave
                        //    - - - -+----*----------
                        //		NL	  +		NR
                        trNewRight.uL = trCurrent.uR; // setAbove
                        trNewRight.uR = trCurrent.usave;
                        trNewRight.uL.dL = trNewRight; // setBelow; trNewRight.uL.dR == null, unchanged
                        trNewRight.uR.dR = trNewRight; // setBelow; trNewRight.uR.dL == null, unchanged
                    } else {
                        //	*** Case: CC_3UN_RIGHT; prev: 1B_3UN_RIGHT
                        // console.log( "continue_chain_from_above: 3 upper neighbors (part II): uL(usave), u1a, u1b" );
                        // => left gets two, right gets one of the upper neighbors
                        // !! trNewLeft cannot have been extended from above
                        //		and trNewRight must have been !!
                        //			\		 +
                        //	 C.usave \ C.uL + C.uR
                        //   ---------*----+- - - -
                        //			NL    +   NR
                        trNewLeft.uR = trCurrent.uL; // setAbove; first uR !!!
                        trNewLeft.uL = trCurrent.usave;
                        trNewLeft.uL.dL = trNewLeft; // setBelow; dR == null, unchanged
                        trNewLeft.uR.dR = trNewLeft; // setBelow; dL == null, unchanged
                    }
                    trNewLeft.usave = trNewRight.usave = null;
                } else if (trCurrent.vHigh == trFirst.vHigh) {
                    // && meetsHighAdjSeg ??? TODO
                    //	*** Case: CC_2UN_CONN; prev: ----
                    // console.log( "continue_chain_from_above: 2 upper neighbors, fresh seg, continues high adjacent seg" );
                    // !! trNewLeft and trNewRight cannot have been extended from above !!
                    //	  C.uL	 /  C.uR
                    //   -------*---------
                    //	   NL  +	NR
                    trNewRight.uR.dR = trNewRight; // setBelow; dL == null, unchanged
                    trNewLeft.uR = trNewRight.uL = null; // setAbove; trNewLeft.uL, trNewRight.uR unchanged
                } else {
                    //	*** Case: CC_2UN; prev: 1B_1UN_CONT, 2B_NOCON_RIGHT/LEFT, 2B_TOUCH_RIGHT/LEFT, 2B_COLIN_RIGHT/LEFT
                    // console.log( "continue_chain_from_above: simple case, 2 upper neighbors (no usave, not fresh seg)" );
                    // !! trNewLeft XOR trNewRight will have been extended from above !!
                    //	  C.uL	 +  C.uR
                    //   -------+---------
                    //	   NL  +	NR
                    if (trNewRight == trCurrent) {
                        // trNewLeft has been extended from above
                        // setAbove
                        trNewRight.uL = trNewRight.uR;
                        trNewRight.uR = null;
                        // setBelow; dR: unchanged, is NOT always null (prev: 2B_NOCON_LEFT, 2B_TOUCH_LEFT, 2B_COLIN_LEFT)
                        trNewRight.uL.dL = trNewRight;
                    } else {
                        // trNewRight has been extended from above
                        trNewLeft.uR = trNewLeft.uL; // setAbove; first uR !!!
                        trNewLeft.uL = null;
                    }
                }
            }

            // functions handling the relationship to the lower neighbors (dL, dR)
            //	of trNewLeft and trNewRight
            // trNewLeft or trNewRight MIGHT have been extended from above
            //  !! in that case dL and dR are different from trCurrent and MUST be set here !!

            function only_one_trap_below(inTrNext) {
                if (trCurrent.vLow == trLast.vLow) {
                    // final part of segment

                    if (meetsLowAdjSeg) {
                        // downward cusp: bottom forms a triangle

                        // ATTENTION: the decision whether trNewLeft and trNewRight are to the
                        //	left or right of the already inserted segment the new one meets here
                        //	has already been taken when selecting trLast to the left or right
                        //	of that already inserted segment !!

                        if (trCurrent.dL) {
                            //	*** Case: 1B_DC_LEFT; next: ----
                            // console.log( "only_one_trap_below: downward cusp, new seg from the left!" );
                            //		+		/
                            //		 +  NR /
                            //	  NL  +	  /
                            //		   + /
                            //   -------*-------
                            //	   C.dL = next

                            // setAbove
                            inTrNext.uL = trNewLeft; // uR: unchanged, NEVER null
                            // setBelow part 1
                            trNewLeft.dL = inTrNext;
                            trNewRight.dR = null;
                        } else {
                            //	*** Case: 1B_DC_RIGHT; next: ----
                            // console.log( "only_one_trap_below: downward cusp, new seg to the right!" );
                            //		\		+
                            //		 \  NL +
                            //		  \	  +  NR
                            //		   \ +
                            //   -------*-------
                            //	   C.dR = next

                            // setAbove
                            inTrNext.uR = trNewRight; // uL: unchanged, NEVER null
                            // setBelow part 1
                            trNewLeft.dL = null;
                            trNewRight.dR = inTrNext;
                        }
                    } else {
                        //	*** Case: 1B_1UN_END; next: ----
                        // console.log( "only_one_trap_below: simple case, new seg ends here, low adjacent seg still missing" );
                        //			  +
                        //		NL	 +  NR
                        //			+
                        //   ------*-------
                        //		  next

                        // setAbove
                        inTrNext.uL = trNewLeft; // trNewLeft must
                        inTrNext.uR = trNewRight; // must
                        // setBelow part 1
                        trNewLeft.dL = trNewRight.dR = inTrNext; // Error
                        //					trNewRight.dR = inTrNext;
                    }
                    // setBelow part 2
                    trNewLeft.dR = trNewRight.dL = null;
                } else {
                    // NOT final part of segment

                    if (inTrNext.uL && inTrNext.uR) {
                        // inTrNext has two upper neighbors
                        // => a segment ends on the upper Y-line of inTrNext
                        // => inTrNext has temporarily 3 upper neighbors
                        // => marks whether the new segment cuts through
                        //		uL or uR of inTrNext and saves the other in .usave
                        if (inTrNext.uL == trCurrent) {
                            //	*** Case: 1B_3UN_LEFT; next: CC_3UN_LEFT
                            // console.log( "only_one_trap_below: inTrNext has 3 upper neighbors (part I): u0a, u0b, uR(usave)" );
                            //		 +		  /
                            //	  NL  +	 NR	 /
                            //		   +	/
                            //   - - - -+--*----
                            //			 +
                            //		  next
                            //						if ( inTrNext.uR != trNewRight ) {		// for robustness	TODO: prevent
                            inTrNext.usave = inTrNext.uR;
                            inTrNext.uleft = true;
                            // trNewLeft: L/R undefined, will be extended down and changed anyway
                            // } else {
                            // ERROR: should not happen
                            // console.log( "ERR add_segment: Trapezoid Loop right", inTrNext, trCurrent, trNewLeft, trNewRight, inSegment, this );
                            //						}
                        } else {
                            //	*** Case: 1B_3UN_RIGHT; next: CC_3UN_RIGHT
                            // console.log( "only_one_trap_below: inTrNext has 3 upper neighbors (part I): uL(usave), u1a, u1b" );
                            //	 \		   +
                            //	  \	  NL  +  NR
                            //	   \	 +
                            //   ---*---+- - - -
                            //		   +
                            //		  next
                            //						if ( inTrNext.uL != trNewLeft ) {		// for robustness	TODO: prevent
                            inTrNext.usave = inTrNext.uL;
                            inTrNext.uleft = false;
                            // trNewRight: L/R undefined, will be extended down and changed anyway
                            // } else {
                            // ERROR: should not happen
                            // console.log( "ERR add_segment: Trapezoid Loop left", inTrNext, trCurrent, trNewLeft, trNewRight, inSegment, this );
                            //						}
                        }
                        //} else {
                        //	*** Case: 1B_1UN_CONT; next: CC_2UN
                        // console.log( "only_one_trap_below: simple case, new seg continues down" );
                        //			  +
                        //		NL	 +  NR
                        //			+
                        //   ------+-------
                        //	 	  +
                        //		next

                        // L/R for one side undefined, which one is not fixed
                        //	but that one will be extended down and changed anyway
                        // for the other side, vLow must lie at the opposite end
                        //	thus both are set accordingly
                    }
                    // setAbove
                    inTrNext.uL = trNewLeft;
                    inTrNext.uR = trNewRight;
                    // setBelow
                    trNewLeft.dR = trNewRight.dL = inTrNext;
                    trNewLeft.dL = trNewRight.dR = null;
                }
            }

            function two_trap_below() {
                // Find out which one (dL,dR) is intersected by this segment and
                //	continue down that one
                var trNext;
                if (trCurrent.vLow == trLast.vLow && meetsLowAdjSeg) {
                    // meetsLowAdjSeg necessary? TODO
                    //	*** Case: 2B_CON_END; next: ----
                    // console.log( "two_trap_below: finished, meets low adjacent segment" );
                    //			  +
                    //		NL	 +  NR
                    //			+
                    //   ------*-------
                    //	 		\  C.dR
                    //	  C.dL	 \

                    // setAbove
                    trCurrent.dL.uL = trNewLeft;
                    trCurrent.dR.uR = trNewRight;
                    // setBelow; sequence of assignments essential, just in case: trCurrent == trNewLeft
                    trNewLeft.dL = trCurrent.dL;
                    trNewRight.dR = trCurrent.dR;
                    trNewLeft.dR = trNewRight.dL = null;

                    trNext = null; // segment finished
                } else {
                    // setAbove part 1
                    trCurrent.dL.uL = trNewLeft;
                    trCurrent.dR.uR = trNewRight;

                    var goDownRight;
                    // passes left or right of an already inserted NOT connected segment
                    //	trCurrent.vLow: high-end of existing segment
                    var compRes = scope.is_left_of(
                        inSegment,
                        trCurrent.vLow,
                        true
                    );
                    if (compRes > 0) {
                        // trCurrent.vLow is left of inSegment
                        //	*** Case: 2B_NOCON_RIGHT; next: CC_2UN
                        // console.log( "two_trap_below: (intersecting dR)" );
                        //		 +
                        //	  NL  +  NR
                        //		   +
                        //   ---*---+- - - -
                        //		 \	 +
                        //	 C.dL \	C.dR
                        goDownRight = true;
                    } else if (compRes < 0) {
                        // trCurrent.vLow is right of inSegment
                        //	*** Case: 2B_NOCON_LEFT; next: CC_2UN
                        // console.log( "two_trap_below: (intersecting dL)" );
                        //			  +
                        //		NL	 +  NR
                        //			+
                        //    - - -+---*-------
                        //	 	  +		\  C.dR
                        //	 	 C.dL	 \
                        goDownRight = false;
                    } else {
                        // trCurrent.vLow lies ON inSegment
                        var vLowSeg = trCurrent.dL.rseg;
                        var directionIsUp = vLowSeg.upward;
                        var otherPt = directionIsUp
                            ? vLowSeg.vFrom
                            : vLowSeg.vTo;
                        compRes = scope.is_left_of(inSegment, otherPt, false);
                        if (compRes > 0) {
                            // otherPt is left of inSegment
                            //	*** Case: 2B_TOUCH_RIGHT; next: CC_2UN
                            // console.log( "two_trap_below: vLow ON new segment, touching from right" );
                            //		 +
                            //	  NL  +  NR
                            //		   +
                            //   -------*- - - -
                            //		   / +
                            //	 C.dL /	C.dR
                            goDownRight = true; // like intersecting dR
                        } else if (compRes < 0) {
                            // otherPt is right of inSegment
                            //	*** Case: 2B_TOUCH_LEFT; next: CC_2UN
                            // console.log( "two_trap_below: vLow ON new segment, touching from left" );
                            //			  +
                            //		NL	 +  NR
                            //			+
                            //    - - -*-------
                            //	 	  +	\  C.dR
                            //	  C.dL	 \
                            goDownRight = false; // like intersecting dL
                        } else {
                            // otherPt lies ON inSegment
                            vLowSeg = directionIsUp
                                ? vLowSeg.snext
                                : vLowSeg.sprev; // other segment with trCurrent.vLow
                            otherPt = directionIsUp
                                ? vLowSeg.vTo
                                : vLowSeg.vFrom;
                            compRes = scope.is_left_of(
                                inSegment,
                                otherPt,
                                false
                            );
                            if (compRes > 0) {
                                // otherPt is left of inSegment
                                //	*** Case: 2B_COLIN_RIGHT; next: CC_2UN
                                // console.log( "two_trap_below: vLow ON new segment, touching from right" );
                                //		  +
                                //	  NL   +  NR
                                //   -------*- - - -
                                //	  C.dL 	\+  C.dR
                                //			 \+
                                goDownRight = true; // like intersecting dR
                                //	} else if ( compRes == 0 ) {		//	NOT POSSIBLE, since 3 points on a line is prevented during input of polychains
                                //		goDownRight = true;		// like intersecting dR
                            } else {
                                // otherPt is right of inSegment
                                //	*** Case: 2B_COLIN_LEFT; next: CC_2UN
                                // console.log( "two_trap_below: vLow ON new segment, touching from left" );
                                //			   +
                                //		NL	  +  NR
                                //    - - - -*-------
                                //	  C.dL	+/  C.dR
                                //		   +/
                                goDownRight = false; // TODO: for test_add_segment_special_4 -> like intersecting dL
                            }
                        }
                    }
                    if (goDownRight) {
                        trNext = trCurrent.dR;
                        // setAbove part 2
                        trCurrent.dR.uL = trNewLeft;
                        // setBelow part 1
                        trNewLeft.dL = trCurrent.dL;
                        trNewRight.dR = null; // L/R undefined, will be extended down and changed anyway
                    } else {
                        trNext = trCurrent.dL;
                        // setAbove part 2
                        trCurrent.dL.uR = trNewRight;
                        // setBelow part 1
                        trNewRight.dR = trCurrent.dR;
                        trNewLeft.dL = null; // L/R undefined, will be extended down and changed anyway
                    }
                    // setBelow part 2
                    trNewLeft.dR = trNewRight.dL = trNext;
                }

                return trNext;
            }

            //
            //	main function body
            //

            /*		if ( ( inSegment.sprev.vTo != inSegment.vFrom ) || ( inSegment.vTo != inSegment.snext.vFrom ) ) {
			console.log( "add_segment: inconsistent point order of adjacent segments: ",
						 inSegment.sprev.vTo, inSegment.vFrom, inSegment.vTo, inSegment.snext.vFrom );
			return;
		}		*/

            //	Find the top-most and bottom-most intersecting trapezoids -> rootXXX
            this.segNodes(inSegment);

            var segLowVert, segLowNode, meetsLowAdjSeg; // y-min vertex
            var segHighVert, segHighNode, meetsHighAdjSeg; // y-max vertex

            if (inSegment.upward) {
                segLowVert = inSegment.vFrom;
                segHighVert = inSegment.vTo;
                segLowNode = inSegment.rootFrom;
                segHighNode = inSegment.rootTo;
                // was lower point already inserted earlier? => segments meet at their ends
                meetsLowAdjSeg = inSegment.sprev.is_inserted;
                // was higher point already inserted earlier? => segments meet at their ends
                meetsHighAdjSeg = inSegment.snext.is_inserted;
            } else {
                segLowVert = inSegment.vTo;
                segHighVert = inSegment.vFrom;
                segLowNode = inSegment.rootTo;
                segHighNode = inSegment.rootFrom;
                meetsLowAdjSeg = inSegment.snext.is_inserted;
                meetsHighAdjSeg = inSegment.sprev.is_inserted;
            }

            //	insert higher vertex into QueryStructure
            if (!meetsHighAdjSeg) {
                // higher vertex not yet inserted => split trapezoid horizontally
                var tmpNode = this.splitNodeAtPoint(
                    segHighNode,
                    segHighVert,
                    false
                );
                // move segLowNode to new (lower) trapezoid, if it was the one which was just split
                if (segHighNode == segLowNode) segLowNode = tmpNode;
                segHighNode = tmpNode;
            }
            var trFirst = segHighNode.trap; // top-most trapezoid for this segment

            // check for robustness		// TODO: prevent
            if (!trFirst.uL && !trFirst.uR) {
                console.log("ERR add_segment: missing trFirst.uX: ", trFirst);
                return;
            }
            if (trFirst.vHigh != segHighVert) {
                console.log(
                    "ERR add_segment: trFirstHigh != segHigh: ",
                    trFirst
                );
                return;
            }

            //	insert lower vertex into QueryStructure
            if (!meetsLowAdjSeg) {
                // lower vertex not yet inserted => split trapezoid horizontally
                segLowNode = this.splitNodeAtPoint(
                    segLowNode,
                    segLowVert,
                    true
                );
            }
            var trLast = segLowNode.trap; // bottom-most trapezoid for this segment

            //
            // Thread the segment into the query "tree" from top to bottom.
            // All the trapezoids which are intersected by inSegment are "split" into two.
            // For each the SINK-QsNode is converted into an X-Node and
            //  new sinks for the new partial trapezoids are added.
            // In fact a real split only happens at the top and/or bottom end of the segment
            //	since at every y-line seperating two trapezoids is traverses it
            //	cuts off the "beam" from the y-vertex on one side, so that at that side
            //	the trapezoid from above can be extended down.
            //

            var trCurrent = trFirst;

            var trNewLeft, trNewRight, trPrevLeft, trPrevRight;

            var counter = this.trapArray.length + 2; // just to prevent infinite loop
            var trNext;
            while (trCurrent) {
                if (--counter < 0) {
                    console.log(
                        "ERR add_segment: infinite loop",
                        trCurrent,
                        inSegment,
                        this
                    );
                    return;
                }
                if (!trCurrent.dL && !trCurrent.dR) {
                    // ERROR: no successors, cannot arise if data is correct
                    console.log(
                        "ERR add_segment: missing successors",
                        trCurrent,
                        inSegment,
                        this
                    );
                    return;
                }

                var qs_trCurrent = trCurrent.sink;
                // SINK-Node -> X-Node
                qs_trCurrent.seg = inSegment;
                qs_trCurrent.trap = null;
                //
                // successive trapezoids bordered by the same segments are merged
                //  by extending the trPrevRight or trPrevLeft down
                //  and redirecting the parent X-Node to the extended sink
                // !!! destroys tree structure since several nodes now point to the same SINK-Node !!!
                // TODO: maybe it's not a problem;
                //  merging of X-Nodes is no option, since they are used as "rootFrom/rootTo" !
                //
                if (trPrevRight && trPrevRight.rseg == trCurrent.rseg) {
                    // console.log( "add_segment: extending right predecessor down!", trPrevRight );
                    trNewLeft = trCurrent;
                    trNewRight = trPrevRight;
                    trNewRight.vLow = trCurrent.vLow;
                    // redirect parent X-Node to extended sink
                    qs_trCurrent.left = new PNLTRI.QsNode(trNewLeft); // trCurrent -> left SINK-Node
                    qs_trCurrent.right = trPrevRight.sink; // deforms tree by multiple links to trPrevRight.sink
                } else if (trPrevLeft && trPrevLeft.lseg == trCurrent.lseg) {
                    // console.log( "add_segment: extending left predecessor down!", trPrevLeft );
                    trNewRight = trCurrent;
                    trNewLeft = trPrevLeft;
                    trNewLeft.vLow = trCurrent.vLow;
                    // redirect parent X-Node to extended sink
                    qs_trCurrent.left = trPrevLeft.sink; // deforms tree by multiple links to trPrevLeft.sink
                    qs_trCurrent.right = new PNLTRI.QsNode(trNewRight); // trCurrent -> right SINK-Node
                } else {
                    trNewLeft = trCurrent;
                    trNewRight = this.cloneTrap(trCurrent);
                    qs_trCurrent.left = new PNLTRI.QsNode(trNewLeft); // trCurrent -> left SINK-Node
                    qs_trCurrent.right = new PNLTRI.QsNode(trNewRight); // new clone -> right SINK-Node
                }

                // handle neighbors above
                if (trCurrent.uL && trCurrent.uR) {
                    continue_chain_from_above();
                } else {
                    fresh_seg_or_upward_cusp();
                }

                // handle neighbors below
                if (trCurrent.dL && trCurrent.dR) {
                    trNext = two_trap_below();
                } else {
                    if (trCurrent.dL) {
                        // console.log( "add_segment: only_one_trap_below! (dL)" );
                        trNext = trCurrent.dL;
                    } else {
                        // console.log( "add_segment: only_one_trap_below! (dR)" );
                        trNext = trCurrent.dR;
                    }
                    only_one_trap_below(trNext);
                }

                if (trNewLeft.rseg) trNewLeft.rseg.trLeft = trNewRight;
                if (trNewRight.lseg) trNewRight.lseg.trRight = trNewLeft;
                trNewLeft.rseg = trNewRight.lseg = inSegment;
                inSegment.trLeft = trNewLeft;
                inSegment.trRight = trNewRight;

                // further loop-step down ?
                if (trCurrent.vLow != trLast.vLow) {
                    trPrevLeft = trNewLeft;
                    trPrevRight = trNewRight;

                    trCurrent = trNext;
                } else {
                    trCurrent = null;
                }
            } // end while

            inSegment.is_inserted = true;
            // console.log( "add_segment: ###### DONE ######" );
        },

        // Assigns a depth to all trapezoids;
        //	0: outside, 1: main polygon, 2: holes, 3:polygons in holes, ...
        // Checks segment orientation and marks those polygon chains for reversal
        //	where the polygon inside lies to their right (contour in CW, holes in CCW)
        assignDepths: function(inPolyData) {
            var thisDepth = [this.trapArray[0]];
            var nextDepth = [];

            var thisTrap,
                borderSeg,
                curDepth = 0;
            do {
                // rseg should exactely go upward on trapezoids inside the polygon (odd depth)
                var expectedRsegUpward = curDepth % 2 == 1;
                while ((thisTrap = thisDepth.pop())) {
                    // assignment !
                    if (thisTrap.depth != -1) continue;
                    thisTrap.depth = curDepth;
                    //
                    if (thisTrap.uL) thisDepth.push(thisTrap.uL);
                    if (thisTrap.uR) thisDepth.push(thisTrap.uR);
                    if (thisTrap.dL) thisDepth.push(thisTrap.dL);
                    if (thisTrap.dR) thisDepth.push(thisTrap.dR);
                    //
                    if (
                        (borderSeg = thisTrap.lseg) &&
                        borderSeg.trLeft.depth == -1
                    )
                        // assignment !
                        nextDepth.push(borderSeg.trLeft);
                    if ((borderSeg = thisTrap.rseg)) {
                        // assignment !
                        if (borderSeg.trRight.depth == -1)
                            nextDepth.push(borderSeg.trRight);
                        if (borderSeg.upward != expectedRsegUpward)
                            inPolyData.set_PolyLeft_wrong(borderSeg.chainId);
                    }
                }
                thisDepth = nextDepth;
                nextDepth = [];
                curDepth++;
            } while (thisDepth.length > 0);
        },

        // creates the visibility map:
        //	for each vertex the list of all vertices in CW order which are directly
        //	visible through neighboring trapezoids and thus can be connected by a diagonal

        create_visibility_map: function(inPolygonData) {
            // positional slots for neighboring trapezoid-diagonals
            var DIAG_UL = 0,
                DIAG_UM = 1,
                DIAG_ULR = 2,
                DIAG_UR = 3;
            var DIAG_DR = 4,
                DIAG_DM = 5,
                DIAG_DLR = 6,
                DIAG_DL = 7;

            var i, j;
            var nbVertices = inPolygonData.nbVertices();

            // initialize arrays for neighboring trapezoid-diagonals and vertices
            var myVisibleDiagonals = new Array(nbVertices);
            for (i = 0; i < nbVertices; i++) {
                myVisibleDiagonals[i] = new Array(DIAG_DL + 1);
            }
            // create the list of neighboring trapezoid-diagonals
            //	put into their positional slots
            var myExternalNeighbors = new Array(nbVertices);
            for (i = 0, j = this.trapArray.length; i < j; i++) {
                var curTrap = this.trapArray[i];
                var highPos = curTrap.uL
                    ? curTrap.uR
                        ? DIAG_DM
                        : DIAG_DL
                    : curTrap.uR
                        ? DIAG_DR
                        : DIAG_DLR;
                var lowPos = curTrap.dL
                    ? curTrap.dR
                        ? DIAG_UM
                        : DIAG_UL
                    : curTrap.dR
                        ? DIAG_UR
                        : DIAG_ULR;

                if (curTrap.depth % 2 == 1) {
                    // inside ?
                    if (
                        highPos == DIAG_DM ||
                        lowPos == DIAG_UM ||
                        (highPos == DIAG_DL && lowPos == DIAG_UR) ||
                        (highPos == DIAG_DR && lowPos == DIAG_UL)
                    ) {
                        var lhDiag = inPolygonData.appendDiagonalsEntry({
                            vFrom: curTrap.vLow,
                            vTo: curTrap.vHigh,
                            mprev: null,
                            mnext: null,
                            marked: false
                        });
                        var hlDiag = inPolygonData.appendDiagonalsEntry({
                            vFrom: curTrap.vHigh,
                            vTo: curTrap.vLow,
                            revDiag: lhDiag,
                            mprev: null,
                            mnext: null,
                            marked: false
                        });
                        lhDiag.revDiag = hlDiag;
                        myVisibleDiagonals[curTrap.vLow.id][lowPos] = lhDiag;
                        myVisibleDiagonals[curTrap.vHigh.id][highPos] = hlDiag;
                    }
                } else {
                    // outside, hole
                    if (curTrap.vHigh.id !== null)
                        myExternalNeighbors[curTrap.vHigh.id] = highPos;
                    if (curTrap.vLow.id !== null)
                        myExternalNeighbors[curTrap.vLow.id] = lowPos;
                }
            }
            // create the list of outgoing diagonals in the right order (CW)
            //	from the ordered list of neighboring trapezoid-diagonals
            //	- starting from an external one
            // and connect those incoming to
            var curDiag, curDiags, firstElem, fromVertex, lastIncoming;
            for (i = 0; i < nbVertices; i++) {
                curDiags = myVisibleDiagonals[i];
                firstElem = myExternalNeighbors[i];
                if (firstElem == null) continue; // eg. skipped vertices (zero length, co-linear		// NOT: === !
                j = firstElem;
                lastIncoming = null;
                do {
                    if (j++ > DIAG_DL) j = DIAG_UL; // circular positional list
                    if ((curDiag = curDiags[j])) {
                        if (lastIncoming) {
                            curDiag.mprev = lastIncoming;
                            lastIncoming.mnext = curDiag;
                        } else {
                            fromVertex = curDiag.vFrom;
                            fromVertex.firstOutDiag = curDiag;
                        }
                        lastIncoming = curDiag.revDiag;
                    }
                } while (j != firstElem);
                if (lastIncoming) fromVertex.lastInDiag = lastIncoming;
            }
        }
    };

    /*==============================================================================
 *
 *============================================================================*/

    PNLTRI.Trapezoider = function(inPolygonData) {
        this.polyData = inPolygonData;
        this.queryStructure = new PNLTRI.QueryStructure(this.polyData);
    };

    PNLTRI.Trapezoider.prototype = {
        constructor: PNLTRI.Trapezoider,

        /*
	 * Mathematics helper methods
	 */

        optimise_randomlist: function(inOutSegListArray) {
            // makes sure that the first N segments are one from each of the N polygon chains
            var mainIdx = 0;
            var helpIdx = this.polyData.nbPolyChains();
            if (helpIdx == 1) return;
            var chainMarker = new Array(helpIdx);
            var oldSegListArray = inOutSegListArray.concat();
            for (var i = 0; i < oldSegListArray.length; i++) {
                var chainId = oldSegListArray[i].chainId;
                if (chainMarker[chainId]) {
                    inOutSegListArray[helpIdx++] = oldSegListArray[i];
                } else {
                    inOutSegListArray[mainIdx++] = oldSegListArray[i];
                    chainMarker[chainId] = true;
                }
            }
        },

        /*
	 * main methods
	 */

        // Creates the trapezoidation of the polygon
        //  and assigns a depth to all trapezoids (odd: inside, even: outside).

        trapezoide_polygon: function() {
            // <<<< public
            var randSegListArray = this.polyData.getSegments().concat();
            //		console.log( "Polygon Chains: ", dumpSegmentList( randSegListArray ) );
            PNLTRI.Math.array_shuffle(randSegListArray);
            this.optimise_randomlist(randSegListArray);
            //		console.log( "Random Segment Sequence: ", dumpRandomSequence( randSegListArray ) );

            var nbSegs = randSegListArray.length;
            var myQs = this.queryStructure;

            var i,
                current = 0,
                logstar = nbSegs;
            while (current < nbSegs) {
                // The CENTRAL mechanism for the near-linear performance:
                //	stratefies the loop through all segments into log* parts
                //	and computes new root-Nodes for the remaining segments in each
                //	partition.
                logstar = Math.log(logstar) / Math.LN2; // == log2(logstar)
                var partEnd =
                    logstar > 1 ? Math.floor(nbSegs / logstar) : nbSegs;

                // Core: adds next partition of the segments
                for (; current < partEnd; current++) {
                    myQs.add_segment(randSegListArray[current]);
                }
                //			console.log( nbSegs, current );

                // To speed up the segment insertion into the trapezoidation
                //	the endponts of those segments not yet inserted
                //	are repeatedly pre-located,
                // thus their final location-query can start at the top of the
                //	appropriate sub-tree instead of the root of the whole
                //	query structure.
                //
                for (i = current; i < nbSegs; i++) {
                    this.queryStructure.segNodes(randSegListArray[i]);
                }
            }

            myQs.assignDepths(this.polyData);
            // cleanup to support garbage collection
            for (i = 0; i < nbSegs; i++) {
                randSegListArray[i].trLeft = randSegListArray[i].trRight = null;
            }
        },

        // Creates a visibility map:
        //	for each vertex the list of all vertices in CW order which are directly
        //	visible through neighboring trapezoids and thus can be connected by a diagonal

        create_visibility_map: function() {
            return this.queryStructure.create_visibility_map(this.polyData);
        }
    };

    /**
     * @author jahting / http://www.ameco.tv/
     *
     *	Algorithm to split a polygon into uni-y-monotone sub-polygons
     *
     *	1) creates a trapezoidation of the main polygon according to Seidel's
     *	   algorithm [Sei91]
     *	2) uses diagonals of the trapezoids as additional segments
     *		to split the main polygon into uni-y-monotone sub-polygons
     */

    PNLTRI.MonoSplitter = function(inPolygonData) {
        this.polyData = inPolygonData;

        this.trapezoider = null;
    };

    PNLTRI.MonoSplitter.prototype = {
        constructor: PNLTRI.MonoSplitter,

        monotonate_trapezoids: function() {
            // <<<<<<<<<< public
            // Trapezoidation
            this.trapezoider = new PNLTRI.Trapezoider(this.polyData);
            //	=> one triangular trapezoid which lies inside the polygon
            this.trapezoider.trapezoide_polygon();

            // create segments for diagonals
            this.trapezoider.create_visibility_map();
            // create mono chains by inserting diagonals
            this.polyData.create_mono_chains();

            // create UNIQUE monotone sub-polygons
            this.polyData.unique_monotone_chains_max();
        }
    };

    /**
     * @author jahting / http://www.ameco.tv/
     *
     *	Algorithm to triangulate uni-y-monotone polygons [FoM84]
     *
     *	expects list of doubly linked monoChains, with Y-max as first vertex
     */

    PNLTRI.MonoTriangulator = function(inPolygonData) {
        this.polyData = inPolygonData;
    };

    PNLTRI.MonoTriangulator.prototype = {
        constructor: PNLTRI.MonoTriangulator,

        // Pass each uni-y-monotone polygon with start at Y-max for greedy triangulation.

        triangulate_all_polygons: function() {
            // <<<<<<<<<< public
            var normedMonoChains = this.polyData.getMonoSubPolys();
            this.polyData.clearTriangles();
            for (var i = 0; i < normedMonoChains.length; i++) {
                // loop through uni-y-monotone chains
                // => monoPosmin is next to monoPosmax (left or right)
                var monoPosmax = normedMonoChains[i];
                var prevMono = monoPosmax.mprev;
                var nextMono = monoPosmax.mnext;

                if (nextMono.mnext == prevMono) {
                    // already a triangle
                    this.polyData.addTriangle(
                        monoPosmax.vFrom,
                        nextMono.vFrom,
                        prevMono.vFrom
                    );
                } else {
                    // triangulate the polygon
                    this.triangulate_monotone_polygon(monoPosmax);
                }
            }
        },

        //	algorithm to triangulate an uni-y-monotone polygon in O(n) time.[FoM84]

        triangulate_monotone_polygon: function(monoPosmax) {
            // private
            var scope = this;

            function error_cleanup() {
                // Error in algorithm OR polygon is not uni-y-monotone
                console.log(
                    "ERR uni-y-monotone: only concave angles left",
                    vertBackLog
                );
                // push all "wrong" triangles => loop ends
                while (vertBackLogIdx > 1) {
                    vertBackLogIdx--;
                    scope.polyData.addTriangle(
                        vertBackLog[vertBackLogIdx - 1],
                        vertBackLog[vertBackLogIdx],
                        vertBackLog[vertBackLogIdx + 1]
                    );
                }
            }

            //
            // Decisive for this algorithm to work correctly is to make sure
            //  the polygon stays uni-y-monotone when cutting off ears, i.e.
            //  to make sure the top-most and bottom-most vertices are removed last
            // Usually this is done by handling the LHS-case ("LeftHandSide is a single segment")
            //	and the RHS-case ("RightHandSide segment is a single segment")
            //	differently by starting at the bottom for LHS and at the top for RHS.
            // This is not necessary. It can be seen easily, that starting
            //	from the vertex next to top handles both cases correctly.
            //

            var frontMono = monoPosmax.mnext; // == LHS: YminPoint; RHS: YmaxPoint.mnext
            var endVert = monoPosmax.vFrom;

            var vertBackLog = [frontMono.vFrom];
            var vertBackLogIdx = 0;

            frontMono = frontMono.mnext;
            var frontVert = frontMono.vFrom;

            // check for robustness		// TODO
            if (frontVert == endVert) return; // Error: only 2 vertices

            while (frontVert != endVert || vertBackLogIdx > 1) {
                if (vertBackLogIdx > 0) {
                    // vertBackLog is not empty
                    var insideAngleCCW = PNLTRI.Math.ptsCrossProd(
                        vertBackLog[vertBackLogIdx],
                        frontVert,
                        vertBackLog[vertBackLogIdx - 1]
                    );
                    if (Math.abs(insideAngleCCW) <= PNLTRI.Math.EPSILON_P) {
                        // co-linear
                        if (
                            frontVert == endVert || // all remaining triangles are co-linear (180 degree)
                            PNLTRI.Math.compare_pts_yx(
                                vertBackLog[vertBackLogIdx],
                                frontVert
                            ) == // co-linear-reversal
                                PNLTRI.Math.compare_pts_yx(
                                    vertBackLog[vertBackLogIdx],
                                    vertBackLog[vertBackLogIdx - 1]
                                )
                        ) {
                            insideAngleCCW = 1; // => create triangle
                        }
                    }
                    if (insideAngleCCW > 0) {
                        // convex corner: cut if off
                        this.polyData.addTriangle(
                            vertBackLog[vertBackLogIdx - 1],
                            vertBackLog[vertBackLogIdx],
                            frontVert
                        );
                        vertBackLogIdx--;
                    } else {
                        // non-convex: add frontVert to the vertBackLog
                        vertBackLog[++vertBackLogIdx] = frontVert;
                        if (frontVert == endVert) error_cleanup();
                        // should never happen !!
                        else {
                            frontMono = frontMono.mnext;
                            frontVert = frontMono.vFrom;
                        }
                    }
                } else {
                    // vertBackLog contains only start vertex:
                    //	add frontVert to the vertBackLog and advance frontVert
                    vertBackLog[++vertBackLogIdx] = frontVert;
                    frontMono = frontMono.mnext;
                    frontVert = frontMono.vFrom;
                }
            }
            // reached the last vertex. Add in the triangle formed
            this.polyData.addTriangle(
                vertBackLog[vertBackLogIdx - 1],
                vertBackLog[vertBackLogIdx],
                frontVert
            );
        }
    };

    /**
     * @author jahting / http://www.ameco.tv/
     */

    /*******************************************************************************
     *
     *	Triangulator for Simple Polygons with Holes
     *
     *  polygon with holes:
     *	- one closed contour polygon chain
     *  - zero or more closed hole polygon chains
     *
     *	polygon chain (closed):
     *	- Array of vertex Objects with attributes "x" and "y"
     *		- representing the sequence of line segments
     *		- closing line segment (last->first vertex) is implied
     *		- line segments are non-zero length and non-crossing
     *
     *	"global vertex index":
     *	- vertex number resulting from concatenation all polygon chains (starts with 0)
     *
     *
     *	Parameters (will not be changed):
     *		inPolygonChains:
     *		- Array of polygon chains
     *
     *	Results (are a fresh copy):
     *		triangulate_polygon:
     *		- Array of Triangles ( Array of 3 "global vertex index" values )
     *
     ******************************************************************************/

    PNLTRI.Triangulator = function() {
        this.lastPolyData = null; // for Debug purposes only
    };

    PNLTRI.Triangulator.prototype = {
        constructor: PNLTRI.Triangulator,

        clear_lastData: function() {
            // save memory after Debug
            this.lastPolyData = null;
        },

        // for the polygon data AFTER triangulation
        //	returns an Array of flags, one flag for each polygon chain:
        //		lies the inside of the polygon to the left?
        //		"true" implies CCW for contours and CW for holes
        get_PolyLeftArr: function() {
            if (this.lastPolyData) return this.lastPolyData.get_PolyLeftArr();
            return null;
        },

        triangulate_polygon: function(inPolygonChains, inForceTrapezoidation) {
            // collected conditions for selecting EarClipTriangulator over Seidel's algorithm
            function is_basic_polygon() {
                if (inForceTrapezoidation) return false;
                return myPolygonData.nbPolyChains() == 1;
            }

            this.clear_lastData();
            if (!inPolygonChains || inPolygonChains.length === 0) return [];
            //
            // initializes general polygon data structure
            //
            var myPolygonData = new PNLTRI.PolygonData(inPolygonChains);
            //
            var basicPolygon = is_basic_polygon();
            var myTriangulator;
            if (basicPolygon) {
                //
                // triangulates single polygon without holes
                //
                myTriangulator = new PNLTRI.EarClipTriangulator(myPolygonData);
                basicPolygon = myTriangulator.triangulate_polygon_no_holes();
            }
            if (!basicPolygon) {
                //
                // splits polygon into uni-y-monotone sub-polygons
                //
                var myMonoSplitter = new PNLTRI.MonoSplitter(myPolygonData);
                myMonoSplitter.monotonate_trapezoids();
                //
                // triangulates all uni-y-monotone sub-polygons
                //
                myTriangulator = new PNLTRI.MonoTriangulator(myPolygonData);
                myTriangulator.triangulate_all_polygons();
            }
            //
            this.lastPolyData = myPolygonData;
            return myPolygonData.getTriangles(); // copy of triangle list
        }
    };

    return PNLTRI;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/PolygonRenderer',[
    "../Utils/Constants",
    "../Utils/Utils",
    "./VectorRenderer",
    "./RendererManager",
    "./FeatureStyle",
    "./Program",
    "./BatchRenderable",
    "./pnltri",
    "./GeoBound"
], function(
    Constants,
    Utils,
    VectorRenderer,
    RendererManager,
    FeatureStyle,
    Program,
    BatchRenderable,
    PNLTRI,
    GeoBound
) {
    /**************************************************************************************************************/
    /**
         @name PolygonRenderer
         @class
             Basic renderer for polygon
         @param {AbstractGlobe} globe AbstractGlobe
         @augments VectorRenderer
         @constructor
         */
    var PolygonRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);
        this.maxTilePerGeometry = 2;
        this.renderContext = globe.renderContext;
        this.defaultVertexShader = "attribute vec3 vertex;\n";
        this.defaultVertexShader += "uniform mat4 mvp;\n";
        this.defaultVertexShader += "void main(void) \n";
        this.defaultVertexShader += "{\n";
        this.defaultVertexShader += "	gl_Position = mvp * vec4(vertex, 1.0);\n";
        this.defaultVertexShader += "}\n";

        this.extrudeVertexShader = "attribute vec3 vertex;\n";
        this.extrudeVertexShader += "attribute vec4 normal;\n";
        this.extrudeVertexShader += "uniform float extrusionScale; \n";
        this.extrudeVertexShader += "uniform mat4 mvp;\n";
        this.extrudeVertexShader += "void main(void) \n";
        this.extrudeVertexShader += "{\n";
        this.extrudeVertexShader +=
            "	vec3 extrudedVertex = vertex + normal.w * vec3(normal.x, normal.y, normal.z) * extrusionScale;";
        this.extrudeVertexShader +=
            "	gl_Position = mvp * vec4(extrudedVertex, 1.0);\n";
        this.extrudeVertexShader += "}\n";

        this.fragmentShader = "precision lowp float; \n";
        this.fragmentShader += "uniform vec4 u_color;\n";
        this.fragmentShader += "void main(void)\n";
        this.fragmentShader += "{\n";
        this.fragmentShader += "	gl_FragColor = u_color;\n";
        this.fragmentShader += "	//if (u_color.a == 0.0) discard;\n";
        this.fragmentShader += "}\n";

        this.program = new Program(globe.renderContext);
        this.program.createFromSource(
            this.defaultVertexShader,
            this.fragmentShader
        );

        this.extrudeProgram = new Program(globe.renderContext);
        this.extrudeProgram.createFromSource(
            this.extrudeVertexShader,
            this.fragmentShader
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(VectorRenderer, PolygonRenderer);

    /**************************************************************************************************************/

    /**
         @name PolygonRenderable
         @class
             Renderable constructor for Polygon
         @param {Bucket} bucket Bucket
         @augments BatchRenderable
         @constructor
         */
    var PolygonRenderable = function(bucket) {
        BatchRenderable.prototype.constructor.call(this, bucket);

        this.origin = null;

        this.vertexSize = bucket.style.extrude ? 7 : 3;
        this.matrix = mat4.create();
    };

    Utils.inherits(BatchRenderable, PolygonRenderable);

    /**************************************************************************************************************/

    /**
     * Create an interpolated for polygon clipping
     */
    var _createInterpolatedVertex = function(t, p1, p2) {
        return [p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1])];
    };

    /**************************************************************************************************************/

    /**
         Clip polygon to a side
         */
    var clipPolygonToSide = function(coord, sign, value, polygon) {
        var clippedPolygon = [];
        var t, newPoint;
        // iterate through vertices
        for (var i = 0; i < polygon.length; i++) {
            var p1 = polygon[i];
            var p2 = polygon[(i + 1) % polygon.length];
            var val1 = p1[coord];
            var val2 = p2[coord];

            // test containement
            var firstInside = (val1 - value) * sign >= 0.0;
            var secondInside = (val2 - value) * sign >= 0.0;

            // output vertices for inside polygon
            if (!firstInside && secondInside) {
                t = (value - val1) / (val2 - val1);
                newPoint = _createInterpolatedVertex(t, p1, p2);
                clippedPolygon.push(newPoint);
                clippedPolygon.push(p2);
            } else if (firstInside && secondInside) {
                clippedPolygon.push(p2);
            } else if (firstInside && !secondInside) {
                t = (value - val1) / (val2 - val1);
                newPoint = _createInterpolatedVertex(t, p1, p2);
                clippedPolygon.push(newPoint);
            }
        }

        return clippedPolygon;
    };

    /**************************************************************************************************************/

    /**
         Clip polygon
         */
    var clipPolygon = function(coordinates, bound) {
        var c;
        c = clipPolygonToSide(0, 1, bound.west, coordinates);
        c = clipPolygonToSide(0, -1, bound.east, c);
        c = clipPolygonToSide(1, 1, bound.south, c);
        c = clipPolygonToSide(1, -1, bound.north, c);
        return c;
    };

    /**************************************************************************************************************/

    /**
         Check if a geometry crosses the date line
         */
    var _fixDateLine = function(coords) {
        //return [coords];
        var crossDateLine = false;
        for (var i = 1; i < coords.length && !crossDateLine; i++) {
            var deltaLon = Math.abs(coords[i][0] - coords[i - 1][0]);
            if (deltaLon > 180 && deltaLon < 360) {
                // DateLine!
                crossDateLine = true;
            }
        }
        var n;
        if (crossDateLine) {
            // Ensure coordinates are always negative
            var negCoords = [];
            for (n = 0; n < coords.length; n++) {
                if (coords[n][0] > 0) {
                    negCoords[n] = [coords[n][0] - 360, coords[n][1]];
                } else {
                    negCoords[n] = [coords[n][0], coords[n][1]];
                }
            }

            var posCoords = [];
            // Ensure coordinates are always positive
            for (n = 0; n < coords.length; n++) {
                if (coords[n][0] < 0) {
                    posCoords[n] = [coords[n][0] + 360, coords[n][1]];
                } else {
                    posCoords[n] = [coords[n][0], coords[n][1]];
                }
            }

            return [posCoords, negCoords];
        } else {
            return [coords];
        }
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to the renderbale
     * Vertex buffer : geometry|extrude
     * Index buffer : geometry triangles|extrude triangles|lines
     * Normal buffer : normals.xyz, extrude value as w
     * @function build
     * @memberof PolygonRenderable.prototype
     * @param geometry
     */
    PolygonRenderable.prototype.build = function(geometry) {
        var renderer = this.bucket.renderer;
        var style = this.bucket.style;
        var coordinateSystem = renderer.globe.getCoordinateSystem();

        var polygons =
            geometry.type === Constants.GEOMETRY.MultiPolygon
                ? geometry.coordinates
                : [geometry.coordinates];

        var geometryBound = new GeoBound();
        var csBound = new GeoBound(
            coordinateSystem.getGeoBound().getWest(),
            coordinateSystem.getGeoBound().getSouth(),
            coordinateSystem.getGeoBound().getEast(),
            coordinateSystem.getGeoBound().getNorth()
        );
        var crsName = "CRS:84";
        if (typeof geometry.crs !== "undefined") {
            crsName = geometry.crs.properties.name;
        }
        var convertedCoord = geometryBound.computeFromCoordinatesInCrsTo(
            polygons[0][0],
            crsName,
            coordinateSystem
        );
        if (!geometryBound.intersects(csBound)) {
            return;
        }

        var pos3d = vec3.create();
        var i, n;
        if (!this.origin) {
            this.origin = vec3.create();
            coordinateSystem.get3DFromWorld(convertedCoord[0], this.origin); // Correction : add [0]

            mat4.identity(this.matrix);
            mat4.translate(this.matrix, this.origin);
        }

        var lastIndex = this.vertices.length / this.vertexSize;
        var offset = this.vertices.length;
        var upOffset, lowOffset;

        var contours = [];
        for (n = 0; n < polygons.length; n++) {
            contours = contours.concat(_fixDateLine(polygons[n][0]));
        }

        for (n = 0; n < contours.length; n++) {
            var coords = clipPolygon(contours[n], csBound);

            offset = this.vertices.length;

            // Build upper polygon vertices
            var clockwise = 0;
            for (i = 0; i < coords.length; i++) {
                // Always use coordinates at zero height on vertex construction, height will be taken into account on extrude
                coordinateSystem.get3DFromWorldInCrs(
                    [coords[i][0], coords[i][1], 0.0],
                    crsName,
                    pos3d
                );
                this.vertices[offset] = pos3d[0] - this.origin[0];
                this.vertices[offset + 1] = pos3d[1] - this.origin[1];
                this.vertices[offset + 2] = pos3d[2] - this.origin[2];

                // Find out if its vertices ordered clockwise to build index buffer properly
                if (i < coords.length - 1) {
                    clockwise +=
                        (coords[i + 1][0] - coords[i][0]) *
                        (coords[i + 1][1] + coords[i][1]);
                }

                if (style.extrude) {
                    // Compute normals
                    vec3.normalize(pos3d);
                    this.vertices[offset + 3] = pos3d[0];
                    this.vertices[offset + 4] = pos3d[1];
                    this.vertices[offset + 5] = pos3d[2];
                    var extrudeValue;
                    if (typeof style.extrude === "boolean") {
                        // Extrude value extracted from KML, use the height coordinate
                        extrudeValue = coords[i][2];
                    } else {
                        // Extrude value is a float defined by user
                        extrudeValue = style.extrude;
                    }
                    this.vertices[offset + 6] =
                        extrudeValue * coordinateSystem.geoide.heightScale;
                }

                offset += this.vertexSize;
            }

            // Build bottom polygon vertices on extrude
            if (style.extrude) {
                // Use same vertices as upper polygon but resest the 4-th compoenent
                var prevOffset = lastIndex * this.vertexSize;
                this.vertices = this.vertices.concat(
                    this.vertices.slice(prevOffset, offset)
                );
                // Reset the 4-th component for extrusion
                for (
                    i = offset;
                    i < this.vertices.length;
                    i += this.vertexSize
                ) {
                    this.vertices[i + 6] = 0.0;
                }
            }

            // Build triangle indices for upper polygon
            var triangulator = new PNLTRI.Triangulator();
            var contour = coords.map(function(value) {
                return { x: value[0], y: value[1] };
            });
            var triangList = triangulator.triangulate_polygon([contour]);
            for (i = 0; i < triangList.length; i++) {
                this.triIndices.push(
                    lastIndex + triangList[i][0],
                    lastIndex + triangList[i][1],
                    lastIndex + triangList[i][2]
                );
                //this.lineIndices.push( lastIndex + triangList[i][0], lastIndex + triangList[i][1], lastIndex + triangList[i][1], lastIndex + triangList[i][2], lastIndex + triangList[i][2], lastIndex + triangList[i][0] );
            }

            // Build side triangle indices
            if (style.extrude) {
                upOffset = lastIndex;
                lowOffset = lastIndex + coords.length;

                for (i = 0; i < coords.length - 1; i++) {
                    // Depending on vertice order, push the
                    if (clockwise > 0) {
                        this.triIndices.push(upOffset, upOffset + 1, lowOffset);
                        this.triIndices.push(
                            upOffset + 1,
                            lowOffset + 1,
                            lowOffset
                        );
                    } else {
                        this.triIndices.push(upOffset, lowOffset, upOffset + 1);
                        this.triIndices.push(
                            upOffset + 1,
                            lowOffset,
                            lowOffset + 1
                        );
                    }
                    upOffset += 1;
                    lowOffset += 1;
                }
            }

            // Build line indices for upper polygon
            for (i = 0; i < coords.length - 1; i++) {
                this.lineIndices.push(lastIndex + i, lastIndex + i + 1);
            }

            // Build top-to-bottom line indices
            if (style.extrude) {
                upOffset = lastIndex;
                lowOffset = lastIndex + coords.length;
                for (i = 0; i < coords.length - 1; i++) {
                    this.lineIndices.push(upOffset + i, lowOffset + i);
                }
            }

            // Update last index
            lastIndex = this.vertices.length / this.vertexSize;
        }
        // Geometry is always added contrary to tiled renderables
        return true;
    };

    /**************************************************************************************************************/

    /**
         @name PolygonBucket
         @class
             Bucket constructor for PolygonRenderer
         @param layer
         @param style
         @constructor
         */
    var PolygonBucket = function(layer, style) {
        this.layer = layer;
        this.style = style;
        this.renderer = null;
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof PolygonBucket.prototype
     * @return {PolygonRenderable} Renderable
     */
    PolygonBucket.prototype.createRenderable = function() {
        return new PolygonRenderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Check if a bucket is compatible
     * @function isCompatible
     * @memberof PolygonBucket.prototype
     * @param style
     * @return {Boolean} Is compatible ?
     */
    PolygonBucket.prototype.isCompatible = function(style) {
        return this.style === style;
    };

    /**************************************************************************************************************/

    /**
     *    Render all the polygons
     * @function render
     * @memberof PolygonRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    PolygonRenderer.prototype.render = function(renderables, start, end) {
        var renderContext = this.globe.renderContext;
        var gl = renderContext.gl;

        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        //gl.enable(gl.POLYGON_OFFSET_FILL);
        //gl.polygonOffset(-2.0,-2.0);
        //gl.disable(gl.DEPTH_TEST);

        var currentProgram = null;

        // Compute the viewProj matrix
        var viewProjMatrix = mat4.create();
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            viewProjMatrix
        );

        var modelViewProjMatrix = mat4.create();
        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            var style = renderable.bucket.style;

            // Setup program
            var program = style.extrude ? this.extrudeProgram : this.program;
            if (program !== currentProgram) {
                program.apply();
                currentProgram = program;
            }

            mat4.multiply(
                viewProjMatrix,
                renderable.matrix,
                modelViewProjMatrix
            );
            gl.uniformMatrix4fv(
                program.uniforms.mvp,
                false,
                modelViewProjMatrix
            );
            gl.uniform4f(
                program.uniforms.u_color,
                style.fillColor[0],
                style.fillColor[1],
                style.fillColor[2],
                style.fillColor[3] * renderable.bucket.layer.getOpacity()
            ); // use fillColor

            renderable.bindBuffers(renderContext);
            gl.lineWidth(style.strokeWidth);

            // Setup attributes
            gl.vertexAttribPointer(
                program.attributes.vertex,
                3,
                gl.FLOAT,
                false,
                4 * renderable.vertexSize,
                0
            );
            if (style.extrude) {
                gl.vertexAttribPointer(
                    program.attributes.normal,
                    4,
                    gl.FLOAT,
                    false,
                    4 * renderable.vertexSize,
                    12
                );
                gl.uniform1f(
                    program.uniforms.extrusionScale,
                    style.extrusionScale
                );
            }

            // Draw
            gl.drawElements(
                gl.TRIANGLES,
                renderable.triIndices.length,
                renderable.indexType,
                0
            );
            if (renderable.lineIndices.length > 0) {
                gl.uniform4f(
                    program.uniforms.u_color,
                    style.strokeColor[0],
                    style.strokeColor[1],
                    style.strokeColor[2],
                    style.strokeColor[3] * renderable.bucket.layer.getOpacity()
                );
                var size = renderable.indexType === gl.UNSIGNED_INT ? 4 : 2;
                gl.drawElements(
                    gl.LINES,
                    renderable.lineIndices.length,
                    renderable.indexType,
                    renderable.triIndices.length * size
                );
            }
        }

        // Revert line width
        gl.lineWidth(1.0);

        //gl.enable(gl.DEPTH_TEST);
        //gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.depthFunc(gl.LESS);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof PolygonRenderer.prototype
     * @param type
     * @param style
     * @return {Boolean} Can apply ?
     */
    PolygonRenderer.prototype.canApply = function(type, style) {
        return (
            (type === Constants.GEOMETRY.Polygon ||
                type === Constants.GEOMETRY.MultiPolygon) &&
            style.fill
        );
    };

    /**************************************************************************************************************/

    /**
     * Create a bucket
     * @function createBucket
     * @memberof PolygonRenderer.prototype
     * @param layer
     * @param style
     * @return {PolygonBucket} Bucket
     */
    PolygonRenderer.prototype.createBucket = function(layer, style) {
        return new PolygonBucket(layer, style);
    };

    /**************************************************************************************************************/

    // Register the renderer
    RendererManager.factory.push(function(globe) {
        return new PolygonRenderer(globe);
    });
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/LineRenderer',[
    "../Utils/Constants",
    "../Utils/Utils",
    "../Utils/Numeric",
    "./VectorRenderer",
    "./RendererManager",
    "./Program",
    "./BatchRenderable"
], function(
    Constants,
    Utils,
    Numeric,
    VectorRenderer,
    RendererManager,
    Program,
    BatchRenderable
) {
    /**************************************************************************************************************/

    /**
 	@name LineRenderer
 	@class
 	 Basic renderer to animate lines with gradient color texture
 	@param {AbstractGlobe} globe AbstractGlobe
 	@constructor
 	*/
    var LineRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);
        this.maxTilePerGeometry = 2;
        this.renderContext = globe.getRenderContext();

        this.defaultVertexShader = "attribute vec4 vertex;\n";
        this.defaultVertexShader += "uniform mat4 mvp;\n";
        this.defaultVertexShader += "varying float s;\n";
        this.defaultVertexShader += "void main(void) \n";
        this.defaultVertexShader += "{\n";
        this.defaultVertexShader += "	s = vertex.w;\n";
        this.defaultVertexShader +=
            "	gl_Position = mvp * vec4(vertex.xyz, 1.0);\n";
        this.defaultVertexShader += "}\n";

        this.fragmentShader = "precision lowp float; \n";
        this.fragmentShader += "uniform vec4 u_color;\n";
        this.fragmentShader += "uniform float speed;\n";
        this.fragmentShader += "uniform float time;\n";
        this.fragmentShader += "uniform float gradientLength;\n";
        this.fragmentShader += "varying float s;\n";
        this.fragmentShader += "uniform sampler2D colorTexture;\n";
        this.fragmentShader += "void main(void)\n";
        this.fragmentShader += "{\n";
        this.fragmentShader +=
            "	// 0.5 is a time scale parameter, parametrize it ?\n";
        this.fragmentShader += "	float m = speed * time * 0.5;\n";
        this.fragmentShader += "	float u = (-s+m)/gradientLength;\n";
        this.fragmentShader +=
            "	gl_FragColor.rgb = texture2D(colorTexture, vec2(u,0.)).rgb;\n";
        this.fragmentShader += "	// TODO: handle appereance of rivers\n";
        this.fragmentShader += "	if ( s < m )\n";
        this.fragmentShader += "	{\n";
        this.fragmentShader += "		gl_FragColor.a = 1.0;\n";
        this.fragmentShader += "	}\n";
        this.fragmentShader += "	else\n";
        this.fragmentShader += "	{\n";
        this.fragmentShader += "		gl_FragColor.a = 0.0;\n";
        this.fragmentShader += "	}\n";
        this.fragmentShader += "}\n";

        this.program = new Program(globe.renderContext);
        this.program.createFromSource(
            this.defaultVertexShader,
            this.fragmentShader
        );

        this.time = Date.now() / 1000; // Store it in seconds
        this.palette = null; // Palette is an array containing two colors(start/end and the middle one)
        this.colorTexture = this.generateTexture([
            [0.0, 0.0, 255.0],
            [0.0, 200.0, 255.0]
        ]);
    };

    /**************************************************************************************************************/

    Utils.inherits(VectorRenderer, LineRenderer);

    /**************************************************************************************************************/

    /**
     * Generate color texture from palette
     * The generated gradient is of type : start color -> middle color -> start color
     * @function generateTexture
     * @memberof LineRenderer.prototype
     * @param palette
     */
    LineRenderer.prototype.generateTexture = function(palette) {
        var startColor = palette[0];
        var middleColor = palette[1];
        var i, r, g, b;
        var pixels = [];
        var gl = this.globe.renderContext.gl;
        this.colorTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.colorTexture);

        for (i = 0; i < 128; i++) {
            r = Numeric.coserp(i / 128, startColor[0], middleColor[0]);
            g = Numeric.coserp(i / 128, startColor[1], middleColor[1]);
            b = Numeric.coserp(i / 128, startColor[2], middleColor[2]);
            pixels.push(r);
            pixels.push(g);
            pixels.push(b);
            pixels.push(255);
        }
        for (i = 0; i < 128; i++) {
            r = Numeric.coserp(i / 128, middleColor[0], startColor[0]);
            g = Numeric.coserp(i / 128, middleColor[1], startColor[1]);
            b = Numeric.coserp(i / 128, middleColor[2], startColor[2]);
            pixels.push(r);
            pixels.push(g);
            pixels.push(b);
            pixels.push(255);
        }
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            pixels.length / 4,
            1,
            0,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            new Uint8Array(pixels)
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

        this.palette = palette;
    };

    /**************************************************************************************************************/
    /**
 	@name LineRenderable
 	@class
 	 Renderable constructor for Line
 	@param {Bucket} bucket Bucket
	@augments BatchRenderable
 	@constructor
 	*/

    var LineRenderable = function(bucket) {
        BatchRenderable.prototype.constructor.call(this, bucket);

        this.vertexSize = 4;

        // TODO : remove matrix ??
        this.matrix = mat4.create();
        mat4.identity(this.matrix);
    };

    /**************************************************************************************************************/

    Utils.inherits(BatchRenderable, LineRenderable);

    /**************************************************************************************************************/

    /**
     * Build vertices and indices for the given geometry
     * @function build
     * @memberof LineRenderable.prototype
     * @param geometry
     */
    LineRenderable.prototype.build = function(geometry) {
        var renderer = this.bucket.renderer;
        var style = this.bucket.style;
        var i, n;

        var lines =
            geometry.type === Constants.GEOMETRY.MultiLineString
                ? geometry.coordinates
                : [geometry.coordinates];

        var currentPoint = vec3.create();
        var previousPoint = vec3.create();

        for (n = 0; n < lines.length; n++) {
            var coords = lines[n];

            var lastIndex = this.vertices.length / 4;
            var coordinateSystem = renderer.globe.getCoordinateSystem();

            // Build line vertices
            var offset = lastIndex * 4;
            var s = 0;
            for (i = 0; i < coords.length; i++) {
                coordinateSystem.get3DFromWorldInCrs(
                    coords[i],
                    geometry.crs.properties.name,
                    currentPoint
                );
                this.vertices[offset] = currentPoint[0];
                this.vertices[offset + 1] = currentPoint[1];
                this.vertices[offset + 2] = currentPoint[2];
                // Compute s(length) between two points
                if (i > 0) {
                    s += vec3.dist(currentPoint, previousPoint);
                }

                // Update previous point(do it by swapping with current cuz it's the same object)
                var tmp = previousPoint;
                previousPoint = currentPoint;
                currentPoint = tmp;

                this.vertices[offset + 3] = s;
                offset += 4;
            }

            // Build line indices
            for (i = 0; i < coords.length - 1; i++) {
                this.lineIndices.push(lastIndex + i, lastIndex + i + 1);
            }
        }
        // Geometry is always added contrary to tiled renderables
        return true;
    };

    /**************************************************************************************************************/
    /**
 	@name LineBucket
 	@class
 	 Bucket constructor for LineRenderer
 	@param layer
	@param style
 	@constructor
 	*/
    var LineBucket = function(layer, style) {
        this.layer = layer;
        this.style = style;
        this.renderer = null;
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof LineBucket.prototype
     */
    LineBucket.prototype.createRenderable = function() {
        return new LineRenderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Check if a bucket is compatible
     * @function is Compatible
     * @memberof LineBucket.prototype
     * @param style
     * @return {Boolean} Is compatible ?
     */
    LineBucket.prototype.isCompatible = function(style) {
        return this.style === style;
    };

    /**************************************************************************************************************/

    /**
     * 	Render all the polygons
     * @function render
     * @memberof LineRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    LineRenderer.prototype.render = function(renderables, start, end) {
        var renderContext = this.globe.renderContext;
        var gl = renderContext.gl;

        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        //gl.enable(gl.POLYGON_OFFSET_FILL);
        //gl.polygonOffset(-2.0,-2.0);
        //gl.disable(gl.DEPTH_TEST);

        // Compute the viewProj matrix
        var viewProjMatrix = mat4.create();
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            viewProjMatrix
        );
        var modelViewProjMatrix = mat4.create();

        this.program.apply();

        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(this.program.uniforms.colorTexture, 0);
        gl.bindTexture(gl.TEXTURE_2D, this.colorTexture);

        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            var style = renderable.bucket.style;

            mat4.multiply(
                viewProjMatrix,
                renderable.matrix,
                modelViewProjMatrix
            );
            gl.uniformMatrix4fv(
                this.program.uniforms.mvp,
                false,
                modelViewProjMatrix
            );

            if (style.palette && style.palette !== this.palette) {
                // Generate new color texture(create an array of color textures per bucket ?)
                gl.deleteTexture(this.colorTexture);
                this.generateTexture(style.palette);
            }

            gl.lineWidth(style.strokeWidth);

            // Update uniforms
            gl.uniform4f(
                this.program.uniforms.color,
                style.strokeColor[0],
                style.strokeColor[1],
                style.strokeColor[2],
                style.strokeColor[3] * renderable.bucket.layer.getOpacity()
            );
            gl.uniform1f(
                this.program.uniforms.speed,
                style.hasOwnProperty("speed") ? style.speed : 1.0
            );
            gl.uniform1f(
                this.program.uniforms.time,
                Date.now() / 1000 - this.time
            );
            gl.uniform1f(
                this.program.uniforms.gradientLength,
                style.hasOwnProperty("gradientLength")
                    ? style.gradientLength
                    : 10.0
            );

            renderable.bindBuffers(renderContext);

            gl.vertexAttribPointer(
                this.program.attributes.vertex,
                4,
                gl.FLOAT,
                false,
                0,
                0
            );

            // Draw
            gl.drawElements(
                gl.LINES,
                renderable.lineIndices.length,
                renderable.indexType,
                0
            );
        }

        // Revert to default
        gl.lineWidth(1);

        //gl.enable(gl.DEPTH_TEST);
        //gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.depthFunc(gl.LESS);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof LineRenderer.prototype
     * @return {Boolean} Can apply ?
     */
    LineRenderer.prototype.canApply = function(type, style) {
        return (
            (type === Constants.GEOMETRY.LineString ||
                type === Constants.GEOMETRY.MultiLineString) &&
            style.gradientLength
        );
    };

    /**************************************************************************************************************/

    /**
     * Create a bucket
     * @function createBucket
     * @memberof LineRenderer.prototype
     * @param layer
     * @param style
     * @return {LineBucket} Line bucket
     */
    LineRenderer.prototype.createBucket = function(layer, style) {
        return new LineBucket(layer, style);
    };

    /**************************************************************************************************************/

    // Register the renderer
    RendererManager.factory.push(function(globe) {
        return new LineRenderer(globe);
    });
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/PointSpriteRenderer',[
    "../Utils/Utils",
    "./VectorRenderer",
    "./Program",
    "./FeatureStyle",
    "./RendererManager",
    "../Utils/Constants",
    "../Utils/Proxy"
], function(
    Utils,
    VectorRenderer,
    Program,
    FeatureStyle,
    RendererManager,
    Constants,
    Proxy
) {
    /**************************************************************************************************************/

    /**
         @name PointSpriteRenderer
         @class
             PointSpriteRenderer constructor
         @param {AbstractGlobe} globe AbstractGlobe
         @augments VectorRenderer
         @constructor
         */
    var PointSpriteRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);

        // For stats
        this.numberOfRenderPoints = 0;

        var vertexShader = `
        attribute vec3 vertex;
        uniform mat4 viewProjectionMatrix;
        uniform float pointSize;
        void main(void)
        {
            gl_Position = viewProjectionMatrix * vec4(vertex,1.0);
            gl_PointSize = pointSize;
        }`;

        var fragmentShader = `
        precision lowp float;
        uniform sampler2D texture;
        uniform float alpha;
        uniform vec3 color;

        void main(void)
        {
            vec4 textureColor = texture2D(texture, gl_PointCoord);
            gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha);
            if (gl_FragColor.a <= 0.0) discard;
            //gl_FragColor = vec4(1.0);
        }`;

        var meterSizeVertexShader = `
        attribute vec3 vertex;
        uniform mat4 viewMatrix;
        uniform mat4 viewProjectionMatrix;
        uniform vec3 billboardPos;
        uniform vec2 billboardSize;

        varying vec2 texcoords;

        void main() {
            vec3 camRight = vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);
            vec3 camUp = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);
            vec3 x = camRight * vertex.x * billboardSize.x;
            vec3 y = camUp * vertex.y * billboardSize.y;
            vec3 pos = billboardPos + x + y;

            gl_Position = viewProjectionMatrix * vec4(pos, 1.0);
            texcoords = vec2(vertex.x + 0.5, 1.0 - vertex.y);
        }`;

        var meterSizeFragmentShader = `
        precision lowp float;

        uniform sampler2D texture;
        uniform float alpha;
        uniform vec3 color;

        varying vec2 texcoords;

        void main(void)
        {
            vec4 textureColor = texture2D(texture, texcoords);
            gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha);
            if (gl_FragColor.a <= 0.0) discard;
        }`;

        this.program = new Program(globe.renderContext);
        this.program.createFromSource(vertexShader, fragmentShader);

        this.meterSizeProgram = new Program(globe.renderContext);
        this.meterSizeProgram.createFromSource(meterSizeVertexShader, meterSizeFragmentShader);

        this.defaultTexture = null;

        const vertices = new Float32Array([
            -0.5, 0.0, 0.0,
            0.5, 0.0, 0.0,
            0.5, 1.0, 0.0,
            -0.5, 1.0, 0.0,
        ]);

        var gl = globe.tileManager.renderContext.gl;
        this.rectVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.rectVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    };

    Utils.inherits(VectorRenderer, PointSpriteRenderer);

    /**************************************************************************************************************/

    /**
         @name Renderable
         @class
             Renderable constructor for PointSprite
         @param {Bucket} bucket Bucket
         @constructor
         */
    var Renderable = function(bucket) {
        this.bucket = bucket;
        this.geometry2vb = {};
        this.vertices = [];
        this.geometries = [];
        this.vertexBuffer = null;
        this.vertexBufferDirty = false;
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to the renderable
     * @function add
     * @memberof Renderable.prototype
     * @param geometry
     * @return {Boolean} If the geometry has been successfully added to the renderable
     */
    Renderable.prototype.add = function(geometry, stockGeometry) {
        this.geometry2vb[geometry.gid] = this.vertices.length;
        // TODO: Find a better way to access to coordinate system
        var globe = this.bucket.renderer.globe;
        var crs = globe.getCoordinateSystem();

        if (this.bucket.style.useMeterSize) {
            const elevation = crs.getElevation(globe, geometry) + 200;
            const pt = crs.get3DFromWorldInCrs(
                [geometry.coordinates[0], geometry.coordinates[1], elevation],
                geometry.crs.properties.name
            );
            this.vertices.push(pt[0], pt[1], pt[2]);
        } else {
            var pt = crs.get3DFromWorldInCrs(
                geometry.coordinates,
                geometry.crs.properties.name
            );
            var realPlanetRadius = crs.getGeoide().getRealPlanetRadius();
            var scale = this.bucket.renderer.globe.isSky()
                ? 0.95
                : 1.0 +
                (crs.getElevation(globe, geometry) + 200) / realPlanetRadius;
            //TODO Instead of 0.95, it should be 0.9995. But with this value, the point is dislayed
            //TODO after order > 5. With order<=5, the image need more control points. Without these
            //TODO control point, the image does not fit perfectly the sphere and the point is behind the image
            this.vertices.push(scale * pt[0], scale * pt[1], scale * pt[2]);
            this.vertexBufferDirty = true;
        }
        if (stockGeometry !== false) {
            this.geometries.push(geometry);
        }
        return true;
    };

    /**************************************************************************************************************/

    /**
     * Update all elevations for each render
     * @function updateElevations
     * @memberof Renderable.prototype
     */
    Renderable.prototype.updateElevations = function() {
        this.vertices = [];
        for (var i = 0; i < this.geometries.length; i++) {
            this.add(this.geometries[i], false);
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from the renderable
     * @function remove
     * @memberof Renderable.prototype
     * @param geometry
     */
    Renderable.prototype.remove = function(geometry) {
        if (this.geometry2vb.hasOwnProperty(geometry.gid)) {
            var vbIndex = this.geometry2vb[geometry.gid];
            delete this.geometry2vb[geometry.gid];
            this.vertices.splice(vbIndex, 3);
            this.vertexBufferDirty = true;

            // Update render data for all other geometries
            for (var g in this.geometry2vb) {
                if (g) {
                    if (this.geometry2vb[g] > vbIndex) {
                        this.geometry2vb[g] -= 3;
                    }
                }
            }
        }
        return this.vertices.length;
    };

    /**************************************************************************************************************/

    /**
     * Dispose the renderable
     * @function dispose
     * @memberof Renderable.prototype
     * @param renderContext
     */
    Renderable.prototype.dispose = function(renderContext) {
        if (this.vertexBuffer) {
            renderContext.gl.deleteBuffer(this.vertexBuffer);
        }
    };

    /**************************************************************************************************************/

    /**
     * Build a default texture
     * @function _buildDefaultTexture
     * @memberof PointSpriteRenderer.prototype
     * @param {Bucket} bucket Bucket
     * @private
     */
    PointSpriteRenderer.prototype._buildDefaultTexture = function(bucket) {
        if (!this.defaultTexture) {
            var gl = this.globe.renderContext.gl;
            this.defaultTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
            var whitePixel = new Uint8Array([255, 255, 255, 255]);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                1,
                1,
                0,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                whitePixel
            );
        }

        bucket.texture = this.defaultTexture;
        bucket.textureWidth = 10;
        bucket.textureHeight = 10;
    };

    /**************************************************************************************************************/

    /**
     * Build a texture from an image and store in a bucket
     * @function _buildTextureFromImage
     * @memberof PointSpriteRenderer.prototype
     * @param {Bucket} bucket Bucket
     * @param image
     * @private
     */
    PointSpriteRenderer.prototype._buildTextureFromImage = function(
        bucket,
        image
    ) {
        bucket.texture = this.globe.renderContext.createNonPowerOfTwoTextureFromImage(
            image
        );
        bucket.textureWidth = image.width;
        bucket.textureHeight = image.height;
    };

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof PointSpriteRenderer.prototype
     * @param type
     * @param style
     * @return {Boolean} Is applicable ?
     */
    PointSpriteRenderer.prototype.canApply = function(type, style) {
        return type === Constants.GEOMETRY.Point && !style.label;
    };

    /**************************************************************************************************************/

    /**
         @name Bucket
         @class
             Bucket constructor for PointSpriteRenderer
         @param layer
         @param style
         @constructor
         */

    var Bucket = function(layer, style) {
        this.layer = layer;
        this.style = new FeatureStyle(style);
        this.texture = null;
        this.renderer = null;
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof Bucket.prototype
     * @return {Renderable} Renderable
     */
    Bucket.prototype.createRenderable = function() {
        return new Renderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Check if a bucket is compatible
     * @function isCompatible
     * @memberof Bucket.prototype
     * @param style
     * @return {Boolean} Is compatible ?
     */
    Bucket.prototype.isCompatible = function(style) {
        if (
            this.style.iconUrl === style.iconUrl &&
            this.style.icon === style.icon &&
            this.style.fillColor[0] === style.fillColor[0] &&
            this.style.fillColor[1] === style.fillColor[1] &&
            this.style.fillColor[2] === style.fillColor[2]
        ) {
            return true;
        }

        return false;
    };

    /**************************************************************************************************************/

    /**
     * Create bucket to render a point
     * @function createBucket
     * @memberof PointSpriteRenderer.prototype
     * @param layer
     * @param style
     * @return {Bucket} Bucket
     */
    PointSpriteRenderer.prototype.createBucket = function(layer, style) {
        var gl = this.globe.renderContext.gl;
        var vb = gl.createBuffer();

        // Create a bucket
        var bucket = new Bucket(layer, style);
        bucket.renderer = this;

        // Initialize bucket : create the texture
        if (style.iconUrl) {
            var image = new Image();
            image.crossOrigin = "";
            var self = this;
            image.onload = function() {
                self._buildTextureFromImage(bucket, image);
                self.globe.renderContext.requestFrame();
            };
            image.onerror = function() {
                self._buildDefaultTexture(bucket);
            };
            image.src = Proxy.proxify(style.iconUrl);
        } else if (style.icon) {
            this._buildTextureFromImage(bucket, style.icon);
        } else {
            this._buildDefaultTexture(bucket);
        }

        return bucket;
    };

    /**************************************************************************************************************/

    /**
     * Render
     * @function render
     * @memberof PointSpriteRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    PointSpriteRenderer.prototype.render = function(renderables, start, end) {
        var renderContext = this.globe.renderContext;
        var gl = renderContext.gl;

        // Setup states
        //gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // The shader only needs the viewProjection matrix, use GlobWeb.modelViewMatrix as a temporary storage
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            renderContext.modelViewMatrix
        );

        var program;

        // Render each renderables
        var currentBucket = null;
        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            renderable.updateElevations();
            var bucket = renderable.bucket;

            if (currentBucket !== bucket) {
                // Setup program
                program = bucket.style.useMeterSize ? this.meterSizeProgram : this.program;
                program.apply();

                gl.uniformMatrix4fv(
                    program.uniforms.viewProjectionMatrix,
                    false,
                    renderContext.modelViewMatrix
                );
                gl.uniform1i(program.uniforms.texture, 0);

                gl.uniform1f(
                    program.uniforms.alpha,
                    bucket.layer.getOpacity()
                );
                var color = bucket.style.getFillColor();
                gl.uniform3f(
                    program.uniforms.color,
                    color[0],
                    color[1],
                    color[2]
                );

                if (bucket.style.useMeterSize) {
                    const radius = this.globe.getCoordinateSystem().getGeoide().getRealPlanetRadius();
                    const w = bucket.style.meterSize[0] / radius;
                    const h = bucket.style.meterSize[1] / radius;
                    gl.uniform2f(program.uniforms.billboardSize, w, h);
                    gl.uniformMatrix4fv(program.uniforms.viewMatrix, false, renderContext.viewMatrix);
                } else {
                    gl.uniform1f(
                        program.uniforms.pointSize,
                        bucket.textureWidth
                    );
                }

                // Bind point texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, bucket.texture);

                currentBucket = bucket;
            }

            if (bucket.style.useMeterSize) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.rectVertexBuffer);
                gl.vertexAttribPointer(program.attributes.vertex, 3, gl.FLOAT, false, 0, 0);

                for (var i = 0; i < renderable.vertices.length; i += 3) {
                    const x = renderable.vertices[i];
                    const y = renderable.vertices[i + 1];
                    const z = renderable.vertices[i + 2];

                    gl.uniform3f(program.uniforms.billboardPos, x, y, z);
                    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
                }
            } else {
                if (!renderable.vertexBuffer) {
                    renderable.vertexBuffer = gl.createBuffer();
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
                gl.vertexAttribPointer(
                    program.attributes.vertex,
                    3,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                if (renderable.vertexBufferDirty) {
                    gl.bufferData(
                        gl.ARRAY_BUFFER,
                        new Float32Array(renderable.vertices),
                        gl.STATIC_DRAW
                    );
                    renderable.vertexBufferDirty = false;
                }

                gl.drawArrays(gl.POINTS, 0, renderable.vertices.length / 3);
            }
        }

        //gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    // Register the renderer
    RendererManager.factory.push(function(globe) {
        return new PointSpriteRenderer(globe);
    });
    return PointSpriteRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/Triangulator',[],function() {
    /**
     Triangulator code taken from http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
     Does not manage holes
     Seems to be O(n^3)!
     */
    var EPSILON = 0.0000000001;

    /*
     Compute the signed area of a polygon
     */
    var Area = function(contour) {
        var n = contour.length;
        var A = 0.0;
        for (var p = n - 1, q = 0; q < n; p = q++) {
            A += contour[p][0] * contour[q][1] - contour[q][0] * contour[p][1];
        }
        return A * 0.5;
    };

    /*
     InsideTriangle decides if a point P is Inside of the triangle
     defined by A, B, C.
     */
    var InsideTriangle = function(Ax, Ay, Bx, By, Cx, Cy, Px, Py) {
        var ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy;
        var cCROSSap, bCROSScp, aCROSSbp;

        ax = Cx - Bx;
        ay = Cy - By;
        bx = Ax - Cx;
        by = Ay - Cy;
        cx = Bx - Ax;
        cy = By - Ay;
        apx = Px - Ax;
        apy = Py - Ay;
        bpx = Px - Bx;
        bpy = Py - By;
        cpx = Px - Cx;
        cpy = Py - Cy;

        aCROSSbp = ax * bpy - ay * bpx;
        cCROSSap = cx * apy - cy * apx;
        bCROSScp = bx * cpy - by * cpx;

        return aCROSSbp >= 0.0 && bCROSScp >= 0.0 && cCROSSap >= 0.0;
    };

    /*
     Check if the giben triangle (u,v,w) is a ear : not other vertex inside
     */
    var Snip = function(contour, u, v, w, n, V) {
        var p;
        var Ax, Ay, Bx, By, Cx, Cy, Px, Py;

        Ax = contour[V[u]][0];
        Ay = contour[V[u]][1];

        Bx = contour[V[v]][0];
        By = contour[V[v]][1];

        Cx = contour[V[w]][0];
        Cy = contour[V[w]][1];

        if (EPSILON > (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax)) {
            return false;
        }

        for (p = 0; p < n; p++) {
            if (p === u || p === v || p === w) {
                continue;
            }
            Px = contour[V[p]][0];
            Py = contour[V[p]][1];
            if (InsideTriangle(Ax, Ay, Bx, By, Cx, Cy, Px, Py)) {
                return false;
            }
        }

        return true;
    };

    /*
     Process triangulation on the given contour
     */
    var Process = function(contour) {
        /* allocate and initialize list of Vertices in polygon */

        var n = contour.length;
        if (
            contour[0][0] === contour[n - 1][0] &&
            contour[0][1] === contour[n - 1][1]
        ) {
            n--;
        }

        if (n < 3) {
            return null;
        }

        var V = new Array(n);
        var m, v;
        /* we want a counter-clockwise polygon in V */

        if (0.0 < Area(contour)) {
            for (v = 0; v < n; v++) {
                V[v] = v;
            }
        } else {
            for (v = 0; v < n; v++) {
                V[v] = n - 1 - v;
            }
        }

        var nv = n;

        var results = [];

        /*  remove nv-2 Vertices, creating 1 triangle every time */
        var count = 2 * nv;
        /* error detection */

        for (m = 0, v = nv - 1; nv > 2; ) {
            /* if we loop, it is probably a non-simple polygon */
            if (0 >= count--) {
                //** Triangulate: ERROR - probable bad polygon!
                return null;
            }

            /* three consecutive vertices in current polygon, <u,v,w> */
            var u = v;
            if (nv <= u) {
                u = 0;
            }
            /* previous */
            v = u + 1;
            if (nv <= v) {
                v = 0;
            }
            /* new v    */
            var w = v + 1;
            if (nv <= w) {
                w = 0;
            }
            /* next     */

            if (Snip(contour, u, v, w, nv, V)) {
                var a, b, c, s, t;

                /* true names of the vertices */
                a = V[u];
                b = V[v];
                c = V[w];

                /* output Triangle */
                results.push(a);
                results.push(b);
                results.push(c);

                m++;

                /* remove v from remaining polygon */
                for (s = v, t = v + 1; t < nv; s++, t++) {
                    V[s] = V[t];
                }
                nv--;

                /* resest error detection counter */
                count = 2 * nv;
            }
        }

        return results;
    };

    var Triangulator = {
        process: Process
    };

    return Triangulator;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/ConvexPolygonRenderer',[
    "../Utils/Utils",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "./VectorRenderer",
    "./Program",
    "./FeatureStyle",
    "./RendererManager",
    "../Tiling/Triangulator",
    "../Utils/Proxy",
    "./glMatrix"
], function(
    Utils,
    Constants,
    ErrorDialog,
    VectorRenderer,
    Program,
    FeatureStyle,
    RendererManager,
    Proxy,
    Triangulator
) {
    /**
         @name Bucket
         @class
          Bucket constructor for ConvexPolygonRenderer
         @param layer
         @param style
         @constructor
         */
    var Bucket = function(layer, style) {
        this.layer = layer;
        this.style = new FeatureStyle(style);
        this.texture = null;
        this.polygonProgram = null;
        this.renderer = null;
        this.mainRenderable = null;
    };

    /**
     * Check if a bucket is compatible
     * @function isCompatible
     * @memberof Bucket.prototype
     * @param style
     * @return {boolean} Is compatible ?
     */
    Bucket.prototype.isCompatible = function(style) {
        if (
            this.style.strokeColor[0] === style.strokeColor[0] &&
            this.style.strokeColor[1] === style.strokeColor[1] &&
            this.style.strokeColor[2] === style.strokeColor[2] &&
            this.style.fill === style.fill &&
            this.style.fillTexture === style.fillTexture &&
            this.style.fillTextureUrl === style.fillTextureUrl &&
            this.style.fillShader === style.fillShader
        ) {
            return true;
        }
        return false;
    };

    /**************************************************************************************************************/

    /**
          @name Renderable
          @class
            Renderable constructor
            Attach to a bucket
          @param {Bucket} bucket Bucket
          @constructor
         */
    var Renderable = function(bucket) {
        this.bucket = bucket;
        this.geometry2vb = {};
        this.vertices = [];
        this.lineIndices = [];
        this.triangleIndices = [];
        this.vertexBuffer = null;
        this.lineIndexBuffer = null;
        this.triangleIndexBuffer = null;
        this.bufferDirty = false;
        this.triBufferDirty = false;
        this.tcoords = [];
    };

    /**************************************************************************************************************/

    /**
     * Add the geometry to the renderable
     * @function add
     * @memberof Renderable.prototype
     * @return if the geometry has been successfully added to the renderable
     */
    Renderable.prototype.add = function(geometry) {
        var rings = [];
        var geometryCrs = "Equatorial";//geometry.crs.properties.name;
        var i, r, pt;
        if (geometry.type === Constants.GEOMETRY.MultiPolygon) {
            for (i = 0; i < geometry.coordinates.length; i++) {
                rings.push(geometry.coordinates[i][0]);
            }
        } else if (geometry.type === Constants.GEOMETRY.LineString) {
            rings.push(geometry.coordinates);
        } else if (geometry.type === Constants.GEOMETRY.MultiLineString) {
            for (i = 0; i < geometry.coordinates.length; i++) {
                rings.push(geometry.coordinates[i]);
            }
        } else {
            rings.push(geometry.coordinates[0]);
        }

        for (r = 0; r < rings.length; r++) {
            var coords = rings[r];
            // var coords = geometry['coordinates'][0];
            //var numPoints = coords.length-1;
            var numPoints = coords.length;

            // Store information for the geometry in the buffers used for rendering
            var data = {
                vertexStart: this.vertices.length,
                vertexCount: 3 * numPoints,
                lineIndexStart: this.lineIndices.length,
                lineIndexCount: 2 * numPoints,
                triIndexStart: 0,
                triIndexCount: 0
            };

            var coordinateSystem = this.bucket.renderer.globe.getCoordinateSystem();
            // Compute texture coordinates if defined
            if (geometry._imageCoordinates) {
                data.tcoordsStart = this.tcoords.length;
                data.tcoordsCount = 2 * numPoints;

                // Initialize variables used for texture coordinates computation
                var p0 = coordinateSystem.get3DFromWorldInCrs(
                    geometry._imageCoordinates[0][0],
                    geometryCrs
                ); // origin
                var p1 = coordinateSystem.get3DFromWorldInCrs(
                    geometry._imageCoordinates[0][1],
                    geometryCrs
                );
                var p3 = coordinateSystem.get3DFromWorldInCrs(
                    geometry._imageCoordinates[0][3],
                    geometryCrs
                );
                var v01 = [];
                vec3.subtract(p1, p0, v01); // U-axis
                var v03 = [];
                vec3.subtract(p3, p0, v03); // V-axis
                var squaredU = vec3.length(v01) * vec3.length(v01);
                var squaredV = vec3.length(v03) * vec3.length(v03);

                for (i = 0; i < numPoints; i++) {
                    pt = coordinateSystem.get3DFromWorldInCrs(
                        coords[i],
                        geometryCrs
                    );
                    var v0P = [];
                    vec3.subtract(pt, p0, v0P);

                    var uDotProduct = vec3.dot(v0P, v01);
                    var vDotProduct = vec3.dot(v0P, v03);
                    var u = uDotProduct / squaredU;
                    var v = vDotProduct / squaredV;
                    this.tcoords.push(u);
                    this.tcoords.push(v);
                }
            }

            // Compute vertices and indices and store them in the buffers
            var startIndex = this.vertices.length / 3;
            for (i = 0; i < numPoints; i++) {
                pt = coordinateSystem.get3DFromWorldInCrs(
                    coords[i],
                    geometryCrs
                );
                this.vertices.push(pt[0], pt[1], pt[2]);

                if (
                    (geometry.type === Constants.GEOMETRY.MultiLineString ||
                        geometry.type === Constants.GEOMETRY.LineString) &&
                    i === numPoints - 1
                ) {
                    break;
                }
                this.lineIndices.push(
                    startIndex + i,
                    startIndex + ((i + 1) % numPoints)
                );
            }

            // If fill, build the triangle indices
            if (this.bucket.style.fill) {
                data.triIndexStart = this.triangleIndices.length;
                data.triIndexCount = 3 * (numPoints - 2);

                var triangleIndices = Triangulator.process(coords);
                if (triangleIndices !== null) {
                    this.triangleIndices = triangleIndices;
                } else {
                    // HACK for not trivial polygons
                    for (i = 0; i < numPoints - 2; i++) {
                        this.triangleIndices.push(
                            startIndex,
                            startIndex + i + 1,
                            startIndex + i + 2
                        );
                    }
                }
            }

            if (this.geometry2vb[geometry.gid]) {
                this.geometry2vb[geometry.gid].vertexCount += data.vertexCount;
                this.geometry2vb[geometry.gid].lineIndexCount +=
                    data.lineIndexCount;
                this.geometry2vb[geometry.gid].triIndexCount +=
                    data.triIndexCount;
            } else {
                this.geometry2vb[geometry.gid] = data;
            }

            this.bufferDirty = true;
            this.triBufferDirty = true;
        }

        return true;
    };

    /**************************************************************************************************************/

    /**
     * Remove the geometry from the renderable
     * @function remove
     * @memberof Renderable.prototype
     * @param geometry
     */
    Renderable.prototype.remove = function(geometry) {
        var i;
        if (this.geometry2vb.hasOwnProperty(geometry.gid)) {
            // retreive the render data for the geometry
            var data = this.geometry2vb[geometry.gid];
            delete this.geometry2vb[geometry.gid];

            // Remove geometry vertex
            this.vertices.splice(data.vertexStart, data.vertexCount);

            // Update indices after vertex removal
            for (
                i = data.lineIndexStart + data.lineIndexCount;
                i < this.lineIndices.length;
                i++
            ) {
                this.lineIndices[i] -= data.vertexCount / 3;
            }
            for (
                i = data.triIndexStart + data.triIndexCount;
                i < this.triangleIndices.length;
                i++
            ) {
                this.triangleIndices[i] -= data.vertexCount / 3;
            }

            this.lineIndices.splice(data.lineIndexStart, data.lineIndexCount);
            this.triangleIndices.splice(data.triIndexStart, data.triIndexCount);
            if (data.tcoordsStart >= 0) {
                this.tcoords.splice(data.tcoordsStart, data.tcoordsCount);
            }

            // Update render data for all other geometries
            for (var g in this.geometry2vb) {
                if (g) {
                    var d = this.geometry2vb[g];
                    if (d.vertexStart > data.vertexStart) {
                        d.vertexStart -= data.vertexCount;
                        d.lineIndexStart -= data.lineIndexCount;
                        d.triIndexStart -= data.triIndexCount;
                        if (d.tcoordsStart >= 0) {
                            d.tcoordsStart -= data.tcoordsCount;
                        }
                    }
                }
            }

            this.bufferDirty = true;
            this.triBufferDirty = true;
        }
        return this.vertices.length;
    };

    /**************************************************************************************************************/

    /**
     * Dispose the renderable : remove all buffers
     * @function dispose
     * @memberof Renderable.prototype
     * @param renderContext
     */
    Renderable.prototype.dispose = function(renderContext) {
        if (this.vertexBuffer) {
            renderContext.gl.deleteBuffer(this.vertexBuffer);
        }
        if (this.lineIndexBuffer) {
            renderContext.gl.deleteBuffer(this.lineIndexBuffer);
        }
        if (this.triangleIndexBuffer) {
            renderContext.gl.deleteBuffer(this.triangleIndexBuffer);
        }
        if (this.tcoordBuffer) {
            renderContext.gl.deleteBuffer(this.tcoordBuffer);
        }
    };

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof Bucket.prototype
     * @return {Renderable} Renderable
     */
    Bucket.prototype.createRenderable = function() {
        return new Renderable(this);
    };

    /**************************************************************************************************************/

    /**
          @name ConvexPolygonRenderer
          @class
            ConvexPolygonRenderer  constructor
          @augments VectorRenderer
          @param {AbstractGlobe} globe AbstractGlobe
          @constructor
          */
    var ConvexPolygonRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);
        this.maxTilePerGeometry = 2;

        // Store object for rendering
        this.renderContext = globe.tileManager.renderContext;
        this.tileConfig = globe.tileManager.tileConfig;

        this.programs = [];

        this.basicVertexShader = "attribute vec3 vertex;\n";
        this.basicVertexShader += "uniform mat4 viewProjectionMatrix;\n";
        this.basicVertexShader += "    \n";
        this.basicVertexShader += "    void main(void)\n";
        this.basicVertexShader += "    {\n";
        this.basicVertexShader +=
            "        gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
        this.basicVertexShader += "    }\n";

        this.basicFragmentShader = "precision lowp float; \n";
        this.basicFragmentShader += "    uniform vec4 color; \n";
        this.basicFragmentShader += "    \n";
        this.basicFragmentShader += "    void main(void) \n";
        this.basicFragmentShader += "    { \n";
        this.basicFragmentShader += "        gl_FragColor = color; \n";
        this.basicFragmentShader += "    } \n";

        this.texVertexShader = "attribute vec3 vertex;\n";
        this.texVertexShader += "    attribute vec2 tcoord;\n";
        this.texVertexShader += "    uniform mat4 viewProjectionMatrix;\n";
        this.texVertexShader += "    \n";
        this.texVertexShader += "    varying vec2 vTextureCoord;\n";
        this.texVertexShader += "    \n";
        this.texVertexShader += "    void main(void) \n";
        this.texVertexShader += "    {\n";
        this.texVertexShader += "        vTextureCoord = tcoord;\n";
        this.texVertexShader +=
            "        vTextureCoord.y = 1.0 - vTextureCoord.y; \n";
        this.texVertexShader +=
            "        gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
        this.texVertexShader += "    }\n";

        this.texFragmentShader = "precision lowp float; \n";
        this.texFragmentShader += "    uniform vec4 color;\n";
        this.texFragmentShader += "    varying vec2 vTextureCoord;\n";
        this.texFragmentShader += "    uniform sampler2D texture; \n";
        this.texFragmentShader += "    void main(void)\n";
        this.texFragmentShader += "    {\n";
        this.texFragmentShader +=
            "        gl_FragColor = texture2D(texture, vTextureCoord) * color;\n";
        this.texFragmentShader += "    }\n";

        this.basicFillShader = {
            vertexCode: this.basicVertexShader,
            fragmentCode: this.basicFragmentShader,
            updateUniforms: null
        };

        this.texFillShader = {
            vertexCode: this.texVertexShader,
            fragmentCode: this.texFragmentShader,
            updateUniforms: null
        };

        this.basicProgram = this.createProgram(this.basicFillShader);
        this.texProgram = this.createProgram(this.texFillShader);

        var gl = this.renderContext.gl;
        // Parameters used to implement ONE shader for color xor texture rendering
        this.whiteTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture);
        var whitePixel = new Uint8Array([255, 255, 255, 255]);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            1,
            1,
            0,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            whitePixel
        );

        // Shared buffer
        // Create texCoord buffer
        this.tcoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);

        var textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0];

        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(textureCoords),
            gl.STATIC_DRAW
        );
        this.tcoordBuffer.itemSize = 2;
        this.tcoordBuffer.numItems = 5;
    };

    Utils.inherits(VectorRenderer, ConvexPolygonRenderer);

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof ConvexPolygonRenderer.prototype
     * @param type
     * @param style
     * @return {boolean} Is applicable ?
     */
    ConvexPolygonRenderer.prototype.canApply = function(type, style) {
        if (!this.globe.isSky()) {
            return false;
        }

        return (
            type === Constants.GEOMETRY.Polygon ||
            type === Constants.GEOMETRY.MultiPolygon ||
            type === Constants.GEOMETRY.LineString ||
            type === Constants.GEOMETRY.MultiLineString
        );
    };

    /**************************************************************************************************************/

    /**
     * Create program from fillShader object
     * @function createProgram
     * @memberof ConvexPolygonRenderer.prototype
     * @param fillShader
     * @return {Program} Program
     */
    ConvexPolygonRenderer.prototype.createProgram = function(fillShader) {
        var program = new Program(this.renderContext);
        program.createFromSource(
            fillShader.vertexCode,
            fillShader.fragmentCode
        );

        // Add program
        program.id = this.programs.length;
        this.programs.push({
            fillShader: fillShader,
            program: program
        });
        return program;
    };

    /**************************************************************************************************************/

    /**
     * Get program if known by renderer, create otherwise
     * @function getProgram
     * @memberof ConvexPolygonRenderer.prototype
     * @param fillShader
     * @return {Program} Program
     */
    ConvexPolygonRenderer.prototype.getProgram = function(fillShader) {
        var program;

        for (var id = 0; id < this.programs.length; id++) {
            if (this.programs[id].fillShader === fillShader) {
                program = this.programs[id].program;
            }
        }

        if (!program) {
            program = this.createProgram(fillShader);
        }
        return program;
    };

    /**************************************************************************************************************/

    /**
     * Create bucket to render a polygon
     * @function createBucket
     * @memberof ConvexPolygonRenderer.prototype
     * @param layer
     * @param style
     * @return {Bucket} Bucket
     */
    ConvexPolygonRenderer.prototype.createBucket = function(layer, style) {
        var gl = this.renderContext.gl;
        var vb = gl.createBuffer();
        // Create a bucket
        var bucket = new Bucket(layer, style);

        // Create texture
        var self = this;
        if (style.fill) {
            var hasTexture = false;
            if (style.fillTextureUrl) {
                var image = new Image();
                image.crossOrigin = "";
                image.onload = function() {
                    bucket.texture = self.renderContext.createNonPowerOfTwoTextureFromImage(
                        image,
                        layer.invertY
                    );
                };

                image.onerror = function(event) {
                    ErrorDialog.open(Constants.LEVEL.WARNING, "Cannot load " + image.src);
                };

                image.src = Proxy.proxify(style.fillTextureUrl);
                hasTexture = true;
            } else if (style.fillTexture) {
                bucket.texture = style.fillTexture;
                hasTexture = true;
            }

            if (style.fillShader && style.fillShader.fragmentCode) {
                // User defined texture program
                if (!style.fillShader.vertexCode) {
                    style.fillShader.vertexCode = this.texVertexShader;
                }
                if (!style.fillShader.vertexCode) {
                    style.fillShader.fragmentCode = this.texFragmentShader;
                }

                bucket.polygonProgram = this.getProgram(style.fillShader);
            } else {
                // Default program
                bucket.polygonProgram = hasTexture
                    ? this.texProgram
                    : this.basicProgram;
            }
        }

        return bucket;
    };

    /**************************************************************************************************************/

    /**
     * Render all the POIs
     * @function render
     * @memberof ConvexPolygonRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    ConvexPolygonRenderer.prototype.render = function(renderables, start, end) {
        var renderContext = this.renderContext;
        var gl = this.renderContext.gl;

        // Setup states
        gl.disable(gl.DEPTH_TEST);
        gl.depthMask(false);
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Setup the basic program
        this.basicProgram.apply();
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            renderContext.modelViewMatrix
        );
        gl.uniformMatrix4fv(
            this.basicProgram.uniforms.viewProjectionMatrix,
            false,
            renderContext.modelViewMatrix
        );

        // Render each renderables
        var currentBucket = null;
        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            var bucket = renderable.bucket;

            // Set the color
            var color = bucket.style.getStrokeColor();
            gl.uniform4f(
                this.basicProgram.uniforms.color,
                color[0],
                color[1],
                color[2],
                color[3] * bucket.layer.getOpacity()
            );

            // Update vertex buffer
            if (!renderable.vertexBuffer) {
                renderable.vertexBuffer = gl.createBuffer();
                renderable.lineIndexBuffer = gl.createBuffer();
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
            gl.vertexAttribPointer(
                this.basicProgram.attributes.vertex,
                3,
                gl.FLOAT,
                false,
                0,
                0
            );

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderable.lineIndexBuffer);

            if (renderable.bufferDirty) {
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array(renderable.vertices),
                    gl.STATIC_DRAW
                );
                gl.bufferData(
                    gl.ELEMENT_ARRAY_BUFFER,
                    new Uint16Array(renderable.lineIndices),
                    gl.STATIC_DRAW
                );
                renderable.bufferDirty = false;
            }

            gl.drawElements(
                gl.LINES,
                renderable.lineIndices.length,
                gl.UNSIGNED_SHORT,
                0
            );

            if (bucket.polygonProgram) {
                var program = bucket.polygonProgram;

                program.apply();
                gl.uniformMatrix4fv(
                    program.uniforms.viewProjectionMatrix,
                    false,
                    renderContext.modelViewMatrix
                );

                gl.uniform1i(program.uniforms.texture, 0);
                if (renderable.tcoords.length > 0) {
                    // Use tcoord buffer defined by _imageCoordinates
                    if (!renderable.tcoordBuffer) {
                        renderable.tcoordBuffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);

                        gl.bufferData(
                            gl.ARRAY_BUFFER,
                            new Float32Array(renderable.tcoords),
                            gl.STATIC_DRAW
                        );
                        renderable.tcoordBuffer.itemSize = 2;
                        renderable.tcoordBuffer.numItems =
                            renderable.tcoords.length / 2;
                    }

                    gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);
                } else {
                    // Use default tcoord buffer
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
                }
                gl.vertexAttribPointer(
                    program.attributes.tcoord,
                    2,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
                gl.vertexAttribPointer(
                    program.attributes.vertex,
                    3,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                if (
                    bucket.style.fillShader &&
                    bucket.style.fillShader.updateUniforms
                ) {
                    bucket.style.fillShader.updateUniforms(
                        gl,
                        renderable.bucket,
                        program
                    );
                }

                if (!renderable.triangleIndexBuffer) {
                    renderable.triangleIndexBuffer = gl.createBuffer();
                }
                gl.bindBuffer(
                    gl.ELEMENT_ARRAY_BUFFER,
                    renderable.triangleIndexBuffer
                );
                if (renderable.triBufferDirty) {
                    gl.bufferData(
                        gl.ELEMENT_ARRAY_BUFFER,
                        new Uint16Array(renderable.triangleIndices),
                        gl.STATIC_DRAW
                    );
                    renderable.triBufferDirty = false;
                }
                // Add texture
                gl.activeTexture(gl.TEXTURE0);
                if (renderable.bucket.texture) {
                    gl.bindTexture(gl.TEXTURE_2D, renderable.bucket.texture); // use texture of renderable
                    gl.uniform4f(
                        program.uniforms.color,
                        1.0,
                        1.0,
                        1.0,
                        color[3] * bucket.layer.getOpacity()
                    ); // use whiteColor
                } else {
                    gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture); // use white texture
                    color = renderable.bucket.style.fillColor;
                    gl.uniform4f(
                        program.uniforms.color,
                        color[0],
                        color[1],
                        color[2],
                        color[3] * bucket.layer.getOpacity()
                    );
                }

                gl.drawElements(
                    gl.TRIANGLES,
                    renderable.triangleIndices.length,
                    gl.UNSIGNED_SHORT,
                    0
                );

                this.basicProgram.apply();
            }
        }

        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    RendererManager.factory.push(function(globe) {
        return new ConvexPolygonRenderer(globe);
    });

    return ConvexPolygonRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/PolyLineRenderer',[
    "../Utils/Constants",
    "../Utils/Utils",
    "./VectorRenderer",
    "./RendererManager",
    "./FeatureStyle",
    "./Program",
    "./BatchRenderable",
    "./GeoBound",
    "../Crs/WGS84Crs"
], function(
    Constants,
    Utils,
    VectorRenderer,
    RendererManager,
    FeatureStyle,
    Program,
    BatchRenderable,
    GeoBound,
    WGS84Crs
) {
    /**************************************************************************************************************/
    /**
     @name PolyLineRenderer
     @class
         Basic renderer for polylines
     @param {AbstractGlobe} globe AbstractGlobe
     @augments VectorRenderer
     @constructor
     */
    var PolyLineRenderer = function(globe) {
        this.globe = globe;
        this.buckets = [];
    };

    /**************************************************************************************************************/

    PolyLineRenderer.prototype.generateLevelZero = function(tile) {
        for (var bucket of this.buckets) {
            const layer = bucket.layer;
            const geometry = bucket.geometry;
            const style = bucket.style;

            this.removeGeometry(layer);
            this.addGeometry(layer, geometry, style);
        }
    };

    /**************************************************************************************************************/

    var MainRenderable = function(bucket, rc) {
        this.bucket = bucket;

        this.renderable = new Renderable(bucket);
        this.clippedRenderable = new Renderable(bucket);

        this.vertexShader = `
        attribute vec3 vertex;
        uniform mat4 uModelViewProjMatrix;
        void main() {
        	gl_Position = uModelViewProjMatrix * vec4(vertex, 1.0);
        }
        `;

        this.fragmentShader = `
        precision lowp float;
        uniform vec4 uColor;
        void main() {
        	gl_FragColor = uColor;
        }
        `;

        this.clippedVertexShader = `
        attribute vec3 aVertex;
        uniform mat4 uModelViewProjMatrix;
        uniform mat4 uModelViewMatrix;

        uniform vec3 uClipPlane;
        uniform vec3 uClipNormal;

        varying float vClipDistance;

        void main() {
            gl_Position = uModelViewProjMatrix * vec4(aVertex, 1.0);

            vec2 a = normalize(aVertex.xy - uClipPlane.xy);
            vec2 n = normalize(uClipNormal.xy);

            vClipDistance = dot(a, n);
        }`;

        this.clippedFragmentShader = `
        precision lowp float;
        uniform vec4 uColor;

        varying float vClipDistance;

        void main() {
            if (vClipDistance < 0.0) discard;
            gl_FragColor = uColor;
        }
        `;

        this.program = new Program(rc);
        this.program.createFromSource(this.vertexShader, this.fragmentShader);

        this.clippedProgram = new Program(rc);
        this.clippedProgram.createFromSource(this.clippedVertexShader, this.clippedFragmentShader);

        this.matrix = mat4.create();

        this.leftClipPlane = vec3.create();
        this.leftClipNormal = vec3.create();

        this.rightClipPlane = vec3.create();
        this.rightClipNormal = vec3.create();
    };

    /**************************************************************************************************************/

    MainRenderable.prototype.dispose = function(rc) {
        this.renderable.dispose(rc);
        this.clippedRenderable.dispose(rc);
    };

    /**************************************************************************************************************/

    MainRenderable.prototype.renderDefault = function(rc, mvpMatrix, color) {
        const gl = rc.gl;

        this.program.apply();

        gl.uniformMatrix4fv(
            this.program.uniforms.uModelViewProjMatrix,
            false,
            mvpMatrix
        );
        gl.uniform4f(
            this.program.uniforms.uColor,
            color[0],
            color[1],
            color[2],
            color[3]
        );

        this.renderable.bindBuffers(rc);

        // Setup attributes
        gl.vertexAttribPointer(
            this.program.attributes.aVertex,
            3,
            gl.FLOAT,
            false,
            12,
            0
        );

        for (var line of this.renderable.lines) {
            // Draw
            gl.drawElements(
                gl.LINE_STRIP,
                line.indexCount,
                gl.UNSIGNED_INT,
                line.startIndex * 4 // * sizeof(int)
            );
        }
    };

    /**************************************************************************************************************/

    MainRenderable.prototype.renderClipped = function(rc, mvpMatrix, color) {
        const gl = rc.gl;

        this.clippedProgram.apply();

        const modelViewMatrix = mat4.create();

        mat4.multiply(
            rc.viewMatrix,
            this.matrix,
            modelViewMatrix
        );

        gl.uniformMatrix4fv(
            this.clippedProgram.uniforms.uModelViewProjMatrix,
            false,
            mvpMatrix
        );

        gl.uniform4f(
            this.clippedProgram.uniforms.uColor,
            color[0],
            color[1],
            color[2],
            color[3]
        );

        this.clippedRenderable.bindBuffers(rc);

        // Setup attributes
        gl.vertexAttribPointer(
            this.clippedProgram.attributes.aVertex,
            3,
            gl.FLOAT,
            false,
            12,
            0
        );

        gl.uniform3f(
            this.clippedProgram.uniforms.uClipPlane,
            this.rightClipPlane[0],
            this.rightClipPlane[1],
            this.rightClipPlane[2]
        );

        gl.uniform3f(
            this.clippedProgram.uniforms.uClipNormal,
            this.rightClipNormal[0],
            this.rightClipNormal[1],
            this.rightClipNormal[2]
        );

        var line;
        for (line of this.clippedRenderable.lines) {
            // Draw
            gl.drawElements(
                gl.LINE_STRIP,
                line.indexCount,
                gl.UNSIGNED_INT,
                line.startIndex * 4 // * sizeof(int)
            );
        }

        gl.uniform3f(
            this.clippedProgram.uniforms.uClipPlane,
            this.leftClipPlane[0],
            this.leftClipPlane[1],
            this.leftClipPlane[2]
        );

        gl.uniform3f(
            this.clippedProgram.uniforms.uClipNormal,
            this.leftClipNormal[0],
            this.leftClipNormal[1],
            this.leftClipNormal[2]
        );

        for (line of this.clippedRenderable.clippedLines) {
            // Draw
            gl.drawElements(
                gl.LINE_STRIP,
                line.indexCount,
                gl.UNSIGNED_INT,
                line.startIndex * 4 // * sizeof(int)
            );
        }
    };

    /**************************************************************************************************************/

    MainRenderable.prototype.render = function(rc, viewProjMatrix) {
        const gl = rc.gl;

        const layer = this.bucket.layer;
        const style = this.bucket.style;

        const modelViewProjMatrix = mat4.create();

        mat4.multiply(
            viewProjMatrix,
            this.matrix,
            modelViewProjMatrix
        );

        const color = style.strokeColor.slice(0);
        color[3] *= layer.getOpacity();

        gl.lineWidth(style.strokeWidth);
        this.renderDefault(rc, modelViewProjMatrix, color);
        this.renderClipped(rc, modelViewProjMatrix, color);
    };

    /**************************************************************************************************************/

    var Renderable = function(bucket) {
        this.bucket = bucket;

        this.vertices = [];
        this.indices = [];
        this.dirty = false;
        this.ibo = null;
        this.vbo = null;

        this.lines = [];
        this.clippedLines = [];
    };

    /**************************************************************************************************************/

    Renderable.prototype._clamp = function(x, a, b) {
        return Math.max(a, Math.min(x, b));
    };

    /**************************************************************************************************************/

    Renderable.prototype._subdivideSegment = function(p0, p1) {
        const globe = this.bucket.renderer.globe;
        const cs = new WGS84Crs();
        const scale = cs.getGeoide().getHeightScale();
        const subdivisionLength = globe.getSubdivisionLength() * scale;
        const maxSubdivisionCount = globe.getMaxSubdivisionCount();

        var p0in3d = vec3.create(); cs.get3DFromWorldInCrs(p0, "CRS:84", p0in3d);
        var p1in3d = vec3.create(); cs.get3DFromWorldInCrs(p1, "CRS:84", p1in3d);

        const d = vec3.dist(p0in3d, p1in3d);
        const subdivisionCount = this._clamp(Math.floor(d / subdivisionLength), 1, maxSubdivisionCount);
        const alt0 = p0[2];
        const alt1 = p1[2];

        const result = [];
        const step = 1.0 / subdivisionCount;
        for (var i = 0; i <= subdivisionCount; ++i) {
            const t = i * step;

            var p = vec3.create(); vec3.lerp(p0in3d, p1in3d, t, p);
            var pInGeo = vec3.create(); cs.getWorldFrom3D(p, pInGeo);
            pInGeo[2] = (1 - t) * alt0 + t * alt1;
            result.push(pInGeo);
        }

        return result;
    };

    /**************************************************************************************************************/

    /**
     * Subdivide a line to follow planet curvature
     */
    Renderable.prototype._subdivideLine = function(line) {
        var result = [];

        for (var i = 0; i < line.length - 1; ++i) {
            result = result.concat(this._subdivideSegment(line[i], line[i + 1]));
        }

        // Remove consecutive duplicates
        for (i = result.length - 1; i >= 1; --i) {
            const curr = result[i];
            const prev = result[i - 1];
            if (curr[0] === prev[0] && curr[1] === prev[1] && curr[2] === prev[2]) {
                result.splice(i, 1);
            }
        }

        return result;
    };

    /**************************************************************************************************************/

    const _fixPoles = function(lines) {
        for (var line of lines) {
            for (var i = 0; i < line.length; ++i) {
                const curr = line[i];
                if (curr[1] === 90.0 || curr[1] === -90) {
                    if (i > 0 && i < line.length - 1) {
                        // General case
                        const prev = line[i-1];
                        const next = line[i+1];

                        if (prev[0] === curr[0]) {
                            line.splice(i + 1, 0, [next[0], curr[1], curr[2]]);
                            ++i;
                        } else if (next[0] === curr[0]) {
                            line.splice(i, 0, [prev[0], curr[1], curr[2]]);
                            ++i;
                        } else {
                            line.splice(i, 0, [prev[0], curr[1], curr[2]]);
                            ++i;
                            line.splice(i + 1, 0, [next[0], curr[1], curr[2]]);
                            ++i;
                        }
                    }
                    // edges
                    else if (i > 0) {
                        const prev = line[i-1];
                        if (prev[0] !== curr[0]) {
                            line.splice(i, 0, [prev[0], curr[1], curr[2]]);
                            ++i;
                        }
                    } else if (i < line.length - 1) {
                        const next = line[i+1];
                        if (next[0] !== curr[0]) {
                            line.splice(i + 1, 0, [next[0], curr[1], curr[2]]);
                            ++i;
                        }
                    }
                }
            }
        }
    };

    /**************************************************************************************************************/

    const _detectDiscontinuities = function(lines, normalLines, clippedLines) {
        for (var line of lines) {
            var continuous = true;
            for (var i = 0; continuous && i < line.length - 1; ++i) {
                const x0 = Math.min(line[i][0], line[i+1][0]);
                const x1 = Math.max(line[i][0], line[i+1][0]);

                if (x0 < 0 && x1 > 0) {
                    const d1 = x1 - x0;
                    const d2 = (360 + x0) - x1;

                    if (d2 < d1) {
                        continuous = false;
                    }
                }
            }

            if (continuous) {
                normalLines.push(line);
            } else {
                clippedLines.push(line);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to the renderable
     * Vertex buffer : geometry
     * Index buffer : lines
     * @function build
     * @memberof Renderable.prototype
     * @param geometry
     */
    MainRenderable.prototype.build = function(geometry) {
        var renderer = this.bucket.renderer;
        var style = this.bucket.style;
        var cs = renderer.globe.getCoordinateSystem();

        var lines;
        if (geometry.type === Constants.GEOMETRY.MultiLineString ||
            Array.isArray(geometry.coordinates[0][0])) {
            lines = geometry.coordinates;
        } else {
            lines = [geometry.coordinates];
        }
        lines = JSON.parse(JSON.stringify(lines));

        var geometryBound = new GeoBound();
        var csBound = new GeoBound(
            cs.getGeoBound().getWest(),
            cs.getGeoBound().getSouth(),
            cs.getGeoBound().getEast(),
            cs.getGeoBound().getNorth()
        );
        var crsName = "CRS:84";
        if (typeof geometry.crs !== "undefined") {
            crsName = geometry.crs.properties.name;
        }
        var originPoint = lines[0][0].slice(0);
        originPoint[2] = 0.0;

        var convertedCoord = geometryBound.computeFromCoordinatesInCrsTo(
            originPoint,
            crsName,
            cs
        );

        var origin = vec3.create();
        cs.get3DFromWorld(convertedCoord, origin); // Correction : add [0]

        mat4.identity(this.matrix);
        mat4.translate(this.matrix, origin);

        const leftPlane = [-180, 0, 0];
        const leftNormal = [1, 0, 0];
        cs.get3DFromWorldInCrs(leftPlane, crsName, this.leftClipPlane);
        cs.get3DFromWorldInCrs(leftNormal, crsName, this.leftClipNormal);
        vec3.normalize(this.leftClipNormal);
        vec3.subtract(this.leftClipPlane, origin);

        const rightPlane = [180, 0, 0];
        const rightNormal = [-1, 0, 0];
        cs.get3DFromWorldInCrs(rightPlane, crsName, this.rightClipPlane);
        cs.get3DFromWorldInCrs(rightNormal, crsName, this.rightClipNormal);
        vec3.normalize(this.rightClipNormal);
        vec3.subtract(this.rightClipPlane, origin);

        // Check if some lines are going through the poles
        // In this case, we want to duplicate the points that do not have the same x coordinate.
        _fixPoles(lines);

        var normalLines = [];
        var clippedLines = [];

        var proj = null;
        if (cs.projection && cs.projection.options && cs.projection.options.projectionName) {
            proj = cs.projection.options.projectionName;
        }

        if (cs.flat === true && proj !== Constants.PROJECTION.Azimuth) {
            _detectDiscontinuities(lines, normalLines, clippedLines);
        } else {
            normalLines = lines.slice(0);
        }

        this.renderable.build(normalLines, cs, crsName, origin);
        this.clippedRenderable.buildClipped(clippedLines, cs, crsName, origin);

        return true;
    };

    /**************************************************************************************************************/

    Renderable.prototype.build = function(lines, cs, crsName, origin) {
        var lastIndex = 0;
        var pos3d = vec3.create();

        for (var line of lines) {
            var lineInfos = {
                startIndex: lastIndex,
                indexCount: -1
            };

            // First, subdivide the line
            const finalLine = this._subdivideLine(line);

            for (var coords of finalLine) {
                cs.get3DFromWorldInCrs(coords, crsName, pos3d);
                for (var i = 0; i < 3; ++i) this.vertices.push(pos3d[i] - origin[i]);
                this.indices.push(lastIndex++);
            }

            lineInfos.indexCount = lastIndex - lineInfos.startIndex;
            this.lines.push(lineInfos);
        }

        this.dirty = true;
    };

    /**************************************************************************************************************/

    Renderable.prototype.buildClipped = function(lines, cs, crsName, origin) {
        var lastIndex = 0;
        var pos3d = vec3.create();
        var i;

        for (var line of lines) {
            var lineInfos = {
                startIndex: lastIndex,
                indexCount: -1
            };

            const finalLine = this._subdivideLine(line);

            const finalLine1 = [];
            const finalLine2 = [];

            for (i = 0; i < finalLine.length; ++i) {
                const x = finalLine[i][0];
                const x1 = x >= 0 ? x : x + 360;
                const x2 = x <= 0 ? x : x - 360;

                finalLine1.push([x1, finalLine[i][1], finalLine[i][2]]);
                finalLine2.push([x2, finalLine[i][1], finalLine[i][2]]);
            }

            // First, subdivide the line
            var lineIdx;
            for (lineIdx = 0; lineIdx < finalLine1.length; ++lineIdx) {
                const coords = finalLine1[lineIdx];
                cs.get3DFromWorldInCrs(coords, crsName, pos3d);
                for (i = 0; i < 3; ++i) this.vertices.push(pos3d[i] - origin[i]);

                var wrapAround = false;
                if (lineIdx > 1) {
                    const x0 = finalLine1[lineIdx][0];
                    const x1 = finalLine1[lineIdx - 1][0];
                    const x2 = finalLine1[lineIdx - 2][0];

                    const currDir = x0 - x1;
                    const lastDir = x1 - x2;

                    // We changed direction
                    // last point is outside the visible range
                    // Current point is inside  the visible range
                    if (lastDir > 0 && currDir < 0 && x1 > 180 && x0 < 180) {
                        const distanceAsIt = x1 - x0;
                        const distanceWithWrapAround = (x0 + 360) - x1;
                        if (distanceWithWrapAround < distanceAsIt) {
                            wrapAround = true;
                        }
                    } else if (lastDir < 0 && currDir > 0 && x1 < 180 && x0 > 180) {
                        const distanceAsIt = x0 - x1;
                        const distanceWithWrapAround = (x1 + 360) - x0;
                        if (distanceWithWrapAround < distanceAsIt) {
                            wrapAround = true;
                        }
                    }
                }

                if (wrapAround) {
                    lineInfos.indexCount = lastIndex - lineInfos.startIndex;
                    this.lines.push(lineInfos);
                    lineInfos = {
                        startIndex: lastIndex,
                        indexCount: -1
                    };
                }

                this.indices.push(lastIndex++);
            }

            lineInfos.indexCount = lastIndex - lineInfos.startIndex;
            this.lines.push(lineInfos);

            lineInfos = {
                startIndex: lastIndex,
                indexCount: -1,
            };

            for (lineIdx = 0; lineIdx < finalLine2.length; ++lineIdx) {
                const coords = finalLine2[lineIdx];
                cs.get3DFromWorldInCrs(coords, crsName, pos3d);
                for (i = 0; i < 3; ++i) this.vertices.push(pos3d[i] - origin[i]);

                wrapAround = false;
                if (lineIdx > 1) {
                    const x0 = finalLine2[lineIdx][0];
                    const x1 = finalLine2[lineIdx - 1][0];
                    const x2 = finalLine2[lineIdx - 2][0];

                    const currDir = x0 - x1;
                    const lastDir = x1 - x2;

                    // We were going "to the left", we changed direction
                    // last point is outside the visible range
                    // Current point is inside  the visible range
                    if (lastDir > 0 && currDir < 0 && x1 > -180 && x0 < -180) {
                        const distanceAsIt = x1 - x0;
                        const distanceWithWrapAround = x0 - (x1 - 360);
                        if (distanceWithWrapAround < distanceAsIt) {
                            wrapAround = true;
                        }
                    } else if (lastDir < 0 && currDir > 0 && x1 < -180 && x0 > -180) {
                        const distanceAsIt = x0 - x1;
                        const distanceWithWrapAround = x1 - (x0 - 360);
                        if (distanceWithWrapAround < distanceAsIt) {
                            wrapAround = true;
                        }
                    }
                }

                if (wrapAround) {
                    lineInfos.indexCount = lastIndex - lineInfos.startIndex;
                    this.clippedLines.push(lineInfos);
                    lineInfos = {
                        startIndex: lastIndex,
                        indexCount: -1
                    };
                }

                this.indices.push(lastIndex++);
            }

            lineInfos.indexCount = lastIndex - lineInfos.startIndex;
            this.clippedLines.push(lineInfos);
        }

        this.dirty = true;
    };

    /**************************************************************************************************************/

    Renderable.prototype.dispose = function(rc) {
        if (!rc) return;

        const gl = rc.gl;

        if (this.ibo) gl.deleteBuffer(this.ibo);
        if (this.vbo) gl.deleteBuffer(this.vbo);

        this.ibo = null;
        this.vbo = null;
    };

    /**************************************************************************************************************/

    Renderable.prototype.bindBuffers = function(rc) {
        if (!rc) return;
        const gl = rc.gl;

        if (this.dirty) {
            this.dispose(rc);

            this.vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);

            this.ibo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(this.indices), gl.STATIC_DRAW);
            this.dirty = false;
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo);
    };

    /**************************************************************************************************************/

    /**
     @name Bucket
     @class
         Bucket constructor for RasterOverlay
     @param layer
     @constructor
    */
    var Bucket = function(layer, style, geometry, rc) {
        this.layer = layer;
        this.renderer = null;
        this.style = new FeatureStyle(style);
        this.geometry = geometry;
        this.mainRenderable = new MainRenderable(this, rc);
        this.id = -1;
    };

    /**************************************************************************************************************/

    PolyLineRenderer.prototype.addGeometry = function(layer, geometry, style) {
        var bucket = new Bucket(layer, style, geometry, this.globe.renderContext);
        bucket.renderer = this;
        bucket.id = this.globe.getRendererManager().bucketId++;
        bucket.mainRenderable.build(geometry);

        geometry._bucket = bucket;
        layer._bucket = bucket;

        this.buckets.push(bucket);
    };

    /**************************************************************************************************************/

    PolyLineRenderer.prototype.removeGeometry = function(layer, geometry) {
        var bucket = layer._bucket;
        if (bucket.mainRenderable) {
            // Cleanup opengl resources
            bucket.mainRenderable.dispose(this.globe.renderContext);
            bucket.mainRenderable = null;
        }

        const index = this.buckets.indexOf(bucket);
        if (index !== -1) {
            this.buckets.splice(index, 1);
        }
    };

    /**************************************************************************************************************/

    /**
     *    Render all the lines
     * @function render
     * @memberof PolyLineRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    PolyLineRenderer.prototype.render = function(renderables, start, end) {
        const rc = this.globe.renderContext;
        const gl = rc.gl;

        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);

        // Compute the viewProj matrix
        var viewProjMatrix = mat4.create();
        mat4.multiply(
            rc.projectionMatrix,
            rc.viewMatrix,
            viewProjMatrix
        );

        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            renderable.render(rc, viewProjMatrix);
        }

        // Revert line width
        gl.lineWidth(1.0);

        //gl.enable(gl.DEPTH_TEST);
        //gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.depthFunc(gl.LESS);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof PolyLineRenderer.prototype
     * @param type
     * @param style
     * @return {Boolean} Can apply ?
     */
    PolyLineRenderer.prototype.canApply = function(type, style) {
        if (style.onTerrain === undefined || style.onTerrain === true) {
            return false;
        }

        return (
            type === Constants.GEOMETRY.LineString ||
            type === Constants.GEOMETRY.MultiLineString);
    };

    /**************************************************************************************************************/

    /**
     * Create a bucket
     * @function createBucket
     * @memberof PolyLineRenderer.prototype
     * @param layer
     * @param style
     * @return {PolyLineBucket} Bucket
     */
    PolyLineRenderer.prototype.createBucket = function(layer, style) {
        return new Bucket(layer, style);
    };

    /**************************************************************************************************************/

    // Register the renderer
    RendererManager.factory.push(function(globe) {
        return new PolyLineRenderer(globe);
    });
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Context/AbstractContext',[
    "jquery",
    "underscore-min",
    "../Utils/Event",
    "moment",
    "../Utils/Utils",
    "../Time/Time",
    "../Utils/UtilsIntersection",
    "../Services/ServiceFactory",
    "../Utils/Constants",
    "../Registry/WMSServerRegistryHandler",
    "../Registry/WMTSServerRegistryHandler",
    "../Registry/WCSServerRegistryHandler",
    "../Registry/OpenSearchRegistryHandler",
    "../Registry/PendingLayersRegistryHandler",
    "../Registry/LayerRegistryHandler",
    "../Gui/Compass",
    "../Gui/Tracker/PositionTracker",
    "../Gui/Tracker/ElevationTracker",
    "../Utils/AttributionHandler",
    "../Gui/dialog/ErrorDialog",
    "../Renderer/PointRenderer",
    "../Renderer/LineStringRenderable",
    "../Renderer/PolygonRenderer",
    "../Renderer/LineRenderer",
    "../Renderer/PointSpriteRenderer",
    "../Renderer/ConvexPolygonRenderer",
    "../Renderer/PolyLineRenderer"
], function (
    $,
    _,
    Event,
    Moment,
    Utils,
    Time,
    UtilsIntersection,
    ServiceFactory,
    Constants,
    WMSServerRegistryHandler,
    WMTSServerRegistryHandler,
    WCSServerRegistryHandler,
    OpenSearchRegistryHandler,
    PendingLayersRegistryHandler,
    LayerRegistryHandler,
    Compass,
    PositionTracker,
    ElevationTracker,
    AttributionHandler,
    ErrorDialog
) {
    //TODO : attention de bien garder les ...Renderer dans le define

    /**
     * Default ID for position tracker
     * @constant
     * @type {string}
     * @default
     */
    const DEFAULT_POSITION_TRACKER_ELT = "posTracker";
    /**
     * Default position for position tracker
     * @constant
     * @type {string}
     * @default
     */
    const DEFAULT_POSITION_TRACKER_ELT_POS = "bottom";
    /**
     * Default ID for elevation tracker
     * @constant
     * @type {string}
     * @default
     */
    const DEFAULT_ELEVATION_TRACKER_ELT = "elevTracker";
    /**
     * Default position for elevation tracker
     * @constant
     * @type {string}
     * @default
     */
    const DEFAULT_ELEVATION_TRACKER_ELT_POS = "bottom";
    /**
     * Default ID for compass
     * @constant
     * @type {string}
     * @default
     */
    const DEFAULT_COMPASS_ELT = "compassDiv";
    /**
     * Default ID for attribution
     * @constant
     * @type {string}
     * @default
     */
    const DEFAULT_ATTRIBUTION_ELT = "globeAttributions";

    /**
     * @constant
     * @type{{RA:{string},DEC:{String}}}
     */
    const TARGET_POS = {
        RA: "initialRa",
        DEC: "initialDec"
    };

    /**
     * @constant
     * @type {number}
     * @default
     */
    const DEFAULT_ZOOM_DURATION = 3000;

    /**
     * @name AbstractContext
     * @class
     * A context is the main webGL object that contains its own coordinate reference system,
     * its own data, its own navigation and its own GUI.<br/>
     * Client implementations should not normally instantiate this class directly.
     * @param {Mizar.configuration} mizarConfiguration - Mizar configuration
     * @param {CONTEXT} mode - the type of context
     * @param {AbstractContext.skyContext|AbstractContext.planetContext} ctxOptions - sky or planet options
     * @implements {Context}
     * @listens Layer#baseLayersReady
     */
    var AbstractContext = function(mizarConfiguration, mode, ctxOptions) {
        Event.prototype.constructor.call(this);
        var self = this;
        this.time = Time.parse(Moment().toISOString());
        this.globe = null; // Sky or globe
        this.navigation = null;
        this.attributionHandler = null;
        this.components = {};
        this.dataProviders = {};
        this.canvas = mizarConfiguration.canvas;
        this.isMobile = ctxOptions.isMobile;
        this.isEnableCtx = true;

        // Link to time travel service
        this.timeTravelService = ctxOptions.timeTravelService;

        this.subscribe(Constants.EVENT_MSG.BASE_LAYERS_READY, function(
            imagery
        ) {
            // When the background takes time to load, the viewMatrix computed by "computeViewMatrix" is created but
            // with empty values. Because of that, the globe cannot be displayed without moving the camera.
            // So we rerun "computeViewMatrix" once "baseLayersReady" is loaded to display the globe
            if (
                self.getNavigation().getRenderContext().viewMatrix[0] !==
                "undefined"
            ) {
                self.getNavigation().computeViewMatrix();
            }
        });
        this.mizarConfiguration = mizarConfiguration.hasOwnProperty(
            "configuration"
        )
            ? mizarConfiguration.configuration
            : {};
        this.ctxOptions = ctxOptions;
        this.mode = mode;
        this.layers = [];
        this.pendingLayers = [];
        this.initCanvas(this.canvas);

        try {
            this.positionTracker = _createTrackerPosition.call(
                this,
                this.mizarConfiguration
            );
        } catch (err) {
            ErrorDialog.open(
                Constants.LEVEL.DEBUG,
                "Cannot create position tracker",
                err
            );
        }

        try {
            this.elevationTracker = _createTrackerElevation.call(
                this,
                this.mizarConfiguration,
                ctxOptions
            );
        } catch (err) {
            ErrorDialog.open(
                Constants.LEVEL.DEBUG,
                "Cannot create elevation tracker",
                err
            );
        }

        try {
            this.compass = _createCompass.call(this, this.mizarConfiguration);
        } catch (err) {
            ErrorDialog.open(
                Constants.LEVEL.DEBUG,
                "Cannot create compass tracker",
                err
            );
        }
    };

    function _initComponentsVisibility(components) {
        // Show UI components depending on its state
        for (var componentId in components) {
            if (_isDivExist(componentId)) {
                if (components[componentId]) {
                    $("#" + componentId).fadeIn(1000);
                } else {
                    $("#" + componentId).fadeOut();
                }
            }
        }
    }

    function _isDivExist(divID) {
        return $("#" + divID).length;
    }

    /**
     * Zoom to the selected layer.
     * @param {Layer} layer - selected layer
     * @private
     */
    function _handleCameraWhenLayerAdded(layer) {
        if (
            layer.isVisible() &&
            layer.getProperties() &&
            !layer.isBackground() &&
            layer.getProperties().hasOwnProperty(TARGET_POS.RA) &&
            layer.getProperties().hasOwnProperty(TARGET_POS.DEC)
        ) {
            var fov = layer.getProperties().initialFov
                ? layer.getProperties().initialFov
                : layer
                    .getGlobe()
                    .getRenderContext()
                    .getFov();
            var navigation = layer.callbackContext.getNavigation();
            var center = navigation.getCenter();
            var globeType = layer.globe.getType();
            switch (globeType) {
            case Constants.GLOBE.Sky:
                navigation.zoomTo(
                    [
                        layer.getProperties().initialRa,
                        layer.getProperties().initialDec
                    ],
                    {
                        fov: fov,
                        duration: DEFAULT_ZOOM_DURATION
                    }
                );
                break;
            case Constants.GLOBE.Planet:
                var bbox = layer.getProperties().bbox;
                if (
                    UtilsIntersection.isValueBetween(
                        center[0],
                        bbox[0],
                        bbox[2]
                    ) &&
                        UtilsIntersection.isValueBetween(
                            center[1],
                            bbox[1],
                            bbox[3]
                        )
                ) {
                    // Do not move, we see the target
                } else {
                    var crs = layer.globe.getCoordinateSystem();
                    var planetRadius = crs
                        .getGeoide()
                        .getRealPlanetRadius();
                    var distanceCamera = Utils.computeDistanceCameraFromBbox(
                        bbox,
                        fov,
                        planetRadius,
                        crs.isFlat()
                    );
                    navigation.zoomTo(
                        [
                            layer.getProperties().initialRa,
                            layer.getProperties().initialDec
                        ],
                        {
                            distance: distanceCamera,
                            duration: 3000
                        }
                    );
                }
                break;
            default:
                throw new Error(
                    "type " + globeType + " is not implemented",
                    "AbstractContext.js"
                );
            }
        }
    }

    /**
     * Creates position tracker
     *
     * When no position tracker element is defined in the configuration,
     * then {@link DEFAULT_POSITION_TRACKER_ELT} is the default element
     * @param {Mizar.configuration} mizarConfiguration
     * @returns {PositionTracker} positionTracker object or null when the tracker is not configured
     * @throws {ReferenceError} Can't get the Div to insert the tracker
     * @private
     */
    function _createTrackerPosition(mizarConfiguration) {
        return new PositionTracker({
            element:
                mizarConfiguration.positionTracker &&
                mizarConfiguration.positionTracker.element
                    ? mizarConfiguration.positionTracker.element
                    : DEFAULT_POSITION_TRACKER_ELT,
            isMobile: mizarConfiguration.isMobile,
            position:
                mizarConfiguration.positionTracker &&
                mizarConfiguration.positionTracker.position
                    ? mizarConfiguration.positionTracker.position
                    : DEFAULT_POSITION_TRACKER_ELT_POS
        });
    }

    /**
     * Creates elevation tracker.
     * When no elevation tracker element is defined in the configuration,
     * then {@link DEFAULT_ELEVATION_TRACKER_ELT} is the default element
     * @param {Mizar.configuration} mizarConfiguration - Mizar configuration
     * @param {AbstractContext.planetContext} ctxOptions - options
     * @returns {ElevationTracker} elevationTracker object or null when the tracker is not configured
     * @throws {ReferenceError} Can't get the Div to insert the tracker
     * @private
     */
    function _createTrackerElevation(mizarConfiguration, ctxOptions) {
        return new ElevationTracker({
            element:
                mizarConfiguration.elevationTracker &&
                mizarConfiguration.elevationTracker.element
                    ? mizarConfiguration.elevationTracker.element
                    : DEFAULT_ELEVATION_TRACKER_ELT,
            isMobile: mizarConfiguration.isMobile,
            position:
                mizarConfiguration.elevationTracker &&
                mizarConfiguration.elevationTracker.elevation
                    ? mizarConfiguration.elevationTracker.position
                    : DEFAULT_ELEVATION_TRACKER_ELT_POS,
            elevationLayer:
                ctxOptions.planetLayer !== undefined
                    ? ctxOptions.planetLayer.elevationLayer
                    : undefined
        });
    }

    /**
     * Creates compass.
     * When no compass element is defined in the configuration,
     * then {@link DEFAULT_COMPASS_ELT} is the default element
     * @param {Mizar.configuration} mizarConfiguration - Mizar configuration
     * @returns {Compass}
     * @throws {ReferenceError} can't get the div to insert the compass
     * @private
     */
    function _createCompass(mizarConfiguration) {
        return new Compass({
            element: mizarConfiguration.compass
                ? mizarConfiguration.compass
                : DEFAULT_COMPASS_ELT,
            ctx: this,
            isMobile: this.isMobile
        });
    }

    /**
     * Adds to the globe either as background or as additional layer
     * @param {Layer} layer - layer to add.
     * @fires Context#backgroundLayer:changed
     * @fires Context#backgroundLayer:added
     * @fires Context#layer:added
     * @private
     */
    function _addToGlobe(layer) {
        if (!this._getGlobe().hasDefinedBackground() && layer.isBackground()) {
            this._getGlobe().setBaseImagery(layer);
        } else {
            this._getGlobe().addLayer(layer);
        }
    }

    /**
     * Removes the layer from rasterOverlayRenderer and set the background attribute to true.
     *
     * When the user uses setBackgroundLayer or setBackgroundLayerByID,
     * the layer had background = false as attribute , so it was add it as a simple overlay.
     * To add the layer as background, first we need to remove it from rasterOverlayRenderer.
     * @param {Layer} layer
     * @private
     */
    function _removeRasterOverlay(layer) {
        // todo : when added a layer without background = true and then using setBackgroundLayer
        // the screen blink. It seems, this is due to the removeOverlay
        if (
            layer.getInformationType() === Constants.INFORMATION_TYPE.RASTER &&
            !layer.isBackground()
        ) {
            this._getGlobe().rasterOverlayRenderer.removeOverlay(layer);
            layer.background = true;
        }
    }

    /**************************************************************************************************************/
    Utils.inherits(Event, AbstractContext);
    /**************************************************************************************************************/

    /**
     * @function getTime
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getTime = function() {
        return this.time;
    };

    /**
     * @function setTime
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.setTime = function(time) {
        this.time = Time.parse(time);
        for (var i = 0; i < this.layers.length; i++) {
            var layer = this.layers[i];
            layer.setTime(this.time);
        }
    };

    /**
     * ShowUp message.<br/>
     * Do not display the canvas with the ID <i>MizarCanvas</i> and the loading icon and displays
     * the HTML element with the ID <i>webGLNotAvailable</i>
     * @param err
     * @protected
     * @todo Mettre en paramtre MizarCanvas et webGLNotAvailable
     */
    AbstractContext.prototype._showUpError = function(err) {
        if (document.getElementById("MizarCanvas")) {
            document.getElementById("MizarCanvas").style.display = "none";
        }
        if (document.getElementById("loading")) {
            document.getElementById("loading").style.display = "none";
        }
        if (document.getElementById("webGLNotAvailable")) {
            document.getElementById("webGLNotAvailable").style.display =
                "block";
        }
    };

    /**
     * Fill data-provider-type layer by features coming from data object
     * @function _fillDataProvider
     * @param {Layer} layer - layer in which data should be added.
     * @param {Object} mizarDescription - See the base properties {@link AbstractLayer.configuration} and a specific layer for specific properties
     * @memberof AbstractContext#
     * @protected
     */
    AbstractContext.prototype._fillDataProvider = function(
        layer,
        mizarDescription
    ) {
        if (
            mizarDescription.data &&
            this.dataProviders[mizarDescription.data.type]
        ) {
            var callback = this.dataProviders[mizarDescription.data.type];
            callback(layer, mizarDescription.data);
        }
    };

    /**
     * Returns the data provider layers or an empty array when no data provider layer.
     * @function getDataProviderLayers
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getDataProviderLayers = function() {
        var dpLayers = [];
        var layers = this.getLayers();
        var i = layers.length;
        var layer = layers[i];
        while (layer) {
            if (
                layer.hasOwnProperty("options") &&
                layer.options.hasOwnProperty("type") &&
                layer.options.type === Constants.LAYER.GeoJSON
            ) {
                dpLayers.push(layer);
            }
            layer = layers[++i];
        }
        return dpLayers;
    };

    /**
     * @function getTileManager
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getTileManager = function() {
        return this._getGlobe().getTileManager();
    };

    /**
     * Registers no standard data provider and call them in the addLayer method.
     * @function registerNoStandardDataProvider
     * @param {string} type - data provider key
     * @param {Function} loadFunc - Function
     * @memberof AbstractContext#
     * @example <caption>Registers planets on the sky</caption>
     *   var planetProvider = ProviderFactory.create(Constants.PROVIDER.Planet);
     *   this.registerNoStandardDataProvider("planets", planetProvider.loadFiles);
     */
    AbstractContext.prototype.registerNoStandardDataProvider = function(
        type,
        loadFunc
    ) {
        this.dataProviders[type.toString()] = loadFunc;
    };

    /**
     * @function getContextConfiguration
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getContextConfiguration = function() {
        return this.ctxOptions;
    };

    /**
     * @function getMizarConfiguration
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getMizarConfiguration = function() {
        return this.mizarConfiguration;
    };

    /**
     * @function _getGlobe
     * @memberof AbstractContext#
     * @private
     */
    AbstractContext.prototype._getGlobe = function() {
        return this.globe;
    };

    /**
     * @function getLonLatFromPixel
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getLonLatFromPixel = function(x, y) {
        return this._getGlobe().getLonLatFromPixel(x, y);
    };

    /**
     * @function getPixelFromLonLat
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getPixelFromLonLat = function(
        longitude,
        latitude
    ) {
        return this._getGlobe().getPixelFromLonLat(longitude, latitude);
    };

    /**
     * @function getElevation
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getElevation = function(lon, lat) {
        return this._getGlobe().getElevation(lon, lat);
    };

    /**
     * @function getPositionTracker
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getPositionTracker = function() {
        return this.positionTracker;
    };

    /**
     * @function getElevationTracker
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getElevationTracker = function() {
        return this.elevationTracker;
    };

    /**
     * @function getLayers
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getLayers = function() {
        return this.layers;
    };

    /**
     * @function getLayerByID
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getLayerByID = function(layerId) {
        return _.find(_.union(this.getLayers()), function(layer) {
            return layer.getID() === layerId;
        });
    };

    /**
     * @function getLayerByName
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getLayerByName = function(layerName) {
        return _.findWhere(this.getLayers(), { name: layerName });
    };

    /**
     * @function addLayer
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.addLayer = function(
        layerDescription,
        callback,
        fallback
    ) {
        var pendingLayersHandler = new PendingLayersRegistryHandler(
            this.pendingLayers,
            this.layers
        );
        var wmsServerHandler = new WMSServerRegistryHandler(
            this.pendingLayers
        );
        var wmtsServerHandler = new WMTSServerRegistryHandler(
            this.pendingLayers
        );
        var wcsServerHandler = new WCSServerRegistryHandler(
            this.layers,
            this.pendingLayers
        );

        var openSearchServerHandler = new OpenSearchRegistryHandler(
            this.pendingLayers
        );        
        var layerHandler = new LayerRegistryHandler(this.pendingLayers);

        pendingLayersHandler.setNext(wmsServerHandler);
        wmsServerHandler.setNext(wmtsServerHandler);
        wmtsServerHandler.setNext(wcsServerHandler);
        wcsServerHandler.setNext(openSearchServerHandler);
        openSearchServerHandler.setNext(layerHandler);

        var self = this;
        pendingLayersHandler.handleRequest(
            layerDescription,
            function(layers) {
                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i];
                    layer.callbackContext = self;

                    self.layers.push(layer);

                    // Take autoFillTimeTravel into account
                    if (layer.autoFillTimeTravel === true) {
                        // Only when visible & time travel service activated and available
                        if (
                            layer.visible === true &&
                            self.timeTravelService &&
                            typeof self.timeTravelService !== "undefined"
                        ) {
                            self.timeTravelService.update(
                                layer.timeTravelValues
                            );
                        }
                    }

                    _addToGlobe.call(self, layer);

                    self._fillDataProvider(layer, layerDescription);
                    if (layer.isVisible()) {
                        layer.setTime(self.getTime());
                    }

                    if (layer.isPickable()) {
                        ServiceFactory.create(
                            Constants.SERVICE.PickingManager
                        ).addPickableLayer(layer);
                    }

                    layer.subscribe(
                        Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED,
                        _handleCameraWhenLayerAdded
                    );

                    //if (layer.addEventTime) {
                    //    layer.addEventTime();
                    //}

                    if (callback) {
                        callback(layer.ID);
                    }
                }
            },
            function(e) {
                if (fallback) {
                    fallback(e);
                } else {
                    ErrorDialog.open(
                        Constants.LEVEL.ERROR,
                        "Cannot create the layer(s)",
                        e
                    );
                }
            }
        );
    };

    /**
     * @function getLinkedLayers
     * @memberof AbstractContext#
     * @return {Array} Array of linked layers
     * @private
     */

    AbstractContext.prototype.getLinkedLayers = function(layerID) {
        // Search linked layers
        var indexes = $.map(this.layers, function(obj, index) {
            if (obj.linkedTo === layerID) {
                return index;
            }
        });
        var linkedLayers = [];
        for (var i = 0; i < indexes.length; i++) {
            linkedLayers.push(this.layers[indexes[i]]);
        }
        return linkedLayers;
    };

    /**
     * @function removeLayer
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.removeLayer = function(layerID) {
        var removedLayer = null;
        var indexes = $.map(this.layers, function(obj, index) {
            if (obj.ID === layerID) {
                return index;
            }
        });

        if (indexes.length > 0) {
            // At least one layer to remove
            var removedLayers = this.layers.splice(indexes[0], 1);
            removedLayer = removedLayers[0];
            if (removedLayer.autoFillTimeTravel === true) {
                this.timeTravelService.update({
                    remove: { ID: layerID }
                });
            }
            var tileManager = this.getTileManager();
            tileManager.abortLayerRequests(removedLayer);

            removedLayer.unsubscribe(
                Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED,
                _handleCameraWhenLayerAdded
            );
            ServiceFactory.create(
                Constants.SERVICE.PickingManager
            ).removePickableLayer(removedLayer);

            this._getGlobe().removeLayer(removedLayer);
            this.getRenderContext().requestFrame();
        }
        return removedLayer;
    };

    /**
     * @function removeAllLayers
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.removeAllLayers = function() {
        var nbLayers = this.layers.length;
        while (nbLayers != 0) {
            var layerIndex = nbLayers - 1;
            var layerID = this.layers[layerIndex].ID;
            if (this.attributionHandler != null)
                this.attributionHandler.removeAttribution(
                    this.layers[layerIndex]
                );
            this.removeLayer(layerID);
            nbLayers--;
        }
    };

    /**
     * @function addDraw
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.addDraw = function(layer) {
        Utils.assert(
            layer.type === Constants.LAYER.Vector,
            "layer must be a vector layer in addDraw",
            "AbstractContext.js"
        );
        layer.setDraw(true);
        this._getGlobe().addLayer(layer);
    };

    /**
     * @function removeDraw
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.removeDraw = function(layer) {
        this._getGlobe().removeLayer(layer);
    };

    /**
     * @function refresh
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.refresh = function() {
        if (this._getGlobe()) {
            this._getGlobe().refresh();
        }
    };

    /**************************************************************************************************************/

    /**
     * Initialization of the canvas element.
     * When no canvas element is provided, sets to full screen.
     * @function initCanvas
     * @memberof AbstractContext#
     * @param {Object} canvas Canvas object
     * @param {?Object} canvas.parentElement HTML object
     */
    AbstractContext.prototype.initCanvas = function(canvas) {
        var width, height;
        var parentCanvas = $(canvas.parentElement);

        $(canvas.parentElement)
            .find("#loading")
            .show();

        if ($(canvas).attr("width")) {
            width = $(canvas).attr("width");
        } else if (parentCanvas.attr("width")) {
            width = parentCanvas.attr("width");
        } else {
            //full screen
            width = window.innerWidth;
        }

        if ($(canvas).attr("height")) {
            height = $(canvas).attr("height");
        } else if (parentCanvas.attr("height")) {
            height = parentCanvas.attr("height");
        } else {
            //full screen
            height = window.innerHeight;
        }

        canvas.width = width;
        canvas.height = height;

        // Add some useful css properties to parent element
        if (parentCanvas) {
            parentCanvas.css({
                position: "relative",
                overflow: "hidden"
            });
        }

        // Define on resize function
        var self = this;
        var onResize = function() {
            if (
                parentCanvas &&
                parentCanvas.attr("height") &&
                parentCanvas.attr("width")
            ) {
                // Embedded
                canvas.width = parentCanvas.width();
                canvas.height = parentCanvas.height();
            } else {
                // Fullscreen
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            self.refresh();
        };

        // Take into account window resize 1s after resizing stopped
        var timer;
        $(window).resize(function() {
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(onResize, 500);
        });

        // Context lost listener
        canvas.addEventListener(
            "webglcontextlost",
            function(event) {
                // TODO
                event.preventDefault();
                document.getElementById("loading").style.display = "none";
                document.getElementById("webGLContextLost").style.display =
                    "block";
            },
            false
        );
    };

    /**
     * Initializes the planet or sky events.
     * @function iniGlobeEvents
     * @memberof AbstractContext#
     * @param {AbstractGlobe} globe Planet or Sky object
     */
    AbstractContext.prototype.initGlobeEvents = function(globe) {
        if (globe) {
            this.globe = globe;
            this.attributionHandler = new AttributionHandler(this.globe, {
                element:
                    this.mizarConfiguration.attributionHandler &&
                    this.mizarConfiguration.attributionHandler.element
                        ? this.mizarConfiguration.attributionHandler.element
                        : DEFAULT_ATTRIBUTION_ELT
            });

            if (this.positionTracker != null) {
                this.positionTracker.attachTo(this);
                // it will be updated by the position tracker
                this.setComponentVisibility("posTrackerInfo", false);
            }

            if (this.elevationTracker != null) {
                this.elevationTracker.attachTo(this);
            }

            if (this.compass != null) {
                this.compass.attachTo(this);
            }
        } else {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "AbstractContext.js", "Globe is null in initGlobeEvents");
        }

        _initComponentsVisibility(this.components);

        //When base layer failed to load, open error dialog
        var self = this;
        this.subscribe(Constants.EVENT_MSG.BASE_LAYERS_ERROR, function(layer) {
            $(self.canvas.parentElement)
                .find("#loading")
                .hide();
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot add the layer " +
                    layer.name ? layer.name : layer.ID +
                    "from " +
                    layer.getBaseUrl(),
                layer.message
            );
        });
    };

    /**************************************************************************************************************/

    /**
     * @function isEnabled
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.isEnabled = function() {
        return this.isEnableCtx;
    };

    /**
     * @function isDisabled
     * @memberof AbstractContext#
     */

    AbstractContext.prototype.isDisabled = function() {
        return !this.isEnabled();
    };

    /**
     * @function show
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.show = function() {
        this.navigation.start();
        this.showComponents();
    };

    /**
     * @function showComponents
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.showComponents = function() {
        // Show UI components depending on its state
        for (var componentId in this.components) {
            if (_isDivExist(componentId) && this.components[componentId]) {
                $("#" + componentId).fadeIn(1000);
            }
        }
    };

    /**
     * @function hideComponents
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.hideComponents = function(uiArray) {
        // Hide all the UI components
        for (var componentId in this.components) {
            if (
                _isDivExist(componentId) &&
                $.inArray(componentId, uiArray) === -1
            ) {
                $("#" + componentId).fadeOut();
            }
        }
    };

    /**
     * @function hide
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.hide = function() {
        this.navigation.stopAnimations();
        this.navigation.stop();

        // Hide all the UI components
        for (var componentId in this.components) {
            if (_isDivExist(componentId)) {
                $("#" + componentId).fadeOut();
            }
        }
    };

    /**
     * @function setComponentVisibility
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.setComponentVisibility = function(
        componentId,
        isVisible
    ) {
        var component = $("#" + componentId);
        if (isVisible) {
            component.show();
        } else {
            component.hide();
        }

        this.components[componentId] = isVisible;
    };

    /**
     * @function getComponentVisibility
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getComponentVisibility = function(componentId) {
        return this.components[componentId];
    };

    /**************************************************************************************************************/

    /**
     * @function showAdditionalLayers
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.showAdditionalLayers = function() {
        _.each(this.visibleLayers, function(layer) {
            layer.setVisible(true);
            if (layer.isPickable()) {
                ServiceFactory.create(
                    Constants.SERVICE.PickingManager
                ).addPickableLayer(layer);
            }
        });
    };

    /**
     * @function hideAdditionalLayers
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.hideAdditionalLayers = function() {
        var self = this;
        this.visibleLayers = [];
        var gwLayers = this.getAdditionalLayers();
        _.each(gwLayers, function(layer) {
            if (layer.isVisible()) {
                layer.setVisible(false);
                self.visibleLayers.push(layer);
            }
        });
    };

    /**
     * @function setBackgroundLayer
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.setBackgroundLayer = function(survey) {
        // Find the layer by name among all the layers
        var gwLayer = this.getLayerByName(survey);
        if (gwLayer) {
            _removeRasterOverlay.call(this, gwLayer);
            this._getGlobe().setBaseImagery(gwLayer);
        } else {
            this.publish(
                Constants.EVENT_MSG.LAYER_BACKGROUND_ERROR,
                survey + " hasn't been found"
            );
        }
        return gwLayer;
    };

    /**
     * @function setBackgroundLayerByID
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.setBackgroundLayerByID = function(surveyID) {
        // Find the layer by name among all the layers
        var gwLayer = this.getLayerByID(surveyID);
        if (gwLayer) {
            _removeRasterOverlay.call(this, gwLayer);
            this._getGlobe().setBaseImagery(gwLayer);
        } else {
            this.publish(
                Constants.EVENT_MSG.LAYER_BACKGROUND_ERROR,
                surveyID + " hasn't been found"
            );
        }
        return gwLayer;
    };

    /**
     * @function getAdditionalLayers
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getAdditionalLayers = function() {
        return _.filter(this.layers, function(layer) {
            return layer.category !== "background";
        });
    };

    /**
     * @function getRenderContext
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getRenderContext = function() {
        return this._getGlobe().getRenderContext();
    };

    /**
     * @function disbable
     * @memberof AbstractContext#
     * @abstract
     */
    AbstractContext.prototype.disable = function() {
        if (this.positionTracker) {
            this.positionTracker.detach();
        }
        if (this.elevationTracker) {
            this.elevationTracker.detach();
        }
        if (this.compass) {
            this.compass.detach();
        }
        var i = 0;
        var layer = this.layers[i];
        while (layer) {
            if (this.attributionHandler != null)
                this.attributionHandler.disable(layer);
            layer = this.layers[++i];
        }
        var renderers = this.getRenderContext().renderers;
        for (var j = 0; j < renderers.length; j++) {
            if (renderers[j].getType() === this.getMode()) {
                renderers[j].disable();
            }
        }
        this.isEnableCtx = false;
    };

    /**
     * @function enable
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.enable = function() {
        if (this.positionTracker != null) this.positionTracker.attachTo(this);

        if (this.elevationTracker != null) this.elevationTracker.attachTo(this);

        if (this.compass != null) this.compass.attachTo(this);

        var i = 0;
        var layer = this.layers[i];
        while (layer) {
            if (layer.isPickable()) {
                ServiceFactory.create(
                    Constants.SERVICE.PickingManager
                ).addPickableLayer(layer);
            }
            if (this.AttributionHandler != null)
                this.attributionHandler.enable(layer);
            layer = this.layers[++i];
        }
        var renderers = this.getRenderContext().renderers;
        for (i = 0; i < renderers.length; i++) {
            if (renderers[i].getType() === this.getMode()) {
                renderers[i].enable();
            }
        }
        this.isEnableCtx = true;
    };

    /**
     * @function setCompassVisible
     * @memberof AbstractContext#
     * @abstract
     */
    AbstractContext.prototype.setCompassVisible = function(divName, visible) {
        throw new SyntaxError(
            "compass visible not implemented",
            "AbstractContext.js"
        );
    };

    /**
     * @function setTimeTravelVisible
     * @memberof AbstractContext#
     * @abstract
     */
    AbstractContext.prototype.setTimeTravelVisible = function(
        divName,
        visible
    ) {
        throw new SyntaxError(
            "time travel visible not implemented",
            "AbstractContext.js"
        );
    };

    /**
     * @function getMode
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getMode = function() {
        return this.mode;
    };

    /**
     * @function setCoordinateSystem
     * @memberof AbstractContext#
     * @abstract
     */
    AbstractContext.prototype.setCoordinateSystem = function(cs) {
        throw new SyntaxError("CRS not implemented", "AbstractContext.js");
    };

    /**
     * @function getNavigation
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getNavigation = function() {
        return this.navigation;
    };

    /**
     * @function getCoordinateSystem
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.getCoordinateSystem = function() {
        return this._getGlobe().getCoordinateSystem();
    };

    /**
     * @function addAnimation
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.addAnimation = function(anim) {
        this._getGlobe().addAnimation(anim);
    };

    /**
     * @function removeAnimation
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.removeAnimation = function(anim) {
        this._getGlobe().removeAnimation(anim);
    };

    /**
     * @function render
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.render = function() {
        this._getGlobe().render();
    };

    /**
     * @function dispose
     * @memberof AbstractContext#
     */
    AbstractContext.prototype.dispose = function() {
        this._getGlobe().dispose();
    };

    AbstractContext.prototype.trackerDestroy = function() {
        if (this.elevationTracker) {
            this.elevationTracker.destroy();
            this.elevationTracker = null;
        }
        if (this.positionTracker) {
            this.positionTracker.destroy();
            this.positionTracker = null;
        }
    };

    /**i
     * @function destroy
     * @memberof AbstractContext#
     * @abstract
     */
    AbstractContext.prototype.destroy = function() {
        this.hide();
        this.trackerDestroy();
        if (this.compass) {
            this.compass.destroy();
            this.compass = null;
        }
        this.removeAllLayers();
        this.components = null;
        this.attributionHandler = null;
        this.layers = null;
        this.visibleLayers = null;
        this.dataProviders = null;
        this.mizarConfiguration = null;
        this.ctxOptions = null;
        this.mode = null;

        this.unsubscribe(Constants.EVENT_MSG.BASE_LAYERS_READY, function(
            imagery
        ) {
            // When the background takes time to load, the viewMatrix computed by "computeViewMatrix" is created but
            // with empty values. Because of that, the globe cannot be displayed without moving the camera.
            // So we rerun "computeViewMatrix" once "baseLayersReady" is loaded to display the globe
            if (
                self.getNavigation().getRenderContext().viewMatrix[0] !==
                "undefined"
            ) {
                self.getNavigation().computeViewMatrix();
            }
        });

        if (this.navigation) {
            this.navigation.destroy();
            this.navigation = null;
        }

        if (this._getGlobe()) {
            this._getGlobe().destroy();
            this.globe = null;
        }
        this.canvas = null;
    };

    /**************************************************************************************************************/

    return AbstractContext;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/TilePool',[],function() {
    /**************************************************************************************************************/

    /**
     @constructor
     TilePool constructor
     */
    var TilePool = function(rc) {
        // Private properties
        var gl = rc.gl;
        var glTexturePools = {};
        var glBuffers = [];
        var self = this;

        // Choose floating point texture filtering depending on extension support
        var float_linear_ext = gl.getExtension("OES_texture_float_linear");
        var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST;

        // Public properties
        this.numCreatedTextures = 0;
        this.numReusedTextures = 0;

        // Private methods

        /**************************************************************************************************************/

        /**
         Create a new GL texture
         */
        var createNewGLTexture = function(image, texturePool) {
            var glTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            if (image.dataType === "byte") {
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGBA,
                    gl.RGBA,
                    gl.UNSIGNED_BYTE,
                    image
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MIN_FILTER,
                    gl.LINEAR_MIPMAP_LINEAR
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MAG_FILTER,
                    gl.LINEAR
                );
                gl.generateMipmap(gl.TEXTURE_2D);
            } else {
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.LUMINANCE,
                    image.width,
                    image.height,
                    0,
                    gl.LUMINANCE,
                    gl.FLOAT,
                    image.typedArray
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MIN_FILTER,
                    float_filtering
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MAG_FILTER,
                    float_filtering
                );
            }

            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_S,
                gl.CLAMP_TO_EDGE
            );
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_T,
                gl.CLAMP_TO_EDGE
            );
            glTexture.pool = texturePool;
            self.numCreatedTextures++;

            return glTexture;
        };

        /**************************************************************************************************************/

        /**
         Reuse a GL texture
         */
        var reuseGLTexture = function(image, texturePool) {
            var glTexture = texturePool.pop();
            gl.bindTexture(gl.TEXTURE_2D, glTexture);

            if (image.dataType === "byte") {
                //gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGBA,
                    gl.RGBA,
                    gl.UNSIGNED_BYTE,
                    image
                );
                gl.generateMipmap(gl.TEXTURE_2D);
            } else {
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.LUMINANCE,
                    image.width,
                    image.height,
                    0,
                    gl.LUMINANCE,
                    gl.FLOAT,
                    image.typedArray
                );
            }

            self.numReusedTextures++;

            return glTexture;
        };

        /**
         * Get or create a texture pool for the given image
         */
        var getOrCreateTexturePool = function(image) {
            var key = image.dataType + image.width;
            if (!glTexturePools[key]) {
                glTexturePools[key] = [];
            }
            return glTexturePools[key];
        };

        // Public methods

        /**************************************************************************************************************/

        /**
         Create a GL texture to be used by a tile
         */
        this.createGLTexture = function(image) {
            var texturePool = getOrCreateTexturePool(image);

            if (texturePool.length > 0) {
                return reuseGLTexture(image, texturePool);
            } else {
                return createNewGLTexture(image, texturePool);
            }
        };

        /**************************************************************************************************************/

        /**
         Create a GL texture to be used by a tile
         */
        this.createGLBuffer = function(vertices) {
            var vb;
            if (glBuffers.length > 0) {
                vb = glBuffers.pop();
            } else {
                vb = gl.createBuffer();
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, vb);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            return vb;
        };

        /**************************************************************************************************************/

        /**
         Dispose a texture
         */
        this.disposeGLTexture = function(texture) {
            texture.pool.push(texture);
        };

        /**************************************************************************************************************/

        /**
         Dispose a texture
         */
        this.disposeGLBuffer = function(buffer) {
            glBuffers.push(buffer);
        };

        /**************************************************************************************************************/

        /**
         Dispose all
         */

        this.disposeAll = function() {
            var i;
            for (var key in glTexturePools) {
                if (glTexturePools.hasOwnProperty(key)) {
                    var glTextures = glTexturePools[key];
                    for (i = 0; i < glTextures.length; i++) {
                        gl.deleteTexture(glTextures[i]);
                    }
                }
            }
            glTexturePools = {};

            for (i = 0; i < glBuffers.length; i++) {
                gl.deleteBuffer(glBuffers[i]);
            }
            glBuffers.length = 0;
        };

        /**************************************************************************************************************/
    };

    return TilePool;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/TileRequest',["./Tile", "../Utils/ImageRequest"], function(Tile, ImageRequest) {
    /**************************************************************************************************************/

    /**************************************************************************************************************/

    /** @constructor
     TileRequest constructor
     */
    var TileRequest = function(tileManager) {
        // Private variables
        var _imageLoaded = false;
        var _elevationLoaded = true;
        var _xhr = new XMLHttpRequest();
        var _imageRequest;

        // Public variables
        this.tile = null;
        this.elevations = null;
        this.image = null;

        var self = this;

        /**
         Handle when elevation is loaded
         */
        var _handleLoadedElevation = function() {
            self.elevations = tileManager.elevationProvider.parseElevations(
                _xhr.responseText
            );
            _elevationLoaded = true;

            if (_imageLoaded) {
                tileManager.pendingRequests.splice(
                    tileManager.pendingRequests.indexOf(self),
                    1
                );
                tileManager.completedRequests.push(self);
                tileManager.renderContext.requestFrame();
            }
        };

        /**************************************************************************************************************/

        /**
         Handle when loading elevation failed
         */
        var _handleErrorElevation = function() {
            self.elevations = null;
            _elevationLoaded = true;

            if (_imageLoaded) {
                tileManager.pendingRequests.splice(
                    tileManager.pendingRequests.indexOf(self),
                    1
                );
                tileManager.completedRequests.push(self);
                tileManager.renderContext.requestFrame();
            }
        };

        // Setup the XHR callback
        _xhr.onreadystatechange = function(e) {
            if (_xhr.readyState === 4) {
                if (_xhr.status === 200) {
                    _handleLoadedElevation();
                } else {
                    _handleErrorElevation();
                }
            }
        };

        /**************************************************************************************************************/

        /**
         Handle when image is loaded
         */
        var _handleLoadedImage = function() {
            // The method can be called twice when the image is in the cache (see launch())
            if (!_imageLoaded) {
                _imageLoaded = true;
                if (_elevationLoaded) {
                    // Call post-process function if defined
                    if (
                        tileManager.imageryProvider &&
                        tileManager.imageryProvider.handleImage
                    ) {
                        tileManager.imageryProvider.handleImage(_imageRequest);
                    }

                    tileManager.pendingRequests.splice(
                        tileManager.pendingRequests.indexOf(self),
                        1
                    );
                    tileManager.completedRequests.push(self);
                    tileManager.renderContext.requestFrame();
                }
                self.image = _imageRequest.image;
            }
        };

        /**************************************************************************************************************/

        /**
         Handle when loading image failed
         */
        var _handleErrorImage = function() {
            self.tile.state = Tile.State.ERROR;
            tileManager.pendingRequests.splice(
                tileManager.pendingRequests.indexOf(self),
                1
            );
            tileManager.availableRequests.push(self);
        };

        /**************************************************************************************************************/

        /**
         Abort request
         */
        var _handleAbort = function() {
            self.tile.state = Tile.State.NONE;
            tileManager.pendingRequests.splice(
                tileManager.pendingRequests.indexOf(self),
                1
            );
            tileManager.availableRequests.push(self);
        };

        /**************************************************************************************************************/

        /**
         Launch the HTTP request for a tile
         */
        this.launch = function(tile) {
            tile.state = Tile.State.LOADING;
            this.tile = tile;
            tileManager.pendingRequests.push(this);

            this.image = null;
            this.elevations = null;

            // Request the elevation if needed
            if (tileManager.elevationProvider && tileManager.elevationProvider.getUrl(tile) != null) {
                // TODO : handle the elevations coming from cache
                _elevationLoaded = false;
                _xhr.open("GET", tileManager.elevationProvider.getUrl(tile));

                // Set withCredentials property after "open": http://stackoverflow.com/questions/19666809/cors-withcredentials-support-limited?answertab=votes#tab-top
                var useCredentials =
                    tileManager.elevationProvider.crossOrigin ===
                    "use-credentials";
                _xhr.withCredentials = useCredentials;

                _xhr.send();
            } else {
                _elevationLoaded = true;
            }

            if (tileManager.imageryProvider && tileManager.imageryProvider.getUrl(tile)) {
                if (!_imageRequest) {
                    _imageRequest = new ImageRequest({
                        successCallback: function() {
                            _handleLoadedImage();
                            if (tileManager.imageryProvider.cache) {
                                tileManager.imageryProvider.cache.storeInCache(
                                    self
                                );
                            }
                        },
                        failCallback: _handleErrorImage,
                        abortCallback: _handleAbort
                    });
                }

                // Check if the image isn't already loaded in cache
                var cachedTileRequest;
                if (tileManager.imageryProvider.cache) {
                    cachedTileRequest = cachedTileRequest = tileManager.imageryProvider.cache.getFromCache(
                        tile
                    );
                }

                _imageLoaded = false;
                if (cachedTileRequest) {
                    _imageRequest.image = cachedTileRequest.image;
                    _handleLoadedImage();
                } else {
                    // Tile not found in cache or cache isn't activated, send the request
                    _imageRequest.send(
                        tileManager.imageryProvider.getUrl(tile),
                        tileManager.imageryProvider.crossOrigin
                    );
                }
            } else {
                _imageLoaded = true;
            }

            // Check if there is nothing to load
            if (
                !tileManager.imageryProvider &&
                !tileManager.elevationProvider
            ) {
                tileManager.pendingRequests.splice(
                    tileManager.pendingRequests.indexOf(this),
                    1
                );
                tileManager.completedRequests.push(this);
            }
        };

        /**************************************************************************************************************/

        /**
         *    Abort launched request
         */
        this.abort = function() {
            if (_imageRequest) {
                _imageRequest.abort();
            }
        };
    };

    /**************************************************************************************************************/

    return TileRequest;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/TileIndexBuffer',[],function() {
    /**************************************************************************************************************/

    /**
     @constructor TileIndexBuffer
     TileIndexBuffer
     */
    var TileIndexBuffer = function(renderContext, config) {
        this.renderContext = renderContext;
        this.config = config;
        this.solidIndexBuffer = null;
        this.indices = null;
        this.subSolidIndexBuffer = [null, null, null, null];
        this.subIndices = [null, null, null, null];
    };

    /**************************************************************************************************************/

    /**
     * Reset the index buffers.
     */
    TileIndexBuffer.prototype.reset = function() {
        var gl = this.renderContext.gl;
        for (var i = 0; i < 4; i++) {
            if (this.subSolidIndexBuffer[i]) {
                gl.deleteBuffer(this.subSolidIndexBuffer[i]);
                this.subSolidIndexBuffer[i] = null;
            }
        }
        if (this.solidIndexBuffer) {
            gl.deleteBuffer(this.solidIndexBuffer);
            this.solidIndexBuffer = null;
        }
    };

    /**************************************************************************************************************/

    /**
     *    Get index buffer for sub solid
     */
    TileIndexBuffer.prototype.getSubSolid = function(ii) {
        if (this.subSolidIndexBuffer[ii] === null) {
            var i = ii % 2;
            var j = Math.floor(ii / 2);
            var n, k;

            var size = this.config.tesselation;
            var halfTesselation = (size - 1) / 2;

            // Build the sub grid for 'inside' tile
            var indices = [];
            for (n = halfTesselation * j; n < halfTesselation * (j + 1); n++) {
                for (
                    k = halfTesselation * i;
                    k < halfTesselation * (i + 1);
                    k++
                ) {
                    indices.push(n * size + k);
                    indices.push((n + 1) * size + k);
                    indices.push(n * size + k + 1);

                    indices.push(n * size + k + 1);
                    indices.push((n + 1) * size + k);
                    indices.push((n + 1) * size + k + 1);
                }
            }

            this.subIndices[ii] = indices;

            if (this.config.skirt) {
                // Build skirts
                // Top skirt
                var start = j === 0 ? size * size : size * size + 4 * size;
                var src = j === 0 ? 0 : halfTesselation * size;
                for (
                    n = halfTesselation * i;
                    n < halfTesselation * (i + 1);
                    n++
                ) {
                    indices.push(start + n);
                    indices.push(src + n);
                    indices.push(start + n + 1);

                    indices.push(start + n + 1);
                    indices.push(src + n);
                    indices.push(src + n + 1);
                }

                // Bottom skirt
                start = j === 0 ? size * size + 4 * size : size * size + size;
                src = j === 0 ? halfTesselation * size : (size - 1) * size;
                for (
                    n = halfTesselation * i;
                    n < halfTesselation * (i + 1);
                    n++
                ) {
                    indices.push(src + n);
                    indices.push(start + n);
                    indices.push(src + n + 1);

                    indices.push(src + n + 1);
                    indices.push(start + n);
                    indices.push(start + n + 1);
                }

                // Left skirt
                start =
                    i === 0 ? size * size + 2 * size : size * size + 5 * size;
                src = i === 0 ? 0 : halfTesselation;
                for (
                    k = halfTesselation * j;
                    k < halfTesselation * (j + 1);
                    k++
                ) {
                    indices.push(start + k);
                    indices.push(start + k + 1);
                    indices.push(src + k * size);

                    indices.push(src + k * size);
                    indices.push(start + k + 1);
                    indices.push(src + (k + 1) * size);
                }

                // Right skirt
                start =
                    i === 0 ? size * size + 5 * size : size * size + 3 * size;
                src = i === 0 ? halfTesselation : size - 1;
                for (
                    k = halfTesselation * j;
                    k < halfTesselation * (j + 1);
                    k++
                ) {
                    indices.push(k * size + src);
                    indices.push((k + 1) * size + src);
                    indices.push(start + k);

                    indices.push(start + k);
                    indices.push((k + 1) * size + src);
                    indices.push(start + k + 1);
                }
            }

            var gl = this.renderContext.gl;
            var ib = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
            gl.bufferData(
                gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(indices),
                gl.STATIC_DRAW
            );
            ib.numIndices = indices.length;
            this.subSolidIndexBuffer[ii] = ib;
        }

        return this.subSolidIndexBuffer[ii];
    };

    /**************************************************************************************************************/

    /*
     Build index buffer
     */
    TileIndexBuffer.prototype.getSolid = function() {
        if (this.solidIndexBuffer === null) {
            var i, j;
            var size = this.config.tesselation;
            this.indices = [];
            // Build the grid
            for (j = 0; j < size - 1; j++) {
                for (i = 0; i < size - 1; i++) {
                    this.indices.push(j * size + i);
                    this.indices.push((j + 1) * size + i);
                    this.indices.push(j * size + i + 1);

                    this.indices.push(j * size + i + 1);
                    this.indices.push((j + 1) * size + i);
                    this.indices.push((j + 1) * size + i + 1);
                }
            }

            if (this.config.skirt) {
                // Top skirt
                var start = size * size;
                for (i = 0; i < size - 1; i++) {
                    this.indices.push(start + i);
                    this.indices.push(i);
                    this.indices.push(start + i + 1);

                    this.indices.push(start + i + 1);
                    this.indices.push(i);
                    this.indices.push(i + 1);
                }

                // Bottom skirt
                start += size;
                for (i = 0; i < size - 1; i++) {
                    this.indices.push((size - 1) * size + i);
                    this.indices.push(start + i);
                    this.indices.push((size - 1) * size + i + 1);

                    this.indices.push((size - 1) * size + i + 1);
                    this.indices.push(start + i);
                    this.indices.push(start + i + 1);
                }

                // Left skirt
                start += size;
                for (j = 0; j < size - 1; j++) {
                    this.indices.push(start + j);
                    this.indices.push(start + j + 1);
                    this.indices.push(j * size);

                    this.indices.push(j * size);
                    this.indices.push(start + j + 1);
                    this.indices.push((j + 1) * size);
                }

                // Right skirt
                start += size;
                for (j = 0; j < size - 1; j++) {
                    this.indices.push(j * size + size - 1);
                    this.indices.push((j + 1) * size + size - 1);
                    this.indices.push(start + j);

                    this.indices.push(start + j);
                    this.indices.push((j + 1) * size + size - 1);
                    this.indices.push(start + j + 1);
                }
            }

            var gl = this.renderContext.gl;
            var ib = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
            gl.bufferData(
                gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(this.indices),
                gl.STATIC_DRAW
            );
            this.numIndices = this.indices.length;

            this.solidIndexBuffer = ib;
            this.solidIndexBuffer.numIndices = this.indices.length;
        }

        return this.solidIndexBuffer;
    };

    /**************************************************************************************************************/

    return TileIndexBuffer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Tiling/TileManager',[
    "./Tile",
    "./GeoTiling",
    "./TilePool",
    "./TileRequest",
    "./TileIndexBuffer",
    "../Renderer/Program",
    "../Utils/Constants"
], function(
    Tile,
    GeoTiling,
    TilePool,
    TileRequest,
    TileIndexBuffer,
    Program,
    Constants
) {
    /**
     * baseLayersError.
     *
     * @event Context#baseLayersError
     * @type {Layer}
     */

    /**
     * baseLayersReady.
     *
     * @event Context#baseLayersReady
     * @type {Layer}
     */

    /**
     * startBackgroundLoad.
     * Called when background layers (imagery and/or elevation) start to be loaded
     * @event Context#startBackgroundLoad
     */

    /**
     * endBackgroundLoad.<br/>
     * Called when background layers (imagery and/or elevation) end loading
     * @event Context#endBackgroundLoad
     */

    /** @constructor
     * TileManager constructor
     *
     * Take in parameters its parent : can be a globe or a sky
     */
    var TileManager = function(parent, options) {
        //TOOD f(tile)
        // this.processedLevel = 0;
        this.parent = parent;
        this.publishEvent = options.publishEvent;
        this.renderContext = this.parent.renderContext;
        // Create a new tile pool or use the one from the parent
        this.tilePool = parent.tilePool || new TilePool(this.renderContext);
        this.tiling = new GeoTiling(4, 2); // Use geo tiling by default

        this.imageryProvider = null;
        this.elevationProvider = null;
        this.tilesToRender = [];
        this.visibleTiles = [];
        this.tilesToRequest = [];
        this.postRenderers = [];

        // Init default texture
        var gl = this.renderContext.gl;
        this.defaultTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
        var defaultColor = options.defaultColor
            ? options.defaultColor
            : [200, 200, 200, 255];
        var pixel = new Uint8Array(defaultColor);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            1,
            1,
            0,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            pixel
        );

        // Tile requests : limit to 4 at a given time
        this.maxRequests = 4;
        this.availableRequests = [];
        for (var i = this.maxRequests; i--; ) {
            this.availableRequests[i] = new TileRequest(this);
        }
        this.pendingRequests = [];
        this.completedRequests = [];

        this.level0TilesLoaded = false;

        // Configuration for tile
        this.tileConfig = {
            tesselation: 9,
            skirt: true,
            cullSign: 1.0,
            imageSize: 256,
            vertexSize: this.renderContext.lighting ? 6 : 3,
            normals: this.renderContext.lighting,
            coordinateSystem: this.parent.coordinateSystem
        };
        this.level0Tiles = this.tiling.generateLevelZeroTiles(
            this.tileConfig,
            this.tilePool
        );

        // Shared index and texture coordinate buffer : all tiles uses the same
        this.tcoordBuffer = null;
        this.tileIndexBuffer = new TileIndexBuffer(
            this.renderContext,
            this.tileConfig
        );

        // HACK : to fix sky rendering, sets to false
        this.renderTileWithoutTexture = options.hasOwnProperty(
            "renderTileWithoutTexture"
        )
            ? options.renderTileWithoutTexture
            : true;

        // For debug
        this.freeze = false;

        // Stats
        this.numTilesGenerated = 0;
        this.frameNumber = 0;

        this.vertexShader = "attribute vec3 vertex;\n";
        this.vertexShader += "attribute vec2 tcoord;\n";
        this.vertexShader += "uniform mat4 modelViewMatrix;\n";
        this.vertexShader += "uniform mat4 projectionMatrix;\n";
        this.vertexShader += "varying vec2 texCoord;\n";
        if (this.renderContext.lighting) {
            this.vertexShader +=
                "attribute vec3 normal;\nvarying vec3 color;\n";
        }
        this.vertexShader += "void main(void) \n";
        this.vertexShader += "{\n";
        this.vertexShader +=
            "gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
        if (this.renderContext.lighting) {
            this.vertexShader +=
                "vec4 vn = modelViewMatrix * vec4(normal,0);\ncolor = max( vec3(-vn[2],-vn[2],-vn[2]), 0.0 );\n";
        }
        this.vertexShader += "texCoord = tcoord;\n";
        this.vertexShader += "}\n";

        this.fragmentShader = "precision lowp float; \n";
        this.fragmentShader += "varying vec2 texCoord;\n";
        if (this.renderContext.lighting) {
            this.fragmentShader += "varying vec3 color;\n";
        }
        this.fragmentShader += "uniform sampler2D colorTexture;\n";
        this.fragmentShader += "void main(void)\n";
        this.fragmentShader += "{\n";
        this.fragmentShader +=
            "	gl_FragColor.rgb = texture2D(colorTexture, texCoord).rgb;\n";
        if (this.renderContext.lighting) {
            this.fragmentShader += "  gl_FragColor.rgb *= color;\n";
        }
        this.fragmentShader += "  gl_FragColor.a = 1.0;\n";
        this.fragmentShader += "}\n";

        this.program = new Program(this.renderContext);
        this.program.createFromSource(this.vertexShader, this.fragmentShader);
    };

    /**
     * Updates overlay of the layer with the updated layer
     * @param renderable renderer related to the current layer
     * @param layer updated layer
     * @private
     */
    function _updateOverlay(renderable, layer) {
        var bucket;
        if (renderable) {
            bucket = renderable.bucket;
        } else if (layer) {
            bucket = layer._bucket;
        } else {
            return;
        }

        if (!bucket) {
            return;
        }

        var renderer = bucket.renderer;

        if (!renderer) {
            return;
        }

        if (renderer.updateOverlay) {
            renderer.updateOverlay(bucket.layer);
        } else {
            renderer.removeOverlay(bucket.layer);
            renderer.addOverlay(bucket.layer);
        }
    }

    function _abortTilesForLayer(tiles, layer, callback) {
        for (var i = tiles.length; i--; ) {
            var tile = tiles[i];
            var extension = tile.extension;
            if (extension && extension.renderer) {
                var renderables = extension.renderer.renderables;
                for (
                    var renderableIdx = renderables.length;
                    renderableIdx--;

                ) {
                    var renderable = renderables[renderableIdx];
                    if (renderable.bucket.layer.ID === layer.getID()) {
                        _abortBucketRequests.call(this, renderable.bucket);
                        if (callback) {
                            callback(renderable, layer);
                        }
                        break;
                    }
                }
            }
        }
    }

    function _abortBucketRequests(bucket) {
        var renderer = bucket.renderer;
        var imageRequests = renderer.imageRequests;
        if (imageRequests) {
            for (var i = imageRequests.length; i--; ) {
                var request = imageRequests[i];
                if (request.renderable) {
                    request.abort();
                }
            }
        }
    }

    /**************************************************************************************************************/

    /**
     * Add post renderer
     */
    TileManager.prototype.addPostRenderer = function(renderer) {
        this.postRenderers.push(renderer);

        this.postRenderers.sort(function(r1, r2) {
            var z1 = r1.zIndex | Constants.DISPLAY.DEFAULT_RASTER;
            var z2 = r2.zIndex | Constants.DISPLAY.DEFAULT_RASTER;
            return z1 - z2;
        });

        if (renderer.generate) {
            this.visitTiles(function(tile) {
                renderer.generate(tile);
            });
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove a post renderer
     */
    TileManager.prototype.removePostRenderer = function(renderer) {
        var rendererIndex = this.postRenderers.indexOf(renderer);
        if (rendererIndex !== -1) {
            // Remove the renderer from all the tiles if it has a cleanupTile method
            if (renderer.cleanupTile) {
                this.visitTiles(function(tile) {
                    renderer.cleanupTile(tile);
                });
            }
            // Remove renderer from the list
            this.postRenderers.splice(rendererIndex, 1);
        }
    };

    /**************************************************************************************************************/

    /**
     * Set the imagery provider to be used
     */
    TileManager.prototype.setImageryProvider = function(ip) {
        this.reset();
        this.imageryProvider = ip;

        if (ip) {
            // Clean tile pool
            this.tilePool.disposeAll();
            this.tiling = ip.tiling;

            // Rebuild level zero tiles
            this.tileConfig.imageSize = ip.tilePixelSize;
            this.level0Tiles = this.tiling.generateLevelZeroTiles(
                this.tileConfig,
                this.tilePool
            );

            // Update program
            if (ip.customShader) {
                this.program.dispose();
                this.program = new Program(this.renderContext);

                // Memorize current fragment shader
                this.currentFragmentShader = ip.customShader.fragmentCode
                    ? ip.customShader.fragmentCode
                    : this.fragmentShader;
                this.program.createFromSource(
                    ip.customShader.vertexCode
                        ? ip.customShader.vertexCode
                        : this.vertexShader,
                    this.currentFragmentShader
                );
            } else {
                // Revert to default if needed
                if (this.currentFragmentShader !== null) {
                    this.program.dispose();
                    this.program = new Program(this.renderContext);
                    this.program.createFromSource(
                        this.vertexShader,
                        this.fragmentShader
                    );
                    this.currentFragmentShader = null;
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Set the elevation provider to be used
     */
    TileManager.prototype.setElevationProvider = function(tp) {
        this.reset();
        this.elevationProvider = tp;

        var newTesselation = tp ? tp.tilePixelSize : 9;
        if (newTesselation !== this.tileConfig.tesselation) {
            this.tileConfig.tesselation = newTesselation;

            // Reset the shared buffers : texture coordinate and indices
            var gl = this.renderContext.gl;
            this.tileIndexBuffer.reset();
            if (this.tcoordBuffer) {
                gl.deleteBuffer(this.tcoordBuffer);
                this.tcoordBuffer = null;
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Reset the tile manager : unload all tiles
     */
    TileManager.prototype.reset = function() {
        // Abort all pending requests
        this.abortRequests();

        // Reset all level zero tiles : destroy render data, and reset state to NONE
        for (var i = this.level0Tiles.length; i--; ) {
            this.level0Tiles[i].deleteChildren(
                this.renderContext,
                this.tilePool
            );
            this.level0Tiles[i].dispose(this.renderContext, this.tilePool);
        }

        this.tileIndexBuffer.reset();

        this.level0TilesLoaded = false;
    };

    /**************************************************************************************************************/

    /**
     *    Abort all pending requests
     */
    TileManager.prototype.abortRequests = function() {
        for (var i = this.pendingRequests.length; i--; ) {
            this.pendingRequests[i].abort();
        }
    };

    TileManager.prototype.abortLayerRequests = function(layer, callback) {
        //TODO Ce n'est pas sur pendingRequest mais sur les tiles de pending request
        //_abortTilesForLayer.call(this, this.pendingRequests, layer);
        this.abortRequests();
        _abortTilesForLayer.call(this, this.visibleTiles, layer, callback);
    };

    /**
     * Updates the visible tiles of the layer.
     * @param layer the layer where the tiles must be updated
     */
    TileManager.prototype.updateVisibleTiles = function(layer) {
        this.abortLayerRequests(layer);
        _updateOverlay(null, layer);
    };

    /**************************************************************************************************************/

    /**
     * Tile visitor
     * @param callback - Callback function on tile
     */
    TileManager.prototype.visitTiles = function(callback) {
        // Store the tiles to process in an array, first copy level0 tiles
        var tilesToProcess = this.level0Tiles.concat([]);

        while (tilesToProcess.length > 0) {
            // Retrieve the first tile and remove it from the array
            var tile = tilesToProcess.shift();

            callback(tile);

            // Add tile children to array to be processed later
            if (tile.children) {
                tilesToProcess.push(tile.children[0]);
                tilesToProcess.push(tile.children[1]);
                tilesToProcess.push(tile.children[2]);
                tilesToProcess.push(tile.children[3]);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Traverse tiless tiles
     * @fires Context#baseLayersReady
     * @fires Context#baseLayersError
     */
    TileManager.prototype.traverseTiles = function() {
        this.tilesToRender.length = 0;
        this.visibleTiles.length = 0;
        this.tilesToRequest.length = 0;
        this.numTraversedTiles = 0;
        var i, tile;

        // First load level 0 tiles if needed
        if (!this.level0TilesLoaded) {
            this.level0TilesLoaded = true;
            for (i = this.level0Tiles.length; i--; ) {
                tile = this.level0Tiles[i];

                var tileIsLoaded = tile.state === Tile.State.LOADED;

                // Update frame number
                tile.frameNumber = this.frameNumber;

                this.level0TilesLoaded = this.level0TilesLoaded && tileIsLoaded;
                if (!tileIsLoaded) {
                    // Request tile if necessary
                    if (tile.state === Tile.State.NONE) {
                        tile.state = Tile.State.REQUESTED;
                        this.tilesToRequest.push(tile);
                    } else if (
                        tile.state === Tile.State.ERROR &&
                        this.imageryProvider
                    ) {
                        this.publishEvent(
                            Constants.EVENT_MSG.BASE_LAYERS_ERROR,
                            this.imageryProvider
                        );
                    }
                }
            }
            if (this.level0TilesLoaded && this.imageryProvider) {
                this.publishEvent(
                    Constants.EVENT_MSG.BASE_LAYERS_READY,
                    this.imageryProvider
                );
            }
        }

        // Traverse tiles
        if (this.level0TilesLoaded) {
            // Normal traversal, iterate through level zero tiles and process them recursively
            for (i = this.level0Tiles.length; i--; ) {
                tile = this.level0Tiles[i];
                if (!tile.isCulled(this.renderContext)) {
                    this.processTile(tile, 0);
                } else {
                    // Delete its children
                    tile.deleteChildren(this.renderContext, this.tilePool);
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Process a tile
     */
    TileManager.prototype.processTile = function(tile, level) {
        this.numTraversedTiles++;

        // Update frame number
        tile.frameNumber = this.frameNumber;

        var isLeaf = true;

        // Request the tile if needed
        if (tile.state === Tile.State.NONE) {
            tile.state = Tile.State.REQUESTED;

            // Add it to the request
            this.tilesToRequest.push(tile);
        }

        // Check if the tiles needs to be refined
        // We only refine loaded tile
        if (tile.state === Tile.State.LOADED) {
            if (this.imageryProvider) {
                isLeaf = level >= this.imageryProvider.numberOfLevels;
            } else {
                isLeaf = false;
            }
            isLeaf |= !tile.needsToBeRefined(this.renderContext);
        }

        if (isLeaf) {
            // Push the tiles to render only if the texture is valid or there is no imagery provider defined
            if (tile.texture || this.renderTileWithoutTexture) {
                this.tilesToRender.push(tile);
            }
            this.visibleTiles.push(tile);
        } else {
            // Create the children if needed
            if (tile.children === null) {
                tile.createChildren();
            }
            for (var i = 0; i < 4; i++) {
                if (!tile.children[i].isCulled(this.renderContext)) {
                    this.processTile(tile.children[i], level + 1);
                } else {
                    tile.children[i].deleteChildren(
                        this.renderContext,
                        this.tilePool
                    );
                }
            }
        }

        // Traverse extension
        for (var x in tile.extension) {
            if (tile.extension.hasOwnProperty(x)) {
                var e = tile.extension[x];
                if (e.traverse) {
                    e.traverse(tile, isLeaf);
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Generate tile
     */
    TileManager.prototype.generateTile = function(tile, tileRequest) {
        tile.generate(this.tilePool, tileRequest.image, tileRequest.elevations);

        // Now post renderers can generate their data on the new tile
        for (var i = this.postRenderers.length; i--; ) {
            if (this.postRenderers[i].generate) {
                this.postRenderers[i].generate(tile);
            }
        }

        this.numTilesGenerated++;
        this.renderContext.requestFrame();
    };

    /**************************************************************************************************************/

    /**
     * Generate tiles
     * @fires Context#endBackgroundLoad
     */
    TileManager.prototype.generateReceivedTiles = function() {
        while (this.completedRequests.length > 0) {
            var tileRequest = this.completedRequests.pop();
            var tile = tileRequest.tile;
            if (tile.frameNumber === this.frameNumber) {
                this.generateTile(tile, tileRequest);
            } else {
                tile.state = Tile.State.NONE;
            }
            this.availableRequests.push(tileRequest);
        }

        // All requests have been processed, send endBackgroundLoad event
        if (
            this.availableRequests.length === this.maxRequests &&
            this.imageryProvider
        ) {
            this.publishEvent(Constants.EVENT_MSG.LAYER_END_BACKGROUND_LOAD);
        }
    };

    /**************************************************************************************************************/

    /**
     * Render tiles
     */
    TileManager.prototype.renderTiles = function() {
        var rc = this.renderContext;
        var gl = rc.gl;
        var i, tile;
        // Compute near/far from tiles
        var nr;
        var fr;
        if (this.tileConfig.cullSign < 0) {
            // When in "Astro" mode, do not compute near/far from tiles not really needed
            // And the code used for "Earth" does not works really well, when the earth is seen from inside...
            // rc.near = Math.max(
            //     rc.minNear,
            //     0.2 * this.tileConfig.coordinateSystem.geoide.radius
            // );
            rc.far = Math.max(
                rc.minFar,
                1.1 * this.tileConfig.coordinateSystem.geoide.radius
            );
        }

        if (this.tilesToRender.length !== 0) {
            // Set state (depends if geo or astro)
            if (this.tileConfig.cullSign < 0) {
                gl.depthMask(false);
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
            } else {
                gl.enable(gl.POLYGON_OFFSET_FILL);
                gl.polygonOffset(0, 4);
            }

            // Check if the program of imagery provider changed
            // Only for fragment shader for now
            if (
                this.currentFragmentShader &&
                this.currentFragmentShader !==
                    this.imageryProvider.customShader.fragmentCode
            ) {
                this.program.dispose();
                this.program = new Program(this.renderContext);

                if (this.imageryProvider && this.imageryProvider.customShader) {
                    this.currentFragmentShader = this.imageryProvider
                        .customShader.fragmentCode
                        ? this.imageryProvider.customShader.fragmentCode
                        : this.fragmentShader;
                    this.program.createFromSource(
                        this.imageryProvider.customShader.vertexShader
                            ? this.imageryProvider.customShader.vertexShader
                            : this.vertexShader,
                        this.currentFragmentShader
                    );
                }
            }

            // Setup program
            this.program.apply();

            var attributes = this.program.attributes;

            // Update projection matrix with new near and far values
            mat4.perspective(
                rc.fov,
                rc.canvas.width / rc.canvas.height,
                rc.near,
                rc.far,
                rc.projectionMatrix
            );

            // Update uniforms if needed
            if (this.imageryProvider && this.imageryProvider.customShader) {
                this.imageryProvider.customShader.updateUniforms(
                    gl,
                    this.program
                );
            }

            // Setup state
            gl.activeTexture(gl.TEXTURE0);
            gl.uniformMatrix4fv(
                this.program.uniforms.projectionMatrix,
                false,
                rc.projectionMatrix
            );
            gl.uniform1i(this.program.uniforms.colorTexture, 0);

            // Bind the texture coordinate buffer (shared between all tiles
            if (!this.tcoordBuffer) {
                this.buildSharedTexCoordBuffer();
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
            gl.vertexAttribPointer(attributes.tcoord, 2, gl.FLOAT, false, 0, 0);

            var currentIB = null;

            for (i = this.tilesToRender.length; i--; ) {
                tile = this.tilesToRender[i];

                var isLoaded = tile.state === Tile.State.LOADED;
                var isLevelZero = tile.parentIndex === -1;

                // Bind tile texture if defined, the default texture otherwise
                if (tile.texture) {
                    gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                } else {
                    gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
                }

                // Update uniforms for modelview matrix
                mat4.multiply(rc.viewMatrix, tile.matrix, rc.modelViewMatrix);
                gl.uniformMatrix4fv(
                    this.program.uniforms.modelViewMatrix,
                    false,
                    rc.modelViewMatrix
                );

                // Bind the vertex buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
                gl.vertexAttribPointer(
                    attributes.vertex,
                    3,
                    gl.FLOAT,
                    false,
                    4 * this.tileConfig.vertexSize,
                    0
                );
                if (this.tileConfig.normals) {
                    gl.vertexAttribPointer(
                        attributes.normal,
                        3,
                        gl.FLOAT,
                        false,
                        4 * this.tileConfig.vertexSize,
                        12
                    );
                }

                var indexBuffer =
                    isLoaded || isLevelZero
                        ? this.tileIndexBuffer.getSolid()
                        : this.tileIndexBuffer.getSubSolid(tile.parentIndex);
                // Bind the index buffer only if different (index buffer is shared between tiles)
                if (currentIB !== indexBuffer) {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                    currentIB = indexBuffer;
                }

                // Finally draw the tiles
                gl.drawElements(
                    gl.TRIANGLES,
                    currentIB.numIndices,
                    gl.UNSIGNED_SHORT,
                    0
                );
            }

            if (this.tileConfig.cullSign < 0) {
                gl.depthMask(true);
                gl.enable(gl.DEPTH_TEST);
            } else {
                gl.disable(gl.POLYGON_OFFSET_FILL);
            }
        }

        for (i = this.postRenderers.length; i--; ) {
            this.postRenderers[i].render(this.visibleTiles);
        }
    };

    // Internal function to sort tiles
    var _sortTilesByDistance = function(t1, t2) {
        return t1.distance - t2.distance;
    };

    /**************************************************************************************************************/

    /**
     * Request tiles
     * @fires Context#startBackgroundLoad
     */
    TileManager.prototype.launchRequests = function() {
        // Process request
        this.tilesToRequest.sort(_sortTilesByDistance);

        var trl = this.tilesToRequest.length;
        for (var i = trl; i--; ) {
            var tile = this.tilesToRequest[i];
            if (this.availableRequests.length > 0) {
                // Check to limit the number of requests done per frame
                // First launch request, send an event
                if (
                    this.availableRequests.length === this.maxRequests &&
                    this.imageryProvider
                ) {
                    this.publishEvent(
                        Constants.EVENT_MSG.LAYER_START_BACKGROUND_LOAD
                    );
                }

                var tileRequest = this.availableRequests.pop();
                tileRequest.launch(tile);
            } else {
                tile.state = Tile.State.NONE;
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Render the tiles
     * @fires Context#baseLayersReady
     * @fires Context#baseLayersError
     * @fires Context#startBackgroundLoad
     * @fires Context#endBackgroundLoad
     */
    TileManager.prototype.render = function() {
        /*           console.log("TileManager.prototype.render",this.tileConfig.coordSystem);
                 if (this.tileConfig.coordSystem === "GAL") {
                 console.log("No rendering");
                 return;
                 }
                 console.log("============================================");
                 */
        if (this.imageryProvider && !this.imageryProvider._ready) {
            return;
        }

        // Specific case when the image provider has a level zero image : generate the texture for each level zero tile
        if (
            !this.level0TilesLoaded &&
            this.imageryProvider &&
            this.imageryProvider.levelZeroImage
        ) {
            this.imageryProvider.generateLevel0Textures(
                this.level0Tiles,
                this.tilePool
            );

            for (var n = this.level0Tiles.length; n--; ) {
                var tile = this.level0Tiles[n];
                // Generate the tile without tile request
                this.generateTile(tile, {});
            }

            this.level0TilesLoaded = true;

            this.publishEvent(
                Constants.EVENT_MSG.BASE_LAYERS_READY,
                this.imageryProvider
            );
        }

        var stats = this.renderContext.stats;

        if (!this.freeze) {
            if (stats) {
                stats.start("traverseTime");
            }
            this.traverseTiles();
            if (stats) {
                stats.end("traverseTime");
            }
        }

        if (this.level0TilesLoaded || !this.imageryProvider) {
            if (stats) {
                stats.start("renderTime");
            }
            this.renderTiles();
            if (stats) {
                stats.end("renderTime");
            }
        }

        if (stats) {
            stats.start("generateTime");
        }
        this.generateReceivedTiles();
        if (stats) {
            stats.end("generateTime");
        }

        if (stats) {
            stats.start("requestTime");
        }
        this.launchRequests();
        if (stats) {
            stats.end("requestTime");
        }

        this.frameNumber++;
    };

    /**************************************************************************************************************/

    /**
     * Returns visible tile for given longitude/latitude, null otherwise
     */
    TileManager.prototype.getVisibleTile = function(lon, lat) {
        return this.tiling.findInsideTile(lon, lat, this.visibleTiles);
    };

    /**************************************************************************************************************/

    /**
     * Build shared texture coordinate buffer
     */
    TileManager.prototype.buildSharedTexCoordBuffer = function() {
        var size = this.tileConfig.tesselation;
        var skirt = this.tileConfig.skirt;
        var bufferSize = 2 * size * size;
        if (skirt) {
            bufferSize += 2 * size * 6;
        }

        var tcoords = new Float32Array(bufferSize);

        var step = 1.0 / (size - 1);

        var offset = 0;
        var u, v;
        var i, j;
        v = 0.0;
        for (j = 0; j < size; j++) {
            u = 0.0;
            for (i = 0; i < size; i++) {
                tcoords[offset] = u;
                tcoords[offset + 1] = v;

                offset += 2;
                u += step;
            }

            v += step;
        }

        if (skirt) {
            // Top skirt
            u = 0.0;
            v = 0.0;
            for (i = 0; i < size; i++) {
                tcoords[offset] = u;
                tcoords[offset + 1] = v;
                u += step;
                offset += 2;
            }
            // Bottom skirt
            u = 0.0;
            v = 1.0;
            for (i = 0; i < size; i++) {
                tcoords[offset] = u;
                tcoords[offset + 1] = v;
                u += step;
                offset += 2;
            }
            // Left skirt
            u = 0.0;
            v = 0.0;
            for (i = 0; i < size; i++) {
                tcoords[offset] = u;
                tcoords[offset + 1] = v;
                v += step;
                offset += 2;
            }
            // Right skirt
            u = 1.0;
            v = 0.0;
            for (i = 0; i < size; i++) {
                tcoords[offset] = u;
                tcoords[offset + 1] = v;
                v += step;
                offset += 2;
            }

            // Center skirt
            u = 0.0;
            v = 0.5;
            for (i = 0; i < size; i++) {
                tcoords[offset] = u;
                tcoords[offset + 1] = v;
                u += step;
                offset += 2;
            }

            // Middle skirt
            u = 0.5;
            v = 0.0;
            for (i = 0; i < size; i++) {
                tcoords[offset] = u;
                tcoords[offset + 1] = v;
                v += step;
                offset += 2;
            }
        }

        var gl = this.renderContext.gl;
        var tcb = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tcb);
        gl.bufferData(gl.ARRAY_BUFFER, tcoords, gl.STATIC_DRAW);

        this.tcoordBuffer = tcb;
    };

    /**
     * Set freeze
     * @function setFreeze
     * @memberof TileManager.prototype
     * @param {Boolean} freeze Freeze active or not
     */
    TileManager.prototype.setFreeze = function(freeze) {
        this.freeze = freeze;
    };
    /**
     * Get freeze
     * @function getFreeze
     * @memberof TileManager.prototype
     * @return {Boolean} Freeze active or not
     */
    TileManager.prototype.getFreeze = function() {
        return this.freeze;
    };

    /**************************************************************************************************************/

    return TileManager;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/Frustum',["./glMatrix"], function() {
    /**************************************************************************************************************/

    /**
   @name Plane
   @class
   		Plane constructor
   @constructor
  */
    var Plane = function() {
        this.normal = vec3.create([0.0, 0.0, 0.0]);
        this.d = 0.0;
    };

    /**************************************************************************************************************/

    /**
     * Plane init from 3 points
     * @function init
     * @memberof Plane.prototype
     * @param v1 Point 1
     * @param v2 Point 2
     * @param v3 Point 3
     */
    Plane.prototype.init = function(v1, v2, v3) {
        var vu = [];
        var vv = [];
        vec3.subtract(v2, v1, vu);
        vec3.subtract(v3, v1, vv);
        vec3.cross(vu, vv, this.normal);
        vec3.normalize(this.normal);
        this.d = -vec3.dot(v1, this.normal);
    };

    /**************************************************************************************************************/

    /**
     * Transform the plane with the given matrix
     * @function transform
     * @memberof Plane.prototype
     * @param matrix Transformation matrix
     */
    Plane.prototype.transform = function(matrix) {
        var vec = [this.normal[0], this.normal[1], this.normal[2], this.d];
        mat4.multiplyVec4(matrix, vec);
        this.normal[0] = vec[0];
        this.normal[1] = vec[1];
        this.normal[2] = vec[2];
        this.d = vec[3];
    };

    /**************************************************************************************************************/

    /**
     * Intersection test between plane and bounding sphere.
     * @function intersectSphere
     * @memberof Plane.prototype
     * @param center Center
     * @param radius Radius
     * @return {Integer}
     * <ul>
     *   <li>1 if the bounding sphere is completely above plane,</li>
     *   <li>0 if the bounding sphere intersects the plane,</li>
     *   <li>-1 if the bounding sphere is completely below the plane.</li>
     * </ul>
     */
    Plane.prototype.intersectSphere = function(center, radius) {
        var dist = vec3.dot(center, this.normal) + this.d;
        if (dist > radius) {
            return 1;
        } else {
            if (dist < -radius) {
                return -1;
            } else {
                return 0;
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Return the distance between a point and the plane
     * @function distance
     * @memberof Plane.prototype
     * @param point Point
     * @return {Float} Distance
     */
    Plane.prototype.distance = function(point) {
        return (
            point[0] * this.normal[0] +
            point[1] * this.normal[1] +
            point[2] * this.normal[2] +
            this.d
        );
    };

    /**************************************************************************************************************/

    /**
     * Intersection test between plane and bounding box.
     * @function intersectBoundingBox
     * @memberof Plane.prototype
     * @param {BoundingBox} bbox Bounding box
     * @return {Integer}
     * <ul>
     *   <li>1 if the bbox is completely above plane,</li>
     *   <li>0 if the bbox intersects the plane,</li>
     *   <li>-1 if the bbox is completely below the plane.</li>
     * </ul>
     */
    Plane.prototype.intersectBoundingBox = function(bbox) {
        var upperBBCorner =
            (this.normal[0] >= 0.0 ? 1 : 0) |
            (this.normal[1] >= 0.0 ? 2 : 0) |
            (this.normal[2] >= 0.0 ? 4 : 0);

        var lowerBBCorner = ~upperBBCorner & 7;

        // if lowest point above plane than all above.
        if (this.distance(bbox.getCorner(lowerBBCorner)) > 0.0) {
            return 1;
        }

        // if highest point is below plane then all below.
        if (this.distance(bbox.getCorner(upperBBCorner)) < 0.0) {
            return -1;
        }

        // d_lower<=0.0f && d_upper>=0.0f
        // therefore must be crossing plane.
        return 0;
    };

    /**************************************************************************************************************/

    /**
   @name Frustum
   @class
   		Frustum constructor
   @constructor
  */

    var Frustum = function() {
        // The frustum does not contains near and far plane, because near and far are computed during rendering.
        // Some tests have been done with a near plane but are not really useful
        this.planes = [
            new Plane(),
            new Plane(),
            new Plane(),
            new Plane(),
            new Plane()
        ];
    };

    /**************************************************************************************************************/

    /**
     * Compute the frustum from the given projection matrix
     * @function compute
     * @memberof Frustum.prototype
     * @param projectionMatrix Projection matrix
     */
    Frustum.prototype.compute = function(projectionMatrix) {
        var inverseProjectionMatrix = mat4.create();
        mat4.inverse(projectionMatrix, inverseProjectionMatrix);

        var bottomleft = mat4.project(inverseProjectionMatrix, [
            -1.0,
            -1.0,
            -1.0,
            1.0
        ]);
        var topleft = mat4.project(inverseProjectionMatrix, [
            -1.0,
            1.0,
            -1.0,
            1.0
        ]);
        var topright = mat4.project(inverseProjectionMatrix, [
            1.0,
            1.0,
            -1.0,
            1.0
        ]);
        var bottomright = mat4.project(inverseProjectionMatrix, [
            1.0,
            -1.0,
            -1.0,
            1.0
        ]);

        this.planes[0].init([0.0, 0.0, 0.0], bottomleft, topleft);
        this.planes[1].init([0.0, 0.0, 0.0], topleft, topright);
        this.planes[2].init([0.0, 0.0, 0.0], topright, bottomright);
        this.planes[3].init([0.0, 0.0, 0.0], bottomright, bottomleft);

        // A plane for near plane if needed
        this.planes[4].init(bottomleft, topleft, topright);
    };

    /**************************************************************************************************************/

    /**
     * Transform the frustum with the given matrix
     * @function transform
     * @memberof Frustum.prototype
     * @param frustum
     * @param matrix Matrix
     */
    Frustum.prototype.transform = function(frustum, matrix) {
        var mat = mat4.create();
        mat4.inverse(matrix, mat);
        this.inverseTransform(frustum, mat);
    };

    /**************************************************************************************************************/

    /**
     * Inverse transform the frustum with the given matrix
     * @function inverseTransform
     * @memberof Frustum.prototype
     * @param frustum
     * @param matrix Matrix
     */
    Frustum.prototype.inverseTransform = function(frustum, matrix) {
        // Optimized implementation
        for (var i = 0; i < frustum.planes.length; i++) {
            var plane = frustum.planes[i];

            var x = plane.normal[0];
            var y = plane.normal[1];
            var z = plane.normal[2];
            var w = plane.d;

            plane = this.planes[i];

            plane.normal[0] =
                matrix[0] * x + matrix[1] * y + matrix[2] * z + matrix[3] * w;
            plane.normal[1] =
                matrix[4] * x + matrix[5] * y + matrix[6] * z + matrix[7] * w;
            plane.normal[2] =
                matrix[8] * x + matrix[9] * y + matrix[10] * z + matrix[11] * w;
            plane.d =
                matrix[12] * x +
                matrix[13] * y +
                matrix[14] * z +
                matrix[15] * w;
        }
    };

    /**************************************************************************************************************/

    /**
     * Intersection test between frustum and bounding sphere.
     * @function containsSphere
     * @memberof Frustum.prototype
     * @param {Array} center Center
     * @param {Float} radius Radius
     * @return {Integer}
     * <ul>
     *   <li>1 if the bounding sphere is completely inside the frustum,</li>
     *   <li>0 if the bounding sphere intersects the frustum,</li>
     *   <li>-1 if the bounding sphere is completely outside the frustum.</li>
     * </ul>
     */
    Frustum.prototype.containsSphere = function(center, radius) {
        var flag = 1;

        for (var i = 0; i < this.planes.length; i++) {
            var pn = this.planes[i].normal;

            // Compute distance between center and plane (inline to be more efficient)
            var dist =
                center[0] * pn[0] +
                center[1] * pn[1] +
                center[2] * pn[2] +
                this.planes[i].d;

            if (dist <= radius) {
                if (dist < -radius) {
                    return -1;
                } else {
                    flag = 0;
                }
            }
        }

        return flag;
    };

    /**************************************************************************************************************/

    /**
     * Test if the frustum contains the given bounding box
     * @function containsBoundingBox
     * @memberof Frustum.prototype
     * @param {BoundingBox} bbox Bounding box
     * @return {boolean} Contains ?
     */
    Frustum.prototype.containsBoundingBox = function(bbox) {
        // Optimized implementation
        for (var i = 0; i < this.planes.length; i++) {
            var plane = this.planes[i];

            // Get the closest point on the bbox
            var bbx = plane.normal[0] >= 0.0 ? bbox.max[0] : bbox.min[0];
            var bby = plane.normal[1] >= 0.0 ? bbox.max[1] : bbox.min[1];
            var bbz = plane.normal[2] >= 0.0 ? bbox.max[2] : bbox.min[2];

            // Compute the distance
            var distance =
                bbx * plane.normal[0] +
                bby * plane.normal[1] +
                bbz * plane.normal[2] +
                plane.d;

            // if highest point is below plane then all below.
            if (distance < 0.0) {
                return false;
            }
        }

        return true;
    };

    /**************************************************************************************************************/

    // Export plane
    Frustum.Plane = Plane;

    return Frustum;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Renderer/RenderContext',["jquery","./Frustum", "./glMatrix"], function($, Frustum) {
    /**************************************************************************************************************/
    /**
         @name RenderContext
         @class
             RenderContext constructor
         @param options Configuration properties for the Planet :
         <ul>
         <li>shadersPath : Shaders directory path ( "../shaders/" as default)</li>
         <li>tileErrorTreshold : Tile error treshold (4 as default)</li>
         <li>lighting : Lighting ? (false as default))</li>
         <li>continuousRendering : Have to continuously render ? (false as default)</li>
         </ul>
         @constructor
         */
    var RenderContext = function(options) {
        this.activeAnimations = [];
        this.shadersPath = options.shadersPath || "../shaders/";
        this.tileErrorTreshold = options.tileErrorTreshold || 4;
        this.lighting = options.lighting || false;
        this.continuousRendering = options.continuousRendering || false;
        this.stats = null;
        this.isActive = true;

        // Init GL
        var canvas = null;

        // Check canvas options
        if (!options.canvas) {
            throw new ReferenceError("Mizar : no canvas in options");
        }

        if (typeof options.canvas === "string") {
            //canvas = document.getElementById(options.canvas);
            canvas = $(options.canvas);
        } else {
            canvas = options.canvas;
        }
        // Check canvas is valid
        if (!(canvas instanceof HTMLCanvasElement)) {
            throw new TypeError("Mizar : invalid canvas");
        }

        // Create the webl context
        var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
        var gl = null;
        for (var ii = 0; ii < names.length && gl === null; ++ii) {
            try {
                gl = canvas.getContext(
                    names[ii],
                    RenderContext.contextAttributes
                );
            } catch (e) {
                /* continue regardless of error */
            }
        }

        if (gl === null) {
            throw new ReferenceError(
                "Mizar : WebGL context cannot be initialized"
            );
        }

        if (options.backgroundColor) {
            var color = options.backgroundColor;
            gl.clearColor(color[0], color[1], color[2], color[3]);
        } else {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
        }

        gl.getExtension("OES_element_index_uint");

        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);

        // Store local variable into static object
        this.viewMatrix = mat4.create();
        this.modelViewMatrix = mat4.create();
        this.projectionMatrix = mat4.create();
        this.viewProjectionMatrix = mat4.create();
        this.gl = gl;
        this.canvas = canvas;
        this.frustum = new Frustum();
        this.worldFrustum = new Frustum();
        this.localFrustum = new Frustum();
        this.eyePosition = vec3.create();
        this.eyeDirection = vec3.create();
        this.minNear = options.minNear || 1e-10;
        this.minFar = options.minFar || 0; // No limit on far
        this.near = 1.0;
        this.far = 6.0;
        this.numActiveAttribArray = 0;
        this.frameRequested = false;
        this.fov = 45;
        this.renderers = [];
        this.cameraUpdateFunction = null;

        this.lastFrameTime = null;
        this.currentFrameTime = null;
        this.totalElapsedTime = 0.0;
        this.deltaTime = 0.0;

        // Initialize the window requestAnimationFrame
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = (function() {
                return (
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.oRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
                    function(callback, element) {
                        window.setTimeout(callback, 1000 / 60);
                    }
                );
            })();
        }

        var self = this;
        this.frameCallback = function() {
            self.frame();
        };
    };

    /**************************************************************************************************************/

    /**
         The context attributes used when creating WebGL context, see WebGL specification.
         Can be changed by the renderers if needed, or by an external interface.
         */
    RenderContext.contextAttributes = {};

    /**************************************************************************************************************/

    /**
     * Request a frame
     * @function requestFrame
     * @memberof RenderContext.prototype
     */
    RenderContext.prototype.requestFrame = function() {
        if (!this.frameRequested) {
            window.requestAnimationFrame(this.frameCallback);
            this.frameRequested = true;
        }
    };

    /**************************************************************************************************************/

    /**
     * Deactivate render context
     * @function deactivate
     * @memberof RenderContext.prototype
     */
    RenderContext.prototype.deactivate = function() {
        this.isActive = false;
        this.frameRequested = false;
    };

    /**************************************************************************************************************/

    /**
     * Activate render context
     * @function activate
     * @memberof RenderContext.prototype
     */
    RenderContext.prototype.activate = function() {
        this.isActive = true;
    };

    /**************************************************************************************************************/

    /**
     * Frame of the application
     * @function frame
     * @memberof RenderContext.prototype
     * @fires Context#startLoad
     * @fires Context#endLoad
     * @fires Context#baseLayersReady
     * @fires Context#baseLayersError
     * @fires Context#startBackgroundLoad
     * @fires Context#endBackgroundLoad
     * @fires Context#features:added
     */
    RenderContext.prototype.frame = function() {
        if (this.isActive) {
            // Reset frame requested flag first
            this.frameRequested = false;

            var stats = this.stats;
            var gl = this.gl;
            var i;

            if (this.stats) {
                this.stats.start("globalRenderTime");
            }

            // Update frame time infos
            this.lastFrameTime = this.currentFrameTime;
            this.currentFrameTime = Date.now();
            if (!this.lastFrameTime) {
                this.lastFrameTime = this.currentFrameTime;
            }

            const dt = this.currentFrameTime - this.lastFrameTime;
            this.totalElapsedTime += dt;
            this.deltaTime = dt;

            // Update active animations
            if (this.activeAnimations.length > 0) {
                for (i = 0; i < this.activeAnimations.length; i++) {
                    this.activeAnimations[i].update(this.currentFrameTime);
                }
            }

            // Clear the buffer
            if (RenderContext.contextAttributes.stencil) {
                gl.clear(
                    gl.COLOR_BUFFER_BIT |
                        gl.DEPTH_BUFFER_BIT |
                        gl.STENCIL_BUFFER_BIT
                );
            } else {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            }

            // Check canvas size is valid
            if (this.canvas.width === 0 || this.canvas.height === 0) {
                return;
            }

            gl.viewport(0, 0, this.canvas.width, this.canvas.height);

            // Update view dependent properties to be used during rendering : view matrix, frustum, projection, etc...
            if (this.cameraUpdateFunction) {
                this.cameraUpdateFunction();
            }
            this.updateViewDependentProperties();

            // Call render method of all registered renderers
            for (i = 0; i < this.renderers.length; i++) {
                this.renderers[i].render();
            }

            if (this.stats) {
                this.stats.end("globalRenderTime");
            }

            // Request next frame
            if (this.continuousRendering) {
                this.requestFrame();
            } else if (this.activeAnimations.length > 0) {
                this.requestFrame();
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Update properies that depends on the view matrix
     * @function updateViewDependentProperties
     * @memberof RenderContext.prototype
     */
    RenderContext.prototype.updateViewDependentProperties = function() {
        var inverseViewMatrix = mat4.create();
        mat4.inverse(this.viewMatrix, inverseViewMatrix);

        vec3.set([0.0, 0.0, 0.0], this.eyePosition);
        mat4.multiplyVec3(inverseViewMatrix, this.eyePosition);

        vec3.set([0.0, 0.0, -1.0], this.eyeDirection);
        mat4.rotateVec3(inverseViewMatrix, this.eyeDirection);

        // Init projection matrix
        mat4.perspective(
            this.fov,
            this.canvas.width / this.canvas.height,
            this.near,
            this.far,
            this.projectionMatrix
        );

        // No need to do this computation every time
        mat4.multiply(
            this.projectionMatrix,
            this.viewMatrix,
            this.viewProjectionMatrix
        );
        // Compute the frustum from the projection matrix
        this.frustum.compute(this.projectionMatrix);

        // Compute the world frustum
        this.worldFrustum.inverseTransform(this.frustum, this.viewMatrix);

        // Compute the pixel size vector from the current view/projection matrix
        this.pixelSizeVector = this.computePixelSizeVector();
    };

    /**************************************************************************************************************/

    /**
     * Get mouse coordinates relative to the canvas element
     * @function getXYRelativeToCanvas
     * @memberof RenderContext.prototype
     * @param event
     * @return Coordinates
     */
    RenderContext.prototype.getXYRelativeToCanvas = function(event) {
        // cf. http://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element
        var pos = [];
        if (event.pageX || event.pageY) {
            pos[0] = event.pageX;
            pos[1] = event.pageY;
        } else {
            pos[0] =
                event.clientX +
                document.body.scrollLeft +
                document.documentElement.scrollLeft;
            pos[1] =
                event.clientY +
                document.body.scrollTop +
                document.documentElement.scrollTop;
        }

        var element = this.canvas;
        while (element) {
            pos[0] -= element.offsetLeft;
            pos[1] -= element.offsetTop;
            element = element.offsetParent;
        }

        return pos;
    };

    /**************************************************************************************************************/

    /**
     * Compute the pixel size vector
     * @function computePixelSizeVector
     * @memberof RenderContext.prototype
     * @param mv
     * @return pixelSizeVector
     */
    RenderContext.prototype.computePixelSizeVector = function(mv) {
        // pre adjust P00,P20,P23,P33 by multiplying them by the viewport window matrix.
        // here we do it in short hand with the knowledge of how the window matrix is formed
        // note P23,P33 are multiplied by an implicit 1 which would come from the window matrix.
        // Robert Osfield, June 2002.

        var width = this.canvas.width;
        var height = this.canvas.height;
        var P = this.projectionMatrix;
        var V = mv || this.viewMatrix;

        // scaling for horizontal pixels
        var P00 = P[0] * width * 0.5;
        var P20_00 = P[8] * width * 0.5 + P[11] * width * 0.5;
        var scale_00 = [
            V[0] * P00 + V[2] * P20_00,
            V[4] * P00 + V[6] * P20_00,
            V[8] * P00 + V[10] * P20_00
        ];

        // scaling for vertical pixels
        var P10 = P[5] * height * 0.5;
        var P20_10 = P[9] * height * 0.5 + P[11] * height * 0.5;
        var scale_10 = [
            V[1] * P10 + V[2] * P20_10,
            V[5] * P10 + V[6] * P20_10,
            V[9] * P10 + V[10] * P20_10
        ];

        var P23 = P[11];
        var P33 = P[15];
        var pixelSizeVector = [
            V[2] * P23,
            V[6] * P23,
            V[10] * P23,
            V[14] * P23 + V[15] * P33
        ];

        var scaleRatio =
            0.7071067811 /
            Math.sqrt(
                vec3.dot(scale_00, scale_00) + vec3.dot(scale_10, scale_10)
            );
        pixelSizeVector[0] *= scaleRatio;
        pixelSizeVector[1] *= scaleRatio;
        pixelSizeVector[2] *= scaleRatio;
        pixelSizeVector[3] *= scaleRatio;

        return pixelSizeVector;
    };

    /**************************************************************************************************************/

    /**
     * Get pixel from 3D
     * TODO: move it to Planet/Sky too ?
     * @function getPixelFrom3D
     * @memberof RenderContext.prototype
     * @param x
     * @param y
     * @param z
     * @return {Array} Point as array of 2 float
     */
    RenderContext.prototype.getPixelFrom3D = function(x, y, z) {
        var viewProjectionMatrix = mat4.create();
        mat4.multiply(
            this.projectionMatrix,
            this.viewMatrix,
            viewProjectionMatrix
        );

        // transform world to clipping coordinates
        var point3D = [x, y, z, 1];
        mat4.project(viewProjectionMatrix, point3D);

        // transform clipping to window coordinates
        var winX = Math.round((1 + point3D[0]) * 0.5 * this.canvas.width);

        // reverse y because (0,0) is top left but opengl's normalized
        // device coordinate (-1,-1) is bottom left
        var winY = Math.round((1 - point3D[1]) * 0.5 * this.canvas.height);

        return [winX, winY];
    };

    /**************************************************************************************************************/

    /**
     * Create a non power of two texture from an image
     * @function createNonPowerOfTwoTextureFromImage
     * @memberof RenderContext.prototype
     * @param image
     * @param invertY
     * @return Texture
     */
    RenderContext.prototype.createNonPowerOfTwoTextureFromImage = function(
        image,
        invertY
    ) {
        var gl = this.gl;
        var tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, invertY);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            image
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // Restore to default
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        return tex;
    };

    /**
     * Returns the canvas
     * @returns {Object} canvas
     */
    RenderContext.prototype.getCanvas = function() {
        return this.canvas;
    };

    /**
     * Returns the field of view in decimal degree.
     * @returns {Object} field of view
     */
    RenderContext.prototype.getFov = function() {
        return this.fov;
    };

    /**
     * Sets the field of fiew in decimal degree.
     * @param fov field of view
     */
    RenderContext.prototype.setFov = function(fov) {
        this.fov = fov;
    };

    /**
     * Returns the world frustum.
     * @returns {Frustum} frustum
     */
    RenderContext.prototype.getWorldFrustum = function() {
        return this.worldFrustum;
    };

    /**
     * Returns the view matrix.
     * @returns {mat4}
     */
    RenderContext.prototype.getViewMatrix = function() {
        return this.viewMatrix;
    };

    /**
     * Sets the view matrix.
     * @param {mat4} mat4 the matrix
     */
    RenderContext.prototype.setViewMatrix = function(mat4) {
        this.viewMatrix = mat4;
    };

    /**************************************************************************************************************/

    return RenderContext;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Globe/AbstractGlobe',[
    "../Utils/Event",
    "../Utils/Utils",
    "../Tiling/TileManager",
    "../Renderer/RendererManager",
    "../Renderer/Ray",
    "../Renderer/GeoBound",
    "../Crs/CoordinateSystemFactory",
    "../Renderer/RenderContext",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog",
    "../Renderer/glMatrix"
], function(
    Event,
    Utils,
    TileManager,
    RendererManager,
    Ray,
    GeoBound,
    CoordinateSystemFactory,
    RenderContext,
    Constants,
    ErrorDialog
) {
    /**
     * AbstractGlobe configuration
     * @typedef {Object} AbstractGlobe.configuration
     * @property {boolean} [continuousRendering=false] - Options that renders the globe in continue
     * @property {Crs} coordinateSystem - coordinate system of the globe
     * @property {Object} [renderContext] - RenderContext object.
     * @property {string} [shadersPath=../shaders/] - Option for RenderContext : shader location.
     * @property {int} [tileErrorTreshold=4] - Option for RenderContext : tile error
     * @property {boolean} [lighting=false] - Option for RenderContext : enable/disable lighting
     * @property {Object|string} canvas - Option for RenderContext : Canvas element to insert in the globe
     * @property {Array} [backgroundColor=[0.0, 0.0, 0.0, 1.0]] - Option for RenderContext : color for background
     * @property {int} [minFar=0] - Option for RenderContext : When 0 , no limit on far
     * @property {Array} [defaultColor=[200, 200, 200, 255]] - Option for TileManager : pixel default color
     * @property {Number} [subdivisionLength=10000] - The targetted length of a segment subdivision
     * @property {Number} [maxSubdivisionCount=128] - The max number of subdivisions for a segment
     *
     */
    /**
     * @name AbstractGlobe
     * @class
     * Creates a sky or a planet with it own coordinate reference system and renders the globe.
     * According to its coordinate reference system, the globe can be projected on a map.<br/>
     * Client implementations should not normally instantiate this class directly.
     * @param {GLOBE} type - Type of the globe.
     * @param {AbstractGlobe.configuration} options - Options for globe creation.
     * @throws {ReferenceError} Will throw an error when the options.coordinateSystem is not defined.
     * @throws {Error} Will throw an error when options.coordinateSystem.geoideName  is not part of {@link CRS}
     * @see {@link module:Crs.CoordinateSystemFactory}
     * @implements {Globe}
     */
    var AbstractGlobe = function(type, options) {
        Utils.assert(
            type === Constants.GLOBE.Sky ||
                type === Constants.GLOBE.Planet ||
                type === Constants.GLOBE.Ground,
            "Type must be a value of Contants.GLOBE for " +
                this.constructor.name,
            "AbstractGlobe.js"
        );
        Utils.assert(
            options != null,
            "Options is required " + this.constructor.name,
            "AbastractGlobe.js"
        );
        Utils.assert(
            options.coordinateSystem != null &&
                typeof options.coordinateSystem === "object" &&
                options.coordinateSystem.geoideName != null,
            "coordinate system is required in options parameters for " +
                this.constructor.name,
            "AbastractGlobe.js"
        );
        this.type = type;

        this.coordinateSystem = CoordinateSystemFactory.create(
            options.coordinateSystem
        );

        if (!options.renderContext) {
            this.renderContext = new RenderContext(options);
        } else {
            this.renderContext = options.renderContext;
        }

        this.publishEvent = options.publishEvent;

        this.isEnable = true;
        this.continuousRendering = options.continuousRendering || false;
        this.tileManager = new TileManager(this, options);
        this.rendererManager = new RendererManager(this);
        this.attributionHandler = null;
        this.baseImagery = null;
        this.preRenderers = [];
        this.nbCreatedLayers = 0;
        this.definedBackgound = false;
        this.subdivisionLength = options.subdivisionLength || 10000;
        this.maxSubdivisionCount = options.maxSubdivisionCount || 128;

        this.cachedPickingValue = null;

        this.tileManager.addPostRenderer(this.rendererManager);

        this.renderContext.renderers.push(this);
        this.refresh();
    };

    /**
     * Computes intersections.
     * @param {Ray} ray
     * @param {Crs} crs - coordinate reference system
     * @returns {number} The nearest intersection, < 0 if no intersection
     * @private
     */
    function _computeIntersection(ray, crs) {
        var intersection;
        if (crs.isFlat()) {
            intersection = ray.planeIntersect([0, 0, 0], [0, 0, 1]);
        } else {
            intersection = ray.sphereIntersect(
                [0, 0, 0],
                crs.getGeoide().getRadius()
            );
        }
        return intersection;
    }

    /**
     * Computes the position.
     * @param {Ray} ray
     * @param {number} intersection
     * @param {Crs} crs
     * @returns {float[]|null} the position
     * @private
     */
    function _computePosition(ray, intersection, crs) {
        if (intersection >= 0) {
            var pos = crs.getWorldFrom3D(ray.computePoint(intersection));
            var geoBound = crs.getGeoBound();
            if (
                !pos ||
                pos[0] < geoBound[0] ||
                pos[0] > geoBound[2] ||
                pos[1] < geoBound[1] ||
                pos[1] > geoBound[3] ||
                isNaN(pos[0]) ||
                isNaN(pos[1])
            ) {
                return null;
            } else {
                return pos;
            }
        } else {
            return null;
        }
    }

    /**
     * Updates the geometry related to the old GeoTiling to the new GeoTiling.
     * @function _updateTileIndexInGeometry
     * @param {TileManager} tileManager tile manager
     * @private
     */
    function _updateTileIndexInGeometry(tileManager) {
        var postRenderers = tileManager.postRenderers;
        var postRendererIdx = postRenderers.length;
        // we use while, this is the fastest loop in Javascript https://jsperf.com/fastest-array-loops-in-javascript/32
        while (postRendererIdx--) {
            // we iterate on renderers
            var postRenderer = postRenderers[postRendererIdx];
            if (postRenderer instanceof RendererManager) {
                // we look for RendererManager because this one contains geometry
                var rendererManager = postRenderers[postRendererIdx];
                var vectors = rendererManager.renderers;
                var vectorIdx = vectors.length;
                while (vectorIdx--) {
                    // we iterate on vector
                    var vector = vectors[vectorIdx];
                    if (
                        vector.levelZeroTiledGeometries &&
                        vector.levelZeroTiledGeometries.length > 0
                    ) {
                        // we retrieve the geometries
                        var geometries = vector.levelZeroTiledGeometries;
                        var geometryIdx = geometries.length;
                        while (geometryIdx--) {
                            // we iterate on each geometry to update the indexed tile related to the geometry
                            // the (0,0) is 0, the (1,0) is 1, ....
                            var geometry = geometries[geometryIdx];
                            var tileIndices =
                                vector.maxTilePerGeometry > 0
                                    ? tileManager.tiling.getOverlappedLevelZeroTiles(
                                        geometry
                                    )
                                    : null;
                            // update
                            geometry._tileIndices = tileIndices;
                        }
                    }
                }
            }
        }
    }

    /*************************************************************************************************************/

    /**
     * @function getType
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.getType = function() {
        return this.type;
    };

    /**
     * @function isSky
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.isSky = function() {
        return this.getType() === Constants.GLOBE.Sky;
    };

    /**
     * @function isPlanet
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.isPlanet = function() {
        return this.getType() === Constants.GLOBE.Planet;
    };

    /**
     * @function hasDefinedBackground
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.hasDefinedBackground = function() {
        return this.definedBackgound;
    };

    /**
     * @function setBaseImagery
     * @memberof AbstractGlobe#
     * @abstract
     */
    AbstractGlobe.prototype.setBaseImagery = function(layer) {
        throw new SyntaxError(
            "setBaseImagery Not implemented",
            "AbstractGlobe.js"
        );
    };

    /**
     * @function getBaseImagery
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.getBaseImagery = function() {
        return this.baseImagery;
    };

    /**
     * @function setBaseElevation
     * @memberof AbstractGlobe#
     * @abstract
     */
    AbstractGlobe.prototype.setBaseElevation = function(layer) {
        throw new SyntaxError(
            "setBaseElevation Not implemented",
            "AbstractGlobe.js"
        );
    };

    /**
     * @function getBaseElevation
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.getBaseElevation = function() {
        return this.tileManager.elevationProvider;
    };

    /**
     * @function addLayer
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.addLayer = function(layer) {
        Utils.assert(
            layer != null,
            "layer must be an AbstractLayer object in addLayer for " +
                this.constructor.name,
            "AbstractGlobe.js"
        );
        var globe = this;
        if (layer.isVectorLayer()) {
            if (layer.isForDataProvider() || layer.isDraw()) {
                layer.id = globe.nbCreatedLayers;
                layer._attach(globe);
                globe.refresh();
                globe.nbCreatedLayers++;
            } else {
                // normal case
                Utils.requestUrl(
                    layer.getUrl(),
                    "json",
                    "application/json",
                    null,
                    function(data) {
                        layer.addFeatureCollection(data);
                        layer.id = globe.nbCreatedLayers;
                        layer._attach(globe);
                        globe.refresh();
                        globe.nbCreatedLayers++;
                        if (layer.callback) {
                            layer.callback(data);
                        }
                    },
                    function(err) {
                        ErrorDialog.open(
                            Constants.LEVEL.ERROR,
                            "Failed to request " + layer.getUrl(),
                            err
                        );
                    }
                );
            }
        } else {
            if (!layer.id) {
                layer.id = this.nbCreatedLayers;
                this.nbCreatedLayers++;
            }
            layer._attach(globe);
            this.refresh();
        }
        if (layer.isBackground()) {
            this.publishEvent(
                Constants.EVENT_MSG.LAYER_BACKGROUND_ADDED,
                layer
            );
        } else {
            this.publishEvent(Constants.EVENT_MSG.LAYER_ADDED, layer);
        }
    };

    /**
     * @function removeLayer
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.removeLayer = function(layer) {
        Utils.assert(
            layer != null,
            "layer must be an AbstractLayer object in removeLayer for " +
                this.constructor.name,
            "AbstractGlobe.js"
        );
        layer.background = false;
        //layer.setVisible(false); <!-- cannot do it because of PlanetLayer -->
        layer._detach();
        this.publishEvent(Constants.EVENT_MSG.LAYER_REMOVED, layer);
    };

    /**
     * @function addAnimation
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.addAnimation = function(anim) {
        Utils.assert(
            anim != null,
            "anim must be an AbstractAnimation object in addAnimation for " +
                this.constructor.name,
            "AbstractGlobe.js"
        );
        anim.renderContext = this.renderContext;
    };

    /**
     * @function removeAnimation
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.removeAnimation = function(anim) {
        Utils.assert(
            anim != null,
            "anim must be an AbstractAnimation object in removeAnimation for " +
                this.constructor.name,
            "AbstractGlobe.js"
        );
        anim.renderContext = null;
    };

    /**
     * @function getElevation
     * @memberof AbstractGlobe#
     * @abstract
     */
    AbstractGlobe.prototype.getElevation = function(lon, lat) {
        throw new SyntaxError(
            "getElevation Not implemented",
            "AbstractGlobe.js"
        );
    };

    /**
     * @function getViewportGeoBound
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.getViewportGeoBound = function(transformCallback) {
        var rc = this.renderContext;
        var tmpMat = mat4.create();

        // Compute eye in world space
        mat4.inverse(rc.viewMatrix, tmpMat);
        var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];

        // Compute the inverse of view/proj matrix
        mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
        mat4.inverse(tmpMat);

        // Transform the four corners of the frustum into world space
        // and then for each corner compute the intersection of ray starting from the eye with the earth
        var points = [
            [-1, -1, 1, 1],
            [1, -1, 1, 1],
            [-1, 1, 1, 1],
            [1, 1, 1, 1]
        ];
        var earthCenter = [0, 0, 0];
        for (var i = 0; i < 4; i++) {
            mat4.multiplyVec4(tmpMat, points[i]);
            vec3.scale(points[i], 1.0 / points[i][3]);
            vec3.subtract(points[i], eye, points[i]);
            vec3.normalize(points[i]);

            var ray = new Ray(eye, points[i]);
            var t = ray.sphereIntersect(
                earthCenter,
                this.coordinateSystem.getGeoide().getRadius()
            );
            //var t = ray.sphereIntersect(earthCenter, 15);
            if (t < 0.0) {
                return null;
            }
            var pos3d = ray.computePoint(t);
            points[i] = this.coordinateSystem.from3DToGeo(pos3d);
            if (transformCallback) {
                points[i] = transformCallback(points[i]);
            }
        }

        var geoBound = new GeoBound();
        geoBound.computeFromCoordinates(points);

        return geoBound;
    };

    /**
     * @function getLonLatFromPixel
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.getLonLatFromPixel = function(x, y) {
        Utils.assert(
            typeof x === "number" && typeof y === "number",
            "(lon,lat) from getLonLatFromPixel must be numbers for " +
                this.constructor.name,
            "AbstractGlobe.js"
        );

        if (this.isPlanet() && this.cachedPickingValue && this.cachedPickingValue.x === x && this.cachedPickingValue.y === y) {
            return this.cachedPickingValue.lonLat;
        }

        var ray = Ray.createFromPixel(this.renderContext, x, y);
        const lonLat = this.computeIntersection(ray);

        this.cachedPickingValue = {
            x: x,
            y: y,
            lonLat: lonLat,
        };

        return lonLat;
    };

    /**
     * @function getPixelFromLonLat
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.getPixelFromLonLat = function(lon, lat) {
        Utils.assert(
            typeof lon === "number" && typeof lat === "number",
            "(lon,lat) from getPixelFromLonLat must be numbers for " +
                this.constructor.name,
            "AbstractGlobe.js"
        );
        var pos3d = vec3.create();
        this.coordinateSystem.get3DFromWorld([lon, lat], pos3d);
        return this.renderContext.getPixelFrom3D(pos3d[0], pos3d[1], pos3d[2]);
    };

    /**
     * @function setCoordinateSystem
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.setCoordinateSystem = function(coordinateSystem) {
        Utils.assert(
            coordinateSystem != null,
            "coordinateSystem must be a Crs object in setCoordinateSystem for " +
                this.constructor.name,
            "AbstractGlobe.js"
        );
        var oldCrs = this.coordinateSystem;
        this.coordinateSystem = coordinateSystem;
        this.dispose();
        this.tileManager.tileConfig.coordinateSystem = coordinateSystem;

        if (this.coordinateSystem.isFlat() && this.coordinateSystem.getProjection().getName() === Constants.PROJECTION.Azimuth ||
            oldCrs.getProjection().getName() === Constants.PROJECTION.Azimuth) {
            this.tileManager.level0Tiles = this.tileManager.tiling.generateLevelZeroTiles(
                this.tileManager.tileConfig,
                this.tileManager.tilePool
            );
        }

        _updateTileIndexInGeometry.call(this, this.getTileManager());
    };

    /**
     * @function getCoordinateSystem
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.getCoordinateSystem = function() {
        return this.coordinateSystem;
    };

    /**
     * @function computeIntersection
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.computeIntersection = function(ray) {
        var intersection;

        if (this.hasMesh()) {
            intersection = Number.MAX_VALUE;
            for (var i = 0; i < this.tileManager.level0Tiles.length; ++i) {
                const tile = this.tileManager.level0Tiles[i];
                const t = tile.intersect(
                    ray,
                    this.tileManager.tileIndexBuffer.indices,
                    this.renderContext
                );
                if (t < intersection && t >= 0) {
                    intersection = t;
                }
            }
            if (intersection === Number.MAX_VALUE) {
                intersection = -1;
            }
        } else {
            //console.log("Ray",ray);
            intersection = _computeIntersection.call(
                this,
                ray,
                this.coordinateSystem
            );
        }

        // console.log("intersection",intersection);
        var result = _computePosition.call(
            this,
            ray,
            intersection,
            this.coordinateSystem
        );
        // console.log("result",result);
        // console.log("=================================");
        return result;
    };

    /**
     * @function getRenderStats
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.getRenderStats = function() {
        return "# rendered tiles : " + this.tileManager.tilesToRender.length;
    };

    /**
     * @function getRenderContext
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.getRenderContext = function() {
        return this.renderContext;
    };

    /**
     * @function setRenderContext
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.setRenderContext = function(context) {
        Utils.assert(
            context != null,
            "context must be a Context object in setRenderContext for " +
                this.constructor.name,
            "AbstractGlobe.js"
        );
        this.renderContext = context;
    };

    /**
     * @function getTileManager
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.getTileManager = function() {
        return this.tileManager;
    };

    /**
     * @function getRendererManager
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.getRendererManager = function() {
        return this.rendererManager;
    };

    /**
     * @function render
     * @memberof AbstractGlobe#
     * @abstract
     */
    AbstractGlobe.prototype.render = function() {
        throw new SyntaxError("render Not implemented", "AbstractGlobe.js");
    };

    /**
     * @function dispose
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.dispose = function() {
        this.tileManager.reset();
        this.tileManager.tilePool.disposeAll();
    };

    /**
     * @function destroy
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.destroy = function() {
        if (this.tileManager) {
            this.dispose();
            this.tileManager.removePostRenderer(this.rendererManager);
            this.tileManager = null;
            this.rendererManager = null;
        }
        this.renderContext.renderers.splice(
            this.renderContext.renderers.indexOf(this),
            1
        );
        if (this.coordinateSystem) {
            this.coordinateSystem.destroy();
            this.coordinateSystem = null;
        }
        this.refresh();
        this.definedBackgound = null;
        this.type = null;
        this.publishEvent = null;
        this.isEnable = null;
        this.globe = null;
        this.continuousRendering = null;
        this.attributionHandler = null;
        this.baseImagery = null;
        this.preRenderers = null;
        this.nbCreatedLayers = null;
    };

    /**
     * @function refresh
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.refresh = function() {
        this.renderContext.requestFrame();
    };

    /**
     * @function isEnabled
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.isEnabled = function() {
        return this.isEnable;
    };

    /**
     * @function enable
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.enable = function() {
        this.isEnable = true;
    };

    /**
     * @function disable
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.disable = function() {
        this.isEnable = false;
    };

    /**
     * @function hasMesh
     * @memberof AbstractGlobe#
     */
    AbstractGlobe.prototype.hasMesh = function() {
        return false;
    };

    /**
     * @function getSubdivisionLength
     * @member AbstractGlobe#
     */
    AbstractGlobe.prototype.getSubdivisionLength = function() {
        return this.subdivisionLength;
    };

    /**
     * @function setSubdivisionLength
     * @member AbstractGlobe#
     */
    AbstractGlobe.prototype.setSubdivisionLength = function(value) {
        this.subdivisionLength = value;
    };

    /**
     * @function getMaxSubdivisionCount
     * @member AbstractGlobe#
     */
    AbstractGlobe.prototype.getMaxSubdivisionCount = function() {
        return this.maxSubdivisionCount;
    };

    /**
     * @function setMaxSubdivisionCount
     * @member AbstractGlobe#
     */
    AbstractGlobe.prototype.setMaxSubdivisionCount = function(value) {
        this.maxSubdivisionCount = value;
    };

    return AbstractGlobe;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributered in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
/**
 * Provides classes for handling a globe.
 * <p>
 * The different possible globes in MIZAR are :
 * <ul>
 *     <li>a sky</li>
 *     <li>a planet</li>
 * </ul>
 * <p>
 * A sky is a globe where the camera is located in it whereas the planet is a globe where the camera
 * is located outside.
 * <br/>
 * In addition to the classes, a {@link module:Globe.GlobeFactory factory} is available to help for creating globe.
 * Once the globe is created, the client can handle it by the use of its {@link Globe interface}.
 *
 * @module Globe
 * @implements {Globe}
 */
define('gw/Globe/Planet',[
    "../Tiling/Tile",
    "../Utils/Event",
    "../Utils/Utils",
    "./AbstractGlobe",
    "../Utils/Constants"
], function(Tile, Event, Utils, AbstractGlobe, Constants) {
    /**
     * @name Planet
     * @class
     * Create a virtual planet in a HTML canvas element with its own coordinate reference system.
     * @augments AbstractGlobe
     * @param {AbstractGlobe.configuration} options - Planet configuration
     * @constructor
     * @memberof module:Globe
     */
    var Planet = function(options) {
        AbstractGlobe.prototype.constructor.call(
            this,
            Constants.GLOBE.Planet,
            options
        );
        this.manualRendererlayers = [];
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractGlobe, Planet);

    /**************************************************************************************************************/

    /**
     * Sets the base imagery layer for the Planet.
     * @function setBaseImagery
     * @memberof Planet#
     * @param {AbstractRasterLayer} layer the layer to use
     * @throws {RangeError} layer must be set.
     */
    Planet.prototype.setBaseImagery = function(layer) {
        if (layer == null) {
            throw new RangeError("layer must be exist.", "Planet.js");
        }

        if (layer === this.baseImagery) {
            return;
        }

        if (this.baseImagery) {
            this.tileManager.setImageryProvider(null);
            this.baseImagery = null;
        }

        // Attach the layer to the globe
        this.definedBackgound = true;
        layer.background = true;
        layer.visible = true;
        //setImageryProvider needs visible=true and we cannit
        if (layer.isDetached()) {
            this.addLayer(layer);
        }
        this.tileManager.setImageryProvider(layer);
        this.baseImagery = layer;
        this.publishEvent(Constants.EVENT_MSG.LAYER_BACKGROUND_CHANGED, layer);
    };

    /**
     * @function setBaseElevation
     * @memberof Planet#
     */
    Planet.prototype.setBaseElevation = function(layer) {
        if (this.tileManager.elevationProvider) {
            this.removeLayer(this.tileManager.elevationProvider);
        }
        this.tileManager.setElevationProvider(layer);
        if (layer) {
            this.addLayer(layer);
        }
    };

    /**
     * @function getElevation
     * @memberof Planet#
     */
    Planet.prototype.getElevation = function(lon, lat) {
        // Use imagery provider tiling if defined, otherwise use globe default one
        var tiling = this.tileManager.tiling;
        if (this.baseImagery) {
            tiling = this.baseImagery.tiling;
        }
        var levelZeroTile = this.tileManager.level0Tiles[
            tiling.lonlat2LevelZeroIndex(lon, lat)
        ];

        if (
            Tile.State &&
            levelZeroTile &&
            levelZeroTile.state === Tile.State.LOADED
        ) {
            return levelZeroTile.getElevation(lon, lat);
        } else {
            return 0.0;
        }
    };

    /**
     * @function render
     * @memberof Planet#
     */
    Planet.prototype.render = function() {
        if (this.isEnabled()) {
            // Call pre-renderers (only in 3D mode, no atmosphere for 2D)
            if (!this.coordinateSystem.isFlat()) {
                for (var i = 0; i < this.preRenderers.length; i++) {
                    this.preRenderers[i].preRender();
                }
            }
            // Render tiles
            this.tileManager.render();
        }

        this.cachedPickingValue = null;
    };

    /**
     * @function hashMesh
     * @memberof Planet#
     */
    Planet.prototype.hasMesh = function() {
        return true;
    };

    /**************************************************************************************************************/

    return Planet;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Globe/Sky',[
    "../Tiling/TileManager",
    "../Tiling/TilePool",
    "../Utils/Utils",
    "./AbstractGlobe",
    "../Utils/Constants"
], function(TileManager, TilePool, Utils, AbstractGlobe, Constants) {
    /**
     * @name Sky
     * @class
     * Create a virtual sky in a HTML canvas element with its own coordinate reference system.
     *
     * The sky handles two different grids in the same time in order to display both
     * the galactic and equatorial rasters.
     *
     * @augments AbstractGlobe
     * @param {AbstractGlobe.configuration} options - Sky configuration
     * @constructor
     * @memberof module:Globe
     */
    var Sky = function(options) {
        AbstractGlobe.prototype.constructor.call(
            this,
            Constants.GLOBE.Sky,
            options
        );
        this.tilePool = new TilePool(this.renderContext);

        this.tileManagers = {
            Equatorial: this.tileManager,
            Galactic: new TileManager(this, options)
        };

        this.renderContext.requestFrame();
    };

    /**************************************************************************************************************/
    Utils.inherits(AbstractGlobe, Sky);

    /**************************************************************************************************************/

    /**
     * @function dispose
     * @memberof Sky#
     */
    Sky.prototype.dispose = function() {
        for (var x in this.tileManagers) {
            if (this.tileManagers.hasOwnProperty(x)) {
                this.tileManagers[x].reset();
                this.tileManagers[x].tilePool.disposeAll();
            }
        }
    };

    /**
     * @function setBaseImagery
     * @memberof Sky#
     * @throws {RangeError} Layer must be set
     **/
    Sky.prototype.setBaseImagery = function(layer) {
        if (layer == null) {
            throw new RangeError("layer must be exist.", "Sky.js");
        }

        if (this.baseImagery === layer) {
            return;
        }

        if (this.baseImagery) {
            this.tileManagers[
                this.baseImagery.tiling.coordinateSystem.getGeoideName()
            ].setImageryProvider(null);
            this.baseImagery = null;
        }

        layer.loadOverview();

        // Attach the layer to the globe
        this.definedBackgound = true;
        layer.visible = true;
        if (layer.isDetached()) {
            this.addLayer(layer);
        }
        this.tileManagers[
            layer.tiling.coordinateSystem.getGeoideName()
        ].setImageryProvider(layer);
        this.baseImagery = layer;
        this.publishEvent(Constants.EVENT_MSG.LAYER_BACKGROUND_CHANGED, layer);
    };

    /**
     * @function render
     * @memberof Sky#
     */
    Sky.prototype.render = function() {
        // Render tiles manager
        if (this.isEnabled()) {
            this.tileManagers[Constants.CRS.Galactic].render();
            this.tileManagers[Constants.CRS.Equatorial].render();
        }
    };

    /**
     * @function destroy
     * @memberof Sky#
     */
    Sky.prototype.destroy = function() {
        AbstractGlobe.prototype.destroy.call(this);
        this.tileManagers.Galactic.reset();
        this.tileManagers.Galactic.tilePool.disposeAll();
        this.tileManagers = null;
    };

    /**************************************************************************************************************/

    return Sky;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name GlobeFactory
 * @class
 * Factory to create a globe.
 * @memberof module:Globe
 */
define('gw/Globe/GlobeFactory',["./Planet", "./Sky", "../Utils/Constants"], function(
    Planet,
    Sky,
    Constants
) {
    return {
        /**
         * Creates a specific globe based on its type (e.g sky, planet).
         * @param {GLOBE} type - the type of globe
         * @param {AbstractGlobe.configuration} options - options to configure a globe
         * @return {Globe} a globe
         * @alias module:Globe.GlobeFactory.create
         * @throws {RangeError} Will throw an error when the type is not part of {@link GLOBE}
         * @see {@link module:Globe.Planet Planet}
         * @see {@link module:Globe.Sky Sky}
         */
        create: function(type, options) {
            var obj;
            switch (type) {
            case Constants.GLOBE.Planet:
                obj = new Planet(options);
                break;
            case Constants.GLOBE.Sky:
                obj = new Sky(options);
                break;
            default:
                throw RangeError(
                    "The type " +
                            type +
                            " is not allowed, A valid type is included in the list GLOBE",
                    "GlobeFactory.js"
                );
            }

            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Navigation/GoogleMouseNavigationHandler',["../Utils/Constants"], function(Constants) {
    /**
     * Google mouse navigation handler configuration
     * @typedef {Object} AbstractNavigation.googleMouse_configuration
     */

    /**
     * @name GoogleMouseNavigationHandler
     * @class
     * GoogleMouseNavigationHandler constructor
     * @param {AbstractNavigation.googleMouse_configuration} options
     * @constructor
     * @memberof module:Navigation
     */
    var GoogleMouseNavigationHandler = function(options) {
        /**************************************************************************************************************/

        /**
         * Private variables
         */

        var _navigation = null;
        var _pressedButton = -1;
        var _lastMouseX = -1;
        var _lastMouseY = -1;
        var _needsStartEvent = false;
        var _needsEndEvent = false;
        var _dx = 0;
        var _dy = 0;
        var _pressedGeo = null;
        var _changeInertia = null;
        var _slower = 0;

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         * Event handler for mouse wheel
         * @function _handleMouseWheel
         * @param event Event
         * @returns {boolean}
         * @private
         * @memberof GoogleMouseNavigationHandler#
         * @fires Context#startNavigation
         * @fires Context#endNavigation
         */
        var _handleMouseWheel = function(event) {
            _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

            var factor;
            var geo, pos;

            // Check differences between firefox and the rest of the world
            if (typeof event.wheelDelta === "undefined") {
                factor = event.detail;
            } else {
                factor = -event.wheelDelta / 120.0;
            }

            if (!_navigation.inertia) {
                // Compute mouse position and corresponding lon lat before zoom
                pos = _navigation.ctx
                    .getRenderContext()
                    .getXYRelativeToCanvas(event);
                geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);
            }

            _navigation.zoom(factor);

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            // Launch inertia if needed
            if (_navigation.inertia) {
                _navigation.inertia.launch("zoom", factor < 0 ? -1 : 1);
            } else {
                // Compute the new position of lon lat and pan the globe toward it
                if (geo) {
                    var pos2 = _navigation.ctx.getPixelFromLonLat(
                        geo[0],
                        geo[1]
                    );

                    var dx = pos[0] - pos2[0];
                    var widthHeightFactor = Math.round(
                        _navigation.ctx.getRenderContext().getCanvas().width /
                            _navigation.ctx.getRenderContext().getCanvas()
                                .height
                    );
                    widthHeightFactor =
                        widthHeightFactor < 1 ? 1 : widthHeightFactor;
                    dx *= widthHeightFactor;
                    var dy = pos[1] - pos2[1];
                    _navigation.pan(dx, dy);
                }
            }

            // Stop mouse wheel to be propagated, because default is to scroll the page
            // This is need when using Firefox event listener on DOMMouseScroll
            if (event.preventDefault) {
                event.preventDefault();
            }
            event.returnValue = false;

            _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_ENDED);
            _navigation.ctx.getRenderContext().requestFrame();

            // Return false to stop mouse wheel to be propagated when using onmousewheel
            return false;
        };

        /**
         * Event handler for mouse down
         * @function _handleMouseDown
         * @param event
         * @returns {boolean}
         * @private
         * @memberof GoogleMouseNavigationHandler#
         */
        var _handleMouseDown = function(event) {
            _pressedButton = event.button;

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            _lastMouseX = event.clientX;
            _lastMouseY = event.clientY;
            _dx = 0;
            _dy = 0;

            // Middle click
            if (event.button === 1) {
                // Cursor's style modification: Rotating icon
                _navigation.ctx.getRenderContext().getCanvas().style.cursor =
                    "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABeUlEQVR42u2XS07DMBCGbaCCQstzy4YDcAGWCAE3YI3omsN0XcSaGxSEWHIBDsCGLY9SykM80m/CFLkhIBycVpVi6ZetUez/S2x5JtYMudkCYJQBbGJ+pBoIgMybQKUoijrW2hnGr+jNFyILQM+8jHkLc0Nv6OeIPflC+AJ8M++1rBA+AD+a/wfCB2Bczdtp5gmIqkK8hwSQt69gcNu3gJ6BRGyB7kG/QlAAOe3rSD5zFeO6cwj3ibVRC52hTmgA2YJJVUUgML5wAFbVXN78RRV0C+TZMVUZLWJ86QCsELsxn3v/oQp6CN02hZYwvnIAloldo2efhQqAAqAAGKl7IL4JpQDpWyA9F8iVHfwmjHMBZnd/yIbzJodcEGdDtInJ0S/1wA7DE5NDNozrATSLtjE7SKmI9hg20b3JoR74qogUYgvThnMIa8SOHfPgFVEaxAbmh5jvMj71Nc8CkISYRmvoHD36mmcFcCFKOhbDgf0XuHOH9mcUrHUBoVXvIfh2krcAAAAASUVORK5CYII=), auto";
            }
            // Left and right click
            else {
                // Save the lon lat clicked
                var pressedPos = _navigation.ctx
                    .getRenderContext()
                    .getXYRelativeToCanvas(event);
                _pressedGeo = _navigation.ctx.getLonLatFromPixel(
                    pressedPos[0],
                    pressedPos[1]
                );

                // Left click
                if (event.button === 0) {
                    // Cursor's style modification: Grabbing icon
                    _navigation.ctx
                        .getRenderContext()
                        .getCanvas().style.cursor =
                        "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAAZUlEQVR42sSTQQrAMAgEHcn/v7w9tYgNNsGW7kkI2TgbRZJ15NbU+waAAFV11MiXz0yq2sxMEiVCDDcHLeky8nQAUDJnM88IuyGOGf/n3wjcQ1zhf+xgxSS+PkXY7aQ9yvy+jccAMs9AI/bwo38AAAAASUVORK5CYII=), auto";
                }
                // Right click
                else {
                    // Cursor's style modification: Zooming (same as Rotating) icon
                    _navigation.ctx
                        .getRenderContext()
                        .getCanvas().style.cursor =
                        "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABeUlEQVR42u2XS07DMBCGbaCCQstzy4YDcAGWCAE3YI3omsN0XcSaGxSEWHIBDsCGLY9SykM80m/CFLkhIBycVpVi6ZetUez/S2x5JtYMudkCYJQBbGJ+pBoIgMybQKUoijrW2hnGr+jNFyILQM+8jHkLc0Nv6OeIPflC+AJ8M++1rBA+AD+a/wfCB2Bczdtp5gmIqkK8hwSQt69gcNu3gJ6BRGyB7kG/QlAAOe3rSD5zFeO6cwj3ibVRC52hTmgA2YJJVUUgML5wAFbVXN78RRV0C+TZMVUZLWJ86QCsELsxn3v/oQp6CN02hZYwvnIAloldo2efhQqAAqAAGKl7IL4JpQDpWyA9F8iVHfwmjHMBZnd/yIbzJodcEGdDtInJ0S/1wA7DE5NDNozrATSLtjE7SKmI9hg20b3JoR74qogUYgvThnMIa8SOHfPgFVEaxAbmh5jvMj71Nc8CkISYRmvoHD36mmcFcCFKOhbDgf0XuHOH9mcUrHUBoVXvIfh2krcAAAAASUVORK5CYII=), auto";
                }
            }

            _needsStartEvent = true;

            // Return false to stop mouse down to be propagated when using onmousedown
            return false;
        };

        /**
         * Event handler for mouse up
         * @function _handleMouseUp
         * @param event
         * @returns {boolean}
         * @private
         * @memberof GoogleMouseNavigationHandler#
         * @fires Context#endNavigation
         */
        var _handleMouseUp = function(event) {
            // No button pressed anymore
            _pressedButton = -1;

            if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
                // Left click
                if (event.button === 0) {
                    //different behavior if the move has change from pan to rotate
                    if (_changeInertia) {
                        _navigation.inertia.launch("rotate", _changeInertia, 0);
                    } else {
                        _navigation.inertia.launch("pan", _dx, _dy);
                    }
                }
                // Middle click
                else if (event.button === 1) {
                    _navigation.inertia.launch("rotate", -_dx, -_dy);
                }
            }

            // Cursor's style modification : Hand icon
            _navigation.ctx.getRenderContext().getCanvas().style.cursor =
                "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAAjElEQVR42pyRQRLAIAwCoePD8vT8jB7aONHRVuWagBuku2MmMxMAuDtnO2VmMDNJAgCQVOz0YSWbR4ZQnuWQC4cK2pLRSEoSJIHkp/nd0RFBnFMJUnkgiaAYGXrxmdeCfg2NmWxLXDWG2d15veUdhdRv7EO2A3YV+E3AKUVDsBKSXx+esEvC3dZ73QMAeuphLLn/cTIAAAAASUVORK5CYII=), auto";

            _pressedGeo = null;
            _slower = 0;

            if (_needsEndEvent) {
                _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_ENDED);
            }

            _needsStartEvent = false;
            _needsEndEvent = false;

            // Stop mouse up event
            return false;
        };

        /**
         * Event handler for mouse move
         * @function _handleMouseMove
         * @param event
         * @returns {boolean}
         * @private
         * @memberof GoogleMouseNavigationHandler#
         * @fires Context#startNavigation
         * @fires Context#endNavigation
         */
        var _handleMouseMove = function(event) {
            // No button pressed
            if (_pressedButton < 0) {
                return;
            }

            _dx = event.clientX - _lastMouseX;
            _dy = event.clientY - _lastMouseY;

            if (_dx === 0 && _dy === 0) {
                return;
            }

            var ret = false;
            var inside;
            var pos, pos2;

            // Pan on Left click
            if (_pressedButton === 0) {
                if (_needsStartEvent) {
                    _navigation.ctx.publish(
                        Constants.EVENT_MSG.NAVIGATION_STARTED
                    );
                    _needsStartEvent = false;
                    _needsEndEvent = true;
                }

                // Compute the mouse position
                pos = _navigation.ctx
                    .getRenderContext()
                    .getXYRelativeToCanvas(event);
                if (_pressedGeo) {
                    _changeInertia = null;
                    inside = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);
                    if (inside) {
                        pos2 = _navigation.ctx.getPixelFromLonLat(
                            _pressedGeo[0],
                            _pressedGeo[1]
                        );
                        _dx = pos[0] - pos2[0];
                        _dy = pos[1] - pos2[1];
                        _navigation.pan(_dx, _dy);
                    }
                }
                // If the mouse not on the globe
                if (!_pressedGeo || !inside) {
                    if (Math.abs(_dx) > Math.abs(_dy)) {
                        _changeInertia =
                            pos[1] >
                            _navigation.ctx.getRenderContext().getCanvas()
                                .height /
                                2
                                ? -_dx
                                : _dx;
                    } else {
                        _changeInertia =
                            pos[0] >
                            _navigation.ctx.getRenderContext().getCanvas()
                                .width /
                                2
                                ? _dy
                                : -_dy;
                    }
                    _navigation.rotate(_changeInertia, 0);
                    pos = _navigation.ctx
                        .getRenderContext()
                        .getXYRelativeToCanvas(event);
                    _pressedGeo = _navigation.ctx.getLonLatFromPixel(
                        pos[0],
                        pos[1]
                    );
                    if (_pressedGeo) {
                        _changeInertia = null;
                    }
                }

                _navigation.ctx.getRenderContext().requestFrame();
                ret = true;
            }
            // Rotate on Middle click
            else if (_pressedButton === 1) {
                _navigation.rotate(-_dx, -_dy);
                _navigation.ctx.getRenderContext().requestFrame();
                ret = true;
            }
            // Zoom on Right click
            else {
                // Mouse move is too fast for zooming, need to slow it down
                _slower++;
                if (_slower % 3 === 0 && _slower > 1) {
                    _navigation.ctx.publish(
                        Constants.EVENT_MSG.NAVIGATION_STARTED
                    );

                    _navigation.zoom(-_dy / 10);

                    if (_dy > 0 && _dy > _dx) {
                        // Compute the new position of lon lat and pan the globe toward it
                        if (_pressedGeo) {
                            pos = [
                                _navigation.ctx.getRenderContext().getCanvas()
                                    .clientLeft +
                                    _navigation.ctx
                                        .getRenderContext()
                                        .getCanvas().clientWidth /
                                        2,
                                _navigation.ctx.getRenderContext().getCanvas()
                                    .clientTop +
                                    _navigation.ctx
                                        .getRenderContext()
                                        .getCanvas().clientHeight /
                                        2
                            ];
                            pos2 = _navigation.ctx.getPixelFromLonLat(
                                _pressedGeo[0],
                                _pressedGeo[1]
                            );

                            var dx = pos[0] - pos2[0];
                            dx = (dx * 10) / 100;
                            var dy = pos[1] - pos2[1];
                            dy = (dy * 10) / 100;

                            _navigation.pan(dx, dy);
                        }
                    }

                    // Stop all animations when an event is received
                    _navigation.stopAnimations();

                    _navigation.ctx.publish(
                        Constants.EVENT_MSG.NAVIGATION_ENDED
                    );
                    _navigation.ctx.getRenderContext().requestFrame();
                }

                ret = true;
            }

            _lastMouseX = event.clientX;
            _lastMouseY = event.clientY;

            return ret;
        };

        /**
         * Event handler for mouse double click
         * @function _handleMouseDblClick
         * @param event
         * @private
         * @memberof GoogleMouseNavigationHandler#
         */
        var _handleMouseDblClick = function(event) {
            if (event.button === 0) {
                var pos = _navigation.ctx
                    .getRenderContext()
                    .getXYRelativeToCanvas(event);
                var geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);

                if (geo) {
                    _navigation.zoomTo(geo);
                }
            }
        };

        /**
         * Event handler for mouse context menu
         * @function _handleContextMenu
         * @param event
         * @private
         * @memberof GoogleMouseNavigationHandler#
         */
        var _handleContextMenu = function(event) {
            // Need this so browser's context menu won't show up when using right click zooming
            event.preventDefault();
            return false;
        };

        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         * Setup the default event handlers for the _navigation
         * @function install
         * @param nav
         * @memberof GoogleMouseNavigationHandler#
         * @fires Context#startNavigation
         * @fires Context#endNavigation
         */
        this.install = function(nav) {
            _navigation = nav;

            var canvas = _navigation.getRenderContext.getCanvas;

            // Cursor's style modification : Hand icon
            canvas.style.cursor =
                "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAAjElEQVR42pyRQRLAIAwCoePD8vT8jB7aONHRVuWagBuku2MmMxMAuDtnO2VmMDNJAgCQVOz0YSWbR4ZQnuWQC4cK2pLRSEoSJIHkp/nd0RFBnFMJUnkgiaAYGXrxmdeCfg2NmWxLXDWG2d15veUdhdRv7EO2A3YV+E3AKUVDsBKSXx+esEvC3dZ73QMAeuphLLn/cTIAAAAASUVORK5CYII=), auto";

            // Setup the mouse event handlers
            canvas.addEventListener("mousedown", _handleMouseDown);
            canvas.addEventListener("mouseup", _handleMouseUp);
            canvas.addEventListener("mousemove", _handleMouseMove);
            canvas.addEventListener("contextmenu", _handleContextMenu);
            canvas.addEventListener("dblclick", _handleMouseDblClick);

            // For Firefox
            canvas.addEventListener("DOMMouseScroll", _handleMouseWheel);
            canvas.addEventListener("mousewheel", _handleMouseWheel);
        };

        /**
         * Remove the default event handlers for the _navigation
         * @function uninstall
         * @memberof GoogleMouseNavigationHandler#
         */
        this.uninstall = function() {
            // Setup the mouse event handlers
            var canvas = _navigation.getRenderContext().getCanvas();

            canvas.style.cursor = "auto";

            canvas.removeEventListener("mousedown", _handleMouseDown);
            canvas.removeEventListener("mouseup", _handleMouseUp);
            canvas.removeEventListener("mousemove", _handleMouseMove);
            canvas.removeEventListener("contextmenu", _handleContextMenu);
            canvas.removeEventListener("dblclick", _handleMouseDblClick);

            // For Firefox
            canvas.removeEventListener("DOMMouseScroll", _handleMouseWheel);
            canvas.removeEventListener("mousewheel", _handleMouseWheel);
        };
    };

    return GoogleMouseNavigationHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Navigation/KeyboardNavigationHandler',["../Utils/Constants"], function(Constants) {
    /**
     * Keyboard navigation handler configuration
     * @typedef {Object} AbstractNavigation.keyboard_configuration
     * @property {float} [panFactor = 10.0] - Factor for panning within the scene
     * @property {float} [zoomFactor = 1.0] - Factor for zooming into the scene
     * @property {boolean} [installOnDocument = false] -true to install the event listener on the document and not on the canvas
     */

    /**
     * @name KeyboardNavigationHandler
     * @class
     * KeyboardNavigationHandler constructor.<br/>
     * The keyboard shortcuts are the following :
     * <ul>
     *     <li><i>space bar</i> : Stop all animations when an event is received</li>
     *     <li><i>+</i> : zoom in the camera</li>
     *     <li><i>-</i> : zoom out the camera</li>
     *     <li><i>Left arrow</i> : pan the camera left</li>
     *     <li><i>shift + left arrow</i> : rotate the camera counterclockwise</li>
     *     <li><i>Right arrow</i> : pan the camera right</li>
     *     <li><i>shift + right arrow</i> : rotate the camera clockwise</li>
     *     <li><i>Up arrow</i> : pan the camera up</li>
     *     <li><i>shift + up arrow</i> : rotate the camera up</li>
     *     <li><i>Down arrow</i> : pan the camera down</li>
     *     <li><i>shift + down arrow</i> : rotate the camera down</li>
     * </ul>
     *
     * @param {AbstractNavigation.keyboard_configuration} options - Keyboard navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var KeyboardNavigationHandler = function(options) {
        /**************************************************************************************************************/

        /**
         * Private variables
         */
        var _navigation = null;
        var self = this;

        /**
         * Public variables
         */
        this.panFactor = 10.0;
        this.zoomFactor = 1.0;

        // Setup options
        if (options) {
            if (options.panFactor && typeof options.panFactor === "number") {
                this.panFactor = options.panFactor;
            }
            if (options.zoomFactor && typeof options.zoomFactor === "number") {
                this.zoomFactor = options.zoomFactor;
            }
        }

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         * Set focus
         */
        var _setFocus = function(event) {
            this.focus();
            return false;
        };

        /**
         * Event handler for key down.
         * @param event
         * @private
         */
        var _handleKeyDown = function(event) {
            switch (event.keyCode) {
            case 32:
                _navigation.ctx.publish(
                    Constants.EVENT_MSG.NAVIGATION_STARTED
                );
                // space bar
                // Stop all animations when an event is received
                _navigation.stopAnimations();
                break;
            case 187:
                // + on Safari
                // falls through
            case 61:
                // +(=) on Firefox and Opera
                // falls through
            case 107:
                // + on other
                _navigation.ctx.publish(
                    Constants.EVENT_MSG.NAVIGATION_STARTED
                );
                _navigation.zoom(-self.zoomFactor);
                break;
            case 189:
                // - on Safari
                // falls through
            case 54:
                // -(6) on Firefox and Opera
                // falls through
            case 109:
                // - on other
                _navigation.ctx.publish(
                    Constants.EVENT_MSG.NAVIGATION_STARTED
                );
                _navigation.zoom(self.zoomFactor);
                break;
            case 81:
                // q
                // falls through
            case 37:
                // Left arrow
                _navigation.ctx.publish(
                    Constants.EVENT_MSG.NAVIGATION_STARTED
                );
                if (event.shiftKey) {
                    _navigation.rotate(self.panFactor, 0);
                } else {
                    _navigation.pan(self.panFactor, 0);
                }
                break;
            case 90:
                // z
                // falls through
            case 38:
                // Up arrow
                _navigation.ctx.publish(
                    Constants.EVENT_MSG.NAVIGATION_STARTED
                );
                if (event.shiftKey) {
                    _navigation.rotate(0, self.panFactor);
                } else {
                    _navigation.pan(0, self.panFactor);
                }
                break;
            case 68:
                // d
                // falls through
            case 39:
                // Right arrow
                _navigation.ctx.publish(
                    Constants.EVENT_MSG.NAVIGATION_STARTED
                );
                if (event.shiftKey) {
                    _navigation.rotate(-self.panFactor, 0);
                } else {
                    _navigation.pan(-self.panFactor, 0);
                }
                break;
            case 83:
                // s
                // falls through
            case 40:
                // Down arrow
                _navigation.ctx.publish(
                    Constants.EVENT_MSG.NAVIGATION_STARTED
                );
                if (event.shiftKey) {
                    _navigation.rotate(0, -self.panFactor);
                } else {
                    _navigation.pan(0, -self.panFactor);
                }
                break;
            }
        };

        var _handleKeyUp = function(event) {
            _navigation.donePanning();
            _navigation.doneRotating();
        };

        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         Setup the default event handlers for the navigation
         */
        this.install = function(navigation) {
            // Setup the keyboard event handlers
            _navigation = navigation;

            if (options && options.installOnDocument) {
                document.addEventListener("keydown", _handleKeyDown);
                document.addEventListener("keyup", _handleKeyUp);
            } else {
                var canvas = _navigation.renderContext.canvas;
                canvas.addEventListener("keydown", _handleKeyDown);
                canvas.addEventListener("keyup", _handleKeyUp);
                // Setup focus handling to receive keyboard event on canvas
                canvas.tabIndex = "0";
                canvas.addEventListener("mousedown", _setFocus);
            }
        };

        /**
         Remove the default event handlers for the navigation
         */
        this.uninstall = function() {
            if (options && options.installOnDocument) {
                document.removeEventListener("keydown", _handleKeyDown);
                document.removeEventListener("keyup", _handleKeyUp);
            } else {
                var canvas = _navigation.renderContext.canvas;
                canvas.removeEventListener("keydown", _handleKeyDown);
                canvas.removeEventListener("keyup", _handleKeyUp);
                canvas.removeEventListener("mousedown", _setFocus);
            }
        };
    };

    return KeyboardNavigationHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Navigation/MouseNavigationHandler',["../Utils/Utils", "../Utils/Constants"], function(Utils, Constants) {
    /**
     * Mouse navigation handler configuration
     * @typedef {Object} AbstractNavigation.mouse_configuration
     * @property {float} [panButton = 0]
     * @property {float} [rotateButton = 1]
     * @property {boolean} [zoomOnDblClick = false] - if true defines animation on double click
     * @property {Object} [zoomOptions] - @see look at options in {@link Navigation#zoomTo}
     */

    /**
     * @name MouseNavigationHandler
     * @class
     * Mouse_navigationHandler constructor.<br/>
     * The mouse movements are the following :
     * <ul>
     *     <li><i>Wheel up</i> : zoom in the camera</li>
     *     <li><i>Wheel down</i> : zoom out the camera</li>
     *     <li><i>Click left+Ri + left mouse</i> : pan the camera right</li>
     *     <li><i>Wheel press + left mouse</i> : rotate the camera counterclockwise</li>
     *     <li><i>Click left + right mouse</i> : pan the camera left</li>
     *     <li><i>Wheel press + right arrow</i> : rotate the camera clockwise</li>
     *     <li><i>Click left + up mouse</i> : pan the camera down</li>
     *     <li><i>Wheel press + up mouse</i> : rotate the camera down</li>
     *     <li><i>Click left + down mouse</i> : pan the camera up</li>
     *     <li><i>Wheel press + down mouse</i> : rotate the camera up</li>
     * </ul>
     * @param {AbstractNavigation.mouse_configuration} options - Mouse navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var MouseNavigationHandler = function(options) {
        /**************************************************************************************************************/

        /**
         * Private variables
         */

        var _navigation = null;
        var _pressedButton = -1;
        var _lastMouseX = -1;
        var _lastMouseY = -1;
        var _dx = 0;
        var _dy = 0;
        var _panButton = (options && options.panButton) || 0;
        var _rotateButton = (options && options.rotateButton) || 1;
        var _zoomOptions =
            options && options.zoomOptions ? options.zoomOptions : {};

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         Event handler for mouse wheel
         */
        var _handleMouseWheel = function(event) {
            var factor;

            // Check differences between firefox and the rest of the world
            if (event.wheelDelta === undefined) {
                factor = event.detail;
            } else {
                factor = -event.wheelDelta / 120.0;
            }

            _navigation.ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_STARTED
            );
            _navigation.zoom(factor, null, event.clientX, event.clientY);

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            // Launch inertia if needed
            if (_navigation.inertia) {
                _navigation.inertia.launch("zoom", factor < 0 ? -1 : 1);
            }

            event.returnValue = false;

            // Return false to stop mouse wheel to be propagated when using onmousewheel
            return false;
        };

        /**
         * Event handler for mouse down
         */
        var _handleMouseDown = function(event) {
            document.addEventListener("mouseup", _handleMouseUp);
            _pressedButton = event.button;

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            if (event.button === _panButton || event.button === _rotateButton) {
                _lastMouseX = event.clientX;
                _lastMouseY = event.clientY;
                _dx = 0;
                _dy = 0;

                _navigation.ctx.publish(
                    Constants.EVENT_MSG.NAVIGATION_STARTED
                );

                _navigation.startInteraction(_lastMouseX, _lastMouseY);

                // Return false to stop mouse down to be propagated when using onmousedown
                return false;
            }

            return true;
        };

        /**
         * Event handler for mouse up
         */
        var _handleMouseUp = function(event) {
            // No button pressed anymore
            _pressedButton = -1;
            document.removeEventListener("mouseup", _handleMouseUp);

            if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
                if (event.button === _panButton) {
                    _navigation.inertia.launch("pan", _dx, _dy);
                }
                if (event.button === _rotateButton) {
                    _navigation.inertia.launch("rotate", _dx, _dy);
                }
            }

            if (event.button === _panButton) {
                _navigation.donePanning();
            }

            if (event.button === _rotateButton) {
                _navigation.doneRotating();
            }

            _navigation.ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_ENDED
            );

            if (event.button === _panButton || event.button === _rotateButton) {
                event.preventDefault();

                // Stop mouse up event
                return false;
            }

            return true;
        };

        /**
         Event handler for mouse move
         */
        var _handleMouseMove = function(event) {
            // No button pressed
            if (_pressedButton < 0) {
                return;
            }

            _dx = event.clientX - _lastMouseX;
            _dy = event.clientY - _lastMouseY;

            if (_dx === 0 && _dy === 0) {
                return;
            }

            var ret = false;
            // Pan
            if (_pressedButton === _panButton) {
                _navigation.pan(_dx, _dy, event.clientX, event.clientY);
                ret = true;
            }
            // Rotate
            else if (_pressedButton === _rotateButton) {
                _navigation.rotate(_dx, _dy);
                ret = true;
            }

            _lastMouseX = event.clientX;
            _lastMouseY = event.clientY;

            return ret;
        };

        /**
         Event handler for mouse double click
         */
        var _handleMouseDblClick = function(event) {
            if (event.button === 0) {
                var pos, geo;
                pos = _navigation.ctx
                    .getRenderContext()
                    .getXYRelativeToCanvas(event);
                geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);

                if (geo) {
                    _navigation.zoomTo(geo, _zoomOptions);
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         *    Setup the default event handlers for the _navigation
         */
        this.install = function(nav) {
            _navigation = nav;
            var canvas = _navigation.renderContext.canvas;

            var passiveSupported = Utils.isPassiveSupported();

            // Setup the mouse event handlers
            canvas.addEventListener("mousedown", _handleMouseDown);
            canvas.addEventListener("mousemove", _handleMouseMove);

            if (options && options.zoomOnDblClick) {
                canvas.addEventListener("dblclick", _handleMouseDblClick);
            }

            // For Firefox
            canvas.addEventListener(
                "DOMMouseScroll",
                _handleMouseWheel,
                passiveSupported ? { passive: true } : false
            );
            canvas.addEventListener(
                "mousewheel",
                _handleMouseWheel,
                passiveSupported ? { passive: true } : false
            );

            // Fix for Google Chrome : avoid dragging
            // TODO : a hack, should be more robust (restore on uninstall?)
            canvas.addEventListener("dragstart", function(event) {
                event.preventDefault();
                return false;
            });

            if (_rotateButton === 2) {
                canvas.addEventListener(
                    "contextmenu",
                    function(e) {
                        e.preventDefault();
                        return false;
                    },
                    false
                );
            }
        };

        /**
         *    Remove the default event handlers for the _navigation
         */
        this.uninstall = function() {
            // Setup the mouse event handlers
            var canvas = _navigation.renderContext.canvas;

            canvas.removeEventListener("mousedown", _handleMouseDown);
            canvas.removeEventListener("mousemove", _handleMouseMove);

            if (options && options.zoomOnDblClick) {
                canvas.removeEventListener("dblclick", _handleMouseDblClick);
            }

            // For Firefox
            canvas.removeEventListener("DOMMouseScroll", _handleMouseWheel);
            canvas.removeEventListener("mousewheel", _handleMouseWheel);
        };
    };

    return MouseNavigationHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Navigation/TouchNavigationHandler',["../Utils/Utils", "../Utils/Constants", "../Gui/dialog/ErrorDialog"], function(Utils, Constants, ErrorDialog) {
    /**************************************************************************************************************/

    /**
     *    Types of actions for inertia execution
     */
    var Type = {
        PAN: 0,
        ROTATE: 1,
        TILT: 2,
        ZOOM: 3
    };

    /**
     * Touch navigation handler configuration
     * @typedef {Object} AbstractNavigation.touch_configuration
     * @property {boolean} [inversed = false] - if true inverse the sens of touching events
     * @property {boolean} [zoomOnDblClick = false] - if true defines animation on double click
     */

    /**
     * @name TouchNavigationHandler
     * @class
     * TouchNavigationHandler constructor
     * @param {AbstractNavigation.touch_configuration} options - Touch navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var TouchNavigationHandler = function(options) {
        /**************************************************************************************************************/

        /**
         * Private variables
         */

        var _navigation = null;
        var _lastFingerDistance;

        var _startTouches = [];
        var _lastTouches;
        var _lastAngle;

        var _dx, _dy;

        // Parameters for intertia management
        var _actionHits = [0, 0, 0, 0];
        var _lastTapDate;
        var _rotation;

        // Double tap
        var _doubletap_interval = 300;
        var _inversed =
            options && options.hasOwnProperty("inversed")
                ? options.inversed
                : false;

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         * Calculate the angle between two coordinates
         */
        var _getAngle = function(touch1, touch2) {
            var y = touch2.clientY - touch1.clientY,
                x = touch2.clientX - touch1.clientX;
            return (Math.atan2(y, x) * 180) / Math.PI;
        };

        /**************************************************************************************************************/

        /**
         * Calculate the rotation degrees between two touchLists (fingers)
         */
        var _getRotation = function(start, end) {
            // Need two fingers
            if (start.length >= 2 && end.length >= 2) {
                return (
                    _getAngle(end[1], end[0]) - _getAngle(start[1], start[0])
                );
            }
            return 0;
        };

        /**************************************************************************************************************/

        /**
         Handle touch start event
         */
        var _handleTouchStart = function(event) {
            //console.log("# events : " + event.touches.length );
            _lastTouches = event.touches;
            _startTouches = event.touches;

            _actionHits = [0, 0, 0, 0];

            _navigation.ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_STARTED
            );

            _navigation.startInteraction(event.touches[0].clientX, event.touches[0].clientY);

            // Stop all animations when an event is received
            _navigation.stopAnimations();
            _dx = 0;
            _dy = 0;
            if (event.touches.length === 2) {
                var dx = event.touches[0].clientX - event.touches[1].clientX;
                var dy = event.touches[0].clientY - event.touches[1].clientY;
                _lastFingerDistance = Math.sqrt(dx * dx + dy * dy);
                ErrorDialog.open(Constants.LEVEL.DEBUG, "TouchNavigationHandler.js","Finger distance : " + _lastFingerDistance);
                _lastAngle = _getRotation(_startTouches, event.touches);
            }

            event.returnValue = false;

            // Return false to stop event to be propagated
            return false;
        };

        /**************************************************************************************************************/

        /**
         Handle touch move event
         */
        var _handleTouchMove = function(event) {
            _dx = event.touches[0].clientX - _lastTouches[0].clientX;
            _dy = event.touches[0].clientY - _lastTouches[0].clientY;
            var dx, dy;
            var rotation, fingerDistance, deltaDistance;

            if (event.touches.length === 1) {
                // Pan
                _navigation.pan(_dx, _dy);
                _actionHits[Type.PAN]++;
            } else {
                // Depending on direction of two fingers, decide if tilt OR rotation
                var sameDirection =
                    (event.touches[0].clientY - _lastTouches[0].clientY) *
                        (event.touches[1].clientY - _lastTouches[1].clientY) >
                    0;
                if (sameDirection) {
                    // Tilt
                    _navigation.rotate(0.0, -_dy);
                    _actionHits[Type.TILT]++;
                } else {
                    // Rotation
                    rotation = _getRotation(_startTouches, event.touches);
                    dx = rotation - _lastAngle;
                    _lastAngle = rotation;

                    if (_inversed) {
                        dx *= -1;
                    }

                    _rotation = dx * 10;
                    _navigation.rotate(_rotation, 0);
                    _actionHits[Type.ROTATE]++;
                }

                // Zoom
                dx = event.touches[0].clientX - event.touches[1].clientX;
                dy = event.touches[0].clientY - event.touches[1].clientY;
                fingerDistance = Math.sqrt(dx * dx + dy * dy);
                deltaDistance = fingerDistance - _lastFingerDistance;

                var scale;
                if (_inversed) {
                    scale = fingerDistance / _lastFingerDistance;
                } else {
                    scale = _lastFingerDistance / fingerDistance;
                }

                if (_lastFingerDistance !== 0) {
                    _navigation.zoom(deltaDistance * 0.025, scale);
                    _actionHits[Type.ZOOM]++;
                }
                _navigation.getRenderContext().requestFrame();
                _lastFingerDistance = fingerDistance;
            }

            // Update _lastTouches
            _lastTouches = event.touches;

            event.returnValue = false;

            return false;
        };

        /**************************************************************************************************************/

        /**
         Handle touch end event
         */
        var _handleTouchEnd = function(event) {
            if (
                options &&
                options.zoomOnDblClick &&
                event.touches.length === 0 &&
                _dx === 0 &&
                _dy === 0
            ) {
                // Handle double tap
                // TODO : take into account the distance
                var now = Date.now();
                if (now - _lastTapDate < _doubletap_interval) {
                    var geo = _navigation.ctx.getLonLatFromPixel(
                        _lastTouches[0].clientX,
                        _lastTouches[0].clientY
                    );

                    if (geo) {
                        _navigation.zoomTo(geo);
                    }
                }
                _lastTapDate = now;
            }

            // Update last touches
            _lastTouches = event.touches;

            if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
                // Launch inertia depending on action hits while "moving" phase
                var hitIndex = _actionHits.indexOf(
                    Math.max.apply(this, _actionHits)
                );
                if (hitIndex === Type.PAN) {
                    // Pan
                    _navigation.inertia.launch("pan", _dx, _dy);
                } else if (hitIndex === Type.ROTATE) {
                    ErrorDialog.open(Constants.LEVEL.DEBUG, "TouchNavigationHandler.js","Rotate not implemented in navigation");
                    // Rotate
                    //_navigation.inertia.launch("rotate", _rotation, 0);
                } else if (hitIndex === Type.TILT) {
                    ErrorDialog.open(Constants.LEVEL.DEBUG, "TouchNavigationHandler.js","Tilt not implemented in navigation");
                    // No inertia for tilt
                }
            }

            if (event.preventDefault) {
                event.preventDefault();
            }
            event.returnValue = false;

            _navigation.ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_ENDED
            );

            return false;
        };

        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         *    Setup the default event handlers for the _navigation
         */
        this.install = function(nav) {
            _navigation = nav;

            // Setup the touch event handlers
            var canvas = _navigation.renderContext.canvas;

            var passiveSupported = Utils.isPassiveSupported();

            canvas.addEventListener(
                "touchstart",
                _handleTouchStart,
                passiveSupported ? { passive: true } : false
            );
            canvas.addEventListener("touchend", _handleTouchEnd, false);
            canvas.addEventListener(
                "touchmove",
                _handleTouchMove,
                passiveSupported ? { passive: true } : false
            );
        };

        /**
         *    Remove the default event handlers for the _navigation
         */
        this.uninstall = function() {
            // Setup the mouse event handlers
            var canvas = _navigation.renderContext.canvas;

            canvas.removeEventListener("touchstart", _handleTouchStart, false);
            canvas.removeEventListener("touchend", _handleTouchEnd, false);
            canvas.removeEventListener("touchmove", _handleTouchMove, false);
        };
    };

    return TouchNavigationHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name NavigationHandlerFactory
 * @class
 * Factory to create a device for the control of the camera.
 * @memberof module:Navigation
 */
define('gw/Navigation/NavigationHandlerFactory',[
    "../Utils/Constants",
    "./GoogleMouseNavigationHandler",
    "./KeyboardNavigationHandler",
    "./MouseNavigationHandler",
    "./TouchNavigationHandler"
], function(
    Constants,
    GoogleMouseNavigationHandler,
    KeyboardNavigationHandler,
    MouseNavigationHandler,
    TouchNavigationHandler
) {
    return {
        /**
         * Creates a specific navigation based on its type (e.g Astro, Flat, Sky).
         * @param {HANDLER} type - the type of navigation
         * @param {AbstractNavigation.touch_configuration|AbstractNavigation.mouse_configuration|AbstractNavigation.googleMouse_configuration|AbstractNavigation.keyboard_configuration} options - see the handlers.
         * @return {Object} one of the handler
         * @alias module:Navigation.NavigationHandlerFactory.create
         * @see {@link GoogleMouseNavigationHandler} - Control the camera with mouse as Google movement
         * @see {@link KeyboardNavigationHandler} - Control the camera with the keyboard
         * @see {@link MouseNavigationHandler} - Control the camera with the mouse
         * @see {@link TouchNavigationHandler} - Control the camera with the smartphone
         * @throws {RangeError} Type not valid - a valid type is included in the list {@link HANDLER}
         */
        create: function(type, options) {
            var obj;
            switch (type) {
            case Constants.HANDLER.GoogleMouse:
                obj = new GoogleMouseNavigationHandler(options);
                break;
            case Constants.HANDLER.Keyboard:
                obj = new KeyboardNavigationHandler(options);
                break;
            case Constants.HANDLER.Mouse:
                obj = new MouseNavigationHandler(options);
                break;
            case Constants.HANDLER.Touch:
                obj = new TouchNavigationHandler(options);
                break;
            default:
                throw RangeError(
                    "The type " +
                            type +
                            " is not allowed, A valid type is included in the list Constants.HANDLER",
                    "NavigationHandlerFactory.js"
                );
            }
            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Animation/AbstractAnimation',[],function() {
    /**
     * @name AbstractAnimation
     * @class
     * AbstractAnimation is an abstract class for all animation contexts which allow
     * an application to create an animation of the camera around the globe.
     * @implements {Animation}
     * @todo Describes here and link to the tutos about Animation
     */
    var AbstractAnimation = function() {
        this.startTime = -1;
        this.pauseTime = -1;
        this.renderContext = null;
    };

    /**
     * @function getRenderContext
     * @memberof AbstractAnimation#
     */
    AbstractAnimation.prototype.getRenderContext = function() {
        return this.renderContext;
    };

    /**
     * Unregisters animation.
     * @function _unregisterActive
     * @memberof AbstractAnimation#
     * @private
     */
    AbstractAnimation.prototype._unregisterActive = function() {
        var index = this.renderContext.activeAnimations.indexOf(this);
        if (index >= 0) {
            this.renderContext.activeAnimations.splice(index, 1);
        }
    };

    /**
     * @function getStatus
     * @memberof AbstractAnimation#
     */
    AbstractAnimation.prototype.getStatus = function() {
        if (this.startTime === -1) {
            return "STOPPED";
        } else {
            return this.pauseTime === -1 ? "RUNNING" : "PAUSED";
        }
    };

    /**
     * @function start
     * @memberof AbstractAnimation#
     */
    AbstractAnimation.prototype.start = function() {
        if (!this.renderContext) {
            return;
        }

        if (this.startTime === -1 || this.pauseTime !== -1) {
            var now = Date.now();
            if (this.startTime === -1) {
                this.startTime = now;
            } else {
                // resume after pause
                this.startTime += now - this.pauseTime;
                this.pauseTime = -1;
            }

            // Register animation as active
            this.renderContext.activeAnimations.push(this);
            this.renderContext.requestFrame();
        }
    };

    /**
     * @function pause
     * @memberof AbstractAnimation#
     */
    AbstractAnimation.prototype.pause = function() {
        if (!this.renderContext) {
            return;
        }

        if (this.startTime !== -1 && this.pauseTime === -1) {
            this.pauseTime = Date.now();
            this._unregisterActive(this);
        }
    };

    /**
     * @function stop
     * @memberof AbstractAnimation#
     */
    AbstractAnimation.prototype.stop = function() {
        this.startTime = -1;
        this.pauseTime = -1;

        if (this.onstop) {
            this.onstop();
        }

        // Unregister animation
        this._unregisterActive(this);
    };

    /**************************************************************************************************************/

    return AbstractAnimation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Animation/SegmentedAnimation',["../Utils/Utils", "./AbstractAnimation", "../Utils/Numeric"], function(
    Utils,
    AbstractAnimation,
    Numeric
) {
    /**
     * Segmented animation configuration
     * @typedef  {Object} AbstractAnimation.segmented_configuration
     * @param {float} duration - duration of the animation
     * @param {function} valueSetter - the function used to set the value.
     */

    /**
     * @name SegmentedAnimation
     * @class
     * SegmentedAnimation is an animation defined with segments.
     * Each segment has a [start,end] pair of 't' value and a [start,end] pair of
     * values that will be interpolated with the interpolator set on the segment.
     * When the animation runs, a t parameter is mapped to [0,1] according to
     * current time and animation duration.
     * The current segment is then looked up with that 't' value and used to interpolate
     * the animation's current value.
     * @augments AbstractAnimation
     * @param {AbstractAnimation.segmented_configuration} options - Configuration of the animation
     * @constructor
     * @memberof module:Animation
     */
    var SegmentedAnimation = function(options) {
        Utils.assert(
            typeof options.duration === "number" &&
                typeof options.valueSetter === "function",
            "Missing required parameters in constructor",
            "SegmentedAnimation.js"
        );
        // Call ancestor constructor
        AbstractAnimation.prototype.constructor.call(this);

        this.segments = [];
        this.duration = options.duration;
        this.valueSetter = options.valueSetter;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractAnimation, SegmentedAnimation);

    /**
     * Creates a segment.
     * @param start t value at which the segment will be the current segment
     * @param startValue value at t=start
     * @param end value at which the segment will be the current segment
     * @param endValue value at t=end
     * @param interpolator
     * @constructor
     * @todo Create a tutorial with a simple SegmentedAnimation on Mars
     */
    var Segment = function(start, startValue, end, endValue, interpolator) {
        this.start = start;
        this.startValue = startValue;
        this.end = end;
        this.endValue = endValue;
        this.interpolator = interpolator;
    };

    /**************************************************************************************************************/

    /**
     * Adds a new segment to the animation.<br/>
     * start, end are 't' values at which the segment will be the current segment<br/>
     * startValue, endValue are animation values at 't'=start and 't'=end<br/>
     * interpolator is the function that will be called to interpolate bewteen startValue and endValue.
     * @function addSegment
     * @memberof SegmentedAnimation
     * @param {float} start - t value at which the segment will be the current segment
     * @param {float} startValue - value at t=start
     * @param {float} end - value at which the segment will be the current segment
     * @param {float} endValue - value at t=end
     * @param {Function} interpolator - interpolator function
     */
    SegmentedAnimation.prototype.addSegment = function(
        start,
        startValue,
        end,
        endValue,
        interpolator
    ) {
        var count = this.segments.length;
        var index = 0;
        while (index < count && this.segments[index].end <= start) {
            index++;
        }
        // Insert new segment at position 'index'
        this.segments.splice(
            index,
            0,
            new Segment(start, startValue, end, endValue, interpolator)
        );
    };

    /**
     * Animation update method
     * @function update
     * @memberof SegmentedAnimation#
     * @param {float} now - Now
     */
    SegmentedAnimation.prototype.update = function(now) {
        var t = Numeric.map01(
            now,
            this.startTime,
            this.startTime + this.duration
        );
        if (t >= 1) {
            // Set last value
            var lastIndex = this.segments.length - 1;
            this.valueSetter(this.segments[lastIndex].endValue);
            this.stop();
        } else {
            // Find current segment
            var count = this.segments.length;
            var index = 0;
            while (index < count && this.segments[index].end < t) {
                index++;
            }
            index = Math.min(index, count - 1);

            // Remap t between segment bounds
            t = Numeric.map01(
                t,
                this.segments[index].start,
                this.segments[index].end
            );
            // Interpolate value
            var value = this.segments[index].interpolator(
                t,
                this.segments[index].startValue,
                this.segments[index].endValue
            );
            // Use value
            this.valueSetter(value);
        }
    };

    /**************************************************************************************************************/

    return SegmentedAnimation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Animation/PathAnimation',[
    "../Utils/Utils",
    "./AbstractAnimation",
    "../Utils/Numeric",
    "../Renderer/glMatrix"
], function(Utils, AbstractAnimation, Numeric) {
    /**
     * Path animation configuration
     * @typedef {Object} AbstractAnimation.path_configuration
     * @param {Array.<float[]>} coords - The path coordinates
     * @param {float} speed - The speed value
     * @param {Function} setter - the function used to set the value
     * @param {Globe} globe - the globe to clamp path animations on the terrain
     */

    /**
     * @name PathAnimation
     * @class
     * PathAnimation is an animation defined with a path.
     * @augments AbstractAnimation
     * @param {AbstractAnimation.path_configuration} options Configuration of the animation
     * @constructor
     * @memberof module:Animation
     * @todo Create a tutorial with a simple PathAnimation on Mars
     */
    var PathAnimation = function(options) {
        Utils.assert(
            Array.isArray(options.coords) &&
                typeof options.speed === "number" &&
                typeof options.setter === "function" &&
                options.globe != null,
            "Missing required arguments in constructor",
            "PathAnimation.js"
        );
        var i;
        var vec1, vec2;
        var dx, dy, dz;
        var node;
        var temp;

        // Call ancestor constructor
        AbstractAnimation.prototype.constructor.call(this);
        this.globe = options.globe;
        this.speed =
            (options.speed *
                this.globe
                    .getCoordinateSystem()
                    .getGeoide()
                    .getHeightScale()) /
            1000;
        this.nodes = [];
        for (i = 0; i < options.coords.length; i++) {
            node = {
                position: this.globe
                    .getCoordinateSystem()
                    .get3DFromWorld(options.coords[i]),
                velocity: null,
                distance: 0.0
            };
            this.nodes.push(node);
            if (i > 0) {
                dx = this.nodes[i].position[0] - this.nodes[i - 1].position[0];
                dy = this.nodes[i].position[1] - this.nodes[i - 1].position[1];
                dz = this.nodes[i].position[2] - this.nodes[i - 1].position[2];
                this.nodes[i - 1].distance = Math.sqrt(
                    dx * dx + dy * dy + dz * dz
                );
            }
        }

        for (i = 1; i < options.coords.length - 1; i++) {
            vec1 = vec3.subtract(
                this.nodes[i + 1].position,
                this.nodes[i].position,
                vec3.create()
            );
            vec2 = vec3.subtract(
                this.nodes[i - 1].position,
                this.nodes[i].position,
                vec3.create()
            );
            vec3.normalize(vec1);
            vec3.normalize(vec2);
            this.nodes[i].velocity = vec3.subtract(vec1, vec2, vec3.create());
            vec3.normalize(this.nodes[i].velocity);
        }

        // Start velocity
        temp = vec3.subtract(
            this.nodes[1].position,
            this.nodes[0].position,
            vec3.create()
        );
        vec3.scale(temp, 3 / this.nodes[0].distance);
        this.nodes[0].velocity = vec3.subtract(
            temp,
            this.nodes[1].velocity,
            vec3.create()
        );
        vec3.scale(this.nodes[0].velocity, 0.5);

        // End velocity
        i = options.coords.length - 1;
        temp = vec3.subtract(
            this.nodes[i].position,
            this.nodes[i - 1].position,
            vec3.create()
        );
        vec3.scale(temp, 3 / this.nodes[i - 1].distance);
        this.nodes[i].velocity = vec3.subtract(
            temp,
            this.nodes[i - 1].velocity,
            vec3.create()
        );
        vec3.scale(this.nodes[i].velocity, 0.5);

        this.index = 0;
        this.currentDistance = 0;
        this.previousTime = -1;
        this.centerOffset = -0.2;
        this.altitudeOffset = 1000;

        var that = this;
        if (options.setter) {
            this.valueSetter = options.setter;
        } else {
            this.valueSetter = function(value, direction) {
                var up = vec3.normalize(value, vec3.create());

                var eye;
                if (options.globe) {
                    var geoEye = options.globe
                        .getCoordinateSystem()
                        .getWorldFrom3D(value);
                    geoEye[2] =
                        options.globe.getElevation(geoEye[0], geoEye[1]) +
                        that.altitudeOffset;
                    eye = options.globe
                        .getCoordinateSystem()
                        .get3DFromWorld(geoEye);
                } else {
                    eye = value;
                    eye[2] += that.altitudeOffset;
                }

                var dirn = vec3.normalize(direction, vec3.create());
                var center = vec3.add(eye, dirn, vec3.create());
                vec3.add(
                    center,
                    vec3.scale(up, that.centerOffset, vec3.create())
                );
                mat4.lookAt(
                    eye,
                    center,
                    up,
                    that.renderContext.getViewMatrix()
                );
            };
        }
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractAnimation, PathAnimation);

    /**************************************************************************************************************/

    /**
     * Sets the speed.
     * @function setSpeed
     * @memberof PathAnimation#
     * @param {float} val Speed
     */
    PathAnimation.prototype.setSpeed = function(val) {
        this.speed =
            (parseFloat(val) *
                this.globe
                    .getCoordinateSystem()
                    .getGeoide()
                    .getHeightScale()) /
            1000.0;
    };

    /**
     * Returns the speed.
     * @function getSpeed
     * @memberof PathAnimation#
     * @return {float} Speed
     */
    PathAnimation.prototype.getSpeed = function() {
        return (
            this.speed /
            (this.globe
                .getCoordinateSystem()
                .getGeoide()
                .getHeightScale() /
                1000.0)
        );
    };

    /**
     * Sets the altitude offset.
     * @function setAltitudeOffset
     * @memberof PathAnimation#
     * @param {float} val Altitude offset
     */
    PathAnimation.prototype.setAltitudeOffset = function(val) {
        this.altitudeOffset = parseFloat(val);
    };

    /**
     * Returns the altitude offset.
     * @function getAltitudeOffset
     * @memberof PathAnimation#
     * @return {float} Altitude offset
     */
    PathAnimation.prototype.getAltitudeOffset = function() {
        return this.altitudeOffset;
    };

    /**
     * Sets the direction angle.
     * @function setDirectionAngle
     * @memberof PathAnimation#
     * @param {float} vertical Direction angle in degree
     */
    PathAnimation.prototype.setDirectionAngle = function(vertical) {
        this.centerOffset = Math.tan((parseFloat(vertical) * Math.PI) / 180.0);
    };

    /**
     * Starts the animation.
     * @function start
     * @memberof PathAnimation#
     */
    PathAnimation.prototype.start = function() {
        var previousStartTime = -1;
        if (this.pauseTime !== -1) {
            previousStartTime = this.startTime;
        }

        Animation.prototype.start.call(this);

        if (previousStartTime !== -1) {
            this.previousTime += this.startTime - previousStartTime;
        } else {
            this.previousTime = -1;
        }
    };

    /**
     * Updates the animation.
     * @function update
     * @memberof PathAnimation
     * @param {float} now the date now
     */
    PathAnimation.prototype.update = function(now) {
        if (this.previousTime === -1) {
            this.index = 0;
            this.currentDistance = 0;
        } else {
            this.currentDistance += (now - this.previousTime) * this.speed;
        }
        this.previousTime = now;

        while (
            this.currentDistance >= this.nodes[this.index].distance &&
            this.index < this.nodes.length - 1
        ) {
            this.currentDistance -= this.nodes[this.index].distance;
            this.index = this.index + 1;
        }

        if (this.index < this.nodes.length - 1) {
            var t = this.currentDistance / this.nodes[this.index].distance;
            var startPos = this.nodes[this.index].position;
            var endPos = this.nodes[this.index + 1].position;
            var startVel = vec3.scale(
                this.nodes[this.index].velocity,
                this.nodes[this.index].distance,
                vec3.create()
            );
            var endVel = vec3.scale(
                this.nodes[this.index + 1].velocity,
                this.nodes[this.index].distance,
                vec3.create()
            );
            var position = Numeric.cubicInterpolation(
                t,
                startPos,
                startVel,
                endPos,
                endVel
            );
            var direction = Numeric.cubicInterpolationDerivative(
                t,
                startPos,
                startVel,
                endPos,
                endVel
            );
            this.valueSetter(position, direction);
        } else if (this.index === this.nodes.length - 1) {
            this.valueSetter(
                this.nodes[this.index].position,
                this.nodes[this.index].velocity
            );
        } else {
            this.stop();
        }
    };

    /**************************************************************************************************************/

    return PathAnimation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 * Mizar is able to create different types of animation on a globe :
 * <ul>
 *     <li>{@link module:Animation.InertiaAnimation InertiaAnimation}: Animation simulating inertia for camera navigation</li>
 *     <li>{@link module:Animation.InterpolatedAnimation InterpolatedAnimation} : Generic animation to interpolate arbitrary values</li>
 *     <li>{@link module:Animation.PathAnimation PathAnimation} : Animation defined with a path</li>
 *     <li>{@link module:Animation.SegmentedAnimation SegmentedAnimation} : Animation defined with segments</li>
 * </ul>
 *
 * In addition to the classes, a {@link module:Animation.AnimationFactory factory} is available to help for creating
 * animation. Once the animation is created, the client can handle it by the use of its {@link Animation interface}.
 *
 * See {@tutorial getting-started-layer-extrude} for an example of sgmented animation.
 *
 * @module Animation
 * @implements {Animation}
 *
 */
define('gw/Animation/InertiaAnimation',["../Utils/Utils", "./AbstractAnimation"], function(
    Utils,
    AbstractAnimation
) {
    /**************************************************************************************************************/

    /**
     * @constant
     * @type {float}
     * @default
     */
    const EPSILON = 0.1;

    /**
     * Default panFactor value
     * @constant
     * @type {number}
     * @default
     */
    const PAN_FACTOR = 0.95;

    /**
     * Default rotateFactor value
     * @constant
     * @type {number}
     * @default
     */
    const ROTATE_FACTOR = 0.95;

    /**
     * Default zoomFactor value
     * @constant
     * @type {number}
     * @default
     */
    const ZOOM_FACTOR = 0.5;

    /**
     * Inertia animation configuration
     * @typedef {Object} AbstractAnimation.inertia_configuration
     * @property {Navigation} nav - Navigation object that applies the transformations.
     * @property {float} [panFactor=0.95] - Pan Factor which is included in [0..1]. - 1 is sensible to the pan
     * @property {float} [zoomFactor=0.50] - Zoom Factor which is included in [0..1]. - 1 is sensible to the zoom
     * @property {float} [rotateFactor=0.95] - Rotate Factor which is included in [0..1]. - 1 is sensible to the rotation
     */

    /**
     * @name InertiaAnimation
     * @class
     * Animation simulating inertia for camera's navigation.
     * Inertia is its tendency to retain its velocity: in the absence of external influence, the camera's motion
     * persists in an uniform rectilinear motion.
     * @augments AbstractAnimation
     * @param {AbstractAnimation.inertia_configuration} options Configuration of the Inertia animation
     * @constructor
     * @memberof module:Animation
     */
    var InertiaAnimation = function(options) {
        Utils.assert(
            options.nav != null,
            "nav is required in constructor",
            "InertiaAnimation.js"
        );
        AbstractAnimation.prototype.constructor.call(this);
        if (options) {
            this.panFactor = options.hasOwnProperty("panFactor")
                ? options.panFactor
                : PAN_FACTOR;
            this.rotateFactor = options.hasOwnProperty("rotateFactor")
                ? options.rotateFactor
                : ROTATE_FACTOR;
            this.zoomFactor = options.hasOwnProperty("zoomFactor")
                ? options.zoomFactor
                : ZOOM_FACTOR;
        }

        this.type = null;
        this.dx = 0;
        this.dy = 0;
        this.navigation = options.nav;
        this.renderContext = options.nav.getRenderContext();
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractAnimation, InertiaAnimation);

    /**************************************************************************************************************/

    /**
     * Updates the inertia.
     * @function update
     * @memberof InertiaAnimation#
     */
    InertiaAnimation.prototype.update = function(now) {
        var hasToStop = false;

        switch (this.type) {
        case "pan":
            this.navigation.pan(this.dx, this.dy);
            this.dx *= this.panFactor;
            this.dy *= this.panFactor;
            hasToStop =
                    Math.abs(this.dx) < EPSILON && Math.abs(this.dy) < EPSILON;
            break;
        case "rotate":
            this.navigation.rotate(this.dx, this.dy);
            this.dx *= this.rotateFactor;
            this.dy *= this.rotateFactor;
            hasToStop =
                    Math.abs(this.dx) < EPSILON && Math.abs(this.dy) < EPSILON;
            break;
        case "zoom":
            this.navigation.zoom(this.dx);
            this.dx *= this.zoomFactor;
            hasToStop = Math.abs(this.dx) < EPSILON;
            break;
        default:
        }
        this.navigation.getRenderContext().requestFrame();

        if (hasToStop) {
            this.stop();
        }
    };

    /**************************************************************************************************************/

    /**
     * Launches the animation.
     * @function launch
     * @param {string} type Type of inertia
     * <ul>
     *   <li>pan</li>
     *   <li>rotate</li>
     *   <li>zoom</li>
     * </ul>
     * @param {int} dx x of inertiaVector Vector of movement in window coordinates(for pan and rotate inertia)
     * @param {int} dy x of inertiaVector Vector of movement in window coordinates(for pan and rotate inertia)
     * @memberof InertiaAnimation#
     */
    InertiaAnimation.prototype.launch = function(type, dx, dy) {
        // Set first value
        this.type = type;
        this.dx = dx;
        this.dy = dy;

        this.start();
    };

    /**************************************************************************************************************/

    return InertiaAnimation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Animation/InterpolatedAnimation',["../Utils/Utils", "./AbstractAnimation","../Utils/Numeric"], function(
    Utils,
    AbstractAnimation,
    Numeric
) {
    /**
     * Interpolated animation configuration
     * @typedef {Object} AbstractAnimation.interpolated_configuration
     * @property {float} startValue - Starting point of the interpolation.
     * @property {float} endValue - Ending point of the interpolation.
     * @property {float} duration - Duration of the animation in seconds
     * @property {Function} interpolationFunction-  Interpolation function
     * @property {Function} setFunction - Setter of the Interpolation function
     */

    /**
     * @name InterpolatedAnimation
     * @class
     * Generic animation to interpolate arbitrary values
     * The animation will interpolate between startValue and endValue, using the
     * interpolateFunction(t, startValue, endValue) (t [0,1])
     * The interpolated value is then given to the setFunction(value)
     * @augments AbstractAnimation
     * @param {AbstractAnimation.interpolated_configuration} options Configuration of the InterpolatedAnimation
     * @constructor
     * @memberof module:Animation
     * @todo Create a tutorial with a simple InterpolatedAnimation on Mars
     */
    var InterpolatedAnimation = function(options) {
        Utils.assert(
            typeof options.startValue === "number" &&
                typeof options.endValue === "number" &&
                typeof options.duration === "number" &&
                typeof options.interpolationFunction === "function" &&
                typeof options.setFunction === "function",
            "Missing required arguments in constructor",
            "InterpolatedAnimation.js"
        );
        // Call ancestor constructor
        AbstractAnimation.prototype.constructor.call(this);
        this.values = [[0.0, options.startValue], [1.0, options.endValue]];
        this.duration = options.duration;
        this.interpolationFunction = options.interpolationFunction;
        this.setFunction = options.setFunction;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractAnimation, InterpolatedAnimation);

    /**************************************************************************************************************/

    /**
     * Adds a new value to the animation.
     * @function addValue
     * @memberof InterpolatedAnimation#
     * @param {float} t Value at [0,1]
     * @param {float} value Value to reach
     */
    InterpolatedAnimation.prototype.addValue = function(t, value) {
        Utils.assert(
            t >= 0 && t <= 1,
            "t must be in [0,1] when using addValue method",
            "InterpolatedAnimation.js"
        );
        Utils.assert(
            typeof value === "number",
            "value must be a number when using addValue method",
            "InterpolatedAnimation.js"
        );
        var count = this.values.length;
        var upper = 0;
        while (upper < count && this.values[upper][0] < t) {
            upper++;
        }
        // Insert new value at position 'upper'
        this.values.splice(upper, 0, [t, value]);
    };

    /**
     * Starts the animation.
     * @function start
     * @memberof InterpolatedAnimation#
     */
    InterpolatedAnimation.prototype.start = function() {
        Animation.prototype.start.call(this);
        this.setFunction(this.startValue);
        //TODO this.startValue is a bug ?
    };

    /**
     * Stops the animation.
     * @function stop
     * @memberof InterpolatedAnimation
     */
    InterpolatedAnimation.prototype.stop = function() {
        Animation.prototype.stop.call(this);
        this.setFunction(this.endValue);
        //TODO this.endValue is a bug ?
    };

    /**
     * Updates the Animation.
     * @function udate
     * @memberof InterpolatedAnimation
     * @param {float} now Now
     */
    InterpolatedAnimation.prototype.update = function(now) {
        var t = Numeric.map01(
            now,
            this.startTime,
            this.startTime + this.duration
        );
        if (t >= 1) {
            this.stop();
            return;
        }

        // Find upper and lower bounds
        var count = this.values.length;
        var upper = 0;
        while (upper < count && this.values[upper][0] < t) {
            upper++;
        }
        upper = Math.min(upper, count - 1);
        var lower = Math.max(0, upper - 1);

        // Remap t between lower and upper bounds
        t = Numeric.map01(t, this.values[lower][0], this.values[upper][0]);
        // Interpolate value
        var value = this.interpolationFunction(
            t,
            this.values[lower][1],
            this.values[upper][1]
        );
        // Use interpolated value
        this.setFunction(value);
    };

    /**************************************************************************************************************/

    return InterpolatedAnimation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name AnimationFactory
 * @class
 * Factory to create an animation
 * @memberof module:Animation
 * @throws {RangeError} the animation type is unknown
 */
define('gw/Animation/AnimationFactory',[
    "../Utils/Constants",
    "./SegmentedAnimation",
    "./PathAnimation",
    "./InertiaAnimation",
    "./InterpolatedAnimation"
], function(
    Constants,
    SegmentedAnimation,
    PathAnimation,
    InertiaAnimation,
    InterpolatedAnimation
) {
    return {
        /**
         * Factory to create an animation.
         *
         * Creates an animation based on :
         * <ul>
         *     <li>the animation type {@link ANIMATION},</li>
         *     <li>the options for the specific animation</li>
         * </ul>
         *
         * Severals animations can be created :
         * <ul>
         *     <li>{@link module:Animation.InertiaAnimation InertiaAnimation}</li>
         *     <li>{@link module:Animation.InterpolatedAnimation InterpolatedAnimation}</li>
         *     <li>{@link module:Animation.PathAnimation PathAnimation}</li>
         *     <li>{@link module:Animation.SegmentedAnimation SegmentedAnimation}</li>
         * </ul>
         * @param {ANIMATION} type - Type of animation.
         * @param {AbstractAnimation.inertia_configuration|AbstractAnimation.interpolated_configuration|AbstractAnimation.path_configuration|AbstractAnimation.segmented_configuration} options - See the options for each animation for further information
         * @return {AbstractAnimation} - the interface to handle an animation
         * @throws {RangeError} Type not valid - a valid type is included in the list {@link ANIMATION}
         * @alias module:Animation.AnimationFactory.create
         * @see {@link module:Animation.InertiaAnimation InertiaAnimation} Animation simulating inertia for camera's navigation
         * @see {@link module:Animation.InterpolatedAnimation InterpolatedAnimation} Generic animation to interpolate arbitrary values
         * @see {@link module:Animation.PathAnimation PathAnimation} Defines an animation based on a path
         * @see {@link module:Animation.SegmentedAnimation SegmentedAnimation} Defines an animation based on segments
         *
         */
        create: function(type, options) {
            var obj;
            switch (type) {
            case Constants.ANIMATION.Inertia:
                obj = new InertiaAnimation(options);
                break;
            case Constants.ANIMATION.Interpolated:
                obj = new InterpolatedAnimation(options);
                break;
            case Constants.ANIMATION.Path:
                obj = new PathAnimation(options);
                break;
            case Constants.ANIMATION.Segmented:
                obj = new SegmentedAnimation(options);
                break;
            default:
                throw RangeError(
                    "The type " +
                            type +
                            " is not allowed, A valid type is included in the list Constants.ANIMATION",
                    "AnimationFactory.js"
                );
            }
            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Navigation/AbstractNavigation',[
    "../Utils/Utils",
    "../Utils/Event",
    "../Navigation/NavigationHandlerFactory",
    "../Animation/AnimationFactory",
    "../Utils/Numeric",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(
    Utils,
    Event,
    NavigationHandlerFactory,
    AnimationFactory,
    Numeric,
    Constants
) {
    /**
     * Navigation configuration
     * @typedef {Object} AbstractNavigation.configuration
     * @property {boolean} [inertia = false] - Animation simulating inertia for camera's navigation
     * @property {AbstractAnimation.inertia_configuration} inertiaAnimation - Inertia Animation is used when <i>inertia</i> is true
     * @property {Object[]} [handlers = [{@link module:Navigation.MouseNavigationHandler MouseNavigationHandler},{@link module:Navigation.KeyboardNavigationHandler KeyboardNavigationHandler}[,{@link module:Navigation.TouchNavigationHandler TouchNavigationHandler}]]
     * @property {AbstractNavigation.mouse_configuration} [mouse] - Mouse navigation configuration when <i>handlers</i> is not defined
     * @property {AbstractNavigation.keyboard_configuration} [keyboard] - Keyboard navigation configuration when <i>handlers</i> is not defined
     * @property {boolean} [isMobile = false] - {@link module:Navigation.TouchNavigationHandler TouchNavigationHandler} configuration when <i>handlers</i> is not defined, sets to true this parameter to support mobile device
     */

    /**
     * @name AbstractNavigation
     * @class
     * The active navigation object can normally be obtained from the {@link Mizar#getNavigation} method of the Mizar instance.
     * Client implementations should not normally instantiate this class directly.
     * @augments Event
     * @param {NAVIGATION} type - type of navigation
     * @param {AbstractContext} ctx - context
     * @param {AbstractNavigation.configuration} [options = {}] - options for navigation
     * @constructor
     * @see {@link module:Navigation.NavigationHandlerFactory NavigationHandlerFactory} the possible handlers
     * @see {@link module:Navigation.MouseNavigationHandler MouseNavigationHandler} for its options when it is set by default
     * @see {@link module:Navigation.KeyboardNavigationHandler KeyboardNavigationHandler} for its options when it is set by default
     * @see {@link module:Navigation.TouchNavigationHandler TouchNavigationHandler} for its options when isMobile is set to true
     * @implements {Navigation}
     *
     */
    var AbstractNavigation = function(type, ctx, options) {
        Event.prototype.constructor.call(this);
        this.type = type;
        this.ctx = ctx;
        this.renderContext = this.ctx.getRenderContext();
        this.renderContext.cameraUpdateFunction = this.update.bind(this);
        this.options = options || {};
        this.options.isMobile = ctx.getMizarConfiguration().isMobile;
        if (this.options.isMobile === true) {
            this.initTouchNavigation();
        }

        // Create default handlers if none are created in options
        this.handlers = _createHandlers.call(this, this.options);

        // Inertia effect
        this.inertia = _addInertiaEffect.call(this, this.options);

        // ZoomTo animation
        this.zoomToAnimation = null;

        // Automatically start
        this.start();
    };

    /**
     * Adds inertia effect
     * @param {Object} options
     * @returns {InertiaAnimation|null} inertia
     * @private
     */
    function _addInertiaEffect(options) {
        var inertia;
        if (options.inertia) {
            var inertiaOptions = options.inertiaAnimation || {};
            inertiaOptions.nav = this;
            inertia = AnimationFactory.create(
                Constants.ANIMATION.Inertia,
                inertiaOptions
            );
            const self = this;
            inertia.onstop = function() {
                self.doneMoving();
            };
        } else {
            inertia = null;
        }
        return inertia;
    }

    /**
     * Creates handlers :
     * <ul>
     *     <li>Provided in options</li>
     *     <li>Create default handlers</li>
     * </ul>
     * @param {Object} options
     * @returns {Object[]} handlers
     * @private
     */
    function _createHandlers(options) {
        var handlers;
        // Create default handlers if none are created in options
        if (options.handlers) {
            handlers = options.handlers;
        } else {
            // Use mouse & keyboard as default handlers
            handlers = _addDefaultHandlers.call(this, options);
        }
        return handlers;
    }

    /**
     * Add default handlers :
     * <ul>
     *     <li>MouseNavigationHandler</li>
     *     <li>KeyboardNavigationHandler</li>
     *     <li>TouchNavigationHandler is isMobile is true</li>
     * </ul>
     * @param {Object} options - options
     * @returns {Object[]} An array of handlers
     * @private
     */
    function _addDefaultHandlers(options) {
        var defaultHandlers = [
            NavigationHandlerFactory.create(
                Constants.HANDLER.Mouse,
                options ? options.mouse : null
            ),
            NavigationHandlerFactory.create(
                Constants.HANDLER.Keyboard,
                options ? options.keyboard : null
            )
        ];
        if (options.isMobile) {
            defaultHandlers.push(
                NavigationHandlerFactory.create(
                    Constants.HANDLER.Touch,
                    options ? options.touch : null
                )
            );
        }
        return defaultHandlers;
    }

    /**************************************************************************************************************/

    Utils.inherits(Event, AbstractNavigation);

    /**************************************************************************************************************/

    /**
     * Initializes the touch navigation handler.
     * @function initTouchNavigation
     * @memberof AbstractContext#
     */
    AbstractNavigation.prototype.initTouchNavigation = function() {
        this.options.touch = {
            inversed: this.ctx.globe.isSky(),
            zoomOnDblClick: true
        };
        var self = this;
        window.addEventListener(
            "orientationchange",
            function() {
                self.ctx.refresh();
            },
            false
        );
    };

    /**
     * Returns the {@link TYPE type} of navigation.
     * The type can take one of the following value : AstroNavigation, FlatNavigation, PlanetNavigation
     * @function getType
     * @return {string} the name of the navigation class, which is used
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.getType = function() {
        return this.type;
    };

    /**
     * Returns the navigation's options given at the initialisation.
     * @function getOptions
     * @return {Object} Options
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.getOptions = function() {
        return this.options;
    };

    /**
     * Starts the navigation.
     * @function start
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.start = function() {
        // Install handlers
        for (var i = 0; i < this.handlers.length; i++) {
            this.handlers[i].install(this);
        }
    };

    /**
     * Stops the navigation.
     * @function stop
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.stop = function() {
        // Uninstall handlers
        for (var i = 0; i < this.handlers.length; i++) {
            this.handlers[i].uninstall();
        }
    };

    /**
     * Stops the animations.
     * @function stopAnimations
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.stopAnimations = function() {
        if (this.inertia) {
            this.inertia.stop();
        }
        if (this.zoomToAnimation) {
            this.zoomToAnimation.stop();
            this.zoomToAnimation = null;
        }
    };

    /**
     * Returns the field of view in decimal degree.
     * @function getFov
     * @return {float[]} the Field of view [fov along width, fov along height]
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.getFov = function() {
        return [this.renderContext.getFov(), this.renderContext.getFov()];
    };

    /**
     * Moves up vector.
     * @function moveUpTo
     * @memberof AbstractNavigation#
     * @param {float[]} vec Vector
     * @param {int} [duration = 1000] - Duration of animation in milliseconds
     * @abstract
     */
    AbstractNavigation.prototype.moveUpTo = function(vec, duration) {
        throw new SyntaxError(
            "moveUpTo not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Returns the center of the field of view.
     * @function getCenter
     * @return {float[]} the center in decimal degree of the field of view [longitude, latitude]
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.getCenter = function() {
        return this.ctx.getLonLatFromPixel(
            this.renderContext.getCanvas().width * 0.5,
            this.renderContext.getCanvas().height * 0.5
        );
    };

    /**
     * Rotates the camera.
     * @function rotate
     * @param {float} dx Window delta x
     * @param {float} dy Window delta y
     * @abstract
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.rotate = function(dx, dy) {
        throw new SyntaxError(
            "rotate is not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Pans the camera to a direction up/down or left/right with the same distance from the object
     * @function pan
     * @param {float} dx Window direction left/right
     * @param {float} dy Window direction up/down
     * @abstract
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.pan = function(dx, dy) {
        throw new SyntaxError(
            "pan is not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Applies zooming.
     * @function zoom
     * @param {float} delta Delta zoom
     * @param {float} scale Scale
     * @abstract
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.zoom = function(delta, scale) {
        throw new SyntaxError(
            "zoom is not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Zooms to a 2D position (longitude, latitude).
     * @function zoomTo
     * @param {float[]} geoPos - spatial position in decimal degree [longitude, latitude]
     * @param {Object} options - options for zoomTo
     * @abstract
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.zoomTo = function(geoPos, options) {
        throw new SyntaxError(
            "zoomTo is not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Computes the view matrix
     * @function computeViewMatrix
     * @memberof AbstractNavigation#
     * @abstract
     */
    AbstractNavigation.prototype.computeViewMatrix = function() {
        throw new SyntaxError(
            "computeViewMatrix not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Callback at the end of animation (when stop method is called).
     * @callback navigationCallback
     */

    /**
     * Basic animation from current view matrix to the given one
     * @function toViewMatrix
     * @param {Object[]} mat Destination view matrix (array of 16)
     * @param {int} fov Final zooming fov in degrees
     * @param {int} duration Duration of animation in milliseconds
     * @param {navigationCallback} callback Callback at the end of animation
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.toViewMatrix = function(
        mat,
        fov,
        duration,
        callback
    ) {
        var navigation = this;
        var vm = this.renderContext.getViewMatrix();

        var srcViewMatrix = mat4.toMat3(vm);
        var srcQuat = quat4.fromRotationMatrix(srcViewMatrix);
        var destViewMatrix = mat4.toMat3(mat);
        var destQuat = quat4.fromRotationMatrix(destViewMatrix);
        var destFov = fov || 45;
        duration = duration || 1000;

        // Animate rotation matrix(with quaternion support), translation and fov
        var startValue = [
            srcQuat,
            [vm[12], vm[13], vm[14]],
            navigation.getRenderContext().getFov()
        ];
        var endValue = [destQuat, [mat[12], mat[13], mat[14]], destFov];
        var animation = AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: duration,
            valueSetter: function(value) {
                // Update rotation matrix
                var newRotationMatrix = quat4.toMat4(value[0]);

                // Need to transpose the new rotation matrix due to bug in glMatrix
                var viewMatrix = mat4.transpose(newRotationMatrix);

                // Update translation
                viewMatrix[12] = value[1][0];
                viewMatrix[13] = value[1][1];
                viewMatrix[14] = value[1][2];

                // sets the new matrix
                navigation.renderContext.setViewMatrix(viewMatrix);

                // Update fov
                navigation.renderContext.setFov(value[2]);

                navigation.renderContext.requestFrame();
            }
        });

        // Add segment
        animation.addSegment(0.0, startValue, 1.0, endValue, function(t, a, b) {
            var pt = Numeric.easeOutQuad(t);
            var resQuat = quat4.create();
            quat4.slerp(a[0], b[0], pt, resQuat);

            var resTranslate = vec3.create();
            vec3.lerp(a[1], b[1], pt, resTranslate);

            var resFov = Numeric.lerp(pt, a[2], b[2]);
            return [
                resQuat, // quaternions
                resTranslate, // translate
                resFov // fov
            ];
        });

        animation.onstop = function() {
            if (callback) {
                callback();
            }
        };

        this.ctx.addAnimation(animation);
        animation.start();
    };

    /**
     * Returns the rendering context.
     * @function getRenderContext
     * @returns {RenderContext} the rendering context
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.getRenderContext = function() {
        return this.renderContext;
    };

    /**
     * Sets the rendering context
     * @function setRenderContext
     * @param {RenderContext} renderContext - the rendering context to set
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.setRenderContext = function(renderContext) {
        this.renderContext = renderContext;
    };

    /**
     * Destroys the navigation.
     * @function destroy
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.destroy = function() {
        this.renderContext.cameraUpdateFunction = null;
        this.type = null;
        this.options = null;
        this.zoomToAnimation = null;
        this.stop();
        this.ctx = null;
        this.renderContext = null;
    };

    /**
     * Update the navigation values if computations are needed.
     * @function update
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.update = function() {
        // Does nothing by default
    };

    /**
     * Called when stopping inertia.
     * @function doneMoving
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.doneMoving = function() {
        this.donePanning();
        this.doneRotating();
    };

    /**
     * Called by mouse and keyboard handler when pan interactions are finished.
     * This is useful to, e.g.,  fetch the new focus point of the navigator.
     * @function donePanning
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.donePanning = function() {
        // Does nothing by default
    };

    /**
     * Called by mouse and keyboard handler when rotate interactions are finished.
     * This is useful to, e.g.,  fetch the new focus point of the navigator.
     * @function doneRotating
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.doneRotating = function() {
        // Does nothing by default
    };

    AbstractNavigation.prototype.startInteraction = function(x, y) {
        // Does nothing by default
    };

    /**************************************************************************************************************/

    return AbstractNavigation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Navigation/PlanetNavigation',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./AbstractNavigation",
    "../Animation/AnimationFactory",
    "../Utils/Numeric",
    "../Renderer/Ray",
    "../Gui/dialog/ErrorDialog",
    "../Renderer/glMatrix"
], function(
    Utils,
    Constants,
    AbstractNavigation,
    AnimationFactory,
    Numeric,
    Ray,
    ErrorDialog
) {
    /**
     * Flat navigation configuration
     * @typedef {AbstractNavigation.configuration} AbstractNavigation.planet_configuration
     * @property {float[]} [initTarget=[0, 0, 3.0 * RADIUS_PLANET]] - Target in decimal degree (longitude, latitude, distance in meter)
     * at initialisation. distance in meter is optional.
     * @property {int} [minDistance=0] the minimum distance sets to 60 Km by default or options.initTarget[2]
     * when this one is inferior to options.minDistance
     * @property {int} [maxDistance=3*RADIUS_PLANET] the maximum distance sets to 3*RADIUS_PLANET by default or
     * options.initTarget[2] when this one is superior to options.maxDistance
     * @property {boolean} [updateViewMatrix=false] indicating if view matrix must be updated on initialization.
     */

    /**
     * 1km epsilon error for elevation.
     * @type {number}
     */
    const OFFSET_ELEVATION = 1000.0;

    /**
     * Duration of animation in milliseconds for the zoom_to function.
     * @type {number}
     */
    const DEFAULT_DURATION_ZOOM_TO = 5000.0;

    /**
     * Duration of animation in milliseconds to align the camera with the north.
     * @type {number}
     */
    const DEFAULT_DURATION_NORTH = 1000.0;

    /**
     * Min tilt in decimal degree.
     * @type {number}
     */
    const MIN_TILT = 10.0;

    /**
     * Max tilt in decimal degree.
     * @type {number}
     */
    const MAX_TILT = 90.0;

    /**
     * Default tilt in decimal degree.
     * @type {number}
     */
    const DEFAULT_TILT = 90.0;

    /**
     * Min heading value in decimal degree.
     * @type {number}
     */
    const MIN_HEADING = 0.0;

    /**
     * Max heading value in decimal degee.
     * @type {number}
     */
    const MAX_HEADING = 360.0;

    /**
     * Default heading in decimal degree.
     * @type {number}
     */
    const DEFAULT_HEADING = MIN_HEADING;

    /**
     * Heading difference between two successive rotation (in degree) of the camera
     * @type {number}
     */
    const DELTA_HEADING = 0.05;

    /**
     * Tilt difference between two successive rotation (in degree) of the camera
     * @type {number}
     */
    const DELTA_TILT = 0.05;

    /**
     * @name PlanetNavigation
     * @augments AbstractNavigation
     * @class
     * <table border="0">
     *     <tr>
     *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
     *         <td>Provides a camera, located outside the globe and looking at the globe. It is used to view a planet</td>
     *     </tr>
     * </table>
     * At initialisation, the distance of the camera is maxDistance
     * @param {PlanetContext} ctx -  Planet context
     * @param {AbstractNavigation.planet_configuration} options - Planet navigation configuration
     * @memberof module:Navigation
     */
    var PlanetNavigation = function(ctx, options) {
        AbstractNavigation.prototype.constructor.call(
            this,
            Constants.NAVIGATION.PlanetNavigation,
            ctx,
            options
        );

        Object.defineProperties(this, {
            scale: {
                get: function() {
                    return this.ctx
                        .getCoordinateSystem()
                        .getGeoide()
                        .getHeightScale();
                }
            },

            distance: {
                get: function() {
                    const value = this._distance * this.scale;
                    return value;
                },
                set: function(v) {
                    const value = v / this.scale;
                    this._distance = value;
                }
            },

            targetHeight: {
                get: function() {
                    return this.ctx.getElevation(
                        this.geoCenter[0],
                        this.geoCenter[1]
                    );
                }
            },

            cameraHeight: {
                get: function() {
                    const tilt = ((90 - this.tilt) * Math.PI) / 180;
                    const c = Math.cos(tilt);
                    const d = c * this._distance;
                    return d + this.targetHeight;
                }
            },

            eye: {
                get: function() {
                    return [
                        this.inverseViewMatrix[12],
                        this.inverseViewMatrix[13],
                        this.inverseViewMatrix[14]
                    ];
                }
            },

            geoEye: {
                get: function() {
                    return this.ctx.getCoordinateSystem().from3DToGeo(this.eye);
                }
            }
        });

        const geoide = this.ctx.getCoordinateSystem().getGeoide();
        // Default values for min and max distance (in meter)
        const minDistance = this.options.minDistance || 50;
        const maxDistance =
            this.options.maxDistance || 3.0 * geoide.getRealPlanetRadius();

        // Scale min and max distance from meter to internal ratio
        this.minDistance = minDistance * geoide.getHeightScale();
        this.maxDistance = maxDistance * geoide.getHeightScale();

        // Initialize the navigation
        this.geoCenter = [0.0, 0.0, 0.0];

        this.heading = DEFAULT_HEADING;
        this.tilt = DEFAULT_TILT;
        this._distance = Number.NaN;
        this.offset = 0.0;

        // Coordinate of the North in XYZ frame
        this.up = [0.0, 0.0, 1.0];

        this.inverseViewMatrix = mat4.create();

        this.lastMousePosition = null;

        var updateViewMatrix = this.options.hasOwnProperty("updateViewMatrix")
            ? this.options.updateViewMatrix
            : true;

        _setInitTarget.call(this, this.options.initTarget);

        // Update the view matrix if needed(true by default)
        if (updateViewMatrix) {
            this.computeViewMatrix();
        }
    };

    /**
     * Defines the position where the camera looks at and the distance of the camera regarding to the planet's surface
     * @param {float[]|undefined} initTarget as [longitude, latitude[, distance in meter]]
     * @private
     */
    function _setInitTarget(initTarget) {
        if (initTarget) {
            this.geoCenter[0] = initTarget[0];
            this.geoCenter[1] = initTarget[1];
            this.distance =
                initTarget.length === 3
                    ? initTarget[2] *
                      this.ctx
                          .getCoordinateSystem()
                          .getGeoide()
                          .getHeightScale()
                    : this.distance;
            if (this.distance < this.minDistance) {
                this.minDistance = this.distance;
            }
            if (this.distance > this.maxDistance) {
                this.maxDistance = this.distance;
            }
        }
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractNavigation, PlanetNavigation);

    /**************************************************************************************************************/

    /**
     * Returns the center of the navigation.
     * @function getCenter
     * @memberof PlanetNavigation#
     * @return {float[]}
     */
    PlanetNavigation.prototype.getCenter = function() {
        var center = AbstractNavigation.prototype.getCenter.call(this);
        if (center == null) {
            center = this.geoCenter;
        }
        return center;
    };

    /**
     * Saves the current navigation state.
     * @function save
     * @memberof PlanetNavigation#
     * @return {{geoCenter: *, heading: *, tilt: *, distance: *}} a JS object containing the navigation state
     */
    PlanetNavigation.prototype.save = function() {
        return {
            geoCenter: this.geoCenter,
            heading: this.heading,
            tilt: this.tilt,
            distance: this.distance
        };
    };

    /**
     * Restores the navigation state.
     * @function restore
     * @memberof PlanetNavigation#
     * @param {Object} state - a JS object containing the navigation state
     * @param {float[]} state.geoCenter - Target of the camera (longitude, latitude)
     * @param state.heading
     * @param {float} state.tilt - tilt of the camera in decimal degree
     * @param {float} state.distance - Distance from the surface of the globe in meter.
     */
    PlanetNavigation.prototype.restore = function(state) {
        this.geoCenter = state.geoCenter;
        this.heading = state.heading;
        this.tilt = state.tilt;
        this.distance = state.distance;
        this.computeViewMatrix();
    };

    /**
     * Zoom to a geographic position
     * @function zoomTo
     * @memberof PlanetNavigation#
     * @param {float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
     * @param {Object} [options] - Options
     * @param {int} [options.distance] - Final zooming distance in meters - if not set, this is the current distance
     * @param {int} [options.duration = 5000] - Duration of animation in milliseconds
     * @param {int} [options.tilt = 90] - Defines the tilt at the end of animation
     * @param {int} [options.heading] - Defines the heading at the end of animation. By default, the current heading is conserved
     * @param {navigationCallback} [options.callback] - Callback at the end of animation
     */
    PlanetNavigation.prototype.zoomTo = function(geoPos, options) {
        var navigation = this;

        var destDistance =
            options && options.hasOwnProperty("distance")
                ? options.distance
                : this.distance /
                  this.ctx
                      .getCoordinateSystem()
                      .getGeoide()
                      .getHeightScale();
        var duration =
            options && options.hasOwnProperty("duration")
                ? options.duration
                : DEFAULT_DURATION_ZOOM_TO;
        var destTilt =
            options && options.hasOwnProperty("tilt")
                ? options.tilt
                : this.tilt;
        var destHeading =
            options && options.hasOwnProperty("heading")
                ? options.heading
                : this.heading;
        var shortestPath = Numeric.shortestPath180(
            this.geoCenter[0],
            geoPos[0]
        );
        var shortestHeading = Numeric.shortestPath180(
            this.heading,
            destHeading
        );
        // Create a single animation to animate geoCenter, distance and tilt
        var startValue = [
            shortestPath[0], // longitude
            this.geoCenter[1], // latitude
            this.distance, // distance from ground
            this.tilt, // tilt
            shortestHeading[0] // heading
        ];
        var endValue = [
            shortestPath[1], // longitude
            geoPos[1], // latitude
            destDistance *
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getHeightScale(), // distance from ground
            destTilt, // tilt
            shortestHeading[1] // heading
        ];

        this.zoomToAnimation = new AnimationFactory.create(
            Constants.ANIMATION.Segmented,
            {
                duration: duration,
                valueSetter: function(value) {
                    navigation.geoCenter[0] =
                        value[0] > 180 ? value[0] - 360 : value[0];
                    navigation.geoCenter[1] = value[1];
                    navigation.distance = value[2];
                    navigation.tilt = value[3];
                    navigation.heading =
                        value[4] > 180 ? value[4] - 360 : value[4];
                    navigation.computeViewMatrix();
                }
            }
        );

        // Compute a max altitude for the animation
        var worldStart = this.ctx
            .getCoordinateSystem()
            .get3DFromWorld(this.geoCenter);
        var worldEnd = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
        var vec = vec3.subtract(worldStart, worldEnd);
        var len = vec3.length(vec);
        var canvas = this.ctx.getRenderContext().canvas;
        var minFov = Math.min(
            Numeric.toRadian(45.0),
            Numeric.toRadian((45.0 * canvas.width) / canvas.height)
        );
        var maxAltitude = (len * 0.5) / Math.tan(minFov * 0.5);
        if (maxAltitude > this.distance) {
            // Compute the middle value
            var midValue = [
                (startValue[0] + endValue[0]) * 0.5,
                (startValue[1] + endValue[1]) * 0.5,
                maxAltitude,
                (startValue[3] + startValue[3]) * 0.5,
                (startValue[4] + startValue[4]) * 0.5
            ];

            // Add two segments
            this.zoomToAnimation.addSegment(
                0.0,
                startValue,
                0.5,
                midValue,
                function(t, a, b) {
                    var pt = Numeric.easeInQuad(t);
                    var dt = Numeric.easeOutQuad(t);
                    var ht = Numeric.easeOutQuad(t);
                    return [
                        Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                        Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                        Numeric.lerp(dt, a[2], b[2]), // distance
                        Numeric.lerp(t, a[3], b[3]), // tilt
                        Numeric.lerp(ht, a[4], b[4]) // heading
                    ];
                }
            );

            this.zoomToAnimation.addSegment(
                0.5,
                midValue,
                1.0,
                endValue,
                function(t, a, b) {
                    var pt = Numeric.easeOutQuad(t);
                    var dt = Numeric.easeInQuad(t);
                    var ht = Numeric.easeInQuad(t);
                    return [
                        Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                        Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                        Numeric.lerp(dt, a[2], b[2]), // distance
                        Numeric.lerp(t, a[3], b[3]), // tilt
                        Numeric.lerp(ht, a[4], b[4]) // heading
                    ];
                }
            );
        } else {
            // Add only one segments
            this.zoomToAnimation.addSegment(
                0.0,
                startValue,
                1.0,
                endValue,
                function(t, a, b) {
                    var pt = Numeric.easeOutQuad(t);
                    var dt = Numeric.easeInQuad(t);
                    var ht = Numeric.easeInQuad(t);
                    return [
                        Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                        Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                        Numeric.lerp(dt, a[2], b[2]), // distance
                        Numeric.lerp(t, a[3], b[3]), // tilt
                        Numeric.lerp(ht, a[4], b[4]) // heading
                    ];
                }
            );
        }

        var self = this;
        this.zoomToAnimation.onstop = function() {
            if (options && options.callback) {
                options.callback();
            }
            self.zoomToAnimation = null;
            self.ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
                destDistance
            );
            self.updateGeoCenter();
        };

        this.ctx.addAnimation(this.zoomToAnimation);

        this.zoomToAnimation.start();
    };

    /**
     * Applies to rotation matrix
     * @function applyLocalRotation
     * @memberof Navigation#
     */
    PlanetNavigation.prototype.applyLocalRotation = function(matrix) {
        mat4.rotate(matrix, Numeric.toRadian(this.heading), [0.0, 0.0, 1.0]);
        mat4.rotate(matrix, Numeric.toRadian(90 - this.tilt), [1.0, 0.0, 0.0]);
    };

    /**
     * Computes the view matrix
     * @function computeViewMatrix
     * @memberof Navigation#
     */
    PlanetNavigation.prototype.computeViewMatrix = function() {
        const oldMatrix = Array.from(this.renderContext.getViewMatrix());
        this.computeInverseViewMatrix();
        mat4.inverse(
            this.inverseViewMatrix,
            this.renderContext.getViewMatrix()
        );
        this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
        this.renderContext.requestFrame();
    };

    /**
     * Compute the inverse view matrix
     * @function computeInverseViewMatrix
     * @memberof PlanetNavigation#
     */
    PlanetNavigation.prototype.computeInverseViewMatrix = function() {
        this.ctx
            .getCoordinateSystem()
            .getLHVTransform(this.geoCenter, this.inverseViewMatrix);
        this.applyLocalRotation(this.inverseViewMatrix);
        mat4.translate(this.inverseViewMatrix, [0.0, 0.0, this.distance]);
    };

    /**
     * Zoom to the current observed location
     * @function zoom
     * @memberof PlanetNavigation#
     * @param {float} delta Delta zoom
     * @param {float} scale Scale
     */
    PlanetNavigation.prototype.zoom = function(delta, scale, x, y) {
        const oldDistance = this.distance;

        if (scale) {
            this.distance *= scale;
        } else {
            this._distance *= 1 + delta * 0.1;
        }

        this.distance = Math.max(
            Math.min(this.distance, this.maxDistance),
            this.minDistance
        );

        if (x && y) {
            // Recompute the geo position
            this.computeInverseViewMatrix();
            const eye = [
                this.inverseViewMatrix[12],
                this.inverseViewMatrix[13],
                this.inverseViewMatrix[14]
            ];

            const center = vec3.create();
            this.ctx.getCoordinateSystem().fromGeoTo3D(this.geoCenter, center);
            const centerDir = vec3.create();
            vec3.subtract(center, eye, centerDir);
            vec3.normalize(centerDir);

            const pos = vec3.create();
            const geoPos = this.ctx.globe.getLonLatFromPixel(x, y);

            this.ctx.getCoordinateSystem().fromGeoTo3D(geoPos, pos);
            const zoomDir = vec3.create();
            vec3.subtract(pos, eye, zoomDir);
            vec3.normalize(zoomDir);
            vec3.scale(zoomDir, oldDistance - this.distance);

            const newEye = vec3.create();
            vec3.add(eye, zoomDir, newEye);

            var r = new Ray(newEye, centerDir);
            const newCenter = this.ctx.globe.computeIntersection(r);
            if (newCenter != null && newCenter != undefined) {
                this.geoCenter = newCenter;
            }
        }

        // compute the view matrix with new values
        this.computeViewMatrix();
    };

    /**
     * Pans the camera
     * @function pan
     * @memberof PlanetNavigation#
     * @param {int} dx Window delta x
     * @param {int} dy Window delta y
     */
    PlanetNavigation.prototype.pan = function(dx, dy, mx, my) {
        if (this.lastMousePosition && mx && my) {
            const crs = this.ctx.getCoordinateSystem();
            const globe = this.ctx.globe;
            const rc = this.renderContext;

            const fov = rc.getFov();
            const halfFov = fov * 0.5 * Math.PI / 180.0;

            this.computeInverseViewMatrix();
            const eye = [
                this.inverseViewMatrix[12],
                this.inverseViewMatrix[13],
                this.inverseViewMatrix[14]
            ];

            const rotation = mat4.create(this.inverseViewMatrix);
            // mat4.translate(rotation, [0, 0, -this.distance]);
            // mat4.inverse(rotation);
            // crs.getLHVTransform(this.geoCenter, rotation);

            const center = vec3.create();
            this.ctx.getCoordinateSystem().fromGeoTo3D(this.geoCenter, center);
            const centerDir = vec3.create();
            vec3.subtract(center, eye, centerDir);
            vec3.normalize(centerDir);

            const pGeo = globe.getLonLatFromPixel(this.lastMousePosition[0], this.lastMousePosition[1]);

            // Cannot move if we do not pick a proper point
            // We always want to update the last mouse position
            // to avoid stopping interaction when moving out of the earth and coming back
            this.lastMousePosition = [mx, my];
            if (!pGeo) return;

            const p = vec3.create();
            crs.fromGeoTo3D(pGeo, p);

            const d = vec3.create();
            vec3.subtract(eye, p, d);
            const distance = vec3.length(d);
            const projScale = distance * Math.tan(halfFov);

            dx = dx * 2 / rc.getCanvas().width;
            dy = dy * 2 / rc.getCanvas().height;

            const deltaWorld = vec3.createFrom(-dx * projScale, dy * projScale, 0);
            mat4.rotateVec3(rotation, deltaWorld);

            const newEye = vec3.create();
            vec3.add(eye, deltaWorld, newEye);

            var r = new Ray(newEye, centerDir);
            const newCenter = this.ctx.globe.computeIntersection(r);
            if (newCenter != null && newCenter != undefined) {
                this.geoCenter = newCenter;
                this.geoCenter[1] = Math.min(88, Math.max(this.geoCenter[1], -88));
            }
        } else {
            // Get geographic frame
            var local2World = mat4.create();
            var coordinateSystem = this.ctx.getCoordinateSystem();
            coordinateSystem.getLocalTransform(this.geoCenter, local2World);
            // Then corresponding vertical axis and north
            var z = vec3.create();
            var previousNorth = vec3.create([0.0, 1.0, 0.0]);
            coordinateSystem.getUpVector(local2World, z);
            //coordinateSystem.getFrontVector( local2World, previousNorth );
            mat4.multiplyVec3(local2World, previousNorth, previousNorth);

            // Then apply local transform
            this.applyLocalRotation(local2World);
            // Retrieve corresponding axes
            var x = vec3.create();
            var y = vec3.create();
            coordinateSystem.getSideVector(local2World, x);
            coordinateSystem.getFrontVector(local2World, y);
            // According to our local configuration, up is y and side is x

            // Compute direction axes
            vec3.cross(z, x, y);
            vec3.cross(y, z, x);
            vec3.normalize(x, x);
            vec3.normalize(y, y);

            //Normalize dx and dy
            dx = dx / this.renderContext.getCanvas().width;
            dy = dy / this.renderContext.getCanvas().height;

            // Move accordingly
            var position = vec3.create();
            coordinateSystem.get3DFromWorld(this.geoCenter, position);
            // FIXME: Might be interesting to be able to control minimum camera speed
            vec3.scale(x, dx * Math.max(this.distance, 1000 * this.scale), x);
            vec3.scale(y, dy * Math.max(this.distance, 1000 * this.scale), y);
            vec3.subtract(position, x, position);
            vec3.add(position, y, position);

            // Clamp onto sphere
            vec3.normalize(position);
            vec3.scale(position, coordinateSystem.getGeoide().getRadius());

            // Update geographic center
            coordinateSystem.getWorldFrom3D(position, this.geoCenter);
            this.geoCenter[2] = this.targetHeight;

            // Compute new north axis
            var newNorth = vec3.create([0.0, 1.0, 0.0]);
            coordinateSystem.getLocalTransform(this.geoCenter, local2World);
            mat4.multiplyVec3(local2World, newNorth, newNorth);

            // Take care if we traverse the pole, ie the north is inverted
            if (vec3.dot(previousNorth, newNorth) < 0) {
                this.heading = (this.heading + 180.0) % MAX_HEADING;
            }

            this.computeViewMatrix();
        }
    };

    /**
     * Rotates the navigation
     * @function rotate
     * @memberof PlanetNavigation#
     * @param {int} dx Window delta x
     * @param {int} dy Window delta y
     */
    PlanetNavigation.prototype.rotate = function(dx, dy) {
        var previousHeading = this.heading;
        var previousTilt = this.tilt;

        this.heading += dx * DELTA_HEADING;
        this.tilt += dy * DELTA_TILT;

        this.clampTilt();

        this.computeViewMatrix();
    };

    /**
     * Check for collision
     * @function hasCollision
     * @memberof PlanetNavigation#
     * @return {Boolean} collision detected ?
     */
    PlanetNavigation.prototype.hasCollision = function() {
        const eye = [
            this.inverseViewMatrix[12],
            this.inverseViewMatrix[13],
            this.inverseViewMatrix[14]
        ];
        const geoEye = vec3.create();
        this.ctx.getCoordinateSystem().from3DToGeo(eye, geoEye);
        const elevation = this.ctx.getElevation(geoEye[0], geoEye[1]);

        const near = this.ctx.getRenderContext().near;

        const dist = geoEye[2] - elevation - 25;
        const collides = dist < 0;

        if (collides) {
            this.offset = -dist + 25;
        }

        return collides;
    };

    /**
     * Compute the new geocenter, being the intersection point
     * with the center of the screen
     */
    PlanetNavigation.prototype.updateGeoCenter = function() {
        const canvas = this.renderContext.canvas;
        const width = canvas.width;
        const height = canvas.height;

        // Recompute the geo position, trace a new ray to check intersection with the terrain
        this.computeInverseViewMatrix();
        const eye = [
            this.inverseViewMatrix[12],
            this.inverseViewMatrix[13],
            this.inverseViewMatrix[14]
        ];
        const pos = vec3.create();
        this.ctx.getCoordinateSystem().fromGeoTo3D(this.geoCenter, pos);
        const dir = vec3.create();
        vec3.subtract(pos, eye, dir);
        vec3.normalize(dir);
        var r = new Ray(eye, dir);

        const center = this.ctx.globe.computeIntersection(r);
        if (center != null && center != undefined) {
            this.geoCenter = center;
            // Update distance
            const center3D = vec3.create();
            this.ctx
                .getCoordinateSystem()
                .fromGeoTo3D(this.geoCenter, center3D);
            this.distance = vec3.dist(center3D, eye);
        }
    };

    /**
     * Returns the distance in meters.
     * @return {float} the distance in meters from the surface of the globe
     */
    PlanetNavigation.prototype.getDistance = function() {
        return this._distance;
    };

    /**
     * Returns a Heading where the values are included in [0,360]
     * @return {number}
     */
    PlanetNavigation.prototype.getHeading = function() {
        return ((this.heading % MAX_HEADING) + MAX_HEADING) % MAX_HEADING;
    };

    /**
     * Destroy
     * @function destroy
     * @memberof PlanetNavigation#
     */
    PlanetNavigation.prototype.destroy = function() {
        AbstractNavigation.prototype.destroy.call(this);
        this.minDistance = null;
        this.maxDistance = null;
        this.geoCenter = null;
        this._distance = null;
        this.heading = null;
        this.tilt = null;
        this.inverseViewMatrix = null;
    };

    /**
     * Update the navigator inner values
     * @function update
     * @memberof PlanetNavigation#
     * @fires Context#navigation:changedDistance
     */
    PlanetNavigation.prototype.update = function() {
        if (!this.ctx.globe.tileManager.level0TilesLoaded) {
            return;
        }

        if (Number.isNaN(this.distance)) {
            this.distance = this.maxDistance;
            this._distance = this.cameraHeight;
        }

        const rc = this.ctx.getRenderContext();

        // Update the near plane distance
        rc.near = this.distance * 0.25;

        this.computeViewMatrix();

        if (this.hasCollision()) {
            const hc = this.cameraHeight;
            const ht = this.targetHeight;
            const nh = (hc + this.offset - ht) / this._distance;
            const as = Math.asin(nh); // New tilt value
            if (Number.isNaN(as)) {
                ErrorDialog.open(Constants.LEVEL.DEBUG, "PlanetNavigation.js",`NaN ! ${hc}, ${ht}, ${this.offset}, ${
                    this._distance
                }, ${nh}`);
                this._distance += this.offset;
            } else {
                this.tilt = (as * 180) / Math.PI;
                this.clampTilt();
            }
            this.computeViewMatrix();
        }

        this.ctx.publish(
            Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
            this.cameraHeight
        );
    };

    /**
     * Clamp the tilt value between 5 and 90 degrees
     * @function clampTilt
     * @memberof PlanetNavigation#
     */
    PlanetNavigation.prototype.clampTilt = function() {
        this.tilt = Math.min(Math.max(this.tilt, MIN_TILT), MAX_TILT);
    };

    PlanetNavigation.prototype.doneMoving = function() {
        this.updateGeoCenter();
        this.lastMousePosition = null;
    };

    PlanetNavigation.prototype.donePanning = function() {
        this.updateGeoCenter();
        this.lastMousePosition = null;
    };

    PlanetNavigation.prototype.doneRotating = function() {
        this.updateGeoCenter();
    };

    PlanetNavigation.prototype.startInteraction = function(x, y) {
        this.lastMousePosition = [x, y];
    };

    /**
     * Moves up vector.
     * @function moveUpTo
     * @memberof PlanetNavigation#
     * @param {float[]} vec Vector
     * @param {int} [duration = 1000] - Duration of animation in milliseconds
     */
    PlanetNavigation.prototype.moveUpTo = function(vec, duration) {
        // Create a single animation to animate up
        var startValue = [];
        var endValue = [];
        this.ctx.getCoordinateSystem().getWorldFrom3D(this.up, endValue);
        this.ctx.getCoordinateSystem().getWorldFrom3D(vec, startValue);

        this.startHeading = this.getHeading();
        if (this.startHeading > 180) {
            this.endHeading = MAX_HEADING;
        } else {
            this.endHeading = MIN_HEADING;
        }

        var durationTime = duration || DEFAULT_DURATION_NORTH;

        var navigation = this;
        var animation = AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: durationTime,
            valueSetter: function(value) {
                navigation.heading = value;
                navigation.computeViewMatrix();
            }
        });

        animation.addSegment(
            0.0,
            this.startHeading,
            1.0,
            this.endHeading,
            function(t, a, b) {
                return Numeric.lerp(t, a, b);
            }
        );

        this.ctx.addAnimation(animation);
        this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);
        animation.start();
    };

    /**************************************************************************************************************/

    return PlanetNavigation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
/**
 * Mizar owns different types of navigation to control the camera on the WebGL scene.
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
 *         <td>{@link module:Navigation.AstroNavigation AstroNavigation}</td>
 *         <td>Provides a camera located at the center of the scene. The camera is inside the globe.
 *         It is used to view the sky</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
 *         <td>{@link module:Navigation.PlanetNavigation PlanetNavigation}</td>
 *         <td>Provides a camera, located outside the globe and looking at the globe. It is used to view a planet</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/nav_flat.png" width="200px"/></td>
 *         <td>{@link module:Navigation.FlatNavigation FlatNavigation}</td>
 *         <td>Provides a camera to navigate on a 2D map - Only available in a Planet context</td>
 *     </tr>
 * </table>
 *
 * The camera is automatically instantiated by the context {@link AbstractContext}, which is created by client.
 * Usually, the navigation is in 3D (AstroNavigation or PlanetNavigation). However, in a particular case, when
 * the client selects a  {@link module:Crs.CoordinateSystemFactory Coordinate Reference System} with a
 * {@link module:Crs.ProjectedCrs projection}, the {@link module:Navigation.FlatNavigation FlatNavigation} is selected.<br/>
 *
 * Then the client can control the navigation by its {@link Navigation interface}
 *
 * <p><p>
 * In addition, the navigation is controlled by the user with the help of devices : keyboard, touch, mouse.
 * When creating the Mizar instance, the user can define a list of supported devices to be able to control the
 * navigation by these devices. By default, the {@link module:Navigation.MouseNavigationHandler MouseNavigationHandler}
 * and {@link module:Navigation.KeyboardNavigationHandler KeyboardNavigationHandler} are set up.
 * When the parameter <i>isMobile</i> is set to true in {@link Mizar} options, then the
 * {@link module:Navigation.TouchNavigationHandler TouchNavigationHandler} is set up
 *
 * <p>
 * @todo Crer un tuto pour montrer les principales mthodes de Navigation et le changement de 3D <--> 2D
 * @module Navigation
 * @implements {Navigation}
 */
define('gw/Navigation/AstroNavigation',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./AbstractNavigation",
    "../Animation/AnimationFactory",
    "../Utils/Numeric",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function(
    Utils,
    Constants,
    AbstractNavigation,
    AnimationFactory,
    Numeric,
    Ray
) {
    /**
     * Astro navigation configuration
     * @typedef {AbstractNavigation.configuration} AbstractNavigation.astro_configuration
     * @property {float[]} [initTarget = [0,0]] - initial target of the camera in decimal degree (longitude, latitude)
     * @property {float} [initFov = 0.001] - initial field of view of the camera in decimal degree
     * @property {float} [minFov = 0.001] - Minimal field of view of the camera in decimal degree
     * @property {float} [maxFov = 100] - Maximal field of view of the camera in decimal degree
     * @property {float[]} [up = [0.0, 0.0, 1.0]] - Up vector that defines the north
     */

    /**
     * Duration of animation in milliseconds to align the camera with the north.
     * @type {number}
     */
    const DEFAULT_DURATION_NORTH = 1000;

    /**
     * Default duration in millisecond for zoom feature.
     * @type {number}
     */
    const DEFAULT_DURATION_ZOOM = 5000;

    /**
     * Difference between two successive rotation (in degree) of the camera.
     * @type {number}
     */
    const DELTA_HEADING = 0.05;

    /**
     * Default min FOV.
     * @type {number}
     */
    const DEFAULT_MIN_FOV = 0.001;

    /**
     * Default max FOV.
     * @type {number}
     */
    const DEFAULT_MAX_FOV = 100;

    /**
     * Arbitrary middle fov value which determines if the animation needs two segments
     * @type {number}
     */
    const DEFAULT_MIDDLE_FOV = 25;

    /**
     * Final FOV.
     * @type {number}
     */
    const DEFAULT_FINAL_FOV = 2.0;

    /**
     * @name AstroNavigation
     * @class
     * <table border="0">
     *     <tr>
     *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
     *         <td>Provides a camera located at the center of the scene. The camera is inside the globe.
     *         It is used to view the sky.</td>
     *     </tr>
     * </table>
     * When an <i>initFov</i> is provided out the range [<i>minFov</i>, <i>maxFov</i>], the range
     * [<i>minFov</i>, <i>maxFov</i>] is updated with the value of <i>initFov</i>.
     * @augments AbstractNavigation
     * @param {SkyContext} ctx - Sky context
     * @param {AbstractNavigation.astro_configuration} options - navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var AstroNavigation = function(ctx, options) {
        AbstractNavigation.prototype.constructor.call(
            this,
            Constants.NAVIGATION.AstroNavigation,
            ctx,
            options
        );

        // Default values for fov (in degrees)
        this.minFov = this.options.minFov || DEFAULT_MIN_FOV;
        this.maxFov = this.options.maxFov || DEFAULT_MAX_FOV;

        // Initialize the navigation
        this.center3d = [1.0, 0.0, 0.0];
        this.up = [0.0, 0.0, 1.0];
        _setInitTarget.call(this, this.options.initTarget);
        _setInitFov.call(this, this.options.initFov);
        _setUpVector.call(this, this.options.up);

        // Update the view matrix now
        this.computeViewMatrix();
    };

    /**
     * Defines the Up vector.
     * @param up
     * @private
     */
    function _setUpVector(up) {
        if (up) {
            this.up = up;
        }
    }

    /**
     * Defines the field of view of the camera at initialisation.<br/>
     * When the initFov outside the range [minFov, maxFov], the range is extented to include the initFov
     * @param {float|undefined} initFov
     * @private
     */
    function _setInitFov(initFov) {
        if (initFov) {
            if (this.minFov > initFov) {
                this.minFov = initFov;
            } else if (this.maxFov < initFov) {
                this.maxFov = initFov;
            }
            this.renderContext.setFov(initFov);
            this._clampFov();
        }
    }

    /**
     * Defines the position where the camera looks at.
     * @param {float[]|undefined} initTarget
     * @private
     */
    function _setInitTarget(initTarget) {
        if (initTarget) {
            this.ctx
                .getCoordinateSystem()
                .get3DFromWorld(initTarget, this.center3d);
        }
    }

    /**
     * Init move up animation.
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} durationTime - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initMoveUpAnimation(navigation, durationTime) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: durationTime,
            valueSetter: function(value) {
                var position3d = navigation.ctx
                    .getCoordinateSystem()
                    .get3DFromWorld([value[0], value[1]]);
                navigation.up[0] = position3d[0];
                navigation.up[1] = position3d[1];
                navigation.up[2] = position3d[2];
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Init zoom animation
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} duration - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initZoomAnimation(navigation, duration) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: duration,
            valueSetter: function(value) {
                var position3d = navigation.ctx
                    .getCoordinateSystem()
                    .get3DFromWorld([value[0], value[1]]);
                navigation.center3d[0] = position3d[0];
                navigation.center3d[1] = position3d[1];
                navigation.center3d[2] = position3d[2];
                navigation.ctx.getRenderContext().setFov(value[2]);
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Adds two segments to the animation, which starts to startValue and stops to endValue
     * by crossing the middleFov at middle value of [startValue, endValue]
     * @param {AbstractAnimation} zoomToAnimation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} middleFov - FOV
     * @private
     */
    function _addZoomOutThenZoomIn(
        zoomToAnimation,
        startValue,
        endValue,
        middleFov
    ) {
        // Compute the middle value
        var midValue = [
            startValue[0] * 0.5 + endValue[0] * 0.5,
            startValue[1] * 0.5 + endValue[1] * 0.5,
            middleFov
        ];

        // zoom out to max altitude
        zoomToAnimation.addSegment(0.0, startValue, 0.5, midValue, function(
            t,
            a,
            b
        ) {
            var pt = Numeric.easeInQuad(t);
            var dt = Numeric.easeOutQuad(t);
            return [
                Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                Numeric.lerp(dt, a[2], b[2])
            ]; // distance
        });

        // zoom in
        _addZoomIn.call(this, zoomToAnimation, midValue, endValue, 0.5);
    }

    /**
     * Adds a segment to the animation, which starts to startValue and stops to endValue
     * @param {AbstractAnimation} animation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} [startParameter=0.0] - start parameter
     * @private
     */
    function _addZoomIn(animation, startValue, endValue, startParameter) {
        var parameter = startParameter ? startParameter : 0.0;
        animation.addSegment(parameter, startValue, 1.0, endValue, function(
            t,
            a,
            b
        ) {
            var pt = Numeric.easeOutQuad(t);
            var dt = Numeric.easeInQuad(t);
            return [
                Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                Numeric.lerp(dt, a[2], b[2])
            ]; // distance
        });
    }

    /**
     * Adds an event when the animation stops.
     * @param {AbstractAnimation} animation - animation where the event is added
     * @param {AbstractContext} ctx - context
     * @param {number} destDistance - Final zooming distance in meter
     * @param {Object} [options] - options
     * @param {Object} [options.callback] - Callback function to call when it is defined.
     * @fires Context#navigation:changedDistance
     * @private
     */
    function _addStop(animation, ctx, destDistance, options) {
        animation.onstop = function() {
            if (options && options.callback) {
                options.callback();
            }
            animation = null;
            ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
                destDistance
            );
        };
    }

    /**
     * Computes parameters for animation
     * @param {AbstractContext} ctx - context
     * @param {Array.<float>} center3D - start position in 3D
     * @param {Array.<float>} geoPos - stop position
     * @param {float} startFov - start FOV
     * @param {float} destFov - stop FOV
     * @return {Array.<float>} Returns [startValue, endValue]
     * @private
     */
    function _computeParametersAnimation(
        ctx,
        center3D,
        geoPos,
        startFov,
        destFov
    ) {
        var geoStart = [];
        ctx.getCoordinateSystem().getWorldFrom3D(center3D, geoStart);
        var path = Numeric.shortestPath360(geoStart[0], geoPos[0]);
        var startValue = [path[0], geoStart[1], startFov];
        var endValue = [path[1], geoPos[1], destFov];
        return [startValue, endValue];
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractNavigation, AstroNavigation);

    /**************************************************************************************************************/

    /**
     * Returns the center of the navigation.
     * @function getCenter
     * @memberof AstroNavigation#
     * @return {float[]}
     */
    AstroNavigation.prototype.getCenter = function() {
        var center = AbstractNavigation.prototype.getCenter.call(this);
        if (center == null) {
            center = [];
            this.ctx
                .getCoordinateSystem()
                .getWorldFrom3D(this.center3d, center);
        }
        return center;
    };

    /**
     * ZoomTo a 3D position
     * @function zoomTo
     * @param {float[]} geoPos - target of the camera
     * @param {Object} options - options
     * @param {float} [options.fov = DEFAULT_FINAL_FOV] - field of view in degree
     * @param {int} [options.duration = DEFAULT_DURATION_ZOOM] - duration of the animation in milliseconds
     * @param {navigationCallback} [options.callback] - Called at the end of navigation
     * @memberof AstroNavigation#
     */
    AstroNavigation.prototype.zoomTo = function(geoPos, options) {
        var navigation = this;

        // default values
        var destFov = options && options.fov ? options.fov : DEFAULT_FINAL_FOV;
        var duration =
            options && options.duration
                ? options.duration
                : DEFAULT_DURATION_ZOOM;

        // Create a single animation to animate center3d and fov
        var parameters = _computeParametersAnimation.call(
            this,
            this.ctx,
            this.center3d,
            geoPos,
            this.renderContext.getFov(),
            destFov
        );
        var startValue = parameters[0];
        var endValue = parameters[1];

        var zoomToAnimation = _initZoomAnimation.call(
            this,
            navigation,
            duration
        );

        // End point which is out of frustum invokes two steps animation, one step otherwise
        var end3DValue = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
        if (
            DEFAULT_MIDDLE_FOV > this.renderContext.getFov() &&
            this.renderContext
                .getWorldFrustum()
                .containsSphere(end3DValue, 0.005) < 0
        ) {
            // Two steps animation, 'rising' & 'falling'
            _addZoomOutThenZoomIn.call(
                this,
                zoomToAnimation,
                startValue,
                endValue,
                DEFAULT_MIDDLE_FOV
            );
        } else {
            // One step animation, 'falling' only
            _addZoomIn.call(this, zoomToAnimation, startValue, endValue);
        }

        _addStop.call(this, zoomToAnimation, this.ctx, destFov, options);

        this.ctx.addAnimation(zoomToAnimation);
        zoomToAnimation.start();
    };

    /**
     * Moves up vector.
     * @function moveUpTo
     * @memberof AstroNavigation#
     * @param {float[]} vec Vector
     * @param {int} [duration = DEFAULT_DURATION_NORTH] - Duration of animation in milliseconds
     */
    AstroNavigation.prototype.moveUpTo = function(vec, duration) {
        // Create a single animation to animate up
        var startValue = [];
        var endValue = [];
        this.ctx.getCoordinateSystem().getWorldFrom3D(this.up, startValue);
        this.ctx.getCoordinateSystem().getWorldFrom3D(vec, endValue);
        var durationTime = duration || DEFAULT_DURATION_NORTH;

        var navigation = this;
        var moveUpToAnimation = _initMoveUpAnimation.call(
            this,
            navigation,
            durationTime
        );
        _addZoomIn.call(this, moveUpToAnimation, startValue, endValue);
        this.ctx.addAnimation(moveUpToAnimation);
        moveUpToAnimation.start();
    };

    /**
     * Computes the view matrix
     * @function computeViewMatrix
     * @memberof AstroNavigation#
     */
    AstroNavigation.prototype.computeViewMatrix = function() {
        vec3.normalize(this.center3d);
        var vm = this.renderContext.getViewMatrix();
        mat4.lookAt([0.0, 0.0, 0.0], this.center3d, this.up, vm);
        this.up = [vm[1], vm[5], vm[9]];
        this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
        this.renderContext.requestFrame();
    };

    /**
     * Event handler for mouse wheel
     * @function zoom
     * @memberof AstroNavigation#
     * @param {float} delta Delta zoom
     * @param {float} scale Scale
     */
    AstroNavigation.prototype.zoom = function(delta, scale) {
        // TODO : improve zoom, using scale or delta ? We should use scale always
        if (scale) {
            this.renderContext.setFov(
                (this.renderContext.getFov() * 1) / scale
            );
        } else {
            // Arbitrary value for smooth zooming
            this.renderContext.setFov(
                this.renderContext.getFov() * (1 + delta * 0.1)
            );
        }

        this._clampFov();
        this.computeViewMatrix();
    };

    /**
     * Pan the navigation by computing the difference between 3D centers
     * @function pan
     * @memberof AstroNavigation#
     * @param {int} dx Window delta x
     * @param {int} dy Window delta y
     */
    AstroNavigation.prototype.pan = function(dx, dy) {
        var x = this.renderContext.getCanvas().width / 2.0;
        var y = this.renderContext.getCanvas().height / 2.0;
        var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);
        this.center3d = ray.computePoint(
            ray.sphereIntersect(
                [0, 0, 0],
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getRadius()
            )
        );
        this.computeViewMatrix();
    };

    /**
     * Rotates the navigation
     * @function rotate
     * @memberof AstroNavigation#
     * @param {float} dx Window delta x
     */
    AstroNavigation.prototype.rotate = function(dx) {
        // constant tiny angle
        var angle = Numeric.toRadian(dx * DELTA_HEADING);
        var rot = quat4.fromAngleAxis(angle, this.center3d);
        quat4.multiplyVec3(rot, this.up);
        this.computeViewMatrix();
    };

    /**
     * Clamping of fov
     * @function _clampFov
     * @memberof AstroNavigation#
     * @private
     */
    AstroNavigation.prototype._clampFov = function() {
        if (this.renderContext.getFov() > this.maxFov) {
            this.renderContext.setFov(this.maxFov);
        }
        if (this.renderContext.getFov() < this.minFov) {
            this.renderContext.setFov(this.minFov);
        }
    };

    /**
     * Destroy
     * @function destroy
     * @memberof AstroNavigation#
     */
    AstroNavigation.prototype.destroy = function() {
        AbstractNavigation.prototype.destroy.call(this);
        this.minFov = null;
        this.maxFov = null;
        this.center3d = null;
        this.up = null;
    };

    /**************************************************************************************************************/

    return AstroNavigation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Navigation/FlatNavigation',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./AbstractNavigation",
    "../Animation/AnimationFactory",
    "../Utils/Numeric",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function(
    Utils,
    Constants,
    AbstractNavigation,
    AnimationFactory,
    Numeric,
    Ray
) {
    /**
     * Flat navigation configuration
     * @typedef {AbstractNavigation.configuration} AbstractNavigation.flat_configuration
     * @property {float[]} [initTarget = [0, 0, 5.0 * RADIUS_PLANET]] - Target in decimal degree (longitude, latitude, distance in meter)
     * at initialisation. distance in meter is optional.
     * @property {float} [minDistance = DEFAULT_MIN_DISTANCE] - The minimum distance in meter from the surface of the globe
     * or options.initTarget[2] when this one is inferior to options.minDistance
     * @property {float} [maxDistance = 5.0 * RADIUS_PLANET] - The maximum distance in meter or
     * options.initTarget[2] when this one is superior to options.maxDistance
     */

    /**
     * Duration of animation in milliseconds to align the camera with the north.
     * @type {number}
     */
    const DEFAULT_DURATION_NORTH = 1000.0;

    /**
     * Min heading value in decimal degree.
     * @type {number}
     */
    const MIN_HEADING = 0.0;

    /**
     * Max heading value in decimal degree.
     * @type {number}
     */
    const MAX_HEADING = 360.0;

    /**
     * Difference between two successive rotation (in degree) of the camera.
     * @type {number}
     */
    const DELTA_HEADING = 0.05;

    /**
     * Rotation axis according to the center of the map (0,0).
     * Long, lat, distance as vector length
     * @type {number[]}
     */
    const ROTATION_AXIS = [0.0, 0.0, 1.0];

    /**
     * 3D cartesian of planet center.
     * Long lat distance as vector ength.
     * @type {number[]}
     */
    const CENTER = [0.0, 0.0, 0.0];

    /**
     * Default min distance in meter.
     * @type {number}
     */
    const DEFAULT_MIN_DISTANCE = 60000;

    /**
     * Default duration in millisecond for zoom feature.
     * @type {number}
     */
    const DEFAULT_DURATION_ZOOM = 5000;

    /**
     * @name FlatNavigation
     * @class
     * <table border="0">
     *     <tr>
     *         <td><img src="../doc/images/nav_flat.png" width="200px"/></td>
     *         <td>Provides a camera to navigate on a 2D map - Only available in a Planet context. A 2D navigation
     *         provides a navigation for which there is no tilt and no roll <img src="https://developers.google.com/kml/documentation/kmlreference"/></td>
     *     </tr>
     * </table>
     * @augments AbstractNavigation
     * @param {PlanetContext} ctx - Planet context
     * @param {AbstractNavigation.flat_configuration} options - Flat navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var FlatNavigation = function(ctx, options) {
        AbstractNavigation.prototype.constructor.call(
            this,
            Constants.NAVIGATION.FlatNavigation,
            ctx,
            options
        );

        // Default values for min and max distance (in meter)
        this.minDistance = this.options.minDistance || DEFAULT_MIN_DISTANCE;
        this.maxDistance =
            this.options.maxDistance ||
            (5.0 *
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getRadius()) /
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getHeightScale();

        // Scale min and max distance from meter to internal ratio
        this.minDistance *= this.ctx
            .getCoordinateSystem()
            .getGeoide()
            .getHeightScale();
        this.maxDistance *= this.ctx
            .getCoordinateSystem()
            .getGeoide()
            .getHeightScale();

        // Initialize the navigation
        this.center = CENTER;
        this.distance = this.maxDistance;
        this.heading = 0;
        this.up = [0.0, 1.0, 0.0];
        _setInitTarget.call(this, this.options.initTarget);

        const rc = this.ctx.getRenderContext();
        if (rc) {
            rc.near = 0.001;
        }

        this.computeViewMatrix();
    };

    /**
     * Defines the position where the camera looks at and the distance of the camera from the planet's surface.
     * @param {float[]|undefined} initTarget as [longitude, latitude[, distance in meter]]
     * @private
     */
    function _setInitTarget(initTarget) {
        if (initTarget) {
            var pos = this.ctx.getCoordinateSystem().get3DFromWorld(initTarget);
            this.center[0] = pos[0];
            this.center[1] = pos[1];
            this.distance =
                initTarget.length === 3
                    ? initTarget[2] *
                      this.ctx
                          .getCoordinateSystem()
                          .getGeoide()
                          .getHeightScale()
                    : this.distance;
            if (this.distance < this.minDistance) {
                this.minDistance = this.distance;
            }
            if (this.distance > this.maxDistance) {
                this.maxDistance = this.distance;
            }
        }
    }

    /**
     * Init move up animation.
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} durationTime - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initMoveUpAnimation(navigation, durationTime) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: durationTime,
            valueSetter: function(value) {
                var angle = value - navigation.heading;
                navigation.heading = value;
                var rot = quat4.fromAngleAxis(
                    Numeric.toRadian(angle),
                    ROTATION_AXIS
                );
                quat4.multiplyVec3(rot, navigation.up);
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Rotates from startHeading to North
     * @param {AbstractAnimation} animation - animation on which the rotation is applied
     * @param {float} startHeading - start heading
     * @private
     */
    function _rotateAnimationToNorth(animation, startHeading) {
        var endHeading;
        if (startHeading > 180) {
            endHeading = MAX_HEADING;
        } else {
            endHeading = MIN_HEADING;
        }
        animation.addSegment(0.0, startHeading, 1.0, endHeading, function(
            t,
            a,
            b
        ) {
            return Numeric.lerp(t, a, b);
        });
    }

    /**
     * Init zoom animation
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} duration - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initZoomAnimation(navigation, duration) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: duration,
            valueSetter: function(value) {
                navigation.center[0] = value[0];
                navigation.center[1] = value[1];
                navigation.distance = value[2];
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Adds two segments to the animation, which starts to startValue and stops to endValue
     * by crossing the maxAltitude at middle value of [startValue, endValue]
     * @param {AbstractAnimation} zoomToAnimation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} maxAltitude - altitude (as vector length) where the camera FOV contains the center and the target position
     * @private
     */
    function _addZoomOutThenZoomIn(
        zoomToAnimation,
        startValue,
        endValue,
        maxAltitude
    ) {
        // Compute the middle value
        var midValue = [
            startValue[0] * 0.5 + endValue[0] * 0.5,
            startValue[1] * 0.5 + endValue[1] * 0.5,
            maxAltitude
        ];

        // zoom out to max altitude
        zoomToAnimation.addSegment(0.0, startValue, 0.5, midValue, function(
            t,
            a,
            b
        ) {
            var pt = Numeric.easeInQuad(t);
            var dt = Numeric.easeOutQuad(t);
            return [
                Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                Numeric.lerp(dt, a[2], b[2])
            ]; // distance
        });

        // zoom in
        _addZoomIn.call(this, zoomToAnimation, midValue, endValue, 0.5);
    }

    /**
     * Adds a segment to the animation, which starts to startValue and stops to endValue
     * @param {AbstractAnimation} zoomToAnimation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} [startParameter=0.0] - start parameter
     * @private
     */
    function _addZoomIn(zoomToAnimation, startValue, endValue, startParameter) {
        var parameter = startParameter ? startParameter : 0.0;
        zoomToAnimation.addSegment(
            parameter,
            startValue,
            1.0,
            endValue,
            function(t, a, b) {
                var pt = Numeric.easeOutQuad(t);
                var dt = Numeric.easeInQuad(t);
                return [
                    Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                    Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                    Numeric.lerp(dt, a[2], b[2])
                ]; // distance
            }
        );
    }

    /**
     * Adds an event when the animation stops.
     * @param {AbstractAnimation} zoomToAnimation - animation where the event is added
     * @param {AbstractContext} ctx - context
     * @param {number} destDistance - Final zooming distance in meter
     * @param {Object} [options] - options
     * @param {Object} [options.callback] - Callback function to call when it is defined.
     * @private
     * @fires Context#navigation:changedDistance
     */
    function _addStop(zoomToAnimation, ctx, destDistance, options) {
        zoomToAnimation.onstop = function() {
            if (options && options.callback) {
                options.callback();
            }
            zoomToAnimation = null;
            ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
                destDistance
            );
        };
    }

    /**
     * Computes altitude (as vector length) for which the fov see the distance between worldStart-worldEnd
     * @param {AbstractContext} ctx - context
     * @param {float[]} worldStart - Starting position as [longitude, latitude, distance]
     * @param {float[]} worldEnd - Ending position as [longitude, latitude, distance]
     * @return {number} the altitude for which the fov see the distance worldStart-worldEnd
     * @private
     */
    function _computeMaxAltitudeForZoomAnimation(ctx, worldStart, worldEnd) {
        var vec = vec3.subtract(worldStart, worldEnd);
        var len = vec3.length(vec);
        var canvas = ctx.getRenderContext().getCanvas();
        var fov = ctx.getRenderContext().getFov();
        var minFov = Math.min(
            Numeric.toRadian(fov),
            Numeric.toRadian((fov * canvas.width) / canvas.height)
        );
        return len / 2.0 / Math.tan(minFov / 2.0);
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractNavigation, FlatNavigation);

    /**************************************************************************************************************/

    /**
     * @function getCenter
     * @memberof FlatNavigation#
     * @return {float[]} Returns the central position of the camera
     */
    FlatNavigation.prototype.getCenter = function() {
        var center = AbstractNavigation.prototype.getCenter.call(this);
        if (center == null) {
            center = this.center;
        }
        return center;
    };

    /**
     * Saves the current navigation state.
     * @function save
     * @memberof FlatNavigation#
     * @return {{center: *, distance: *, up: *}} a JS object containing the navigation state
     */
    FlatNavigation.prototype.save = function() {
        return {
            center: this.center,
            distance: this.distance,
            up: this.up
        };
    };

    /**
     * Restores the navigation state.
     * @function restore
     * @memberof FlatNavigation#
     * @param {Object} state a JS object containing the navigation state
     * @param {float[]} state.center - Center of the camera's field of view in decimal degree as [longitude, latitude]
     * @param {int} state.distance - Distance in meters from the surface of the globe to the camera
     */
    FlatNavigation.prototype.restore = function(state) {
        this.center = state.center;
        this.distance = state.distance;
        this.up = state.up;
        this.computeViewMatrix();
    };

    /**
     * Computes the view matrix.
     * @function computeViewMatrix
     * @memberof FlatNavigation#
     */
    FlatNavigation.prototype.computeViewMatrix = function() {
        var vm = this.renderContext.getViewMatrix();
        var eye = [this.center[0], this.center[1], this.distance];
        mat4.lookAt(eye, this.center, this.up, vm);
        this.up = [vm[1], vm[5], vm[9]];
        this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
        this.renderContext.requestFrame();
    };

    /**
     * Zooms to a geographic position by creating an animation.
     *
     * @function zoomTo
     * @memberof FlatNavigation#
     * @param {float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
     * @param {Object} options - options
     * @param {int} [options.distance] - Final zooming distance in meters. By default, the distance does not change
     * @param {int} [options.duration = DEFAULT_DURATION_ZOOM] -  Duration of animation in milliseconds
     * @param {navigationCallback} options.callback - Callback at the end of animation
     */
    FlatNavigation.prototype.zoomTo = function(geoPos, options) {
        this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE);
        var navigation = this;
        var duration =
            options && options.duration
                ? options.duration
                : DEFAULT_DURATION_ZOOM;
        var zoomToAnimation = _initZoomAnimation.call(
            this,
            navigation,
            duration
        );

        var destDistance =
            options && options.distance
                ? options.distance
                : this.distance /
                  this.ctx
                      .getCoordinateSystem()
                      .getGeoide()
                      .getHeightScale();
        var pos = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
        var startValue = [this.center[0], this.center[1], this.distance];
        var endValue = [
            pos[0],
            pos[1],
            destDistance *
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getHeightScale()
        ];

        var maxAltitude = _computeMaxAltitudeForZoomAnimation.call(
            this,
            this.ctx,
            this.center,
            pos
        );

        if (maxAltitude > this.distance) {
            _addZoomOutThenZoomIn.call(
                this,
                zoomToAnimation,
                startValue,
                endValue,
                maxAltitude
            );
        } else {
            _addZoomIn.call(this, zoomToAnimation, startValue, endValue);
        }

        _addStop.call(this, zoomToAnimation, this.ctx, destDistance, options);

        this.ctx.addAnimation(zoomToAnimation);
        zoomToAnimation.start();
    };

    /**
     * Zoom to the current observed location
     * @function zoom
     * @memberof FlatNavigation#
     * @param {float} delta Delta zoom
     * @param {float} scale Scale
     */
    FlatNavigation.prototype.zoom = function(delta, scale) {
        var previousDistance = this.distance;

        // TODO : improve zoom, using scale or delta ? We should use scale always
        if (scale) {
            this.distance *= scale;
        } else {
            this.distance *= 1 + delta * 0.1;
        }

        if (this.distance > this.maxDistance) {
            this.distance = previousDistance;
        }
        if (this.distance < this.minDistance) {
            this.distance = previousDistance;
        }

        //TODO : add the collision algorithm because of the elevation

        this.computeViewMatrix();
        this.ctx.publish(
            Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
            this.getDistance()
        );
    };

    /**
     * Pans the camera
     * @function pan
     * @memberof FlatNavigation#
     * @param {int} dx Window delta x
     * @param {int} dy Window delta y
     */
    FlatNavigation.prototype.pan = function(dx, dy) {
        var x = this.renderContext.getCanvas().width / 2.0;
        var y = this.renderContext.getCanvas().height / 2.0;

        // Get the most-left point
        var ptLeft = this.ctx.getLonLatFromPixel(0, y);
        if (ptLeft === null && dx > 0) {
            dx = 0;
        }

        // Get the most-right point
        var ptRight = this.ctx.getLonLatFromPixel(
            this.renderContext.getCanvas().width,
            y
        );
        if (ptRight === null && dx < 0) {
            dx = 0;
        }

        // Get the most-top point
        var ptTop = this.ctx.getLonLatFromPixel(x, 0);
        if (ptTop === null && dy > 0) {
            dy = 0;
        }

        // Get the most-bottom point
        var ptBottom = this.ctx.getLonLatFromPixel(
            x,
            this.renderContext.getCanvas().height
        );
        if (ptBottom === null && dy < 0) {
            dy = 0;
        }

        if (dx === 0 && dy === 0) {
            return;
        }

        var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);

        this.center = ray.computePoint(
            ray.planeIntersect(CENTER, ROTATION_AXIS)
        );

        this.computeViewMatrix();
    };

    /**
     * Camera heading.
     * @function rotate
     * @memberof FlatNavigation#
     * @param {int} dx Window delta x
     */
    FlatNavigation.prototype.rotate = function(dx) {
        // Constant tiny angle
        var angle = dx * DELTA_HEADING;
        this.heading += angle;
        var rot = quat4.fromAngleAxis(Numeric.toRadian(angle), ROTATION_AXIS);
        quat4.multiplyVec3(rot, this.up);
        this.computeViewMatrix();
    };

    /**
     * Returns the distance in meters.
     * @function getDistance
     * @memberof FlatNavigation#
     * @return {float} the distance in meters from the surface of the globe
     */
    FlatNavigation.prototype.getDistance = function() {
        return (
            this.distance *
            this.ctx
                .getCoordinateSystem()
                .getGeoide()
                .getRealPlanetRadius()
        );
    };

    /**
     * Returns the heading of the camera.
     * @function getHeading
     * @memberof FlatNavigation#
     * @return {number} the heading angle between [0, 360]
     */
    FlatNavigation.prototype.getHeading = function() {
        return ((this.heading % MAX_HEADING) + MAX_HEADING) % MAX_HEADING;
    };

    /**
     * Moves up vector.
     * @function moveUpTo
     * @memberof FlatNavigation#
     * @param {float[]} vec Vector
     * @param {int} [duration = DEFAULT_DURATION_NORTH] - Duration of animation in milliseconds
     */
    FlatNavigation.prototype.moveUpTo = function(vec, duration) {
        // Create a single animation to animate up
        var startValue = [];
        var endValue = this.up;
        endValue[0] = Numeric.toDegree(endValue[0]);
        endValue[1] = Numeric.toDegree(endValue[1]);
        //endValue[2] = endValue[2];

        this.ctx.getCoordinateSystem().getWorldFrom3D(vec, startValue);

        var durationTime = duration || DEFAULT_DURATION_NORTH;

        var navigation = this;
        var moveUpToAnimation = _initMoveUpAnimation.call(
            this,
            navigation,
            durationTime
        );
        _rotateAnimationToNorth.call(
            this,
            moveUpToAnimation,
            this.getHeading()
        );
        this.ctx.addAnimation(moveUpToAnimation);
        moveUpToAnimation.start();
    };

    /**
     * Destroy
     * @function destroy
     * @memberof FlatNavigation#
     */
    FlatNavigation.prototype.destroy = function() {
        AbstractNavigation.prototype.destroy.call(this);
        this.up = null;
        this.minDistance = null;
        this.maxDistance = null;
        this.heading = null;
        this.center = null;
        this.distance = null;
    };

    /**************************************************************************************************************/

    return FlatNavigation;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Navigation/GroundNavigation',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./AbstractNavigation",
    "../Animation/SegmentedAnimation",
    "../Animation/AnimationFactory",
    "../Utils/Numeric",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function(
    Utils,
    Constants,
    AbstractNavigation,
    SegmentedAnimation,
    AnimationFactory,
    Numeric,
    Ray
) {
    /**************************************************************************************************************/

    /**
     * Duration of animation in milliseconds to align the camera with the north.
     * @type {number}
     */
    const DEFAULT_DURATION_NORTH = 1000;

    /**
     * Default duration in millisecond for zoom feature.
     * @type {number}
     */
    const DEFAULT_DURATION_ZOOM = 5000;

    /**
     * Default min FOV.
     * @type {number}
     */
    const DEFAULT_MIN_FOV = 0.5;

    /**
     * Default max FOV.
     * @type {number}
     */
    const DEFAULT_MAX_FOV = 70;

    /**
     * Arbitrary middle fov value which determines if the animation needs two segments
     * @type {number}
     */
    const DEFAULT_MIDDLE_FOV = 25;

    /**
     * Final FOV.
     * @type {number}
     */
    const DEFAULT_FINAL_FOV = 2.0;

    /**
     * 3D position of the azimuth 0.
     * @type {number[]}
     */
    const DEFAULT_AZIMUTH_ZERO = [1.0, 0.0, 0.0];

    /**
     * Min heading value in decimal degree.
     * @type {number}
     */
    const MIN_HEADING = 0.0;

    /**
     * Max heading value in decimal degee.
     * @type {number}
     */
    const MAX_HEADING = 360.0;

    /**
     * Difference between two successive rotation (in degree) of the camera.
     * @type {number}
     */
    const DELTA_HEADING = 0.05;

    /**
     * Default heading in decimal degree.
     * @type {number}
     */
    const DEFAULT_HEADING = MIN_HEADING;

    /**
     * @name GroundNavigation
     * @class
     * When an <i>initFov</i> is provided out the range [<i>minFov</i>, <i>maxFov</i>], the range
     * [<i>minFov</i>, <i>maxFov</i>] is updated with the value of <i>initFov</i>.
     * @augments AstroNavigation
     * @param {GroundContext} ctx - ground context
     * @param {AbstractNavigation.astro_configuration} options - navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var GroundNavigation = function(ctx, options) {
        AbstractNavigation.prototype.constructor.call(
            this,
            Constants.NAVIGATION.GroundNavigation,
            ctx,
            options
        );

        // Default values for fov (in degrees)
        this.minFov = this.options.minFov || DEFAULT_MIN_FOV;
        this.maxFov = this.options.maxFov || DEFAULT_MAX_FOV;

        // Initialize the navigation
        this.center3d = DEFAULT_AZIMUTH_ZERO;
        this.up = [0.0, 0.0, 1.0];
        this.heading = this.options.initTarget
            ? this.options.initTarget[0]
            : DEFAULT_HEADING;
        _setInitTarget.call(this, this.options.initTarget);
        _setInitFov.call(this, this.options.initFov);
        _setUpVector.call(this, this.options.up);

        // Update the view matrix now
        this.computeViewMatrix();
    };

    /**
     * Defines the position where the camera looks at.
     * @param {float[]|undefined} initTarget
     * @private
     */
    function _setInitTarget(initTarget) {
        if (initTarget) {
            this.ctx
                .getCoordinateSystem()
                .get3DFromWorld(initTarget, this.center3d);
        }
    }

    /**
     * Defines the field of view of the camera at initialisation.<br/>
     * When the initFov outside the range [minFov, maxFov], the range is extented to include the initFov
     * @param {float|undefined} initFov
     * @private
     */
    function _setInitFov(initFov) {
        if (initFov) {
            if (this.minFov > initFov) {
                this.minFov = initFov;
            } else if (this.maxFov < initFov) {
                this.maxFov = initFov;
            }
            this.renderContext.setFov(initFov);
            this._clampFov();
        }
    }

    /**
     * Defines the Up vector.
     * @param up
     * @private
     */
    function _setUpVector(up) {
        if (up) {
            this.up = up;
        }
    }

    /**
     * Init move up animation.
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} durationTime - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initMoveUpAnimation(navigation, durationTime) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: durationTime,
            valueSetter: function(value) {
                var position3d = navigation.ctx
                    .getCoordinateSystem()
                    .get3DFromWorld([value[0], value[1]]);
                navigation.center3d[0] = position3d[0];
                navigation.center3d[1] = position3d[1];
                navigation.center3d[2] = position3d[2];
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Init zoom animation
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} duration - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initZoomAnimation(navigation, duration) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: duration,
            valueSetter: function(value) {
                var position3d = navigation.ctx
                    .getCoordinateSystem()
                    .get3DFromWorld([value[0], value[1]]);
                navigation.center3d[0] = position3d[0];
                navigation.center3d[1] = position3d[1];
                navigation.center3d[2] = position3d[2];
                navigation.ctx.getRenderContext().setFov(value[2]);
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Adds two segments to the animation, which starts to startValue and stops to endValue
     * by crossing the middleFov at middle value of [startValue, endValue]
     * @param {AbstractAnimation} zoomToAnimation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} middleFov - FOV
     * @private
     */
    function _addZoomOutThenZoomIn(
        zoomToAnimation,
        startValue,
        endValue,
        middleFov
    ) {
        // Compute the middle value
        var midValue = [
            startValue[0] * 0.5 + endValue[0] * 0.5,
            startValue[1] * 0.5 + endValue[1] * 0.5,
            middleFov
        ];

        // zoom out to max altitude
        zoomToAnimation.addSegment(0.0, startValue, 0.5, midValue, function(
            t,
            a,
            b
        ) {
            var pt = Numeric.easeInQuad(t);
            var dt = Numeric.easeOutQuad(t);
            return [
                Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                Numeric.lerp(dt, a[2], b[2])
            ]; // distance
        });

        // zoom in
        _addZoomIn.call(this, zoomToAnimation, midValue, endValue, 0.5);
    }

    /**
     * Adds a segment to the animation, which starts to startValue and stops to endValue
     * @param {AbstractAnimation} animation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} [startParameter=0.0] - start parameter
     * @private
     */
    function _addZoomIn(animation, startValue, endValue, startParameter) {
        var parameter = startParameter ? startParameter : 0.0;
        animation.addSegment(parameter, startValue, 1.0, endValue, function(
            t,
            a,
            b
        ) {
            var pt = Numeric.easeOutQuad(t);
            var dt = Numeric.easeInQuad(t);
            return [
                Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                Numeric.lerp(dt, a[2], b[2])
            ]; // distance
        });
    }

    /**
     * Adds an event when the animation stops.
     * @param {AbstractAnimation} animation - animation where the event is added
     * @param {AbstractContext} ctx - context
     * @param {number} destDistance - Final zooming distance in meter
     * @param {Object} [options] - options
     * @param {Object} [options.callback] - Callback function to call when it is defined.
     * @fires Context#navigation:changedDistance
     * @private
     */
    function _addStop(animation, ctx, destDistance, options) {
        animation.onstop = function() {
            if (options && options.callback) {
                options.callback();
            }
            animation = null;
            ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
                destDistance
            );
        };
    }

    /**
     * Computes parameters for animation
     * @param {AbstractContext} ctx - context
     * @param {Array.<float>} center3D - start position in 3D
     * @param {Array.<float>} geoPos - stop position
     * @param {float} startFov - start FOV
     * @param {float} destFov - stop FOV
     * @return {Array.<float>} Returns [startValue, endValue]
     * @private
     */
    function _computeParametersAnimation(
        ctx,
        center3D,
        geoPos,
        startFov,
        destFov
    ) {
        var geoStart = [];
        ctx.getCoordinateSystem().getWorldFrom3D(center3D, geoStart);
        var path = Numeric.shortestPath360(geoStart[0], geoPos[0]);
        var startValue = [path[0], geoStart[1], startFov];
        var endValue = [path[1], geoPos[1], destFov];
        return [startValue, endValue];
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractNavigation, GroundNavigation);

    /**************************************************************************************************************/

    /**
     * Returns the center of the navigation.
     * @function getCenter
     * @memberof GroundNavigation#
     * @return {float[]}
     */
    GroundNavigation.prototype.getCenter = function() {
        var center = AbstractNavigation.prototype.getCenter.call(this);
        if (center == null) {
            center = [];
            this.ctx
                .getCoordinateSystem()
                .getWorldFrom3D(this.center3d, center);
        }
        return center;
    };

    /**
     * ZoomTo a 3D position
     * @function zoomTo
     * @param {float[]} geoPos - target of the camera
     * @param {Object} options - options
     * @param {float} [options.fov = DEFAULT_FINAL_FOV] - field of view in degree
     * @param {int} [options.duration = DEFAULT_DURATION_ZOOM] - duration of the animation in milliseconds
     * @param {navigationCallback} [options.callback] - Called at the end of navigation
     * @memberof GroundNavigation#
     */
    GroundNavigation.prototype.zoomTo = function(geoPos, options) {
        var navigation = this;

        // default values
        var destFov = options && options.fov ? options.fov : DEFAULT_FINAL_FOV;
        var duration =
            options && options.duration
                ? options.duration
                : DEFAULT_DURATION_ZOOM;

        // Create a single animation to animate center3d and fov
        var parameters = _computeParametersAnimation.call(
            this,
            this.ctx,
            this.center3d,
            geoPos,
            this.renderContext.getFov(),
            destFov
        );
        var startValue = parameters[0];
        var endValue = parameters[1];

        var zoomToAnimation = _initZoomAnimation.call(
            this,
            navigation,
            duration
        );

        // End point which is out of frustum invokes two steps animation, one step otherwise
        var end3DValue = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
        if (
            DEFAULT_MIDDLE_FOV > this.renderContext.getFov() &&
            this.renderContext
                .getWorldFrustum()
                .containsSphere(end3DValue, 0.005) < 0
        ) {
            // Two steps animation, 'rising' & 'falling'
            _addZoomOutThenZoomIn.call(
                this,
                zoomToAnimation,
                startValue,
                endValue,
                DEFAULT_MIDDLE_FOV
            );
        } else {
            // One step animation, 'falling' only
            _addZoomIn.call(this, zoomToAnimation, startValue, endValue);
        }

        _addStop.call(this, zoomToAnimation, this.ctx, destFov, options);

        this.ctx.addAnimation(zoomToAnimation);
        zoomToAnimation.start();
    };

    GroundNavigation.prototype.moveUpTo = function(vec, duration) {
        // Create a single animation to animate up
        var startValue = this.center3d;
        var endValue = DEFAULT_AZIMUTH_ZERO;
        var durationTime = duration || DEFAULT_DURATION_NORTH;

        var navigation = this;
        var moveUpToAnimation = _initMoveUpAnimation.call(
            this,
            navigation,
            durationTime
        );
        _addZoomIn.call(this, moveUpToAnimation, startValue, endValue);
        this.ctx.addAnimation(moveUpToAnimation);
        moveUpToAnimation.start();
    };

    /**
     * Compute the view matrix
     * @function computeViewMatrix
     * @memberof GroundNavigation#
     */
    GroundNavigation.prototype.computeViewMatrix = function() {
        var eye = [];
        vec3.normalize(this.center3d);

        var vm = this.renderContext.viewMatrix;

        mat4.lookAt([0.0, 0.0, 0.0], this.center3d, this.up, vm);

        var geo = [];
        this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, geo);
        this.heading = geo[0];
        this.up = [0, 0, vm[9]];
        this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
        this.renderContext.requestFrame();
    };

    /**************************************************************************************************************/

    /**
         Event handler for mouse wheel
         @function zoom
         @param delta Delta zoom
         @memberof GroundNavigation#
         */
    GroundNavigation.prototype.zoom = function(delta, scale) {
        // TODO : improve zoom, using scale or delta ? We should use scale always
        if (scale) {
            this.renderContext.setFov(
                (this.renderContext.getFov() * 1) / scale
            );
        } else {
            // Arbitrary value for smooth zooming
            this.renderContext.setFov(
                this.renderContext.getFov() * (1 + delta * 0.1)
            );
        }

        this._clampFov();
        this.computeViewMatrix();
    };

    /**************************************************************************************************************/

    /**
         Pan the navigation by computing the difference between 3D centers
         @function pan
         @param dx Window delta x
         @param dy Window delta y
         @memberof GroundNavigation#
         */
    GroundNavigation.prototype.pan = function(dx, dy) {
        var x = this.renderContext.canvas.width / 2.0;
        var y = this.renderContext.canvas.height / 2.0;
        var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);
        this.center3d = ray.computePoint(
            ray.sphereIntersect(
                [0, 0, 0],
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getRadius()
            )
        );
        this.computeViewMatrix();
    };

    /**************************************************************************************************************/

    /**
         Rotate the navigation
         @function rotate
         @param dx Window delta x
         @param dy Window delta y
         @memberof GroundNavigation#
         */
    GroundNavigation.prototype.rotate = function(dx, dy) {
        var angle = dx * DELTA_HEADING;
        var coord = [];
        this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, coord);
        this.heading += angle;
        coord[0] = this.heading;
        this.ctx.getCoordinateSystem().get3DFromWorld(coord, this.center3d);
        this.computeViewMatrix();
    };

    /**
         @function getHeading
         @memberof GroundNavigation#
         */
    GroundNavigation.prototype.getHeading = function() {
        return this.heading;
    };

    /**************************************************************************************************************/

    /**
     *    Clamping of fov
     */
    GroundNavigation.prototype._clampFov = function() {
        if (this.renderContext.getFov() > this.maxFov) {
            this.renderContext.setFov(this.maxFov);
        }
        if (this.renderContext.getFov() < this.minFov) {
            this.renderContext.setFov(this.minFov);
        }
    };

    /**************************************************************************************************************/

    return GroundNavigation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name NavigationFactory
 * @class
 * Factory to control the camera.
 * @memberof module:Navigation
 */
define('gw/Navigation/NavigationFactory',[
    "./PlanetNavigation",
    "./AstroNavigation",
    "./FlatNavigation",
    "./GroundNavigation",
    "../Utils/Constants"
], function(
    PlanetNavigation,
    AstroNavigation,
    FlatNavigation,
    GroundNavigation,
    Constants
) {
    return {
        /**
         * Mizar owns different types of navigation to control the camera on the WebGL scene.
         * This class allows to create a navigation based on its type (e.g Astro, Flat, Sky).
         * <table border="1">
         *     <tr>
         *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
         *         <td>{@link module:Navigation.AstroNavigation AstroNavigation}</td>
         *         <td>Provides a camera located at the center of the scene. The camera is inside the globe.
         *         It is used to view the sky</td>
         *     </tr>
         *     <tr>
         *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
         *         <td>{@link module:Navigation.PlanetNavigation PlanetNavigation}</td>
         *         <td>Provides a camera, located outside the globe and looking at the globe. It is used to view a planet</td>
         *     </tr>
         *     <tr>
         *         <td><img src="../doc/images/nav_flat.png" width="200px"/></td>
         *         <td>{@link module:Navigation.FlatNavigation FlatNavigation}</td>
         *         <td>Provides a camera to navigate on a 2D map - Only available in a Planet context</td>
         *     </tr>
         * </table>
         * @param {NAVIGATION} type - the type of navigation
         * @param {AbstractContext} ctx - The context where the camera look at
         * @param {AbstractNavigation.astro_configuration|AbstractNavigation.planet_configuration|AbstractNavigation.flat_configuration} options - see the navigations.
         * @return {Navigation} navigation
         * @alias module:Navigation.NavigationFactory.create
         * @see {@link module:Navigation.PlanetNavigation PlanetNavigation} - Control the camera and turn around the globe, wich is located
         * at the center of the webGL scene.
         * @see {@link module:Navigation.AstroNavigation AstroNavigation} - Control the camera at the center of the scene. The camera is inside the globe
         * @see {@link module:Navigation.FlatNavigation FlatNavigation} - Control the camera. The camera look at the 2D projection
         * @see {@link module:Navigation.GroundNavigation GroundNavigation} - Control the camera. The camera look at the 3D projection of the ground
         * @throws {RangeError} Type not valid - a valid type is included in the list {@link NAVIGATION}
         */
        create: function(type, ctx, options) {
            var obj;
            switch (type) {
            case Constants.NAVIGATION.AstroNavigation:
                obj = new AstroNavigation(ctx, options);
                break;
            case Constants.NAVIGATION.PlanetNavigation:
                obj = new PlanetNavigation(ctx, options);
                break;
            case Constants.NAVIGATION.FlatNavigation:
                obj = new FlatNavigation(ctx, options);
                break;
            case Constants.NAVIGATION.GroundNavigation:
                obj = new GroundNavigation(ctx, options);
                break;
            default:
                throw new RangeError(
                    "The type " +
                            type +
                            " is not allowed, A valid type is included in the list NAVIGATION",
                    "NavigationFactory.js"
                );
            }
            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * globalTime:set.<br/>
 * Called when the time is set
 * @event Context#globalTime:set
 * @type {Context}
 */

/**
 * globalTime:rewind.<br/>
 * Called when the time is set to rewind
 * @event Context#globalTime:rewind
 * @type {Context}
 */

/**
 * globalTime:forward.<br/>
 * Called when the time is set to forward
 * @event Context#globalTime:forward
 * @type {Context}
 */

/**
 * Compass module : map control with "north" composant
 */
define('gw/Gui/TimeTravel',["jquery", "../Utils/Constants", "../Services/TimeTravelCore"], function(
    $,
    Constants,
    TimeTravelCore
) {
    /**
     *    Private variables
     */
    var parentElement = null;
    var ctx = null;
    var svgDoc;

    const REWIND_SVG =
        "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTExIDE4VjZsLTguNSA2IDguNSA2em0uNS02bDguNSA2VjZsLTguNSA2eiIvPiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PC9zdmc+";
    const FORWARD_SVG =
        "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTQgMThsOC41LTZMNCA2djEyem05LTEydjEybDguNS02TDEzIDZ6Ii8+ICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=";
    const HOUR_GLASS_SVG =
        "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTYgMnY2aC4wMUw2IDguMDEgMTAgMTJsLTQgNCAuMDEuMDFINlYyMmgxMnYtNS45OWgtLjAxTDE4IDE2bC00LTQgNC0zLjk5LS4wMS0uMDFIMThWMkg2em0xMCAxNC41VjIwSDh2LTMuNWw0LTQgNCA0em0tNC01bC00LTRWNGg4djMuNWwtNCA0eiIvPiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDBWMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=";

    /**
     * Create a time travel Widget
     * @param options
     * @throws {ReferenceError} Can't get the Div to insert the time tracker
     * @throws {ReferenceError} Can't get the element name
     * @constructor
     * @fires Context#globalTime:set
     * @fires Context#globalTime:rewind
     * @fires Context#globalTime:forward
     */
    var TimeTravel = function(options) {
        parentElement = options.element;
        ctx = options.ctx;

        // Add compass object to parent element
        // Don't use <object> HTML tag due to cross-origin nature of svg
        if (parentElement == null) {
            throw new ReferenceError(
                "Can't get the element name from the options parameters"
            );
        } else if (document.getElementById(options.element) == null) {
            throw new ReferenceError(
                "Can' get the div " +
                    parentElement +
                    " in the web page to insert " +
                    this.constructor.name
            );
        } else {
            // OK
        }

        var svgRewindDoc = null;
        var svgForwardDoc = null;
        var svgHourGlassDoc = null;

        document.getElementById(parentElement).innerHTML =
            "<div id=\"objectForward\"></div><div id=\"objectHourGlass\"></div><div id=\"objectRewind\"></div>";

        var _handleMouseUp = function(name) {
            ctx.publish(name, ctx);
        };

        var _handleMouseUpSet = function(event) {
            _handleMouseUp(Constants.EVENT_MSG.GLOBAL_TIME_SET);
        };

        var _handleMouseUpForward = function(event) {
            _handleMouseUp(Constants.EVENT_MSG.GLOBAL_TIME_FORWARD);
        };

        var _handleMouseUpRewind = function(event) {
            _handleMouseUp(Constants.EVENT_MSG.GLOBAL_TIME_REWIND);
        };

        ctx.subscribe(
            Constants.EVENT_MSG.GLOBAL_TIME_CHANGED,
            this.updateDisplayDate
        );

        TimeTravelCore.init(options);

        $.get(
            HOUR_GLASS_SVG,
            function(response) {
                // Import contents of the svg document into this document
                svgHourGlassDoc = document.importNode(
                    response.documentElement,
                    true
                );

                // Update width/height
                svgHourGlassDoc.height.baseVal.value = 32;
                svgHourGlassDoc.width.baseVal.value = 32;

                // Append the imported SVG root element to the appropriate HTML element
                $("#objectHourGlass").append(svgHourGlassDoc);

                options.svgHourGlassDoc = svgHourGlassDoc;
                $("#objectHourGlass svg").css({
                    float: "right",
                    fill:
                        TimeTravelCore.isCurrentDateTheFirst() &&
                        TimeTravelCore.isCurrentDateTheLast()
                            ? "#333333"
                            : "white"
                });

                svgHourGlassDoc.addEventListener("mouseup", _handleMouseUpSet);

                if (svgRewindDoc && svgForwardDoc && svgHourGlassDoc) {
                    $("#" + parentElement).css("display", "block");
                }
            },
            "xml"
        );
        $.get(
            REWIND_SVG,
            function(response) {
                // Import contents of the svg document into this document
                svgRewindDoc = document.importNode(
                    response.documentElement,
                    true
                );

                // Update width/height
                svgRewindDoc.height.baseVal.value = 32;
                svgRewindDoc.width.baseVal.value = 32;

                // Append the imported SVG root element to the appropriate HTML element
                $("#objectRewind").append(svgRewindDoc);
                $("#objectRewind svg").css({
                    float: "right",
                    fill: TimeTravelCore.isCurrentDateTheFirst()
                        ? "#333333"
                        : "white"
                });

                options.svgRewindDoc = svgRewindDoc;
                svgRewindDoc.addEventListener("mouseup", _handleMouseUpRewind);

                if (svgRewindDoc && svgForwardDoc && svgHourGlassDoc) {
                    $("#" + parentElement).css("display", "block");
                }
            },
            "xml"
        );
        $.get(
            FORWARD_SVG,
            function(response) {
                // Import contents of the svg document into this document
                svgForwardDoc = document.importNode(
                    response.documentElement,
                    true
                );

                // Update width/height
                svgForwardDoc.height.baseVal.value = 32;
                svgForwardDoc.width.baseVal.value = 32;

                // Append the imported SVG root element to the appropriate HTML element
                $("#objectForward").append(svgForwardDoc);
                $("#objectForward svg").css({
                    float: "right",
                    fill: TimeTravelCore.isCurrentDateTheLast()
                        ? "#333333"
                        : "white"
                });

                options.svgForwardDoc = svgForwardDoc;
                svgForwardDoc.addEventListener(
                    "mouseup",
                    _handleMouseUpForward
                );

                if (svgRewindDoc && svgForwardDoc && svgHourGlassDoc) {
                    $("#" + parentElement).css("display", "block");
                }
            },
            "xml"
        );
    };

    /**************************************************************************************************************/

    /**
     * Update display date and send current date to context
     * @function updateDisplayDate
     * @param {Time.configuration} date Time configuration
     * @memberof TimeTravel#
     */
    TimeTravel.prototype.updateDisplayDate = function(date) {
        if (document.getElementById("textTimeTravelDiv") !== null) {
            if (
                TimeTravelCore.isCurrentDateTheFirst() &&
                TimeTravelCore.isCurrentDateTheLast()
            ) {
                document.getElementById("textTimeTravelDiv").innerHTML = "";
            } else {
                document.getElementById("textTimeTravelDiv").innerHTML =
                    date.display;
            }
        }

        ctx.setTime(date);

        var theColorRewind =
            $("#objectRewind:hover svg").css("fill") === "rgb(255, 0, 0)"
                ? "red"
                : "white";
        var theColorForward =
            $("#objectForward:hover svg").css("fill") === "rgb(255, 0, 0)"
                ? "red"
                : "white";

        $("#objectRewind svg").css({
            float: "right",
            fill: TimeTravelCore.isCurrentDateTheFirst()
                ? "#333333"
                : theColorRewind
        });
        $("#objectForward svg").css({
            float: "right",
            fill: TimeTravelCore.isCurrentDateTheLast()
                ? "#333333"
                : theColorForward
        });
        $("#objectHourGlass svg").css({
            float: "right",
            fill:
                TimeTravelCore.isCurrentDateTheFirst() &&
                TimeTravelCore.isCurrentDateTheLast()
                    ? "#333333"
                    : "white"
        });

        $("#objectRewind svg")
            .mouseover(function() {
                if (TimeTravelCore.isCurrentDateTheFirst()) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "red");
                }
            })
            .mouseout(function() {
                if (TimeTravelCore.isCurrentDateTheFirst()) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "white");
                }
            });

        $("#objectForward svg")
            .mouseover(function() {
                if (TimeTravelCore.isCurrentDateTheLast()) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "red");
                }
            })
            .mouseout(function() {
                if (TimeTravelCore.isCurrentDateTheLast()) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "white");
                }
            });

        $("#objectHourGlass svg")
            .mouseover(function() {
                if (
                    TimeTravelCore.isCurrentDateTheFirst() &&
                    TimeTravelCore.isCurrentDateTheLast()
                ) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "red");
                }
            })
            .mouseout(function() {
                if (
                    TimeTravelCore.isCurrentDateTheFirst() &&
                    TimeTravelCore.isCurrentDateTheLast()
                ) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "white");
                }
            });
    };

    /**
     *    functions
     */
    TimeTravel.prototype.remove = TimeTravelCore.remove;
    TimeTravel.prototype.goRewind = TimeTravelCore.goRewind;
    TimeTravel.prototype.goForward = TimeTravelCore.goForward;
    TimeTravel.prototype.chooseTime = TimeTravelCore.chooseTime;

    /**************************************************************************************************************/

    return TimeTravel;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * Mizar is able to handle different types of context.
 * <p>
 * A context is a concept that brings together :
 * <ul>
 *     <li>a webGL {@link AbstractGlobe globe}</li>
 *     <li>a {@link AbstractCrs coordinate reference system}</li>
 *     <li>a {@link AbstractNavigation navigation}</li>
 * </ul>
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
 *         <td>{@link module:Context.SkyContext SkyContext}</td>
 *         <td>A context representing a sky</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
 *         <td>{@link module:Context.PlanetContext PlanetContext}</td>
 *         <td>A context representing a planet</td>
 *     </tr>
 *     <tr>
 *         <td></td>
 *         <td>{@link module:Context.GroundContext GroundContext}</td>
 *         <td>A context representing a planet's ground</td>
 *     </tr>
 * </table>
 *
 * The context is automatically instantiated by the method createContext from {@link Mizar}.
 * <br/>
 * In addition to the classes, a {@link module:Context.ContextFactory factory} and a {@link ContextManager context manager}
 * are availables to help for creating context. Once the context is created, the client can handle it by the use of its
 * {@link Context interface}.
 *
 * @module Context
 * @implements {Context}
 */
define('gw/Context/PlanetContext',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractContext",
    "../Utils/Constants",
    "../Globe/GlobeFactory",
    "../Navigation/NavigationFactory",
    "../Services/ServiceFactory",
    "../Gui/Compass",
    "../Gui/TimeTravel",
    "../Gui/dialog/ErrorDialog"
], function(
    $,
    _,
    Utils,
    AbstractContext,
    Constants,
    GlobeFactory,
    NavigationFactory,
    ServiceFactory,
    Compass,
    TimeTravel,
    ErrorDialog
) {
    /**
     * Planet context configuration
     * @typedef {Object} AbstractContext.planetContext
     * @property {float} [tileErrorTreshold=3]
     * @property {float} [continuousRendering=false]
     * @property {RenderContext} [renderContext] - Context rendering
     * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
     * @property {AbstractNavigation.planet_configuration|AbstractNavigation.flat_configuration} navigation - navigation configuration
     */

    /**
     * @name PlanetContext
     * @class
     * Virtual globe where the camera is outside the globe.
     * When an error happens at the initialisation, a message is displayed
     * @augments AbstractContext
     * @param {Mizar.configuration} mizarConfiguration - mizar configuration
     * @param {AbstractContext.planetContext} options - planet context configuration
     * @constructor
     * @memberof module:Context
     */
    var PlanetContext = function(mizarConfiguration, options) {
        AbstractContext.prototype.constructor.call(
            this,
            mizarConfiguration,
            Constants.CONTEXT.Planet,
            options
        );
        var self = this;
        this.components = {
            posTrackerInfo: true,
            posTracker: true,
            elevTracker: true,
            compassDiv: true,
            timeTravelDiv: true
        };

        var planetOptions = _createPlanetConfiguration.call(this, options);

        // Initialize planet
        try {
            this.globe = GlobeFactory.create(
                Constants.GLOBE.Planet,
                planetOptions
            );
            this.navigation = _createNavigation.call(
                this,
                this.getCoordinateSystem().isFlat(),
                options.navigation
            );
            this.initGlobeEvents(this.globe);

            ServiceFactory.create(Constants.SERVICE.PickingManager).init(this);

            try {
                this.setTimeTravelVisible(
                    mizarConfiguration.timeTravel &&
                    mizarConfiguration.timeTravel.element
                        ? mizarConfiguration.timeTravel.element
                        : "timeTravelDiv",
                    true
                );
            } catch (err) {
                ErrorDialog.open(
                    Constants.LEVEL.DEBUG,
                    "Cannot create the Time travel",
                    err
                );
            }
        } catch (err) {
            this._showUpError(err);
        }
    };

    /**
     * Planet configuration data model
     * @typedef {Object} AbstractGlobe.dm_planet
     * @property {Object} canvas - canvas object
     * @property {int} tileErrorTreshold - tile error treshold
     * @property {boolean} continuousRendering - continuous rendering
     * @property {renderContext|null} renderContext - Rendering context
     * @property {AbstractCrs.crsFactory} coordinateSystem - Coordinate reference system of the planet
     * @property {string} shadersPath = "../../shaders/" - Shaders location
     * @property {boolean} lighting = false - Lighting
     * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
     * @property {int} minFar = 0
     * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
     * @property {boolean} renderTileWithoutTexture = true
     * @property {function} publishEvent - Callback
     */

    /**
     * Create the navigation according to the isFlat parameter.
     * @param {boolean} isFlat - The globe is projected or in 3D
     * @param {AbstractNavigation.planet_configuration|AbstractNavigation.flat_configuration} navigationOpts - Options for navigation
     * @returns {FlatNavigation|PlanetNavigation} navigation
     * @private
     */
    function _createNavigation(isFlat, navigationOpts) {
        var navigationType;
        if (isFlat) {
            navigationType = Constants.NAVIGATION.FlatNavigation;
        } else {
            navigationType = Constants.NAVIGATION.PlanetNavigation;
        }

        return NavigationFactory.create(navigationType, this, navigationOpts);
    }

    /**
     * Creates planet configuration
     * @param {Object} options
     * @param {int} [options.tileErrorTreshold = 3] - Tile error treshold
     * @param {boolean} [options.continuousRendering = false] - continuous rendering
     * @param {renderContext} [options.renderContext] - Rendering context
     * @param {Crs} options.coordinateSystem - Coordinate reference system of the planet
     * @returns {AbstractGlobe.dm_planet} Planet data model.
     * @private
     */
    function _createPlanetConfiguration(options) {
        var self = this;
        return {
            tileErrorTreshold: options.tileErrorTreshold || 3,
            continuousRendering: options.continuousRendering || false,
            renderContext: options.renderContext,
            canvas: this.canvas,
            isMobile: options.isMobile || false,
            coordinateSystem: options.coordinateSystem,
            shadersPath: this.mizarConfiguration.mizarAPIUrl + "shaders/",
            lighting: false,
            backgroundColor: [0.0, 0.0, 0.0, 1.0],
            minFar: 0,
            defaultColor: [200, 200, 200, 255],
            renderTileWithoutTexture: true,
            //todofl : redondance car params identiques
            publishEvent: function(message, object) {
                self.publish(message, object);
            }
        };
    }

    /**
     * Computes GeoCenter according to the coordinate reference system.
     * @param {Crs} crs - coordinate reference system
     * @returns {float[]} geocenter
     * @private
     */
    function _computeGeoCenter(crs) {
        var geoCenter;
        if (crs.isFlat()) {
            geoCenter = crs.getWorldFrom3D(this.navigation.center);
        } else {
            geoCenter = this.navigation.geoCenter;
        }
        return geoCenter;
    }

    /**
     * Propagates navigation options (inertia and mouse) when the coordinate reference system changes.
     * @param {AbstractNavigation.configuration} options - Navigation configuration
     * @private
     * @returns {Object} navigation options
     */
    function _propagateNavOptions(options) {
        var navOptions = {};
        navOptions.inertia = options.hasOwnProperty("inertia")
            ? options.inertia
            : false;
        if (options.hasOwnProperty("mouse")) {
            navOptions.mouse = options.mouse;
        }
        return navOptions;
    }

    /**
     * Updates the navigation according to the new coordinate reference system and the current settings
     * of the previous coordinate reference system
     * @param {Crs} newCrs -  the new coordinate reference system
     * @param {float[]} geoCenter - Current geo center of the camera in the previous coordinate reference system
     * @param {float} geoDistance - Distance from the globe's surface of the camera in the previous coordinate reference system
     * @param {Object} navOptions - Navigation's options
     * @param {boolean} [navOptions.inertia=false] - Inertia
     * @param {Object} [navOptions.mouse] - Mouse's configuration
     * @private
     */
    function _updateNavForNewCrs(newCrs, geoCenter, geoDistance, navOptions) {
        if (newCrs.isFlat()) {
            this.navigation = NavigationFactory.create(
                Constants.NAVIGATION.FlatNavigation,
                this,
                navOptions
            );
            this.navigation.center = newCrs.get3DFromWorld(geoCenter);
        } else {
            this.navigation = NavigationFactory.create(
                Constants.NAVIGATION.PlanetNavigation,
                this,
                navOptions
            );
            this.navigation.geoCenter = geoCenter;
        }
        this.navigation.distance =
            geoDistance * newCrs.getGeoide().getHeightScale();
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractContext, PlanetContext);

    /**************************************************************************************************************/

    /**
     * @function setTimeTravelVisible
     * @memberof PlanetContext#
     */
    PlanetContext.prototype.setTimeTravelVisible = function(divName, visible) {
        if (visible) {
            this.timeTravel = new TimeTravel({
                element: divName,
                ctx: this,
                crs: this.getCoordinateSystem().getGeoideName()
            });
        } else {
            if (this.timeTravel) {
                this.timeTravel.remove();
            }
        }
        this.setComponentVisibility(divName, visible);
    };

    /**
     * @function setBaseElevation
     * @memberof PlanetContext#
     * @throws {TypeError} The provided error is not a WCSElevation or a WMSElevation
     */
    PlanetContext.prototype.setBaseElevation = function(layer) {
        if (
            layer.getType() !== Constants.LAYER.WCSElevation &&
            layer.getType() !== Constants.LAYER.WMSElevation
        ) {
            throw new TypeError(
                "The provided layer ID=" +
                    layer.getID() +
                    " has a type +" +
                    layer.getType() +
                    " instead of WCSElevation or WMSElevation",
                "PlanetContext.js"
            );
        }
        this.globe.setBaseElevation(layer);
        if (this.elevationTracker != null) {
            this.elevationTracker.setScaleLayer(layer);
        }
    };

    /**
     * @function setBaseElevationByID
     * @memberof PlanetContext#
     */
    PlanetContext.prototype.setBaseElevationByID = function(layerID) {
        // Find the layer by name among all the layers
        var layer = this.getLayerByID(layerID);
        if (layer) {
            this.setBaseElevation(layer);
        }
        return layer;
    };

    /**
     * @function getBaseElevation
     * @memberof PlanetContext#
     */
    PlanetContext.prototype.getBaseElevation = function() {
        return this.globe.getBaseElevation();
    };

    /**
     * @function setCoordinateSystem
     * @memberof PlanetContext#
     */
    PlanetContext.prototype.setCoordinateSystem = function(newCrs) {
        if (newCrs.getType() !== this.getMode()) {
            throw new RangeError(
                "incompatible coordinate reference system with Planet context",
                "PlanetContext.js"
            );
        }
        // Change navigation
        var geoCenter;
        var geoDistance;

        var self = this;
        $(self.canvas.parentElement)
            .find("#loading")
            .show();

        // Compute current position and distance in order to set them in the new navigation related to the
        // new coordinate reference system
        geoCenter = _computeGeoCenter.call(
            this,
            this.globe.getCoordinateSystem()
        );
        geoDistance =
            this.navigation.distance /
            this.globe
                .getCoordinateSystem()
                .getGeoide()
                .getHeightScale();

        // Update the coordinate reference system
        this.globe.setCoordinateSystem(newCrs);
        this.navigation.stop();

        // Creates the options for the new navigation related to the new coordinate reference system.
        // We only keep the inertia and the options for the mouse
        var navOptions = _propagateNavOptions.call(
            this,
            this.navigation.getOptions()
        );

        try {
            // Create a new navigation related to the new coordinate reference system
            _updateNavForNewCrs.call(
                this,
                newCrs,
                geoCenter,
                geoDistance,
                navOptions
            );
        } catch (err) {
            this._showUpError(err);
        }

        if (this.positionTracker) {
            this.positionTracker.detach();
            this.positionTracker.attachTo(this);
        }

        if (this.elevationTracker) {
            this.elevationTracker.detach();
            this.elevationTracker.attachTo(this);
        }

        this.navigation.computeViewMatrix();
        this.publish(Constants.EVENT_MSG.CRS_MODIFIED, this);
    };

    /**
     * @function destroy
     * @memberof PlanetContext#
     */
    PlanetContext.prototype.destroy = function() {
        //this.setTimeTravelVisible(false);
        AbstractContext.prototype.destroy.call(this);
    };

    /**************************************************************************************************************/
    return PlanetContext;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Context/SkyContext',[
    "underscore-min",
    "../Utils/Utils",
    "./AbstractContext",
    "../Globe/GlobeFactory",
    "../Navigation/NavigationFactory",
    "../Services/ServiceFactory",
    "../Gui/TimeTravel",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function(
    _,
    Utils,
    AbstractContext,
    GlobeFactory,
    NavigationFactory,
    ServiceFactory,
    TimeTravel,
    Constants,
    ErrorDialog
) {
    /**
     * sky context configuration
     * @typedef {Object} AbstractContext.skyContext
     * @property {float} [tileErrorTreshold=1.5]
     * @property {float} [continuousRendering=true]
     * @property {float} [radius = 10.0] - Vector distance of the sky
     * @property {int} [minFar = 15]
     * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
     * @property {RenderContext} [renderContext] - Context rendering
     * @property {AbstractNavigation.astro_configuration} navigation - navigation configuration
     * @property {string} [compass="compassDiv"] - div element where compass is displayed
     * @property {string} [timeTravel="timeTravelDiv"] - div element where time travel is displayed
     */

    /**
     * @name SkyContext
     * @class
     * Virtual globe where the camera is inside the globe.<br/>
     * When an error happens at the initialisation, a message is displayed
     * @augments AbstractContext
     * @param {Mizar.configuration} mizarConfiguration - mizar configuration
     * @param {AbstractContext.skyContext} options - skyContext configuration
     * @constructor
     * @memberof module:Context
     */
    var SkyContext = function(mizarConfiguration, options) {
        AbstractContext.prototype.constructor.call(
            this,
            mizarConfiguration,
            Constants.CONTEXT.Sky,
            options
        );

        var self = this;
        this.components = {
            posTrackerInfo: true,
            posTracker: true,
            elevTracker: false,
            compassDiv: true,
            timeTravelDiv: true
        };
        var skyOptions = _createSkyConfiguration.call(this, options);

        // Initialize sky
        try {
            // Create the sky
            this.globe = GlobeFactory.create(Constants.GLOBE.Sky, skyOptions);
            this.navigation = NavigationFactory.create(
                Constants.NAVIGATION.AstroNavigation,
                this,
                options.navigation ? options.navigation : options
            );
            this.initGlobeEvents(this.globe);

            ServiceFactory.create(Constants.SERVICE.PickingManager).init(this);

            try {
                this.setTimeTravelVisible(
                    mizarConfiguration.timeTravel &&
                    mizarConfiguration.timeTravel.element
                        ? mizarConfiguration.timeTravel.element
                        : "timeTravelDiv",
                    true
                );
            } catch (err) {
                ErrorDialog.open(
                    Constants.LEVEL.DEBUG,
                    "Cannot create the Time travel",
                    err
                );
            }
        } catch (err) {
            this._showUpError(err);
        }
    };

    /**
     * Planet configuration data model
     * @typedef {Object} AbstractGlobe.dm_sky
     * @property {Object} canvas - canvas object
     * @property {int} tileErrorTreshold - tile error treshold
     * @property {boolean} continuousRendering - continuous rendering
     * @property {renderContext} [renderContext] - Rendering context
     * @property {Crs} coordinateSystem - Coordinate reference system of the planet
     * @property {boolean} lighting = false - Lighting
     * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
     * @property {int} minFar
     * @property {float} radius
     * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
     * @property {string} shadersPath = "../../shaders/" - Shaders location
     * @property {boolean} renderTileWithoutTexture = false
     * @property {function} publishEvent - Callback
     */

    /**
     * Creates planet configuration
     * @param {Object} options
     * @param {int} [options.tileErrorTreshold = 1.5] - Tile error treshold
     * @param {boolean} [options.continuousRendering = true] - continuous rendering
     * @param {renderContext} [options.renderContext] - Rendering context
     * @param {AbstractCrs.crsFactory} options.coordinateSystem - Coordinate reference system of the planet
     * @param {float} [options.radius = 10.0] - Radius object in vector length
     * @returns {AbstractGlobe.dm_sky} Planet data model.
     * @private
     */
    function _createSkyConfiguration(options) {
        var self = this;
        var skyOptions = {
            canvas: this.canvas,
            tileErrorTreshold: options.tileErrorTreshold || 1.5,
            continuousRendering: options.continuousRendering || true,
            renderTileWithoutTexture: false,
            radius: options.radius || 10.0,
            minFar: options.minFar || 15, // Fix problem with far buffer, with planet rendering
            coordinateSystem: options.coordinateSystem,
            lighting: false,
            backgroundColor: [0.0, 0.0, 0.0, 1.0],
            defaultColor: [200, 200, 200, 255],
            shadersPath: this.mizarConfiguration.mizarAPIUrl + "shaders/",
            publishEvent: function(message, object) {
                self.publish(message, object);
            }
        };
        if (options.renderContext) {
            skyOptions.renderContext = options.renderContext;
        }
        return skyOptions;
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractContext, SkyContext);

    /**************************************************************************************************************/

    /**
     * @function setTimeTravelVisible
     * @memberof SkyContext#
     */
    SkyContext.prototype.setTimeTravelVisible = function(divName, visible) {
        if (visible) {
            this.timeTravel = new TimeTravel({
                element: divName,
                ctx: this,
                crs: Constants.CRS.Equatorial
            });
        } else {
            if (this.timeTravel) {
                this.timeTravel.remove();
            }
        }
        this.setComponentVisibility(divName, visible);
    };

    /**
     * @function setCoordinateSystem
     * @memberof SkyContext#
     * @throws ReferenceError - incompatible coordinate reference system with Sky context
     */
    SkyContext.prototype.setCoordinateSystem = function(cs) {
        if (cs.getType() !== this.getMode()) {
            throw new ReferenceError(
                "incompatible coordinate reference system with Sky context",
                "SkyContex.js"
            );
        }
        this.globe.setCoordinateSystem(cs);
        this.publish(Constants.EVENT_MSG.CRS_MODIFIED, this);
    };

    /**
     * @function destroy
     * @memberof SkyContext#
     */
    SkyContext.prototype.destroy = function() {
        //this.setTimeTravelVisible(false);
        if (this.timeTravel) {
            this.timeTravel.remove();
        }
        AbstractContext.prototype.destroy.call(this);
    };

    /**************************************************************************************************************/

    return SkyContext;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/Context/GroundContext',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractContext",
    "../Utils/Constants",
    "../Globe/GlobeFactory",
    "../Navigation/NavigationFactory",
    "../Services/ServiceFactory",
    "../Gui/TimeTravel",
    "../Gui/dialog/ErrorDialog"
], function(
    $,
    _,
    Utils,
    AbstractContext,
    Constants,
    GlobeFactory,
    NavigationFactory,
    ServiceFactory,
    TimeTravel,
    ErrorDialog
) {
    /**
     * ground context configuration
     * @typedef {Object} AbstractContext.groundContext
     * @property {float} [tileErrorTreshold=1.5]
     * @property {float} [continuousRendering=true]
     * @property {float} [radius = 10.0] - Vector distance of the sky
     * @property {int} [minFar = 15]
     * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
     * @property {RenderContext} [renderContext] - Context rendering
     * @property {AbstractNavigation.astro_configuration} navigation - navigation configuration
     * @property {string} [compass="compassDiv"] - div element where compass is displayed
     * @property {string} [timeTravel="timeTravelDiv"] - div element where time travel is displayed
     */

    /**
     * @name GroundContext
     * @class
     * Virtual globe where the camera is inside the globe and having the horizontal coordinate as .<br/>
     * When an error happens at the initialisation, a message is displayed
     * @augments AbstractContext
     * @param {Mizar.configuration} mizarConfiguration - mizar configuration
     * @param {AbstractContext.skyContext} options - skyContext configuration
     * @constructor
     * @memberof module:Context
     */
    var GroundContext = function(mizarConfiguration, options) {
        AbstractContext.prototype.constructor.call(
            this,
            mizarConfiguration,
            Constants.CONTEXT.Ground,
            options
        );
        var self = this;

        this.components = {
            posTrackerInfo: false,
            posTracker: false,
            elevTracker: false,
            compassDiv: false,
            timeTravelDiv: false
        };

        var groundOptions = _createGroundConfiguration.call(this, options);

        // Initialize sky
        try {
            // Create the sky
            this.globe = GlobeFactory.create(
                Constants.GLOBE.Sky,
                groundOptions
            );
            // create the navigation
            this.navigation = NavigationFactory.create(
                Constants.NAVIGATION.GroundNavigation,
                this,
                options.navigation ? options.navigation : options
            );
            // init the globe
            this.initGlobeEvents(this.globe);
            // adding picking manager
            ServiceFactory.create(Constants.SERVICE.PickingManager).init(this);
            try {
                this.setTimeTravelVisible(
                    mizarConfiguration.timeTravel &&
                    mizarConfiguration.timeTravel.element
                        ? mizarConfiguration.timeTravel.element
                        : "timeTravelDiv",
                    true
                );
            } catch (err) {
                ErrorDialog.open(
                    Constants.LEVEL.DEBUG,
                    "Cannot create the Time travel",
                    err
                );
            }
        } catch (err) {
            this._showUpError(err);
        }
    };

    /**
     * Ground configuration data model
     * @typedef {Object} AbstractGlobe.dm_ground
     * @property {Object} canvas - canvas object
     * @property {int} tileErrorTreshold - tile error treshold
     * @property {boolean} continuousRendering - continuous rendering
     * @property {renderContext} [renderContext] - Rendering context
     * @property {Crs} coordinateSystem - Coordinate reference system of the planet
     * @property {boolean} lighting = false - Lighting
     * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
     * @property {int} minFar
     * @property {float} radius
     * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
     * @property {string} shadersPath = "../../shaders/" - Shaders location
     * @property {boolean} renderTileWithoutTexture = false
     * @property {function} publishEvent - Callback
     */

    /**
     * Creates planet configuration
     * @param {Object} options
     * @param {int} [options.tileErrorTreshold = 3] - Tile error treshold
     * @param {boolean} [options.continuousRendering = false] - continuous rendering
     * @param {renderContext} [options.renderContext] - Rendering context
     * @param {Crs} options.coordinateSystem - Coordinate reference system of the planet' ground
     * @param {float} [options.radius = 10.0] - Radius object in vector length
     * @returns {AbstractGlobe.dm_ground} Ground data model.
     * @private
     */
    function _createGroundConfiguration(options) {
        var self = this;
        return {
            tileErrorTreshold: options.tileErrorTreshold || 3,
            continuousRendering: options.continuousRendering || false,
            renderContext: options.renderContext,
            canvas: this.canvas,
            coordinateSystem: options.coordinateSystem,
            shadersPath: this.mizarConfiguration.mizarAPIUrl + "shaders/",
            lighting: false,
            backgroundColor: [0.0, 0.0, 0.0, 1.0],
            minFar: 0,
            defaultColor: [200, 200, 200, 255],
            renderTileWithoutTexture: true,
            publishEvent: function(message, object) {
                self.publish(message, object);
            }
        };
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractContext, GroundContext);

    /**************************************************************************************************************/

    /**
     * @function setTimeTravelVisible
     * @memberof GroundContext#
     */
    GroundContext.prototype.setTimeTravelVisible = function(divName, visible) {
        if (visible) {
            this.timeTravel = new TimeTravel({
                element: divName,
                ctx: this,
                crs: this.getCoordinateSystem().getGeoideName()
            });
        } else {
            if (this.timeTravel) {
                this.timeTravel.remove();
            }
        }
        this.setComponentVisibility(divName, visible);
    };

    /**
     * @function setCoordinateSystem
     * @memberof GroundContext#
     * @throws RangeError - "incompatible coordinate reference system with Sky context"
     */
    GroundContext.prototype.setCoordinateSystem = function(cs) {
        if (cs.getType() !== this.getMode()) {
            throw new RangeError(
                "incompatible coordinate reference system with Sky context",
                "GroundContext.js"
            );
        }
        this.globe.setCoordinateSystem(cs);
        this.publish(Constants.EVENT_MSG.CRS_MODIFIED, this);
    };

    /**
     * @function destroy
     * @memberof GroundContext#
     */
    GroundContext.prototype.destroy = function() {
        //this.setTimeTravelVisible(false);
        if (this.timeTravel) {
            this.timeTravel.remove();
        }
        AbstractContext.prototype.destroy.call(this);
    };

    /**************************************************************************************************************/

    return GroundContext;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name ContextFactory
 * @class
 * Factory to create a context
 * @memberof module:Context
 */
define('gw/Context/ContextFactory',[
    "../Utils/Constants",
    "./PlanetContext",
    "./SkyContext",
    "./GroundContext"
], function(Constants, PlanetContext, SkyContext, GroundContext) {
    return {
        /**
         * Factory to create a context.
         *
         * Creates a context based on :
         * <ul>
         *     <li>the context type {@link CONTEXT},</li>
         *     <li>the global Mizar's configuration,</li>
         *     <li>the options for the specific context</li>
         * </ul>
         * @param {CONTEXT} type - Type of animation.
         * @param {Object} configuration - see options.configuration for {@link Mizar}
         * @param {Object} options - See options.planetContext or options.skyContext configuration for {@link Mizar}
         * @return {Context} - the object to handle an animation
         * @throws {RangeError} Type not valid - a valid type is included in the list {@link CONTEXT}
         * @alias module:Context.ContextFactory.create
         *
         */
        create: function(type, configuration, options) {
            var obj;
            switch (type) {
            case Constants.CONTEXT.Planet:
                obj = new PlanetContext(configuration, options);
                break;
            case Constants.CONTEXT.Sky:
                obj = new SkyContext(configuration, options);
                break;
            case Constants.CONTEXT.Ground:
                obj = new GroundContext(configuration, options);
                break;
            default:
                throw new RangeError(
                    "The type " +
                            type +
                            " is not allowed, A valid type is included in the list Constants.CONTEXT",
                    "ContextFactory.js"
                );
            }
            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Provider/ConstellationProvider',[
    "jquery",
    "./AbstractProvider",
    "../Renderer/FeatureStyle",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function($, AbstractProvider, FeatureStyle, Utils, Constants, ErrorDialog) {
    /**************************************************************************************************************/

    var namesFile;
    var catalogueFile;

    var constellations = {};
    var self;

    /**
     *    Extract information in "constellation" variables
     */
    function extractDatabase(mizarLayer) {
        var constellationNamesTab = namesFile.split("\n");
        var catalogueTab = catalogueFile.split("\n");

        // For each constellation point
        for (var i = 0; i < catalogueTab.length; i++) {
            var word = catalogueTab[i].replace("  ", " ");
            word = word.split(" "); // word = "RA Decl Abbreviation "I"/"O"(Inerpolated/Original(Corner))"
            var RA = parseFloat(word[0]);
            var Decl = parseFloat(word[1]);
            var currentAbb = word[2];
            var IO = word[3];

            // Convert hours to degrees
            RA *= 15;

            // If abbreviation doesn't exist
            if (!constellations[currentAbb]) {
                // Find constellation name
                for (var j = 0; j < constellationNamesTab.length; j++) {
                    word = constellationNamesTab[j].split(";"); // word[0] = abbreviation, word[1] = name;
                    var abb = word[0];

                    if (abb === currentAbb) {
                        var name = word[1];

                        // Add new constellation as a property
                        constellations[currentAbb] = {
                            coord: [],
                            name: name,

                            // Values used to calculate the position of the center of constellation
                            x: 0.0,
                            y: 0.0,
                            z: 0.0,
                            nbStars: 0
                        };
                        break;
                    }
                }
            }

            // Convert to default coordinate system
            var posGeo = [RA, Decl];

            // Calculate the center of constillation
            var pos3d = [];
            // Need to convert to 3D because of 0h -> 24h notation
            mizarLayer.globe
                .getCoordinateSystem()
                .get3DFromWorldInCrs(posGeo, Constants.CRS.Equatorial, pos3d);
            constellations[currentAbb].x += pos3d[0];
            constellations[currentAbb].y += pos3d[1];
            constellations[currentAbb].z += pos3d[2];
            constellations[currentAbb].nbStars++;

            constellations[currentAbb].coord.push(posGeo);
        }
    }

    /*
     * 	Failure function
     */
    function failure() {
        ErrorDialog.open(Constants.LEVEL.ERROR, "Failed to load files");
    }

    /**
     * @name ConstellationProvider
     * @class
     *   ConstellationProvider context constructor
     * @param {object} options
     * @augments AbstractProvider
     * @constructor
     * @memberof module:Provider
     */
    var ConstellationProvider = function(options) {
        AbstractProvider.prototype.constructor.call(this, options);
        self = this;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProvider, ConstellationProvider);

    /**************************************************************************************************************/

    /**
     * Asynchronous request to load constellation data
     * @function loadFiles
     * @memberof ConstellationProvider#
     * @param {Layer} layer - Mizar layer
     * @param {Object} configuration - Configuration options
     * @param {string} configuration.nameUrl - Url providing the constellations name data
     * @param {string} configuration.catalogueUrl - Url providing all information about each constellation
     * @see http://vizier.cfa.harvard.edu/viz-bin/ftp-index?VI/49
     */
    ConstellationProvider.prototype.loadFiles = function(layer, configuration) {
        var mizarLayer = layer;
        if (configuration.nameUrl && configuration.catalogueUrl) {
            // loadFiles( configuration.nameUrl, configuration.catalogueUrl );
            var nameRequest = {
                type: "GET",
                url: configuration.nameUrl,
                success: function(response) {
                    namesFile = response;
                },
                error: function(xhr, ajaxOptions, thrownError) {
                    ErrorDialog.open(
                        Constants.LEVEL.ERROR,
                        "Failed to request " + configuration.nameUrl,
                        xhr.responseText
                    );
                }
            };

            var catalogueRequest = {
                type: "GET",
                url: configuration.catalogueUrl,
                success: function(response) {
                    catalogueFile = response;
                },
                error: function(xhr, ajaxOptions, thrownError) {
                    ErrorDialog.open(
                        Constants.LEVEL.ERROR,
                        "Failed to request " + configuration.catalogueUr,
                        xhr.responseText
                    );
                }
            };

            // Synchronizing two asynchronious requests with the same callback
            $.when($.ajax(nameRequest), $.ajax(catalogueRequest)).then(
                function() {
                    extractDatabase(mizarLayer);
                    self.handleFeatures(mizarLayer);
                },
                failure
            );
        } else {
            ErrorDialog.open(
                Constants.LEVEL.DEBUG,
                "Not valid options for ContellationProvider",
                "nameUrl and catalogueUrl attributes must be passed"
            );
            return false;
        }
    };

    /**
     * @function handleFeatures
     * @memberof ConstellationProvider#
     */

    ConstellationProvider.prototype.handleFeatures = function(mizarLayer) {
        var constellationNamesFeatures = [];
        var constellationShapesFeatures = [];

        // Fill constellationShapes & constellationNames
        for (var i in constellations) {
            if (constellations.hasOwnProperty(i)) {
                var current = constellations[i];

                // Close the polygon
                current.coord.push(current.coord[0]);

                var constellationShape = {
                    geometry: {
                        type: Constants.GEOMETRY.Polygon,
                        gid: "constellationShape_" + current.name,
                        coordinates: [current.coord],
                        crs: {
                            type: "name",
                            properties: {
                                name: Constants.CRS.Equatorial
                            }
                        }
                    },
                    properties: {
                        name: current.name
                    }
                };

                constellationShapesFeatures.push(constellationShape);

                // Compute mean value to show the constellation name in the center of constellation..
                // .. sometimes out of constellation's perimeter because of the awkward constellation's shape(ex. "Hydra" or "Draco" constellations)
                var geoPos = [];
                mizarLayer.globe
                    .getCoordinateSystem()
                    .getWorldFrom3D(
                        [
                            current.x / current.nbStars,
                            current.y / current.nbStars,
                            current.z / current.nbStars
                        ],
                        geoPos
                    );

                var constellationName = {
                    geometry: {
                        type: Constants.GEOMETRY.Point,
                        gid: "constellationName_" + current.name,
                        coordinates: [geoPos[0], geoPos[1]],
                        crs: {
                            type: "name",
                            properties: {
                                name: Constants.CRS.Equatorial
                            }
                        }
                    },
                    properties: {
                        name: current.name,
                        style: new FeatureStyle({
                            textColor: "#083BA8",
                            fillColor: [1.0, 1.0, 1.0, 1.0],
                            label: current.name
                        })
                    }
                };
                constellationNamesFeatures.push(constellationName);
            }
        }

        // Create feature collections
        var constellationShapesFeatureCollection = {
            type: "FeatureCollection",
            features: constellationShapesFeatures
        };
        var constellationNameFeatureCollection = {
            type: "FeatureCollection",
            features: constellationNamesFeatures
        };

        // Add shapes&names to the layer
        mizarLayer.addFeatureCollection(constellationShapesFeatureCollection);
        mizarLayer.addFeatureCollection(constellationNameFeatureCollection);
    };

    /**************************************************************************************************************/

    return ConstellationProvider;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Provider/StarProvider',[
    "jquery",
    "./AbstractProvider",
    "../Renderer/FeatureStyle",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function($, AbstractProvider, FeatureStyle, Utils, Constants, ErrorDialog) {
    var namesFile;
    var catalogueFile;
    var self;

    /*
         * 	Failure function
         */
    function failure() {
        ErrorDialog.open(
            Constants.LEVEL.ERROR,
            "Failed ot load files in StarProvider"
        );
    }

    /**
     * @name StarProvider
     * @class
     *    Specific star catalogue provider of the Brightest Stars (Ochsenbein+ 1988) from VizieR database
     * @param {object} options
     * @augments AbstractProvider
     * @constructor
     * @memberof module:Provider
     * @see Search Catalogue of the Brightest Stars (Ochsenbein+ 1988) in VizieR database for more details
     */
    var StarProvider = function(options) {
        AbstractProvider.prototype.constructor.call(this, options);
        self = this;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProvider, StarProvider);

    /**************************************************************************************************************/

    /**
     * Asynchronous requests to load star database
     * @function loadFiles
     * @memberof StarProvider.prototype
     * @param {Layer} mizarLayer - Mizar layer
     * @param {Object} configuration - Configuration options
     * @param {string} configuration.nameUrl - Url providing the stars name data
     * @param {string} configuration.catalogueUrl - Url providing all information about each star
     */
    StarProvider.prototype.loadFiles = function(mizarLayer, configuration) {
        if (configuration.nameUrl && configuration.catalogueUrl) {
            var nameRequest = {
                type: "GET",
                url: configuration.nameUrl,
                success: function(response) {
                    namesFile = response;
                },
                error: function(xhr, ajaxOptions, thrownError) {
                    ErrorDialog.open(
                        Constants.LEVEL.ERROR,
                        "Failed ot request " + configuration.nameUrl,
                        xhr.responseText
                    );
                }
            };

            var catalogueRequest = {
                type: "GET",
                url: configuration.catalogueUrl,
                success: function(response) {
                    catalogueFile = response;
                },
                error: function(xhr, ajaxOptions, thrownError) {
                    ErrorDialog.open(
                        Constants.LEVEL.ERROR,
                        "Failed ot request " + configuration.catalogueUrl,
                        xhr.responseText
                    );
                }
            };

            // Synchronizing two asynchronious requests with the same callback
            $.proxy(
                $.when($.ajax(nameRequest), $.ajax(catalogueRequest)).then(
                    function() {
                        self.handleFeatures(mizarLayer);
                    },
                    failure
                )
            );
        } else {
            ErrorDialog.open(
                Constants.LEVEL.DEBUG,
                "Not valid options for StarProvider",
                "nameUrl and catalogueUrl attributes must be passed"
            );
            return false;
        }
    };

    /**
     * @function handleFeatures
     * @memberof StarProvider#
     */
    StarProvider.prototype.handleFeatures = function(mizarLayer) {
        // Extract the table data
        var tmpTab = namesFile.slice(
            namesFile.indexOf("897;Acamar"),
            namesFile.indexOf("1231;Zaurak") + 11
        );
        var namesTab = tmpTab.split("\n");
        tmpTab = catalogueFile.slice(
            catalogueFile.indexOf("001."),
            catalogueFile.indexOf("4.98;K3Ibv") + 10
        );
        var catalogueTab = tmpTab.split("\n");
        var pois = [];

        // For each known star
        for (var i = 0; i < namesTab.length; i++) {
            var word = namesTab[i].split(";"); // word[0] = HR, word[1] = name;
            var HR = parseInt(word[0], 10);
            var starName = word[1];

            // Search corresponding HR in catalogue
            for (var j = 0; j < catalogueTab.length; j++) {
                word = catalogueTab[j].split(";");
                if (parseInt(word[2], 10) === HR) {
                    // Star found in the catalogue

                    var raString = word[6]; // right ascension format : "hours minutes seconds"
                    var declString = word[7]; // declinaton format : "degrees minutes seconds"

                    var geo = [];
                    mizarLayer.globe
                        .getCoordinateSystem()
                        .getDecimalDegFromSexagesimal(
                            [raString, declString],
                            geo
                        );

                    // Add poi layer
                    var poi = {
                        geometry: {
                            type: Constants.GEOMETRY.Point,
                            gid: "star_" + starName,
                            coordinates: [geo[0], geo[1]],
                            crs: {
                                type: "name",
                                properties: {
                                    name: Constants.CRS.Equatorial
                                }
                            }
                        },
                        properties: {
                            name: starName,
                            style: new FeatureStyle({
                                label: starName,
                                fillColor: [1.0, 1.0, 1.0, 1.0]
                            })
                        }
                    };
                    pois.push(poi);
                }
            }
        }

        // Create feature collection
        var poiFeatureCollection = {
            type: "FeatureCollection",
            features: pois
        };

        mizarLayer.addFeatureCollection(poiFeatureCollection);
    };

    /**************************************************************************************************************/

    return StarProvider;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Provider/CraterProvider',[
    "jquery",
    "./AbstractProvider",
    "../Utils/Utils",
    "../Renderer/FeatureStyle",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function($, AbstractProvider, Utils, FeatureStyle, Constants, ErrorDialog) {
    const DEFAULT_STROKE_COLOR = [1.0, 1.0, 1.0, 1.0];

    var self;
    var featureCollection;

    /**
     * @name CraterProvider
     * @class
     *   Displays the name of the crater
     * @param {object} options
     * @augments AbstractProvider
     * @constructor
     * @memberof module:Provider
     */
    var CraterProvider = function(options) {
        AbstractProvider.prototype.constructor.call(this, options);
        self = this;
    };

    /*******************************************************************************/
    Utils.inherits(AbstractProvider, CraterProvider);
    /*******************************************************************************/

    /**
     * @function loadFiles
     * @param {Layer} layer - mizar Layer
     * @param {Object} configuration - configuration
     * @param {string} configuration.url - URL of the GeoJSON file
     * @memberof CraterProvider#
     */
    CraterProvider.prototype.loadFiles = function(layer, configuration) {
        Utils.requestUrl(
            configuration.url,
            "text",
            "text/plain",
            null,
            function(response) {
                if (typeof response === "string") {
                    featureCollection = JSON.parse(response);
                } else {
                    featureCollection = response;
                }
                self.handleFeatures(layer);
            },
            function(err) {
                ErrorDialog.open(
                    Constants.LEVEL.ERROR,
                    "Failed ot request " + configuration.url,
                    err
                );
            }
        );
    };

    /**
     * @function handleFeatures
     * @memberof CraterProvider#
     */
    CraterProvider.prototype.handleFeatures = function(layer) {
        var crs = featureCollection.crs;
        var features = featureCollection.features;
        var ptMaxSize = layer.options.pointMaxSize
            ? layer.options.pointMaxSize
            : 20;
        var strokeColor = layer.getStyle().getStrokeColor()
            ? layer.getStyle().getStrokeColor()
            : DEFAULT_STROKE_COLOR;
        for (var i = 0; i < features.length; i++) {
            var currentFeature = features[i];
            currentFeature.geometry.crs = crs;
            var craterName = currentFeature.properties.name;
            currentFeature.properties.style = new FeatureStyle({
                label: craterName,
                strokeColor: strokeColor,
                pointMaxSize: ptMaxSize
            });
        }
        layer.addFeatureCollection(featureCollection);
    };

    return CraterProvider;
});

/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('gw/Provider/TrajectoryProvider',[
    "jquery",
    "./AbstractProvider",
    "../Renderer/FeatureStyle",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Services/MeasureToolPlanetCore",
    "../Gui/dialog/ErrorDialog"
], function(
    $,
    AbstractProvider,
    FeatureStyle,
    Utils,
    Constants,
    MeasureToolPlanetCore,
    ErrorDialog
) {
    var self;
    var interval;
    var poiFeatureCollection;
    var url;
    var data;

    /**
     * Parses the files
     * @param {string} response  response
     * @returns {Object} the points of the trafectory
     */
    function _parseFile(response) {
        var pois = [];
        var lines = response.split("\n");
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            // skip comments
            if (line.startsWith("#")) {
                continue;
            }
            var data = line.split(",");
            if (data.length > 1) {
                var long = parseFloat(data[0]);
                var lat = parseFloat(data[1]);
                var date = data[2];
                pois.push([long, lat, date]);
            }
        }
        return pois;
    }

    /**
     * Ceates lines from the set of points
     * @param {Object} pois pois
     * @returns {string} the geometry
     */
    function _createLines(pois) {
        var geom = [];
        for (var j = 1; j < pois.length; j++) {
            var line = [];
            line.push(pois[j - 1]);
            line.push(pois[j]);
            geom.push(line);
        }
        return geom;
    }

    /**
     * ExtractDates from the set of points
     * @param {Object} Set of points
     * @returns Object range date as [date min, date max]
     */
    function _extractDates(pois) {
        var dateMin = pois[0][2];
        var dateMax = pois[pois.length - 1][2];
        return [dateMin, dateMax];
    }

    /**
     * Computes the trajectory.
     * @param {Layer} mizarLayer
     */
    var computePositions = function(mizarLayer) {
        Utils.requestUrl(
            url,
            "text",
            "plain/text",
            null,
            function(response) {
                var pois = _parseFile(response);
                var geom = _createLines(pois);
                var dates = _extractDates(pois);

                var style = new FeatureStyle({
                    iconUrl: "css/images/lander.png",
                    strokeColor: FeatureStyle.fromStringToColor("white"),
                    fillColor: FeatureStyle.fromStringToColor("white")
                });

                var trajectory = createTrajectory(
                    mizarLayer,
                    Constants.GEOMETRY.MultiLineString,
                    mizarLayer.name,
                    { trajectory: geom, color: "white", dates: dates }
                );
                // Create feature collection
                poiFeatureCollection = {
                    type: "FeatureCollection",
                    crs: {
                        type: "name",
                        properties: {
                            name: "IAU2000:30101"
                        }
                    },
                    features: [
                        trajectory,
                        {
                            type: "Feature",
                            properties: {
                                title: "Landing site",
                                style: style,
                                thumbnail:
                                    "http://space.skyrocket.de/img_sat/team-indus__1.jpg",
                                abstract:
                                    "The <a href=\"http://www.teamindus.in/mission/\" class=\"selectValue\">Team Indus Lunar Lander</a> is a lunar lander developed by the Indian nonprofit organisation Team Indus. It is an entry to win the Google Lunar XPRIZE (GLXP).<p>The Team Indus Lunar Lander is a lunar lander, which has a propulsion system to enable itself to leave earth orbit and to enter a trajectory to the moon. After landing it will deploy the Indian ECA (Ek Choti si Asha) rover, which will move to a distance of at least 500 m to satisfy the rules of the GLXP. <p>The propulsion system is bipropellant, consisting of a single 440 N prime thruster and sixteen 22 N thrusters. <p>Once deployed from the rocket, the spacecraft will orbit the earth twice. In a manoeuvre called the trans-lunar injection by which it will successfully leave Earths orbit, the rocket engines will be fired to set course to the Moon. At this point, the craft will be traveling at the maximum speed of 10.5 km/salmost 39600 km/h for the distance of 384400 km within 10 days. When roughly 100 km from the Moon, it will perform another manoeuvre called the Lunar Orbit Capture to eventually settle into a parking orbit. By now, the craft will have decelerated to 800 m/s. These extreme variations in speed will consume most of the spacecrafts fuel.The landing phase of the mission will be initiated at a 100 km  100 km orbit around the Moon. The entire process will be controlled by software onboard the spacecraft using data collected from laser sensors. These sensors will detect and analysis the surface, orienting the craft accordingly. Considering that manual control of the craft at this point is impossible, automation and preprogramming is the only way to go. At a time optimised to coincide with the lunar dawn on Mare Imbrium, the spacecraft thrusters will be fired again to decrease the orbit for a soft touchdown.The Team Indus Lunar Lander is a lunar lander developed by the Indian nonprofit organisation Team Indus. It is an entry to win the Google Lunar XPRIZE (GLXP).The Team Indus Lunar Lander is a lunar lander, which has a propulsion system to enable itself to leave earth orbit and to enter a trajectory to the moon. After landing it will deploy the Indian ECA (Ek Choti si Asha) rover, which will move to a distance of at least 500 m to satisfy the rules of the GLXP.The propulsion system is bipropellant, consisting of a single 440 N prime thruster and sixteen 22 N thrusters.Once deployed from the rocket, the spacecraft will orbit the earth twice. In a manoeuvre called the trans-lunar injection by which it will successfully leave Earths orbit, the rocket engines will be fired to set course to the Moon. At this point, the craft will be traveling at the maximum speed of 10.5 km/salmost 39600 km/h for the distance of 384400 km within 10 days. When roughly 100 km from the Moon, it will perform another manoeuvre called the Lunar Orbit Capture to eventually settle into a parking orbit. By now, the craft will have decelerated to 800 m/s. These extreme variations in speed will consume most of the spacecrafts fuel.The landing phase of the mission will be initiated at a 100 km  100 km orbit around the Moon. The entire process will be controlled by software onboard the spacecraft using data collected from laser sensors. These sensors will detect and analysis the surface, orienting the craft accordingly. Considering that manual control of the craft at this point is impossible, automation and preprogramming is the only way to go. At a time optimised to coincide with the lunar dawn on <a href=\"https://en.wikipedia.org/wiki/Mare_Imbrium\" class=\"selectValue\">Mare Imbrium</a>, the spacecraft thrusters will be fired again to decrease the orbit for a soft touchdown."
                            },
                            geometry: {
                                type: "Point",
                                coordinates: [-25.680079147, 29.5212266285]
                            }
                        }
                    ]
                };

                mizarLayer.addFeatureCollection(poiFeatureCollection);
            },
            function(err) {
                ErrorDialog.open(
                    Constants.LEVEL.ERROR,
                    "Failed ot request " + url,
                    err
                );
            }
        );
    };

    /*
     * Json template for a point
     * @param 
     */
    function createTrajectory(mizarLayer, type, name, obj) {
        function _computeDistance(trajectory) {
            var distance = 0;
            var line = trajectory[0];
            for (var i = 1; i < trajectory.length; i++) {
                var lineNext = trajectory[i];
                distance += MeasureToolPlanetCore.calculateDistanceElevation(
                    line[0],
                    lineNext[0]
                );
                line = lineNext;
            }
            return distance * 1000;
        }

        return {
            type: "Feature",
            geometry: {
                type: Constants.GEOMETRY.MultiLineString,
                gid: "trajectory" + type + "_" + name,
                coordinates: obj.trajectory
            },
            properties: {
                title: name,
                thumbnail: data.thumbnailPath,
                abstract: data.abstractPath,
                startDate: obj.dates[0],
                endDate: obj.dates[1],
                distance: _computeDistance(obj.trajectory).toFixed() + " meters"
            }
        };
    }

    /**
     * @name TrajectoryProvider
     * @class
     *    Create a trajectory, which can be refreshed
     * @param {object} options
     * @augments AbstractProvider
     * @constructor
     * @memberof module:Provider
     */
    var TrajectoryProvider = function(options) {
        AbstractProvider.prototype.constructor.call(this, options);
        self = this;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProvider, TrajectoryProvider);

    /**************************************************************************************************************/

    /**
     * Asynchronous requests to reload trajectory at some time interval
     * @function loadFiles
     * @memberof TrajectoryProvider#
     * @param {Layer} mizarLayer - Mizar layer
     * @param {Object} configuration - Configuration options
     * @param {string} configuration.url - Url providing the trajectory
     * @param {string} configuration.interval - time in ms where the trajectory is reloaded
     */

    TrajectoryProvider.prototype.loadFiles = function(layer, configuration) {
        data = configuration;
        interval = configuration.interval ? configuration.interval : 60000;
        url = configuration.url;
        self.handleFeatures(layer);
    };

    /**
     * @function handleFeatures
     * @memberof TrajectoryProvider#
     */

    TrajectoryProvider.prototype.handleFeatures = function(layer) {
        computePositions(layer);
        setInterval(function() {
            layer.removeFeatureCollection(poiFeatureCollection);
            computePositions(layer);
        }, interval);
    };

    return TrajectoryProvider;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gw/Provider/ProviderFactory',[
    "./ConstellationProvider",
    "./PlanetProvider",
    "./StarProvider",
    "./CraterProvider",
    "./TrajectoryProvider",
    "../Utils/Constants"
], function(
    ConstellationProvider,
    PlanetProvider,
    StarProvider,
    CraterProvider,
    TrajectoryProvider,
    Constants
) {
    return {
        /**
         * Factory to create a provider.
         *
         * Creates a provider based on :
         * <ul>
         *     <li>the provider type {@link PROVIDER},</li>
         *     <li>the options for the specific provider</li>
         * </ul>
         *
         * Severals providers can be created :
         * <ul>
         *     <li>{@link module:Provider.ConstellationProvider ConstellationProvider}</li>
         *     <li>{@link module:Provider.CraterProvider CraterProvider}</li>
         *     <li>{@link module:Provider.PlanetProvider PlanetProvider}</li>
         *     <li>{@link module:Provider.StarProvider StarProvider}</li>
         *     <li>{@link module:Provider.TrajectoryProvider TrajectoryProvider}</li>
         * </ul>
         * @param {PROVIDER} type - Type of provider.
         * @param {Object} options - See the options for each animation for further information
         * @return {Provider} - the interface to handle an animation
         * @throws {RangeError} Type not valid - a valid type is included in the list {@link PROVIDER}
         * @alias module:Provider.ProviderFactory.create
         * @see {@link module:Provider.ConstellationProvider ConstellationProvider} Loads constellations
         * @see {@link module:Provider.CraterProvider CraterProvider} Loads Craters
         * @see {@link module:Provider.PlanetProvider PlanetProvider} Loads planets position
         * @see {@link module:Provider.TrajectoryProvider TrajectoryProvider} Loads trajectory
         *
         */

        create: function(type, options) {
            var obj;
            switch (type) {
            case Constants.PROVIDER.Constellation:
                obj = new ConstellationProvider(options);
                break;
            case Constants.PROVIDER.Crater:
                obj = new CraterProvider(options);
                break;
            case Constants.PROVIDER.Planet:
                obj = new PlanetProvider(options);
                break;
            case Constants.PROVIDER.Star:
                obj = new StarProvider(options);
                break;
            case Constants.PROVIDER.Trajectory:
                obj = new TrajectoryProvider(options);
                break;
            default:
                throw new RangeError(
                    "unable to create the provider " + type,
                    "ProviderFactory.js"
                );
            }
            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Utils/Stats',[],function() {
    /**
     @name Stats
     @class
         Display some rendering statistics in a HTML element
     @param {Context} Context
     @param {Object} options - Configuration properties for Stats.
     @param {Object} [options.element] - the HTML element to receivce statistcs, can be a string (the ID) or the DOM element itself
     @param {boolean] {[options.verbose=false] - the verbosity of the stats, default is false
     @constructor
    */
    var Stats = function(context, options) {
        this.type = null;
        context.getRenderContext().stats = this;
        //context.globe.renderContext.stats = this;
        this.context = context;
        var elt = options ? options.element : undefined;
        if (elt) {
            if (typeof elt === "string") {
                this.element = document.getElementById(elt);
                this.type = "dom";
            } else {
                this.element = elt;
                this.type = "jquery";
            }
        }

        this.showFPS = this.context.globe.continuousRendering;
        this.verbose = options && options.verbose ? options.verbose : false;
        this.numFrames = 0;

        var self = this;
        window.setInterval(function() {
            self.print();
        }, 1000);
    };

    /**************************************************************************************************************/

    /**
     Start measuring time
     */
    Stats.prototype.start = function(name) {
        this[name] = Date.now();
    };

    /**************************************************************************************************************/

    /**
     End measuring time
     */
    Stats.prototype.end = function(name) {
        var time = Date.now() - this[name];

        var max = this["max_" + name] || -1;
        if (max < time) {
            max = time;
        }

        var sum = this["sum_" + name] || 0;
        sum += time;

        this[name] = time;
        this["max_" + name] = max;
        this["sum_" + name] = sum;
        if (name === "globalRenderTime") {
            this.numFrames++;
        }
    };

    /**************************************************************************************************************/

    /**
     Print stats in an HTML element
     */
    Stats.prototype.print = function() {
        if (this.numFrames > 0) {
            var content = "";

            if (this.showFPS) {
                content += "FPS : " + this.numFrames + "<br>";
            }

            content +=
                "Average render time : " +
                (this.sum_globalRenderTime / this.numFrames).toFixed(2) +
                " ms";
            // FIXME: currently count stats for the first renderer in render context
            /*if (this.context.globe.renderContext.renderers[0].getRenderStats) {
                content += "<br>" + this.renderContext.renderers[0].getRenderStats();
            }
            */
            if (this.verbose) {
                content +=
                    "<br>Average traverse tiles time : " +
                    (this.sum_traverseTime / this.numFrames).toFixed(2) +
                    " ms";
                content +=
                    "<br>Average render tiles time : " +
                    (this.sum_renderTime / this.numFrames).toFixed(2) +
                    " ms";
                content +=
                    "<br>Average generate tiles time : " +
                    (this.sum_generateTime / this.numFrames).toFixed(2) +
                    " ms";
                content +=
                    "<br>Average request tiles time : " +
                    (this.sum_requestTime / this.numFrames).toFixed(2) +
                    " ms";
                content +=
                    "<br>Max render time : " +
                    this.max_globalRenderTime +
                    " ms";
                content +=
                    "<br>Max traverse tiles time : " +
                    this.max_traverseTime +
                    " ms";
                content +=
                    "<br>Max render tiles time : " +
                    this.max_renderTime +
                    " ms";
                content +=
                    "<br>Max generate tiles time : " +
                    this.max_generateTime +
                    " ms";
                content +=
                    "<br>Max request tiles time : " +
                    this.max_requestTime +
                    " ms";
            }

            if (this.element) {
                if (this.type === "dom") {
                    this.element.innerHTML = content;
                } else if (this.type === "jquery") {
                    this.element.html(content);
                }
            }

            this.sum_globalRenderTime = 0;
            this.sum_traverseTime = 0;
            this.sum_renderTime = 0;
            this.sum_generateTime = 0;
            this.sum_requestTime = 0;
            this.max_globalRenderTime = 0;
            this.max_traverseTime = 0;
            this.max_renderTime = 0;
            this.max_generateTime = 0;
            this.max_requestTime = 0;
            this.numFrames = 0;
        }
    };

    /**************************************************************************************************************/

    return Stats;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @fileOverview Entry point for the {@link Mizar MIZAR API}
 * @version [VERSION_API]
 * @author CNES
 */
define('gw/Mizar',[
    "jquery",
    "underscore-min",
    "./Context/ContextFactory",
    "./Navigation/NavigationFactory",
    "./Layer/LayerFactory",
    "./Crs/CoordinateSystemFactory",
    "./Animation/AnimationFactory",
    "./Utils/UtilityFactory",
    "./Services/ServiceFactory",
    "./Provider/ProviderFactory",
    "./Utils/Utils",
    "./Utils/Event",
    "./Utils/Stats",
    "./Utils/Constants",
    "./Gui/dialog/ErrorDialog",
    "./Layer/HipsMetadata",
    "./Time/Time",
    "./Utils/Proxy"
], function(
    $,
    _,
    ContextFactory,
    NavigationFactory,
    LayerFactory,
    CoordinateSystemFactory,
    AnimationFactory,
    UtilityFactory,
    ServiceFactory,
    ProviderFactory,
    Utils,
    Event,
    Stats,
    Constants,
    ErrorDialog,
    HipsMetadata,
    Time,
    Proxy
) {
    /**
     * mizarMode:toggle.<br/>
     * Called when Mizar switches from a context to another context
     * @event Mizar#mizarMode:toggle
     * @type {Context}
     */

    /**
     * API version
     * @constant
     * @type {string}
     */
    const API_VERSION = Constants.API.version;

    /**
     * Angle from pole to camera
     * @constant
     * @type {number}
     */
    const ANGLE_CAMERA_POLE = 30.0;

    /**
     * @constant
     * @type {string}
     */
    const MIZAR_NAME_PROD = "Mizar.min";

    /**
     * @constant
     * @type {string}
     */
    const MIZAR_NAME_DEV = "Mizar.";

    /**
     *  Mizar input parameters
     * @typedef {Object} Mizar_inputParameters
     * @property {Object|string} canvas - canvas ID or canvas element in which Mizar is running
     * @property {Mizar_inputConfiguration} [configuration] - Mizar global configuration
     * @property {AbstractContext.skyContext} [skyContext] - Sky context configuration
     * @property {AbstractContext.planetContext} [planetContext] - Planet context configuration
     * @property {AbstractContext.groundContext} [groundContext] - Ground context configuration
     */

    /**
     * Mizar configuration
     * @typedef {Object} Mizar_inputConfiguration
     * @property {string} [mizarBaseUrl] - Used to access to MizarWidget resources
     * @property {boolean} [debug = false] - Debug mode
     * @property {boolean} [isMobile = false] - Mobile support
     * @property {AbstractTracker_position_configuration} [positionTracker] - Position tracker configuration
     * @property {AbstractTracker_elevation_configuration} [elevationTracker] - Elevation tracker configuration
     * @property {TimeTravel_position_configuration} [timeTravel] - Time travel GUI
     * @property {Object} [registry] - Hips service registry
     * @property {string} registry.hips - Hips Registry
     * @property {boolean} [proxyUse=false] - Uses a proxy to send request
     * @property {string} [proxyUrl] - Proxy URL to use when proxyUse is true. This is used to avoid CORS errors.
     */
    /**
     * Time travel configuration
     * @typedef {Object} TimeTravel_position_configuration
     * @property {string} [element = timeTravelDiv] - tracker div element
     */

    /**
     * Position tracker configuration
     * @typedef {Object} AbstractTracker_position_configuration
     * @property {string} [element = posTracker] - tracker div element
     * @property {string}  [position = bottom] - tracker position in the GUI
     */

    /**
     * Elevation tracker configuration
     * @typedef {Object} AbstractTracker_elevation_configuration
     * @property {string} [element = elevTracker] - tracker div element
     * @property {string}  [position = bottom] - tracker position in the GUI
     * @property {Layer} [elevationLayer] - elevationLayer
     */

    /**
     * Mizar configuration
     * @typedef {Mizar_inputConfiguration} Mizar.configuration
     * @property {string} mizarAPIUrl - URL of this script, used to reference shaders and CSS of Mizar API
     */

    /**
     * Mizar parameters
     * @typedef {Object} Mizar_parameters
     * @property {Object|string} canvas - canvas ID or canvas element
     * @property {Mizar.configuration} [configuration] - Mizar global configuration
     * @property {AbstractContext.skyContext} [skyContext] - Sky context configuration
     * @property {AbstractContext.planetContext} [planetContext] - Planet context configuration
     * @property {AbstractContext.groundContext} [groundContext] - Ground context configuration
     */

    /**
     * @name Mizar
     * @class
     * Creates an instance of the Mizar API.
     * @param {Mizar_inputParameters} options - Configuration for Mizar
     * @throws {ReferenceError} No option found
     * @throws {TypeError} Canvas not defined
     * @constructor
     */
    var Mizar = function(options) {
        Event.prototype.constructor.call(this);

        _checkConfiguration(options);
        this.options = _createConfiguration(options);

        ErrorDialog.setDebug(this.options.configuration.debug ? this.options.configuration.debug : false);

        // Init all factories
        /**
         * Creates a {@link module:Context.ContextFactory Context}
         * @name ContextFactory
         * @memberof Mizar#
         */
        this.ContextFactory = ContextFactory;

        /**
         * Creates a {@link module:Layer.LayerFactory Layer}
         * @name LayerFactory
         * @memberof Mizar#
         */
        this.LayerFactory = LayerFactory;

        // Proxy settings
        const proxyUse = this.options.configuration.proxyUse || false;
        Proxy.setProxyUse(proxyUse);
        if (proxyUse) {
            Proxy.setProxyUrl(this.options.configuration.proxyUrl);
        }

        /**
         * Creates an {@link module:Animation.AnimationFactory animation}
         * @name AnimationFactory
         */
        this.AnimationFactory = AnimationFactory;

        /**
         * Creates a {@link module:Services.ServiceFactory service}
         * @name ServiceFactory
         */
        this.ServiceFactory = ServiceFactory;

        /**
         * Creates an {@link module:Utils.UtilityFactory utility}
         * @name UtilityFactory
         * @memberof Mizar#
         */
        this.UtilityFactory = UtilityFactory;

        /**
         * Creates a {@link module:Provider.ProviderFactory provider}
         * @name ProviderFactory
         * @memberof Mizar#
         */
        this.ProviderFactory = ProviderFactory;

        /**
         * Access to time.
         * @name TimeUtility
         * @memberof Mizar#
         */
        this.TimeUtility = Time;

        this.skyContext = null;
        this.planetContext = null;
        this.groundContext = null;
        this.activatedContext = null;
        this.renderContext = null;
        this.dataProviders = {};

        if (options.skyContext) {
            options.skyContext.isMobile = options.isMobile;
            this.createContext(Mizar.CONTEXT.Sky, options.skyContext);
            this.setActivatedContext(Mizar.CONTEXT.Sky);
        }

        if (options.planetContext) {
            options.planetContext.isMobile = options.isMobile;
            this.createContext(Mizar.CONTEXT.Planet, options.planetContext);
            this.setActivatedContext(Mizar.CONTEXT.Planet);
        }

        if (options.groundContext) {
            options.groundContext.isMobile = options.isMobile;
            this.createContext(Mizar.CONTEXT.Ground, options.groundContext);
            this.setActivatedContext(Mizar.CONTEXT.Ground);
        }
    };

    /**********************************************************************************************************
     *                                      Static variables
     **********************************************************************************************************/

    /**
     * API {@link VERSION version}
     * [SemVer]{@link http://semver.org/} concept is used for versioning
     * @name VERSION
     * @memberof Mizar#
     */
    Mizar.VERSION = API_VERSION;

    /**
     * List of supported values for {@link ANIMATION animation}*
     * @name ANIMATION
     * @memberof Mizar#
     * @see {@link module:Animation animation package} for further information.
     */
    Mizar.ANIMATION = Constants.ANIMATION;

    /**
     * List of supported values for {@link LAYER layer}
     * @name LAYER
     * @memberof Mizar#
     * @see {@link module:Layer layer package} for further information.
     */
    Mizar.LAYER = Constants.LAYER;

    /**
     * List of supported values for {@link INFORMATION_TYPE information}
     * @name INFORMATION_TYPE
     * @memberof Mizar#
     */

    Mizar.INFORMATION_TYPE = Constants.INFORMATION_TYPE;

    /**
     * List of supported values for {@link GEOMETRY geometry}
     * @name GEOMETRY
     * @memberof Mizar#
     */
    Mizar.GEOMETRY = Constants.GEOMETRY;

    /**
     * List of supported values for {@link NAVIGATION navigation}
     * @name NAVIGATION
     * @memberof Mizar#
     * @see {@link module:Navigation navigation package} for further information.
     */
    Mizar.NAVIGATION = Constants.NAVIGATION;

    /**
     * List of supported values for {@link CONTEXT context}
     * @name CONTEXT
     * @memberof Mizar#
     * @see {@link module:Context context package} for further information.
     */
    Mizar.CONTEXT = Constants.CONTEXT;

    /**
     * List of supported values for {@link PROJECTION projection}
     * @name PROJECTION
     * @memberof Mizar#
     * @see {@link module:Projection projection package} for further information.
     */
    Mizar.PROJECTION = Constants.PROJECTION;

    /**
     * List of supported values for {@link CRS coordinate reference system}
     * @name CRS
     * @memberof Mizar#
     * @see {@link module:Crs coordinate system package} for further information.
     */
    Mizar.CRS = Constants.CRS;

    /**
     * List of supported values for {@link CRS_TO_CONTEXT crs/context mapping}
     * @name CRS_TO_CONTEXT
     * @memberof Mizar#
     */
    Mizar.CRS_TO_CONTEXT = Constants.CRS_TO_CONTEXT;

    /**
     * List of supported values {@link DISPLAY display}
     * @name DISPLAY
     * @memberof Mizar#
     */
    Mizar.DISPLAY = Constants.DISPLAY;

    /**
     * List of supported values for {@link SERVICE service}
     * @name SERVICE
     * @memberof Mizar#
     */
    Mizar.SERVICE = Constants.SERVICE;

    /**
     * List of supported values for {@link UTILITY utility}
     * @name UTILITY
     * @memberof Mizar#
     */
    Mizar.UTILITY = Constants.UTILITY;

    /**
     * List of supported values for {@link PROVIDER provider}
     * @name PROVIDER
     * @memberof Mizar#
     * @see {@link module:Provider provider package} for further information.
     */
    Mizar.PROVIDER = Constants.PROVIDER;

    /**
     * List of supported values for {@link EVENT_MSG event}
     * @name EVENT_MSG
     * @memberof Mizar#
     */
    Mizar.EVENT_MSG = Constants.EVENT_MSG;

    /**
     * List of supported valaues for {@link TIME_STEP time step}
     * @name TIME_STEP
     * @memberof Mizar#
     */
    Mizar.TIME_STEP = Constants.TIME_STEP;

    /**********************************************************************************************************
     *                                      Private methods
     **********************************************************************************************************/

    /**
     * Returns the script object that contains the URL of this script
     * @param {Object[]} scripts - All the scripts from the document where Mizar is imported
     * @param {MIZAR_NAME_PROD|MIZAR_NAME_DEV} scriptName - production or dev script name
     * @param {int} index - Number of range '/' to remove from the end of the URL
     * @private
     */
    function _extractURLFrom(scripts, scriptName, index) {
        var mizarSrc = _.find(scripts, function(script) {
            return script.src.indexOf(scriptName) !== -1;
        });
        if (mizarSrc) {
            mizarSrc =
                mizarSrc.src
                    .split("/")
                    .slice(0, index)
                    .join("/") + "/";
        }
        return mizarSrc;
    }

    /**
     * Return the base URL of this script.
     * @returns {string} the base URL or an empty string
     * @private
     */
    function _getMizarAPIBaseURL() {
        var scripts = document.getElementsByTagName("script");
        return (
            _extractURLFrom.call(this, scripts, MIZAR_NAME_PROD, -1) ||
            _extractURLFrom.call(this, scripts, MIZAR_NAME_DEV, -2) || ""
        );
    }

    /**
     * Checks inputs
     * @param {Object} options - Mizar configuration
     * @throws {ReferenceError} No option found
     * @throws {TypeError} Canvas not defined
     * @function _checkConfiguration
     * @memberof Mizar#
     * @private
     */
    function _checkConfiguration(options) {
        if (typeof options === "undefined") {
            throw new ReferenceError("No option found", "Mizar.js");
        } else if (typeof options.canvas === "undefined") {
            throw new TypeError("Canvas not defined", "Mizar.js");
        } else {
            // do nothing
        }
    }

    /**
     * Checks inputs from user and creates the mizar configuration
     * @param {Mizar.inputParameters} options inputs from user
     * @returns {Mizar_parameters} mizar configuration.
     * @function _createConfiguration
     * @memberof Mizar#
     * @private
     */
    function _createConfiguration(options) {
        var mizarAPIUrl = _getMizarAPIBaseURL();        
        var mizarOptions = {
            canvas:
                typeof options.canvas === "string"
                    ? document.getElementById(options.canvas)
                    : options.canvas
        };
        if (options.hasOwnProperty("configuration")) {
            mizarOptions.configuration = options.configuration;
        } else {
            mizarOptions.configuration = {};
        }
        mizarOptions.configuration.mizarAPIUrl = mizarAPIUrl;
        if (options.hasOwnProperty("skyContext")) {
            mizarOptions.skyContext = options.skyContext;
        }
        if (options.hasOwnProperty("planetContext")) {
            mizarOptions.planetContext = options.planetContext;
        }
        if (options.hasOwnProperty("groundContext")) {
            mizarOptions.groundContext = options.groundContext;
        }
        return mizarOptions;
    }

    /**
     * Switch to a context
     * @param {AbstractContext} context - Target context
     * @param {Object} [options] - options management for the source context
     * @param {boolean} [options.mustBeDestroyed=false] - options management for the source context : destroy it
     * @param {boolean} [options.mustBeHidden=false] - options management for the source context : hidden it
     * @function _switchToContext
     * @memberof Mizar#
     * @private
     * @fires Mizar#mizarMode:toggle
     */
    function _switchToContext(context, options) {
        if (context && context.globe) {
            context.globe.isEnable = false;
        }

        var self = this;
        var mustBeDestroyed = options.hasOwnProperty("mustBeDestroyed")
            ? options.mustBeDestroyed
            : false;
        var mustBeHidden = options.hasOwnProperty("mustBeHidden")
            ? options.mustBeHidden
            : false;

        // Hide sky
        this.getActivatedContext().hide();

        // Hide all additional layers
        this.getActivatedContext().hideAdditionalLayers();

        var viewMatrix;
        var fov;
        if (
            context.hasOwnProperty("_oldVM") &&
            context.hasOwnProperty("_oldFov")
        ) {
            viewMatrix = context._oldVM;
            fov = context._oldFov;
        } else if (context.getNavigation().inverseViewMatrix === undefined) {
            this.getActivatedContext()._oldVM = this.renderContext.getViewMatrix();
            this.getActivatedContext()._oldFov = this.renderContext.getFov();
            viewMatrix = context
                .getNavigation()
                .getRenderContext()
                .getViewMatrix();
            fov = 90;
        } else {
            this.getActivatedContext()._oldVM = this.renderContext.getViewMatrix();
            this.getActivatedContext()._oldFov = this.renderContext.getFov();
            viewMatrix = mat4.create();
            context.getNavigation().computeInverseViewMatrix();
            mat4.inverse(context.getNavigation().inverseViewMatrix, viewMatrix);
            fov = 90;
        }

        if (mustBeDestroyed) {
            this.getActivatedContext().destroy();
        } else if (mustBeHidden) {
            this.getActivatedContext().disable();
        } else {
            // display the two contexts in the same time
        }
        this.activatedContext = context;
        if (!context.getNavigation().getRenderContext().cameraUpdateFunction) {
            context
                .getNavigation()
                .getRenderContext().cameraUpdateFunction = context
                    .getNavigation()
                    .update.bind(context.getNavigation());
        }
        context.getNavigation().toViewMatrix(viewMatrix, fov, 2000, function() {
            if (context) {
                context.enable();

                if (context && context.globe) {
                    context.globe.isEnable = true;
                }
            }
            if (options && options.callback) {
                options.callback.call(self);
            }
            context.showAdditionalLayers();
            self.getActivatedContext().show();
            self.publish(Constants.EVENT_MSG.MIZAR_MODE_TOGGLE, context);
            self.getActivatedContext().refresh();
            if (self.getRenderContext().viewMatrix[0] !== "undefined") {
                self.getActivatedContext()
                    .getNavigation()
                    .computeViewMatrix();
            }
        });
    }

    /**
     * Saves the atmosphere state and disable it when 2D is used
     * @function _disableAtmosphere
     * @memberof Mizar#
     * @fires Context#startLoad
     * @fires Context#endLoad
     * @fires Context#baseLayersReady
     * @fires Context#baseLayersError
     * @fires Context#startBackgroundLoad
     * @fires Context#endBackgroundLoad
     * @fires Context#features:added
     * @private
     */
    function _disableAtmosphere() {
        if (this.getActivatedContext()._atmosphereLayer !== undefined) {
            if (this.getActivatedContext()._atmosphereLayer.globe !== null) {
                this.getActivatedContext()._saveAtmosphereVisible = this.getActivatedContext()._atmosphereLayer.visible;
                this.getActivatedContext()._atmosphereLayer.setVisible(false);
                this.render();
            }
        }
    }

    /**
     * Retrieves the atmosphere and enable it when 3D is used
     * @function _enableAtmosphere
     * @memberof Mizar#
     * @fires Context#startLoad
     * @fires Context#endLoad
     * @fires Context#baseLayersReady
     * @fires Context#baseLayersError
     * @fires Context#startBackgroundLoad
     * @fires Context#endBackgroundLoad
     * @fires Context#features:added
     * @private
     */
    function _enableAtmosphere() {
        if (this.getActivatedContext()._atmosphereLayer !== undefined) {
            if (this.getActivatedContext()._atmosphereLayer.globe !== null) {
                this.getActivatedContext()._atmosphereLayer.setVisible(
                    this.getActivatedContext()._saveAtmosphereVisible
                );
                this.render();
            }
        }
    }

    /**
     * Switch 2D to 3D.
     * @function _switch2Dto3D
     * @memberof Mizar#
     * @fires Context#startLoad
     * @fires Context#endLoad
     * @fires Context#baseLayersReady
     * @fires Context#baseLayersError
     * @fires Context#startBackgroundLoad
     * @fires Context#endBackgroundLoad
     * @fires Context#features:added
     * @private
     */
    function _switch2Dto3D() {
        _enableAtmosphere.call(this);

        // Enable skyContext behind the planet
        if (this.skyContext) {
            this.skyContext.enable();
        }

        this.setCrs({ geoideName: this.getCrs().getGeoideName() });

        // Check zoom level
        this.planetContext.navigation.zoom(0);
    }

    /**
     * Switch 3D to 2D.
     * @function _switch3Dto2D
     * @memberof Mizar#
     * @private
     */
    function _switch3Dto2D() {
        _disableAtmosphere.call(this);

        // Disable skyContext
        if (this.skyContext) {
            this.skyContext.disable();
        }

        // If a pole is closed to the center of the canvas, this should mean that
        // the user is interested to the pole, so we switch to azimuth projection
        // instead of plate carre projection
        _project2AzimuthOrPlate.call(
            this,
            this.getActivatedContext().navigation.getCenter()
        );
    }

    /**
     * Selects the right projection according to the target of the camera.<br/>
     * When the angle of the target of the camera with a pole (north or south)
     * is inferior to ANGLE_CAMERA_POLE, then the azimuthal projection is selected
     * otherwise plate carre is selected
     * @param {float[]} lookAt - target of the camera [longitude, latitude] in decimal degree
     * @function _project2AzimuthOrPlate
     * @memberof Mizar#
     * @private
     */
    function _project2AzimuthOrPlate(lookAt) {
        if (lookAt !== null && 90 - Math.abs(lookAt[1]) <= ANGLE_CAMERA_POLE) {
            this.setCrs({
                geoideName: this.getCrs().getGeoideName(),
                projectionName: Mizar.PROJECTION.Azimuth,
                pole: Math.sign(lookAt[1]) > 0 ? "north" : "south"
            });
        } else {
            this.setCrs({
                geoideName: this.getCrs().getGeoideName(),
                projectionName: Mizar.PROJECTION.Plate
            });
        }
    }

    /**
     * Skip if sky mode
     * @function _skipIfSkyMode
     * @memberof Mizar#
     * @throws {RangeError} Toggle Dimension is not implemented for Sky
     * @private
     */
    function _skipIfSkyMode() {
        if (this.getActivatedContext().getMode() === Mizar.CONTEXT.Sky) {
            throw new RangeError(
                "Toggle Dimension is not implemented for Sky",
                "Mizar.js"
            );
        }
    }

    /**
     * Get service url from HIPS Layer
     * @function _getHipsServiceUrlArray
     * @memberof Mizar#
     * @param hipsLayer
     * @returns {Array}
     * @private
     */
    function _getHipsServiceUrlArray(hipsLayer) {
        var hipsServiceUrlArray = [];

        if (hipsLayer.hips_service_url) {
            hipsServiceUrlArray.push(hipsLayer.hips_service_url);
        }
        if (hipsLayer.hips_service_url_1) {
            hipsServiceUrlArray.push(hipsLayer.hips_service_url_1);
        }
        if (hipsLayer.hips_service_url_2) {
            hipsServiceUrlArray.push(hipsLayer.hips_service_url_2);
        }
        return hipsServiceUrlArray;
    }

    /**
     * Loads HIPS layers from passed service url
     * @function _checkHipsServiceIsAvailable
     * @memberof Mizar#
     * @param {Array} hipsServiceUrlArray - HIPS service URL
     * @param {serviceRegistryCallback} callback - The callback that handles the response
     * @private
     */
    function _checkHipsServiceIsAvailable(hipsServiceUrlArray, callback) {
        if (hipsServiceUrlArray.length === 0) {
            return callback(undefined);
        }
        var url = hipsServiceUrlArray.shift();

        Utils.requestUrl(
            url + "/properties",
            "text",
            "text/plain",
            null,
            function(data) {
                callback(url);
            },
            function(err) {
                _checkHipsServiceIsAvailable(hipsServiceUrlArray, callback);
            }
        );
    }

    /**
     * Loads HIPS layers from passed service url
     * @function _loadHIPSLayers
     * @memberof Mizar#
     * @param {Mizar} Mizar - Mizar API
     * @param {Options} [options] - Options
     * @param {string} [options.registry] - Registry
     * @param {string} [options.registry.hips] - Hips Registry
     * @private
     */
    function _loadHIPSLayers(Mizar, options) {
        if (
            typeof options !== "undefined" &&
            options.hasOwnProperty("registry") &&
            options.registry.hasOwnProperty("hips")
        ) {
            Utils.requestUrl(
                options.registry.hips,
                "json",
                "application/json",
                null,
                function(hipsLayersJSON) {
                    _.each(
                        hipsLayersJSON,
                        function(hipsLayer) {
                            var hipsServiceUrlArray = _getHipsServiceUrlArray(
                                hipsLayer
                            );
                            var hipsUrl = _checkHipsServiceIsAvailable(
                                hipsServiceUrlArray,
                                function(hipsServiceUrl) {
                                    if (typeof hipsServiceUrl === "undefined") {
                                        var text = "";
                                        if (
                                            typeof hipsLayer.obs_title ===
                                            "undefined"
                                        ) {
                                            text =
                                                "with ID <b>" +
                                                hipsLayer.ID +
                                                "</b>";
                                        } else {
                                            text =
                                                "with title <b>" +
                                                hipsLayer.obs_title +
                                                "</b>";
                                        }
                                        ErrorDialog.open(
                                            Constants.LEVEL.ERROR,
                                            " Cannot add layer " + text,
                                            "no mirror available"
                                        );
                                        return;
                                    }
                                    $.proxy(_createHips, Mizar)(
                                        hipsLayer,
                                        hipsServiceUrl
                                    );
                                }
                            );
                        },
                        Mizar
                    );
                },
                function(err) {
                    ErrorDialog.open(
                        Constants.LEVEL.WARNING,
                        "Cannot connect to " + options.registry.hips,
                        err.message
                    );
                }
            );
        }
    }

    /**
     * Creates a HIPS layer from registry
     * @function _createHips
     * @memberof Mizar#
     * @param hipsLayer
     * @param hipsServiceUrl
     * @private
     */
    function _createHips(hipsLayer, hipsServiceUrl) {
        try {
            if (
                hipsLayer.hasOwnProperty("hips_status") &&
                hipsLayer.hips_status.match("public") === null
            ) {
                return;
            }
            hipsLayer.hips_service_url = hipsServiceUrl;
            this.addLayer({
                type: Mizar.LAYER.Hips,
                hipsMetadata: new HipsMetadata(hipsLayer)
            });
        } catch (e) {
            var name = hipsLayer.obs_title
                ? hipsLayer.obs_title
                : hipsLayer.obs_collection;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Hips layer " +
                    name +
                    " not valid for " +
                    hipsLayer.hips_service_url,
                e.message
            );
        }
    }

    /**************************************************************************************************************/

    Utils.inherits(Event, Mizar);

    /**************************************************************************************************************/

    /**************************************************************************************************************
     *                                          Public methods
     **************************************************************************************************************/

    /**
     * Returns the sky context.
     * @returns {SkyContext|null}
     * @function getSkyContext
     * @memberof Mizar#
     */
    Mizar.prototype.getSkyContext = function() {
        return this.skyContext;
    };

    /**
     * Returns the planet context.
     * @returns {PlanetContext|null}
     * @function getPlanetContext
     * @memberof Mizar#
     */
    Mizar.prototype.getPlanetContext = function() {
        return this.planetContext;
    };

    /**
     * Returns the ground context.
     * @returns {GroundContext|null}
     * @function getGroundContext
     * @memberof Mizar#
     */
    Mizar.prototype.getGroundContext = function() {
        return this.groundContext;
    };

    /**
     * Returns the context according to the mode.
     * @function _getContext
     * @param {CONTEXT|undefined} mode - the selected mode
     * @memberof Mizar#
     * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
     * @returns {Context} the context
     * @private
     */
    function _getContext(mode) {
        var context;
        switch (mode) {
        case undefined:
            context = this.getActivatedContext();
            break;
        case Mizar.CONTEXT.Sky:
            context = this.getSkyContext();
            break;
        case Mizar.CONTEXT.Planet:
            context = this.getPlanetContext();
            break;
        case Mizar.CONTEXT.Ground:
            context = this.getGroundContext();
            break;
        default:
            throw new RangeError(
                "The mode " +
                        mode +
                        " is not allowed, A valid mode is included in the list CONTEXT",
                "Mizar.js"
            );
        }
        return context;
    }

    /**
     * Returns the selected context.
     * When activatedContext is not set, it is set automatically to the created context
     * (in the following order : sky, planet, ground). When no context is created,
     * an  exception "No created context" is send.
     * @returns {PlanetContext|SkyContext|GroundContext|null}
     * @function getActivatedContext
     * @memberof Mizar#
     */
    Mizar.prototype.getActivatedContext = function() {
        try {
            if (this.activatedContext == null) {
                if (this.skyContext != null) {
                    this.activatedContext = this.skyContext;
                } else if (this.planetContext != null) {
                    this.activatedContext = this.planetContext;
                } else if (this.groundContext != null) {
                    this.activatedContext = this.groundContext;
                } else {
                    throw new ReferenceError("No created context", "Mizar.js");
                }
            }
        } catch (e) {
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot get the context",
                e.message
            );
        }
        return this.activatedContext;
    };

    /**
     * Selects the context as default context according to the {@link CONTEXT context mode}.<br/>
     * Once a context is selected, methods can be applied to it.
     * @param {CONTEXT} contextMode - select one context among {@link CONTEXT context}
     * @returns {boolean} true when the contextMode is known otherwise false
     * @function setActivatedContext
     * @memberof Mizar#
     * @throws {RangeError} contextMode not valid - a valid contextMode is included in the list {@link CONTEXT}
     */
    Mizar.prototype.setActivatedContext = function(contextMode) {
        var result;
        switch (contextMode) {
        case Mizar.CONTEXT.Planet:
            this.activatedContext = this.planetContext;
            result = true;
            break;
        case Mizar.CONTEXT.Sky:
            this.activatedContext = this.skyContext;
            result = true;
            break;
        case Mizar.CONTEXT.Ground:
            this.activatedContext = this.groundContext;
            result = true;
            break;
        default:
            result = false;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot set the context to " + contextMode
            );
        }
    };

    /**
     * Returns the mode in which the active context is set.
     * @function getMode
     * @memberof Mizar#
     * @returns {CONTEXT|null} Returns the mode otherwise null when no created context
     */
    Mizar.prototype.getMode = function() {
        var result;
        var context = this.getActivatedContext();
        if (context) {
            result = context.getMode();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Returns the rendering context.
     * @returns {RenderContext|null} the rendering context
     * @function getRenderContext
     * @memberof Mizar#
     */
    Mizar.prototype.getRenderContext = function() {
        var result;
        var context = this.getActivatedContext();
        if (context) {
            result = context.getRenderContext();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Returns the options
     * @function getOptions
     * @memberof Mizar#
     * @returns {Mizar_parameters} - Mizar's options
     */
    Mizar.prototype.getOptions = function() {
        return this.options;
    };

    //               ***************************** coordinate reference *****************************

    /**
     * Returns the coordinate reference system related to the selected {@link CONTEXT context}
     * @returns {Crs|null} the coordinate reference system or null when no created context
     * @function getCrs
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext} to select a context
     * @see {@link Mizar#createContext} to create a context
     */
    Mizar.prototype.getCrs = function() {
        var result;
        var context = this.getActivatedContext();
        if (context) {
            result = context.getCoordinateSystem();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Sets the coordinate reference system related to the selected {@link CONTEXT context}
     * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - coordinate system description
     * @returns {boolean} true when the coordinate system is set otherwise false when an error occurs
     * @function setCrs
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.setCrs = function(coordinateSystem) {
        var result;
        var context = this.getActivatedContext();
        if (context) {
            var crs = CoordinateSystemFactory.create(coordinateSystem);
            context.setCoordinateSystem(crs);
            result = true;
        } else {
            result = false;
        }
        return result;
    };

    /**
     * Update the time travel navigation range
     * @param {JSON} parameters Parameters
     * @function setTime
     * @memberof Mizar#
     */
    Mizar.prototype.updateTimeTravel = function(parameters) {
        this.getServiceByName(Mizar.SERVICE.TimeTravel).update(parameters);
    };

    /**
     * Sets the current or integrated time of the application
     * @param {Time.configuration} time single, multiple or range of values
     * @function setTime
     * @memberof Mizar#
     */
    Mizar.prototype.setTime = function(time) {
        this.activatedContext.setTime(time);
    };

    /**
     * Returns the current or integrated time.
     * @returns {Time.configuration} the simple, multiple or range of values
     * @function getTime
     * @memberof Mizar#
     */
    Mizar.prototype.getTime = function() {
        return this.activatedContext.getTime();
    };

    //               ***************************** context management *****************************

    /**
     * Creates a context according to the {@link CONTEXT context mode}.<br/>
     * @param {CONTEXT} contextMode - Select on context among {@link CONTEXT context}
     * @param {AbstractContext.skyContext|AbstractContext.planetContext|AbstractContext.groundContext} options - Options for the context, See options.planetContext or options.skycontext configuration for {@link Mizar}
     * @retuns {boolean} true when the context is created otherwise false when the contextMode is unknown
     * @throws {RangeError} contextMode not valid - a valid contextMode is included in the list {@link CONTEXT}
     * @function createContext
     * @memberof Mizar#
     */
    Mizar.prototype.createContext = function(contextMode, options) {
        var result;
        try {
            options.renderContext = this.renderContext;
            options.timeTravelService = this.getServiceByName(
                Mizar.SERVICE.TimeTravel
            );
            options.isMobile = this.getOptions().configuration.isMobile;

            var ctx = this.ContextFactory.create(
                contextMode,
                this.getOptions(),
                options
            );

            switch (contextMode) {
            case Mizar.CONTEXT.Sky:
                this.skyContext = ctx;
                _loadHIPSLayers(this, this.getOptions().configuration);
                break;
            case Mizar.CONTEXT.Planet:
                this.planetContext = ctx;
                break;
            case Mizar.CONTEXT.Ground:
                this.groundContext = ctx;
                break;
            default:
                throw new RangeError(
                    "Unknown contextMode '" + contextMode + "'",
                    "Mizar.js"
                );
            }
            this.renderContext = ctx.getRenderContext();
            result = true;
        } catch (e) {
            result = false;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot create the context",
                e.message
            );
        }
        return result;
    };

    /**
     * Switches 2D <--> 3D, only for planetary context. <br/>
     * When this method is used in a sky context, and exception is thrown
     * @returns {boolean} true when toggle works otherwise false
     * @function toggleDimension
     * @memberof Mizar#
     * @fires Context#startLoad
     * @fires Context#endLoad
     * @fires Context#baseLayersReady
     * @fires Context#baseLayersError
     * @fires Context#startBackgroundLoad
     * @fires Context#endBackgroundLoad
     * @fires Context#features:added
     */
    Mizar.prototype.toggleDimension = function() {
        var result;
        try {
            _skipIfSkyMode.call(this);
            if (this.getCrs().isFlat()) {
                // we are in 2D and we are going to 3D
                _switch2Dto3D.call(this);
            } else {
                // we are in 3D and we are goint to 2D
                _switch3Dto2D.call(this);
            }
            this.render();
            result = true;
        } catch (e) {
            result = false;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot toggle the dimension",
                e.message
            );
        }
        return result;
    };

    /**
     * Switches to a context.
     * @param {AbstractContext} context - target context
     * @param {Object} [options] - options management for the source context
     * @param {boolean} [options.mustBeDestroyed=false] - options management for the source context
     * @param {boolean} [options.mustBeHidden=false] - options management for the source context
     * @param {Function} callback - Call at the end of the toggle
     * @fires Mizar#mizarMode:toggle
     * @function toggleToContext
     * @memberof Mizar#
     */
    Mizar.prototype.toggleToContext = function(context, options) {
        var result;
        try {
            var toggleMode =
                this.getActivatedContext().getMode() === Mizar.CONTEXT.Sky
                    ? Mizar.CONTEXT.Planet
                    : Mizar.CONTEXT.Sky;
            var opts = options || {};
            _switchToContext.call(this, context, opts);
            result = true;
        } catch (e) {
            result = false;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot toggle the context",
                e.message
            );
        }
        return result;
    };

    //               ***************************** layer management *****************************

    /**
     * Returns the sky layers, which have been added by {@link Mizar#addLayer}.
     * @function getSkyLayers
     * @returns {Layer[]|null} the layers
     * @memberof Mizar#
     */
    Mizar.prototype.getSkyLayers = function() {
        var result;
        var context = this.getSkyContext();
        if (context) {
            result = context.getLayers();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Returns the planet layers, which have been added by {@link Mizar#addLayer}
     * @function getPlanetLayers
     * @returns {Layer[]|null} the layers
     * @memberof Mizar#
     */
    Mizar.prototype.getPlanetLayers = function() {
        var result;
        var context = this.getPlanetContext();
        if (context) {
            result = context.getLayers();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Returns the grounds layers, which have been added by {@link Mizar#addLayer}
     * @function getGroundLayers
     * @returns {Layer[]|null} the layers
     * @memberof Mizar#
     */
    Mizar.prototype.getGroundLayers = function() {
        var result;
        var context = this.getGroundContext();
        if (context) {
            result = context.getLayers();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Returns the layers for a specific context.<br/>
     * When no context is specified, the layers from the selected context are returned.
     * @function getLayers
     * @param {CONTEXT|null} mode - Context on which the function is applied
     * @returns {Layer[]} the layers
     * @memberof Mizar#
     * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
     * @see {@link Mizar#setActivatedContext} to select a context
     * @see {@link Mizar#createContext} to create a context
     */
    Mizar.prototype.getLayers = function(mode) {
        var result;
        try {
            result = _getContext.call(this, mode).getLayers();
        } catch (e) {
            result = null;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot get the layers",
                e.message
            );
        }
        return result;
    };

    /**
     * Draws the layer on the top.
     * @function setLayerOnTheTop
     * @param {string} layerID Layer ID
     * @return {boolean} Returns true when the layer is drawn on the top otherwise false.
     * @memberof Mizar#
     */
    Mizar.prototype.setLayerOnTheTop = function(layerID) {
        var result;
        var layer = this.getLayerByID(layerID);
        if (layer != null) {
            layer.setOnTheTop();
            result = true;
        } else {
            result = false;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot set the layer on the top",
                layerID + " does not exist"
            );
        }
        return result;
    };

    /**
     * Returns all the layers regardless of the {@link CONTEXT context}.
     * @function getAllLayers
     * @return {Layer[]} the layers
     * @memberof Mizar#
     */
    Mizar.prototype.getAllLayers = function() {
        return _.union(this.getSkyLayers(), this.getPlanetLayers());
    };

    /**
     * Returns the layer by its ID according to the {@link CONTEXT context}.<br/>
     * When no context is specified, the layer from the selected context is returned.<br/>
     * The ID is a unique layer identifier, which is returned when the layer description is {@link Mizar#addLayer added}
     * to Mizar
     * @function getLayerByID
     * @param {string} layerID - Layer's ID
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {Layer|undefined|null} The layer or undefined when the layer is not found
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext} to select a context
     * @see {@link Mizar#createContext} to create a context
     */
    Mizar.prototype.getLayerByID = function(layerID, mode) {
        var result;
        try {
            result = _getContext.call(this, mode).getLayerByID(layerID);
        } catch (e) {
            result = null;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot get the layer by ID",
                e.message
            );
        }
        return result;
    };

    /**
     * Returns the layer by its name according to the {@link CONTEXT context}.<br/>
     * When no context is specified, the layer from the selected context is returned.<br/>
     * <b>Note:</b> The name may not be unique. In this case, the first layer having this name is returned
     * @function getLayerByName
     * @param {string} layerName - Layer's name, provided in the layer description when the layer is {@link Mizar#addLayer added}
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {Layer|undefined|null} the layer or undefined when the layer is not found
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext} to select a context
     * @see {@link Mizar#createContext} to create a context
     */
    Mizar.prototype.getLayerByName = function(layerName, mode) {
        var result;
        try {
            result = _getContext.call(this, mode).getLayerByName(layerName);
        } catch (e) {
            result = null;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot get the layer by name",
                e.message
            );
        }
        return result;
    };

    /**
     * Adds a layer according to the selected {@link CONTEXT context}.<br/>
     * When layerPlanet is not provided, then the layer is added to the selected context otherwise the layer
     * is added to the layerPlanet.
     *
     * @function addLayer
     * @param {Object} layerDescription - See the base properties {@link AbstractLayer.configuration} and a specific layer for specific properties
     * @returns {string|null} a unique identifier or null when a problem happens
     * @memberof Mizar#
     * @listens AbstractLayer#visibility:changed
     * @see {@link module:Layer.AtmosphereLayer AtmosphereLayer} : A layer to create an atmosphere on a planet.
     * @see {@link module:Layer.BingLayer BingLayer}: The Microsoft service proving a WMTS server.
     * @see {@link module:Layer.CoordinateGridLayer CoordinateGridLayer} : A layer to create a grid on the sky
     * @see {@link module:Layer.GeoJsonLayer GeoJSONLayer} : A layer to add a GeoJSON on the globe
     * @see {@link module:Layer.GroundOverlayLayer GroundOverlayLayer} : A layer to draw an image overlay draped onto the terrain
     * @see {@link module:Layer.HipsCatLayer HipsCatLayer} : A layer to draw a HIPS catalogue
     * @see {@link module:Layer.HipsFitsLayer HipsFitsLayer} : A layer to draw an Hips Fits
     * @see {@link module:Layer.HipsGraphicLayer HipsGraphicLayer} : A layer to draw a Hips JPEG/PNG
     * @see {@link module:Layer.MocLayer MocLayer} : A layer to draw a multi-order-coverage index
     * @see {@link module:Layer.OpenSearchLayer OpenSearchLayer} : A layer to draw the result from an open search service
     * @see {@link module:Layer.OSMLayer OSMLayer} : A layer to display data coming from OpenStreetMap server
     * @see {@link module:Layer.TileWireframeLayer TileWireframeLayer} : A layer to draw a grid on the planet
     * @see {@link module:Layer.VectorLayer VectorLayer} : A layer to draw a vector
     * @see {@link module:Layer.WCSElevationLayer WCSElevationLayer} : A layer to draw the elevation
     * @see {@link module:Layer.WMSElevationLayer WMSElevationLayer} : A layer to draw the elevation
     * @see {@link module:Layer.WMSLayer WMSLayer} : A layer to draw images coming from the WMS server
     * @see {@link module:Layer.WMTSLayer WMTSLayer} : A layer to draw predefined tiles coming from a WMTS server
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.addLayer = function(layerDescription, callback, fallback) {
        //var result;
        //try {
        this.getActivatedContext().addLayer(
            layerDescription,
            callback,
            fallback
        );
        //} catch(e) {
        //    result = false;
        //    var prefixe;
        //    var text;
        //    var hipsLayer = layerDescription.hipsMetadata;
        //    if(hipsLayer != null) {
        //        if (typeof hipsLayer.hipsMetadata.obs_title === 'undefined') {
        //            prefixe = "ID ";
        //            text = hipsLayer.hipsMetadata.ID;
        //        } else {
        //            prefixe = "";
        //            text = hipsLayer.hipsMetadata.obs_title;
        //        }
        //        //ErrorDialog.open("Hips layer " + prefixe + "<font style='color:yellow'><b>" + text + "</b></font> not valid in Hips registry <font color='grey'><i>(" + hipsLayer.hipsMetadata.hips_service_url + " - reason : "+ e.message +")</i></font>.");
        //    } else {
        //        //ErrorDialog.open("Cannot add the layer <font style='color:yellow'><b>" + JSON.stringify(layerDescription) + "</b></font><font color='grey'><i>(reason : "+ e.message +")</i></font>.");
        //    }
        //}
    };

    /**
     * Removes a layer by its ID according to the {@link CONTEXT context}.<br/>
     * When no context is specified, then the function is applied on the selected context.
     * @function removeLayer
     * @param {string} layerID - Layer's ID
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {boolean} true when the layer is added otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext} to select a context
     * @see {@link Mizar#createContext} to create a context
     */
    Mizar.prototype.removeLayer = function(layerID, mode) {
        var result;
        try {
            var removedLayer = _getContext
                .call(this, mode)
                .removeLayer(layerID);
            result = typeof removedLayer !== "undefined";
        } catch (e) {
            result = false;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot remove the layer",
                e.message
            );
        }
        return result;
    };

    /**
     * Sets the background layer according to the selected context.<br/>
     * When no context is specified, then the function is applied on the selected context.<br/>
     * <b>Note 1:</b> The name is not a unique identifier. The first layer matching at this name is returned<br/>
     * <b>Note 2:</b> The layer must be {@link Mizar#addLayer added} before
     * @function setBackgroundLayer
     * @param {string} layerName - Layer's name, which has been provided in the layer description
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {boolean} true when the layer is set as background otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext} to select a context
     * @see {@link Mizar#createContext} to create a context
     */
    Mizar.prototype.setBackgroundLayer = function(layerName, mode) {
        var result;
        try {
            var gwLayer = _getContext
                .call(this, mode)
                .setBackgroundLayer(layerName);
            result = typeof gwLayer !== "undefined";
        } catch (e) {
            result = false;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot set the background",
                e.message
            );
        }
        return result;
    };

    /**
     * Sets the background layer by ID according to the {@link CONTEXT context}.<br/>
     * When no context is specified, then the function is applied on the selected context.
     * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
     * @function setBackgroundLayerByID
     * @param {string} layerID - Unique layer identifier.
     * @param {CONTEXT|undefined} mode - Context on which the function is applied.
     * @returns {boolean} true when the layer is set as background otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext} to select a context
     * @see {@link Mizar#createContext} to create a context
     */
    Mizar.prototype.setBackgroundLayerByID = function(layerID, mode) {
        var result;
        try {
            var gwLayer = _getContext
                .call(this, mode)
                .setBackgroundLayerByID(layerID);
            result = typeof gwLayer !== "undefined";
        } catch (e) {
            result = false;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot set the backgorund by ID",
                e.message
            );
        }
        return result;
    };

    /**
     * Sets the base elevation by its layer's name according to the {@link CONTEXT context}.<br/>
     * When no context is specified, then the function is applied on the selected context.
     * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
     * @function setBaseElevation
     * @param {string} layerName - Name of the layer
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {boolean} true when the base elevation is set otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.setBaseElevation = function(layerName, mode) {
        var result;
        try {
            var layer = this.getLayerByName(layerName, mode);
            var gwLayer = _getContext.call(this, mode).setBaseElevation(layer);
            result = typeof gwLayer !== "undefined";
        } catch (e) {
            result = false;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot set the base elevation",
                e.message
            );
        }
        return result;
    };

    /**
     * Gets the base elevation to the {@link CONTEXT context}.<br/>
     * When no context is specified, then the function is applied on the selected context.
     * @function getBaseElevation
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {WCSElevationLayer|null} true when the base elevation is set otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.getBaseElevation = function(mode) {
        return _getContext.call(this, mode).getBaseElevation();
    };

    /**
     * Sets the base elevation by its layer's ID according to the {@link CONTEXT context}.<br/>
     * When no context is specified, then the function is applied on the selected context.
     * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
     * @function setBaseElevation
     * @param {string} layerID - ID of the layer
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {boolean} true when the base elevation is set otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.setBaseElevationByID = function(layerID, mode) {
        var result;
        try {
            var gwLayer = _getContext
                .call(this, mode)
                .setBaseElevationByID(layerID);
            result = typeof gwLayer !== "undefined";
        } catch (e) {
            result = false;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot set the base elevation by ID",
                e.message
            );
        }
        return result;
    };

    /**
     * Looks through each value in the list according to the context, returning an array of all the values that match the query.<br/>
     * The query is performed on the name and the description of each layer.<br/>
     * When no context is specified, the function is applied on the selected context.
     * @function searchOnLayerDescription
     * @param {string} query - query on the layer'name or description
     * @param {CONTEXT|undefined} mode - Context on which the query is run.
     * @returns {Layer[]}
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.searchOnLayerDescription = function(query, mode) {
        var layers = this.getLayers(mode);
        return _.filter(layers, function(layer) {
            return (
                String(layer.getName()).indexOf(query) >= 0 ||
                String(layer.getDescription() || "").indexOf(query) >= 0
            );
        });
    };

    /**
     * Looks through each value in the sky layers, returning an array of all the values that match the query.<br/>
     * The query is performed on the name and the description of each layer
     * @function searchSkyLayer
     * @param {string} query - query on the layer's name or description
     * @returns {Layer[]} An array of layers matching the constraint
     * @memberof Mizar#
     */
    Mizar.prototype.searchSkyLayer = function(query) {
        var layers = this.getSkyLayers();
        return _.filter(layers, function(layer) {
            return (
                String(layer.getName()).indexOf(query) >= 0 ||
                String(layer.getDescription() || "").indexOf(query) >= 0
            );
        });
    };

    /**
     * Looks through each value in the planets layers, returning an array of all the values that match the query.<br/>
     * The query is performed on the name and the description of each layer
     * @function searchPlanetLayer
     * @param {string} query - query on the layer'name or description
     * @returns {Layer[]} An array of layers matching the constraint
     * @memberof Mizar#
     */
    Mizar.prototype.searchPlanetLayer = function(query) {
        var layers = this.getPlanetLayers();
        //Search by name
        return _.filter(layers, function(layer) {
            return (
                String(layer.getName()).indexOf(query) >= 0 ||
                String(layer.getDescription() || "").indexOf(query) >= 0
            );
        });
    };

    //               ***************************** Utility management *****************************

    /**
     * Registers no standard data provider in a predefined context.<br/>
     * When no context is specified, the function is applied to the selected context.
     * @function registerNoStandardDataProvider
     * @param {string} type - data provider key
     * @param {Function} loadFunc - Function to convert the data
     * @param {CONTEXT|undefined} mode - Context
     * @returns {boolean} true when data provider is registered otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     * @example <caption>Registers planets on the sky</caption>
     *   var planetProvider = ProviderFactory.create(Mizar.PROVIDER.Planet);
     *   this.registerNoStandardDataProvider("planets", planetProvider.loadFiles);
     */
    Mizar.prototype.registerNoStandardDataProvider = function(
        type,
        loadFunc,
        mode
    ) {
        var result;
        try {
            _getContext
                .call(this, mode)
                .registerNoStandardDataProvider(type, loadFunc);
            result = true;
        } catch (e) {
            result = false;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot register the data provider",
                e.message
            );
        }
        return result;
    };

    /**
     * Returns the service based on its name
     * @param {SERVICE} serviceName
     * @param {Object} options - options for the service
     * @memberof Mizar#
     * @returns {Object|null} - the service
     */
    Mizar.prototype.getServiceByName = function(serviceName, options) {
        var result;
        try {
            result = ServiceFactory.create(serviceName, options);
        } catch (e) {
            result = null;
            ErrorDialog.open(
                Constants.LEVEL.ERROR,
                "Cannot get the service by name",
                e.message
            );
        }
        return result;
    };

    /**
     * Creates and get Stats Object
     * @function createStats
     * @param {Object} options - Configuration properties for stats.
     * @param {string|object} options.element div ID ou jquery element in wich the stats are written
     * @param {boolean} [options.verbose=false] detailled display when verbose=true
     * @return {Stats}
     * @memberof Mizar#
     * @see {@link Stats}
     */
    Mizar.prototype.createStats = function(options) {
        var result;
        if (this.skyContext) {
            this.Stats = new Stats(this.skyContext, options);
            result = true;
        } else if (this.planetContext) {
            this.Stats = new Stats(this.planetContext, options);
            result = true;
        } else if (this.groundContext) {
            this.Stats = new Stats(this.groundContext, options);
            result = true;
        } else {
            result = false;
            ErrorDialog.open("Cannot create the stats", true);
        }
        return result;
    };

    //               ***************************** Rendering management *****************************

    /**
     * Renders the canvas.
     * @returns {boolean} true when the canvas is rendered otherwise false
     * @function render
     * @memberof Mizar#
     * @fires Context#startLoad
     * @fires Context#endLoad
     * @fires Context#baseLayersReady
     * @fires Context#baseLayersError
     * @fires Context#startBackgroundLoad
     * @fires Context#endBackgroundLoad
     * @fires Context#features:added
     */
    Mizar.prototype.render = function() {
        var result;
        var renderContext = this.getRenderContext();
        if (renderContext) {
            this.getRenderContext().frame();
            result = true;
        } else {
            result = false;
        }
        return result;
    };

    //               ***************************** Memory management *****************************

    /**
     * Disposes the Mizar's contexts (planet, sky and ground).
     *
     * Reset the {@link TileManager} and delete texture for each defined context.
     * @function dispose
     * @memberof Mizar#
     */
    Mizar.prototype.dispose = function() {
        if (this.planetContext) {
            this.planetContext.dispose();
        }
        if (this.skyContext) {
            this.skyContext.dispose();
        }
        if (this.groundContext) {
            this.groundContext.dispose();
        }
    };

    /**
     * Reload a layer (keep id and ID)
     * @function reloadLayer
     * @memberof Mizar#
     */
    Mizar.prototype.reloadLayer = function(layer) {
        var ctx = this.getActivatedContext();
        if (ctx) {
            var tileManager = ctx.getTileManager();
            tileManager.abortLayerRequests(layer);
            layer._detach(ctx.globe);
            layer._attach(ctx.globe);
        } else {
            ErrorDialog.open(
                Constants.LEVEL.WARNING,
                "Context not yet available"
            );
        }
    };

    /**
     * Destroys Mizar
     *
     * @function destroy
     * @memberof Mizar#
     */
    Mizar.prototype.destroy = function() {
        if (this.planetContext) {
            this.planetContext.destroy();
        }
        if (this.skyContext) {
            this.skyContext.destroy();
        }
        if (this.groundContext) {
            this.groundContext.destroy();
        }
        this.activatedContext = null;
        this.renderContext = null;
        this.ContextFactory = null;
        this.LayerFactory = null;
        this.AnimationFactory = null;
        this.ServiceFactory = null;
        this.UtilityFactory = null;
    };

    // Make object MIZAR available in caller web page
    window.Mizar = Mizar;

    return Mizar;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 * Utility module : contains various functions useful for differnt modules
 */
define('utils/UtilsCore',["wcs", "gw/Mizar"],
    function (wcs, Mizar) {

        var mizarWidgetAPI;
        var votable2geojsonUrl;

        /**
         *    HSV values in [0..1[
         *    returns [r, g, b] values from 0 to 255
         */
        function hsv_to_rgb(h, s, v) {
            var h_i = Math.floor(h * 6);
            var f = h * 6 - h_i;
            var p = v * (1 - s);
            var q = v * (1 - f * s);
            var t = v * (1 - (1 - f) * s);
            var r;
            var g;
            var b;
            switch (h_i) {
                case 0:
                    r = v;
                    g = t;
                    b = p;
                    break;
                case 1:
                    r = q;
                    g = v;
                    b = p;
                    break;
                case 2:
                    r = p;
                    g = v;
                    b = t;
                    break;
                case 3:
                    r = p;
                    g = q;
                    b = v;
                    break;
                case 4:
                    r = t;
                    g = p;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = p;
                    b = q;
                    break;
                default:
                    r = 1;
                    g = 1;
                    b = 1;
            }
            return [r, g, b];
        }

        /**
         *    Create geographic coordinate from x,y image pixel using WCS
         */
        function createCoordinate(x, y) {
            var coordinate = wcs.pixelToCoordinate([x, y]);
            // Convert to geographic representation
            if (coordinate.ra > 180) {
                coordinate.ra -= 360;
            }
            return [coordinate.ra, coordinate.dec];
        }

		/**
		 * Convert spherical coordinate to cartesian
		 */
		var to3D = function(pt) {
			var lon = pt[0] * Math.PI / 180;
			var lat = pt[1] * Math.PI / 180;
			var x = Math.cos(lat) * Math.cos(lon);
			var y = Math.cos(lat) * Math.sin(lon);
			var z = Math.sin(lat);
			return [x,y,z];
		};

		/**
		 * Return the sign of a value
		 */
		var sign = function(v) {
			if (v < 0)
				return -1 ;
			else { if (v > 0) return 1; else return 0; };
		};

		/**
		 * Check if there is intersection between 2 great-arc
		 */
		var greatArcIntersection = function(a0,a1,b0,b1) {
			var p = vec3.cross(a0,a1,[]);
			var q = vec3.cross(b0,b1,[]);
			var t = vec3.normalize(vec3.cross(p,q,[]));

			var s1 = vec3.dot(vec3.cross(a0,p,[]),t);
			var s2 = vec3.dot(vec3.cross(a1,p,[]),t);
			var s3 = vec3.dot(vec3.cross(b0,q,[]),t);
			var s4 = vec3.dot(vec3.cross(b1,q,[]),t);

			var st =  sign(-s1) + sign(s2) + sign(-s3) + sign(s4);
			return Math.abs(st) == 4;
		};

		/**
		 * Point in ring with spherical geometry
		 */
		var pointInRingSpherical = function (point, ring) {
			var nvert = ring.length;
			var nbinter = 0;

			var p0 = to3D(point);
			var p1 = to3D([point[0],point[1]+90]);

			for (var i = 0; i < nvert-1; i++) {
				if (greatArcIntersection(to3D(ring[i]),to3D(ring[i+1]),p0,p1)) {
					nbinter++;
				}
			}
			return (nbinter % 2) == 1;
		};

		var pointInRingCartesian =  function (point, ring) {
                var nvert = ring.length;
                if (ring[0][0] === ring[nvert - 1][0] && ring[0][1] === ring[nvert - 1][1]) {
                    nvert--;
                }
                var inPoly = false;
                var j = nvert - 1;
                for (var i = 0; i < nvert; j = i++) {
                    if (((ring[i][1] > point[1]) !== (ring[j][1] > point[1])) &&
                        (point[0] < (ring[j][0] - ring[i][0]) * (point[1] - ring[i][1]) / (ring[j][1] - ring[i][1]) + ring[i][0])) {
                        inPoly = !inPoly;
                    }
                }
                return inPoly;
        };

        return {
            init: function (m, options) {
                mizarWidgetAPI = m;
                votable2geojsonUrl = "TODO must be implemented in JS";//options.votable2geojson.baseUrl;
                //TODO must be implemented in JS
            },

            inherits: function (base, sub) {
                function TempCtor() {
                }

                TempCtor.prototype = base.prototype;
                sub.prototype = new TempCtor();
                sub.prototype.constructor = sub;
            },

            /**
             *    Generate eye-friendly color based on hsv
             */
            generateColor: function () {
                //use golden ratio
                var golden_ratio_conjugate = 0.618033988749895;
                var h = Math.random();
                h += golden_ratio_conjugate;
                h %= 1;
                return hsv_to_rgb(h, 0.5, 0.95);
            },

            /**
             *    Format the given feature identifier to remove special caracters(as ?, [, ], ., etc..) which cannot be used as HTML id's
             */
            formatId: function (id) {
                if (typeof id === 'string') {
                  return id.replace(/\s{1,}|\.{1,}|\[{1,}|\]{1,}|\({1,}|\){1,}|\~{1,}|\+{1,}|\{1,}|\-{1,}|\'{1,}|\"{1,}/g, "");
                } else {
                  return id;
                }
            },

            /**
             *    Get GeoJson polygon coordinates representing fits using wcs data from header
             */
            getPolygonCoordinatesFromFits: function (fits) {
                var hdu = fits.getHDU();
                var fitsData = hdu.data;

                // Create mapper
                wcs = new WCS.Mapper(hdu.header);
                var coords = [];

                // Debug test: isn't working currently
                //var test = wcs.coordinateToPixel(99.77120833333333, 5.540722222222222);
                //var iTest = wcs.pixelToCoordinate([4844.563607341353, 0.46768419804220684]);

                // Find coordinates of coming fits
                coords.push(createCoordinate(0, fitsData.height));
                coords.push(createCoordinate(fitsData.width, fitsData.height));
                coords.push(createCoordinate(fitsData.width, 0));
                coords.push(createCoordinate(0, 0));
                // Close the polygon
                coords.push(coords[0]);
                return coords;
            },

            /**
             *    Compute barycenter of the given GeoJSON geometry
             */
            computeGeometryBarycenter: function (geometry) {
                var sLonBarycenter;
                var sLatBarycenter;
                var sLon = 0;
                var sLat = 0;
                var nbPoints = 0;
                switch (geometry.type) {
                    case mizarWidgetAPI.GEOMETRY.MultiLineString:
                        sLonBarycenter = geometry.coordinates[0][0][0];
                        sLatBarycenter = geometry.coordinates[0][0][1];
                        break;
                    case mizarWidgetAPI.GEOMETRY.LineString:
                        sLonBarycenter = geometry.coordinates[0][0];
                        sLatBarycenter = geometry.coordinates[0][1];
                        break;
                    case mizarWidgetAPI.GEOMETRY.Point:
                        sLonBarycenter = geometry.coordinates[0];
                        sLatBarycenter = geometry.coordinates[1];
                        break;
                    case mizarWidgetAPI.GEOMETRY.Polygon:
                        for (var i = 0; i < geometry.coordinates[0].length - 1; i++) {
                            sLon += geometry.coordinates[0][i][0];
                            sLat += geometry.coordinates[0][i][1];
                            nbPoints++;
                        }
                        sLonBarycenter = sLon / nbPoints;
                        sLatBarycenter = sLat / nbPoints;
                        break;
                    case mizarWidgetAPI.GEOMETRY.MultiPolygon:
                        for (var i = 0; i < geometry.coordinates.length; i++) {
                            var polygon = geometry.coordinates[i][0];
                            for (var j = 0; j < polygon.length - 1; j++) {
                                sLon += polygon[j][0];
                                sLat += polygon[j][1];
                                nbPoints++;
                            }
                        }
                        sLonBarycenter = sLon / nbPoints;
                        sLatBarycenter = sLat / nbPoints;
                        break;
                    case mizarWidgetAPI.GEOMETRY.LineString:
                        //TODO change into boucle
                        //TODO Already defined above !!!!
/*                        _.each(geometry.coordinates, function (value, i) {
                            sLon += value[0];
                            sLat += value[1];
                            nbPoints++;
                        });
  */                      sLonBarycenter = sLon / nbPoints;
                        sLatBarycenter = sLat / nbPoints;
                        break;
                    default:
                        return;
                }

                return [sLonBarycenter, sLatBarycenter];
            },

            /**
             *    Determine if a point lies inside a polygon
             *
             *    @param {Float[]} point Point in geographic coordinates
             *    @param {Float[][]} ring Array of points representing the polygon
             */
            pointInRing: pointInRingSpherical,

            /**
             *    Determine if a point lies inside a sphere of radius depending on viewport
             */
            pointInSphere: function (point, sphere, pointTextureHeight) {
                var point3D = [];
                var sphere3D = [];

                // Compute pixel size vector to offset the points from the earth
                var pixelSizeVector = mizarWidgetAPI.getRenderContext().computePixelSizeVector();

                mizarWidgetAPI.getCrs().get3DFromWorld(point, point3D);
                mizarWidgetAPI.getCrs().get3DFromWorld(sphere, sphere3D);

                var radius = pointTextureHeight * (pixelSizeVector[0] * sphere3D[0] + pixelSizeVector[1] * sphere3D[1] + pixelSizeVector[2] * sphere3D[2] + pixelSizeVector[3]);

                //Calculate the squared distance from the point to the center of the sphere
                var vecDist = [];
                vec3.subtract(point3D, sphere3D, vecDist);
                vecDist = vec3.dot(vecDist, vecDist);

                //Calculate if the squared distance between the sphere's center and the point
                //is less than the squared radius of the sphere
                if (vecDist < radius * radius) {
                    return true;
                }

                //If not, return false
                return false;
            },

            /**
             * Check if a point lies on a line
             * @param point
             * @param segmentStart
             * @param segmentEnd
             * @returns {boolean}
             */
            pointInLine: function (point, segmentStart, segmentEnd) {
                var deltax = segmentEnd[0] - segmentStart[0];
                var deltay, t;
                var liesInXDir = false;

                if (deltax == 0) {
                    liesInXDir = (point[0] == segmentStart[0]);
                } else {
                    t = (point[0] - segmentStart[0]) / deltax;
                    liesInXDir = (t >= 0 && t <= 1);
                }

                if (liesInXDir) {
                    deltay = segmentEnd[1] - segmentStart[1];
                    if (deltax == 0) {
                        return (point[1] == segmentStart[1]);
                    } else {
                        t = (point[1] - segmentStart[1]) / deltay;
                        return (t >= 0 && t <= 1);
                    }
                } else {
                    return false;
                }
            },

            getAstroCoordinatesFromCursorLocation: function (ctx, navigation, LHV) {
                // Find angle between eye and north
                var geoEye = [];
                ctx.getCoordinateSystem().getWorldFrom3D(navigation.center3d, geoEye);

                if (_.isEmpty(LHV))
                    LHV = [];

                ctx.getCoordinateSystem().getLHVTransform(geoEye, LHV);

                return ctx.getCoordinateSystem().formatCoordinates([geoEye[0], geoEye[1]]);
            },

            /**
             * Get coordinates from cursor position.
             * @param event
             * @param ctx
             * @returns parameter
             */
            getHEALPixCutCoordinates: function (event, ctx, navigation) {
                // Find RA/Dec of each corner of viewport
                var coords = [[0, 0], [ctx.getRenderContext().canvas.width, 0], [ctx.getRenderContext().canvas.width, ctx.getRenderContext().canvas.height], [0, ctx.getRenderContext().canvas.height]];
                for (var i = 0; i < coords.length; i++) {
                    var geo = ctx.getLonLatFromPixel(coords[i][0], coords[i][1]);
                    // Convert to RA/Dec
                    //if (geo[0] < 0) {
                    //    geo[0] += 360;
                    //}
                    coords[i] = geo;
                }

                // Find angle between eye and north
                //var geoEye = [];
                //globe.coordinateSystem.from3DToGeo(navigation.center3d, geoEye);
                //
                var LHV = [];
                //globe.coordinateSystem.getLHVTransform(geoEye, LHV);
                //
                //var astro = Utils.formatCoordinates([geoEye[0], geoEye[1]]);

                this.getAstroCoordinatesFromCursorLocation(ctx, navigation, LHV);

                var north = [LHV[4], LHV[5], LHV[6]];
                var cosNorth = vec3.dot(navigation.up, north);
                var radNorth = Math.acos(cosNorth);
                if (isNaN(radNorth)) {
                    console.error("North is NaN'ed...");
                    return;
                }
                var degNorth = radNorth * 180 / Math.PI;

                // Depending on z component of east vector find if angle is positive or negative
                if (globe.renderContext.viewMatrix[8] < 0) {
                    degNorth *= -1;
                }

                var cdelt1 = parseFloat($('#cdelt1').val());
                var cdelt2 = parseFloat($('#cdelt2').val());

                // Get choosen layer
                var healpixLayer = ctx.globe.baseImagery;

                if (!context.fileName) {
                    ErrorDialog.open("FITS fileName isn't defined for HealpixCut service<br/>");
                }

                if (isNaN(cdelt1) || isNaN(cdelt2)) {
                    $('#HEALPixCut').find('input').each(function () {
                        if (!$(this).val()) {
                            $(this).addClass('inputError');
                        }
                    });
                    return;
                }

                return {
                    long1: coords[0][0],
                    lat1: coords[0][1],
                    long2: coords[1][0],
                    lat2: coords[1][1],
                    long3: coords[2][0],
                    lat3: coords[2][1],
                    long4: coords[3][0],
                    lat4: coords[3][1],
                    rotation: degNorth,
                    coordinateSystem: "Equatorial",
                    cdelt1: cdelt1,
                    cdelt2: cdelt2,
                    filename: context.fileName,
                    PHASE: "RUN"
                };
            },



            // Functions used by Mizar_Gui to avoid direct dependencies to GlobWeb

            isHipsFitsLayer: function (obj) {
                return (obj.type ==  Mizar.LAYER.Hips && obj.fitsSupported == true);
            },
            isHipsLayer: function (obj) {
                return (obj.type ==  Mizar.LAYER.Hips && obj.fitsSupported == false);
            },
            isOpenSearchLayer: function (obj) {
                return (obj.type == Mizar.LAYER.OpenSearch);
            },
            isVectorLayer: function (obj) {
                return (obj.type == Mizar.LAYER.Vector);
            },
            isGeoJsonLayer: function (obj) {
                return (obj.type == Mizar.LAYER.GeoJSON);
            },
            isMocLayer: function (obj) {
                return (obj.type == Mizar.LAYER.Moc);
            },
            isHipsCatLayer: function (obj){
                return (obj.type == Mizar.LAYER.HipsCat);
            },

            /**
             * Convert votable to json from url
             * @param {String} url
             * @param {Function} callback
             */
            convertVotable2JsonFromURL: function (url, callback) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url);
                //self = this;
                xhr.onload = function () {
                    var xml = xhr.responseXML;
                    if (xml) {
                        this.convertVotable2JsonFromXML(xhr.responseText, callback);
                    } else {
                        console.log("No XML response");
                    }
                };
                xhr.onerror = function (err) {
                    console.log("Error getting table " + url + "\n" + "(" + err
                        + ")");
                };
                xhr.send(null);
            },

            /**************************************************************************************************************/

            /**
             * Convert votable to json from xml
             * @param {Object} xml xml votable
             * @param {Function} callback
             */
            convertVotable2JsonFromXML: function (xml, callback) {
                try {
                    // Send response of xml to SiTools2 to convert it to GeoJSON
                    $.ajax({
                        type: "POST",
                        url: votable2geojsonUrl,
                        data: {
                            votable: xml,
                            coordinateSystem: "EQUATORIAL"
                        },
                        success: function (response) {
                            callback(response);
                        },
                        error: function (thrownError) {
                            console.error(thrownError);
                        }
                    });
                } catch (e) {
                    console.log("Error displaying table:\n" + e.toString());
                }
            }
        };
    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Error dialog module
 */
define('gui/dialog/ErrorDialog',["jquery", "jquery.ui"], function ($) {

// The main div for error
    var errorDiv = '<div id="errorDiv" style="text-align: justify" title="Error"></div>';

// Create the div, use jQuery UI dialog
    var $errorDiv = $(errorDiv)
        .appendTo('body')
        .dialog({
            autoOpen: false,
            resizable: true,
            draggable: true,
            width: '300px',
            minHeight: 'auto',
            maxHeight: '300px',
            dialogClass: 'errorBox'
        });

    return {
        /**
         *    Open dialog
         *
         *    @param html HTML text
         */
        open: function (html) {
            console.log("htlml",html);
            $errorDiv
                .html(html)
                .dialog("open");
        }
    };

});

/**
 * @license RequireJS text 2.0.5 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
  define: false, window: false, process: false, Packages: false,
  java: false, location: false */

define('text',['module'], function (module) {
    'use strict';

    var text, fs,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = [],
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.5',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node)) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback) {
            var file = fs.readFileSync(url, 'utf8');
            //Remove BOM (Byte Mark Order) from utf8 files if it is there.
            if (file.indexOf('\uFEFF') === 0) {
                file = file.substring(1);
            }
            callback(file);
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                stringBuffer.append(line);

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    }

    return text;
});


define('text!templates/openSearchService.html',[],function () { return '<div id="openSearchTabs">\n    <ul>\n    </ul>\n</div>';});


define('text!templates/openSearchForm.html',[],function () { return '<form class="osForm" id="openSearchForm_<%= layer.id %>">\n    <table>\n    <tr>\n    <%\n    cpt = -1;\n    for(var i=0; i<layer.getServices().queryForm.parameters.length; i++)\n    {\n    var parameter = layer.getServices().queryForm.parameters[i];\n    if (parameter.isDisplayed === true) {\n      cpt++;\n    %>\n    <td><label <%= parameter.titleAttribute %> for="<%= parameter.name %>"><%= parameter.name %></label></td>\n    <td>\n    <%\n    // Options parameter\n    // ==================\n    if (parameter.type === "options")\n    {\n    %>\n      <select name="p_<%= parameter.name %>" id="p_<%= parameter.name %>">\n        <option value="">None</option>\n        <%\n        for(var j=0; j<parameter.options.length; j++)\n        {\n        %>\n        <option <% if ( parameter.options[j] === parameter.currentValue ){ %>selected <%}%> value="<%= parameter.options[j] %>"><%= parameter.options[j] %></option>\n        <%\n        }\n        %>\n        </select>\n        <%\n      } else if (parameter.type === "datetime") {\n        %>\n        <input type="text" id="p_<%= parameter.name %>" <%= parameter.titleAttribute %> <%= parameter.patternAttribute %> class="datetimepicker" value="<%= parameter.currentValue %>" autocomplete="off"></input>\n        <%\n      } else if (parameter.type === "number") {\n        %>\n        <input size="8" type="text" id="p_<%= parameter.name %>" <%= parameter.titleAttribute %> <%= parameter.patternAttribute %> name="<%= parameter.name %>" value="<%= parameter.currentValue %>">\n        <%\n      } else {\n    %>\n      <input size="16" type="text" id="p_<%= parameter.name %>" <%= parameter.titleAttribute %> <%= parameter.patternAttribute %> name="<%= parameter.name %>" value="<%= parameter.currentValue %>">\n    <%\n      } \n      %>\n      </td>\n      <% if (cpt % 2 ===0) {\n      %>\n      </tr><tr>\n      <%\n      }\n     } else {\n      %>\n      <input size="16" type="hidden" id="p_<%= parameter.name %>" value="<%= parameter.currentValue %>">\n      <%\n      }\n    }\n    %>\n      </tr>\n    </table>\n    <button class="submitFormParams" id="submitFormParams">Save parameters</button>\n  </form>\n';});

/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define('jquery-mousewheel',['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

/**
 * @preserve jQuery DateTimePicker
 * @homepage http://xdsoft.net/jqplugins/datetimepicker/
 * @author Chupurnov Valeriy (<chupurnov@gmail.com>)
 */

/**
 * @param {jQuery} $
 */
var datetimepickerFactory = function ($) {
	'use strict';

	var default_options  = {
		i18n: {
			ar: { // Arabic
				months: [
					" ", "", "", "", "", "", "", "", "", " ", " ", " "
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", "", ""]
			},
			ro: { // Romanian
				months: [
					"Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"
				],
				dayOfWeekShort: [
					"Du", "Lu", "Ma", "Mi", "Jo", "Vi", "S"
				],
				dayOfWeek: ["Duminic", "Luni", "Mari", "Miercuri", "Joi", "Vineri", "Smbt"]
			},
			id: { // Indonesian
				months: [
					"Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"
				],
				dayOfWeekShort: [
					"Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"
				],
				dayOfWeek: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
			},
			is: { // Icelandic
				months: [
					"Janar", "Febrar", "Mars", "Aprl", "Ma", "Jn", "Jl", "gst", "September", "Oktber", "Nvember", "Desember"
				],
				dayOfWeekShort: [
					"Sun", "Mn", "ri", "Mi", "Fim", "Fs", "Lau"
				],
				dayOfWeek: ["Sunnudagur", "Mnudagur", "rijudagur", "Mivikudagur", "Fimmtudagur", "Fstudagur", "Laugardagur"]
			},
			bg: { // Bulgarian
				months: [
					"", "", "", "", "", "", "", "", "", "", "", ""
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			fa: { // Persian/Farsi
				months: [
					'', '', '', '', '', '', '', '', '', '', '', ''
				],
				dayOfWeekShort: [
					'', '', ' ', '', '', '', ''
				],
				dayOfWeek: ["", "", "", "", "", "", "", ""]
			},
			ru: { // Russian
				months: [
					'', '', '', '', '', '', '', '', '', '', '', ''
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			uk: { // Ukrainian
				months: [
					'', '', '', '', '', '', '', '', '', '', '', ''
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "'", ""]
			},
			en: { // English
				months: [
					"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
				],
				dayOfWeekShort: [
					"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
				],
				dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
			},
			el: { // 
				months: [
					"", "", "", "", "", "", "", "", "", "", "", ""
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			de: { // German
				months: [
					'Januar', 'Februar', 'Mrz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'
				],
				dayOfWeekShort: [
					"So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"
				],
				dayOfWeek: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
			},
			nl: { // Dutch
				months: [
					"januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"
				],
				dayOfWeekShort: [
					"zo", "ma", "di", "wo", "do", "vr", "za"
				],
				dayOfWeek: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
			},
			tr: { // Turkish
				months: [
					"Ocak", "ubat", "Mart", "Nisan", "Mays", "Haziran", "Temmuz", "Austos", "Eyll", "Ekim", "Kasm", "Aralk"
				],
				dayOfWeekShort: [
					"Paz", "Pts", "Sal", "ar", "Per", "Cum", "Cts"
				],
				dayOfWeek: ["Pazar", "Pazartesi", "Sal", "aramba", "Perembe", "Cuma", "Cumartesi"]
			},
			fr: { //French
				months: [
					"Janvier", "Fvrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "Aot", "Septembre", "Octobre", "Novembre", "Dcembre"
				],
				dayOfWeekShort: [
					"Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"
				],
				dayOfWeek: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"]
			},
			es: { // Spanish
				months: [
					"Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
				],
				dayOfWeekShort: [
					"Dom", "Lun", "Mar", "Mi", "Jue", "Vie", "Sb"
				],
				dayOfWeek: ["Domingo", "Lunes", "Martes", "Mircoles", "Jueves", "Viernes", "Sbado"]
			},
			th: { // Thai
				months: [
					'', '', '', '', '', '', '', '', '', '', '', ''
				],
				dayOfWeekShort: [
					'.', '.', '.', '.', '.', '.', '.'
				],
				dayOfWeek: ["", "", "", "", "", "", "", ""]
			},
			pl: { // Polish
				months: [
					"stycze", "luty", "marzec", "kwiecie", "maj", "czerwiec", "lipiec", "sierpie", "wrzesie", "padziernik", "listopad", "grudzie"
				],
				dayOfWeekShort: [
					"nd", "pn", "wt", "r", "cz", "pt", "sb"
				],
				dayOfWeek: ["niedziela", "poniedziaek", "wtorek", "roda", "czwartek", "pitek", "sobota"]
			},
			pt: { // Portuguese
				months: [
					"Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
				],
				dayOfWeekShort: [
					"Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"
				],
				dayOfWeek: ["Domingo", "Segunda", "Tera", "Quarta", "Quinta", "Sexta", "Sbado"]
			},
			ch: { // Simplified Chinese
				months: [
					"", "", "", "", "", "", "", "", "", "", "", ""
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				]
			},
			se: { // Swedish
				months: [
					"Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September",  "Oktober", "November", "December"
				],
				dayOfWeekShort: [
					"Sn", "Mn", "Tis", "Ons", "Tor", "Fre", "Lr"
				]
			},
			km: { // Khmer ()
				months: [
					"", "", "", "", "", "", "", "", "", "", "", ""
				],
				dayOfWeekShort: ["", "", "", "", "", "", ""],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			kr: { // Korean
				months: [
					"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			it: { // Italian
				months: [
					"Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
				],
				dayOfWeekShort: [
					"Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"
				],
				dayOfWeek: ["Domenica", "Luned", "Marted", "Mercoled", "Gioved", "Venerd", "Sabato"]
			},
			da: { // Dansk
				months: [
					"Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"
				],
				dayOfWeekShort: [
					"Sn", "Man", "Tir", "Ons", "Tor", "Fre", "Lr"
				],
				dayOfWeek: ["sndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lrdag"]
			},
			no: { // Norwegian
				months: [
					"Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"
				],
				dayOfWeekShort: [
					"Sn", "Man", "Tir", "Ons", "Tor", "Fre", "Lr"
				],
				dayOfWeek: ['Sndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag']
			},
			ja: { // Japanese
				months: [
					"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			vi: { // Vietnamese
				months: [
					"Thng 1", "Thng 2", "Thng 3", "Thng 4", "Thng 5", "Thng 6", "Thng 7", "Thng 8", "Thng 9", "Thng 10", "Thng 11", "Thng 12"
				],
				dayOfWeekShort: [
					"CN", "T2", "T3", "T4", "T5", "T6", "T7"
				],
				dayOfWeek: ["Ch nht", "Th hai", "Th ba", "Th t", "Th nm", "Th su", "Th by"]
			},
			sl: { // Slovenina
				months: [
					"Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"
				],
				dayOfWeekShort: [
					"Ned", "Pon", "Tor", "Sre", "et", "Pet", "Sob"
				],
				dayOfWeek: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "etrtek", "Petek", "Sobota"]
			},
			cs: { // etina
				months: [
					"Leden", "nor", "Bezen", "Duben", "Kvten", "erven", "ervenec", "Srpen", "Z", "jen", "Listopad", "Prosinec"
				],
				dayOfWeekShort: [
					"Ne", "Po", "t", "St", "t", "P", "So"
				]
			},
			hu: { // Hungarian
				months: [
					"Janur", "Februr", "Mrcius", "prilis", "Mjus", "Jnius", "Jlius", "Augusztus", "Szeptember", "Oktber", "November", "December"
				],
				dayOfWeekShort: [
					"Va", "H", "Ke", "Sze", "Cs", "P", "Szo"
				],
				dayOfWeek: ["vasrnap", "htf", "kedd", "szerda", "cstrtk", "pntek", "szombat"]
			},
			az: { //Azerbaijanian (Azeri)
				months: [
					"Yanvar", "Fevral", "Mart", "Aprel", "May", "Iyun", "Iyul", "Avqust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr"
				],
				dayOfWeekShort: [
					"B", "Be", "a", "", "Ca", "C", ""
				],
				dayOfWeek: ["Bazar", "Bazar ertsi", "rnb axam", "rnb", "Cm axam", "Cm", "nb"]
			},
			bs: { //Bosanski
				months: [
					"Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"
				],
				dayOfWeekShort: [
					"Ned", "Pon", "Uto", "Sri", "et", "Pet", "Sub"
				],
				dayOfWeek: ["Nedjelja","Ponedjeljak", "Utorak", "Srijeda", "etvrtak", "Petak", "Subota"]
			},
			ca: { //Catal
				months: [
					"Gener", "Febrer", "Mar", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"
				],
				dayOfWeekShort: [
					"Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"
				],
				dayOfWeek: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"]
			},
			'en-GB': { //English (British)
				months: [
					"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
				],
				dayOfWeekShort: [
					"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
				],
				dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
			},
			et: { //"Eesti"
				months: [
					"Jaanuar", "Veebruar", "Mrts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"
				],
				dayOfWeekShort: [
					"P", "E", "T", "K", "N", "R", "L"
				],
				dayOfWeek: ["Phapev", "Esmaspev", "Teisipev", "Kolmapev", "Neljapev", "Reede", "Laupev"]
			},
			eu: { //Euskara
				months: [
					"Urtarrila", "Otsaila", "Martxoa", "Apirila", "Maiatza", "Ekaina", "Uztaila", "Abuztua", "Iraila", "Urria", "Azaroa", "Abendua"
				],
				dayOfWeekShort: [
					"Ig.", "Al.", "Ar.", "Az.", "Og.", "Or.", "La."
				],
				dayOfWeek: ['Igandea', 'Astelehena', 'Asteartea', 'Asteazkena', 'Osteguna', 'Ostirala', 'Larunbata']
			},
			fi: { //Finnish (Suomi)
				months: [
					"Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Keskuu", "Heinkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"
				],
				dayOfWeekShort: [
					"Su", "Ma", "Ti", "Ke", "To", "Pe", "La"
				],
				dayOfWeek: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"]
			},
			gl: { //Galego
				months: [
					"Xan", "Feb", "Maz", "Abr", "Mai", "Xun", "Xul", "Ago", "Set", "Out", "Nov", "Dec"
				],
				dayOfWeekShort: [
					"Dom", "Lun", "Mar", "Mer", "Xov", "Ven", "Sab"
				],
				dayOfWeek: ["Domingo", "Luns", "Martes", "Mrcores", "Xoves", "Venres", "Sbado"]
			},
			hr: { //Hrvatski
				months: [
					"Sijeanj", "Veljaa", "Oujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"
				],
				dayOfWeekShort: [
					"Ned", "Pon", "Uto", "Sri", "et", "Pet", "Sub"
				],
				dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "etvrtak", "Petak", "Subota"]
			},
			ko: { //Korean ()
				months: [
					"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			lt: { //Lithuanian (lietuvi)
				months: [
					"Sausio", "Vasario", "Kovo", "Balandio", "Gegus", "Birelio", "Liepos", "Rugpjio", "Rugsjo", "Spalio", "Lapkriio", "Gruodio"
				],
				dayOfWeekShort: [
					"Sek", "Pir", "Ant", "Tre", "Ket", "Pen", "e"
				],
				dayOfWeek: ["Sekmadienis", "Pirmadienis", "Antradienis", "Treiadienis", "Ketvirtadienis", "Penktadienis", "etadienis"]
			},
			lv: { //Latvian (Latvieu)
				months: [
					"Janvris", "Februris", "Marts", "Aprlis ", "Maijs", "Jnijs", "Jlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"
				],
				dayOfWeekShort: [
					"Sv", "Pr", "Ot", "Tr", "Ct", "Pk", "St"
				],
				dayOfWeek: ["Svtdiena", "Pirmdiena", "Otrdiena", "Trediena", "Ceturtdiena", "Piektdiena", "Sestdiena"]
			},
			mk: { //Macedonian ()
				months: [
					"", "", "", "", "", "", "", "", "", "", "", ""
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			mn: { //Mongolian ()
				months: [
					"1- ", "2- ", "3- ", "4- ", "5- ", "6- ", "7- ", "8- ", "9- ", "10- ", "11- ", "12- "
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			'pt-BR': { //Portugus(Brasil)
				months: [
					"Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
				],
				dayOfWeekShort: [
					"Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb"
				],
				dayOfWeek: ["Domingo", "Segunda", "Tera", "Quarta", "Quinta", "Sexta", "Sbado"]
			},
			sk: { //Slovenina
				months: [
					"Janur", "Februr", "Marec", "Aprl", "Mj", "Jn", "Jl", "August", "September", "Oktber", "November", "December"
				],
				dayOfWeekShort: [
					"Ne", "Po", "Ut", "St", "t", "Pi", "So"
				],
				dayOfWeek: ["Nedea", "Pondelok", "Utorok", "Streda", "tvrtok", "Piatok", "Sobota"]
			},
			sq: { //Albanian (Shqip)
				months: [
					"Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nntor", "Dhjetor"
				],
				dayOfWeekShort: [
					"Die", "Hn", "Mar", "Mr", "Enj", "Pre", "Shtu"
				],
				dayOfWeek: ["E Diel", "E Hn", "E Mart", "E Mrkur", "E Enjte", "E Premte", "E Shtun"]
			},
			'sr-YU': { //Serbian (Srpski)
				months: [
					"Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"
				],
				dayOfWeekShort: [
					"Ned", "Pon", "Uto", "Sre", "et", "Pet", "Sub"
				],
				dayOfWeek: ["Nedelja","Ponedeljak", "Utorak", "Sreda", "etvrtak", "Petak", "Subota"]
			},
			sr: { //Serbian Cyrillic ()
				months: [
					"", "", "", "", "", "", "", "", "", "", "", ""
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["","", "", "", "", "", ""]
			},
			sv: { //Svenska
				months: [
					"Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"
				],
				dayOfWeekShort: [
					"Sn", "Mn", "Tis", "Ons", "Tor", "Fre", "Lr"
				],
				dayOfWeek: ["Sndag", "Mndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lrdag"]
			},
			'zh-TW': { //Traditional Chinese ()
				months: [
					"", "", "", "", "", "", "", "", "", "", "", ""
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			zh: { //Simplified Chinese ()
				months: [
					"", "", "", "", "", "", "", "", "", "", "", ""
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			ug:{ // Uyghur()
				months: [
					"1-","2-","3-","4-","5-","6-","7-","8-","9-","10-","11-","12-"
				],
				dayOfWeek: [
					"", "","","","","",""
				]
			},
			he: { //Hebrew ()
				months: [
					'', '', '', '', '', '', '', '', '', '', '', ''
				],
				dayOfWeekShort: [
					'\'', '\'', '\'', '\'', '\'', '\'', ''
				],
				dayOfWeek: ["", "", "", "", "", "", "", ""]
			},
			hy: { // Armenian
				months: [
					"", "", "", "", "", "", "", "", "", "", "", ""
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			},
			kg: { // Kyrgyz
				months: [
					' ', ' ', ' ', ' ', '', '', '', ' ', ' ', ' ', ' ', ' '
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: [
					"", "", "", "", "", "", ""
				]
			},
			rm: { // Romansh
				months: [
					"Schaner", "Favrer", "Mars", "Avrigl", "Matg", "Zercladur", "Fanadur", "Avust", "Settember", "October", "November", "December"
				],
				dayOfWeekShort: [
					"Du", "Gli", "Ma", "Me", "Gie", "Ve", "So"
				],
				dayOfWeek: [
					"Dumengia", "Glindesdi", "Mardi", "Mesemna", "Gievgia", "Venderdi", "Sonda"
				]
			},
			ka: { // Georgian
				months: [
					'', '', '', '', '', '', '', '', '', '', '', ''
				],
				dayOfWeekShort: [
					"", "", "", "", "", "", ""
				],
				dayOfWeek: ["", "", "", "", "", "", ""]
			}
		},

		ownerDocument: document,
		contentWindow: window,

		value: '',
		rtl: false,

		format:	'Y/m/d H:i',
		formatTime:	'H:i',
		formatDate:	'Y/m/d',

		startDate:	false, // new Date(), '1986/12/08', '-1970/01/05','-1970/01/05',
		step: 60,
		monthChangeSpinner: true,

		closeOnDateSelect: false,
		closeOnTimeSelect: true,
		closeOnWithoutClick: true,
		closeOnInputClick: true,
		openOnFocus: true,

		timepicker: true,
		datepicker: true,
		weeks: false,

		defaultTime: false,	// use formatTime format (ex. '10:00' for formatTime:	'H:i')
		defaultDate: false,	// use formatDate format (ex new Date() or '1986/12/08' or '-1970/01/05' or '-1970/01/05')

		minDate: false,
		maxDate: false,
		minTime: false,
		maxTime: false,
		minDateTime: false,
		maxDateTime: false,

		allowTimes: [],
		opened: false,
		initTime: true,
		inline: false,
		theme: '',
		touchMovedThreshold: 5,

		onSelectDate: function () {},
		onSelectTime: function () {},
		onChangeMonth: function () {},
		onGetWeekOfYear: function () {},
		onChangeYear: function () {},
		onChangeDateTime: function () {},
		onShow: function () {},
		onClose: function () {},
		onGenerate: function () {},

		withoutCopyright: true,
		inverseButton: false,
		hours12: false,
		next: 'xdsoft_next',
		prev : 'xdsoft_prev',
		dayOfWeekStart: 0,
		parentID: 'body',
		timeHeightInTimePicker: 25,
		timepickerScrollbar: true,
		todayButton: true,
		prevButton: true,
		nextButton: true,
		defaultSelect: true,

		scrollMonth: true,
		scrollTime: true,
		scrollInput: true,

		lazyInit: false,
		mask: false,
		validateOnBlur: true,
		allowBlank: true,
		yearStart: 1950,
		yearEnd: 2050,
		monthStart: 0,
		monthEnd: 11,
		style: '',
		id: '',
		fixed: false,
		roundTime: 'round', // ceil, floor
		className: '',
		weekends: [],
		highlightedDates: [],
		highlightedPeriods: [],
		allowDates : [],
		allowDateRe : null,
		disabledDates : [],
		disabledWeekDays: [],
		yearOffset: 0,
		beforeShowDay: null,

		enterLikeTab: true,
		showApplyButton: false
	};

	var dateHelper = null,
		defaultDateHelper = null,
		globalLocaleDefault = 'en',
		globalLocale = 'en';

	var dateFormatterOptionsDefault = {
		meridiem: ['AM', 'PM']
	};

	var initDateFormatter = function(){
		var locale = default_options.i18n[globalLocale],
			opts = {
				days: locale.dayOfWeek,
				daysShort: locale.dayOfWeekShort,
				months: locale.months,
				monthsShort: $.map(locale.months, function(n){ return n.substring(0, 3) })
			};

		if (typeof DateFormatter === 'function') {
			dateHelper = defaultDateHelper = new DateFormatter({
				dateSettings: $.extend({}, dateFormatterOptionsDefault, opts)
			});
		}
	};

	var dateFormatters = {
		moment: {
			default_options:{
				format: 'YYYY/MM/DD HH:mm',
				formatDate: 'YYYY/MM/DD',
				formatTime: 'HH:mm',
			},
			formatter: {
				parseDate: function (date, format) {
					if(isFormatStandard(format)){
						return defaultDateHelper.parseDate(date, format);
					} 
					var d = moment(date, format);
					return d.isValid() ? d.toDate() : false;
				},

				formatDate: function (date, format) {
					if(isFormatStandard(format)){
						return defaultDateHelper.formatDate(date, format);
					} 
					return moment(date).format(format);
				},

				formatMask: function(format){
					return format
						.replace(/Y{4}/g, '9999')
						.replace(/Y{2}/g, '99')
						.replace(/M{2}/g, '19')
						.replace(/D{2}/g, '39')
						.replace(/H{2}/g, '29')
						.replace(/m{2}/g, '59')
						.replace(/s{2}/g, '59');
				},
			}
		}
	}

	// for locale settings
	$.datetimepicker = {
		setLocale: function(locale){
			var newLocale = default_options.i18n[locale] ? locale : globalLocaleDefault;
			if (globalLocale !== newLocale) {
				globalLocale = newLocale;
				// reinit date formatter
				initDateFormatter();
			}
		},

		setDateFormatter: function(dateFormatter) {
			if(typeof dateFormatter === 'string' && dateFormatters.hasOwnProperty(dateFormatter)){
				var df = dateFormatters[dateFormatter];
				$.extend(default_options, df.default_options);
				dateHelper = df.formatter; 
			}
			else {
				dateHelper = dateFormatter;
			}
		},
	};

	var standardFormats = {
		RFC_2822: 'D, d M Y H:i:s O',
		ATOM: 'Y-m-d\TH:i:sP',
		ISO_8601: 'Y-m-d\TH:i:sO',
		RFC_822: 'D, d M y H:i:s O',
		RFC_850: 'l, d-M-y H:i:s T',
		RFC_1036: 'D, d M y H:i:s O',
		RFC_1123: 'D, d M Y H:i:s O',
		RSS: 'D, d M Y H:i:s O',
		W3C: 'Y-m-d\TH:i:sP'
	}

	var isFormatStandard = function(format){
		return Object.values(standardFormats).indexOf(format) === -1 ? false : true;
	}

	$.extend($.datetimepicker, standardFormats);

	// first init date formatter
	initDateFormatter();

	// fix for ie8
	if (!window.getComputedStyle) {
		window.getComputedStyle = function (el) {
			this.el = el;
			this.getPropertyValue = function (prop) {
				var re = /(-([a-z]))/g;
				if (prop === 'float') {
					prop = 'styleFloat';
				}
				if (re.test(prop)) {
					prop = prop.replace(re, function (a, b, c) {
						return c.toUpperCase();
					});
				}
				return el.currentStyle[prop] || null;
			};
			return this;
		};
	}
	if (!Array.prototype.indexOf) {
		Array.prototype.indexOf = function (obj, start) {
			var i, j;
			for (i = (start || 0), j = this.length; i < j; i += 1) {
				if (this[i] === obj) { return i; }
			}
			return -1;
		};
	}

	Date.prototype.countDaysInMonth = function () {
		return new Date(this.getFullYear(), this.getMonth() + 1, 0).getDate();
	};

	$.fn.xdsoftScroller = function (options, percent) {
		return this.each(function () {
			var timeboxparent = $(this),
				pointerEventToXY = function (e) {
					var out = {x: 0, y: 0},
						touch;
					if (e.type === 'touchstart' || e.type === 'touchmove' || e.type === 'touchend' || e.type === 'touchcancel') {
						touch  = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
						out.x = touch.clientX;
						out.y = touch.clientY;
					} else if (e.type === 'mousedown' || e.type === 'mouseup' || e.type === 'mousemove' || e.type === 'mouseover' || e.type === 'mouseout' || e.type === 'mouseenter' || e.type === 'mouseleave') {
						out.x = e.clientX;
						out.y = e.clientY;
					}
					return out;
				},
				timebox,
				parentHeight,
				height,
				scrollbar,
				scroller,
				maximumOffset = 100,
				start = false,
				startY = 0,
				startTop = 0,
				h1 = 0,
				touchStart = false,
				startTopScroll = 0,
				calcOffset = function () {};

			if (percent === 'hide') {
				timeboxparent.find('.xdsoft_scrollbar').hide();
				return;
			}

			if (!$(this).hasClass('xdsoft_scroller_box')) {
				timebox = timeboxparent.children().eq(0);
				parentHeight = timeboxparent[0].clientHeight;
				height = timebox[0].offsetHeight;
				scrollbar = $('<div class="xdsoft_scrollbar"></div>');
				scroller = $('<div class="xdsoft_scroller"></div>');
				scrollbar.append(scroller);

				timeboxparent.addClass('xdsoft_scroller_box').append(scrollbar);
				calcOffset = function calcOffset(event) {
					var offset = pointerEventToXY(event).y - startY + startTopScroll;
					if (offset < 0) {
						offset = 0;
					}
					if (offset + scroller[0].offsetHeight > h1) {
						offset = h1 - scroller[0].offsetHeight;
					}
					timeboxparent.trigger('scroll_element.xdsoft_scroller', [maximumOffset ? offset / maximumOffset : 0]);
				};

				scroller
					.on('touchstart.xdsoft_scroller mousedown.xdsoft_scroller', function (event) {
						if (!parentHeight) {
							timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
						}

						startY = pointerEventToXY(event).y;
						startTopScroll = parseInt(scroller.css('margin-top'), 10);
						h1 = scrollbar[0].offsetHeight;

						if (event.type === 'mousedown' || event.type === 'touchstart') {
							if (options.ownerDocument) {
								$(options.ownerDocument.body).addClass('xdsoft_noselect');
							}
							$([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft_scroller', function arguments_callee() {
								$([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft_scroller', arguments_callee)
									.off('mousemove.xdsoft_scroller', calcOffset)
									.removeClass('xdsoft_noselect');
							});
							$(options.ownerDocument.body).on('mousemove.xdsoft_scroller', calcOffset);
						} else {
							touchStart = true;
							event.stopPropagation();
							event.preventDefault();
						}
					})
					.on('touchmove', function (event) {
						if (touchStart) {
							event.preventDefault();
							calcOffset(event);
						}
					})
					.on('touchend touchcancel', function () {
						touchStart =  false;
						startTopScroll = 0;
					});

				timeboxparent
					.on('scroll_element.xdsoft_scroller', function (event, percentage) {
						if (!parentHeight) {
							timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percentage, true]);
						}
						percentage = percentage > 1 ? 1 : (percentage < 0 || isNaN(percentage)) ? 0 : percentage;

						scroller.css('margin-top', maximumOffset * percentage);

						setTimeout(function () {
							timebox.css('marginTop', -parseInt((timebox[0].offsetHeight - parentHeight) * percentage, 10));
						}, 10);
					})
					.on('resize_scroll.xdsoft_scroller', function (event, percentage, noTriggerScroll) {
						var percent, sh;
						parentHeight = timeboxparent[0].clientHeight;
						height = timebox[0].offsetHeight;
						percent = parentHeight / height;
						sh = percent * scrollbar[0].offsetHeight;
						if (percent > 1) {
							scroller.hide();
						} else {
							scroller.show();
							scroller.css('height', parseInt(sh > 10 ? sh : 10, 10));
							maximumOffset = scrollbar[0].offsetHeight - scroller[0].offsetHeight;
							if (noTriggerScroll !== true) {
								timeboxparent.trigger('scroll_element.xdsoft_scroller', [percentage || Math.abs(parseInt(timebox.css('marginTop'), 10)) / (height - parentHeight)]);
							}
						}
					});

				timeboxparent.on('mousewheel', function (event) {
					var top = Math.abs(parseInt(timebox.css('marginTop'), 10));

					top = top - (event.deltaY * 20);
					if (top < 0) {
						top = 0;
					}

					timeboxparent.trigger('scroll_element.xdsoft_scroller', [top / (height - parentHeight)]);
					event.stopPropagation();
					return false;
				});

				timeboxparent.on('touchstart', function (event) {
					start = pointerEventToXY(event);
					startTop = Math.abs(parseInt(timebox.css('marginTop'), 10));
				});

				timeboxparent.on('touchmove', function (event) {
					if (start) {
						event.preventDefault();
						var coord = pointerEventToXY(event);
						timeboxparent.trigger('scroll_element.xdsoft_scroller', [(startTop - (coord.y - start.y)) / (height - parentHeight)]);
					}
				});

				timeboxparent.on('touchend touchcancel', function () {
					start = false;
					startTop = 0;
				});
			}
			timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
		});
	};

	$.fn.datetimepicker = function (opt, opt2) {
		var result = this,
			KEY0 = 48,
			KEY9 = 57,
			_KEY0 = 96,
			_KEY9 = 105,
			CTRLKEY = 17,
			DEL = 46,
			ENTER = 13,
			ESC = 27,
			BACKSPACE = 8,
			ARROWLEFT = 37,
			ARROWUP = 38,
			ARROWRIGHT = 39,
			ARROWDOWN = 40,
			TAB = 9,
			F5 = 116,
			AKEY = 65,
			CKEY = 67,
			VKEY = 86,
			ZKEY = 90,
			YKEY = 89,
			ctrlDown	=	false,
			options = ($.isPlainObject(opt) || !opt) ? $.extend(true, {}, default_options, opt) : $.extend(true, {}, default_options),

			lazyInitTimer = 0,
			createDateTimePicker,
			destroyDateTimePicker,

			lazyInit = function (input) {
				input
					.on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function initOnActionCallback() {
						if (input.is(':disabled') || input.data('xdsoft_datetimepicker')) {
							return;
						}
						clearTimeout(lazyInitTimer);
						lazyInitTimer = setTimeout(function () {

							if (!input.data('xdsoft_datetimepicker')) {
								createDateTimePicker(input);
							}
							input
								.off('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', initOnActionCallback)
								.trigger('open.xdsoft');
						}, 100);
					});
			};

		createDateTimePicker = function (input) {
			var datetimepicker = $('<div class="xdsoft_datetimepicker xdsoft_noselect"></div>'),
				xdsoft_copyright = $('<div class="xdsoft_copyright"><a target="_blank" href="http://xdsoft.net/jqplugins/datetimepicker/">xdsoft.net</a></div>'),
				datepicker = $('<div class="xdsoft_datepicker active"></div>'),
				month_picker = $('<div class="xdsoft_monthpicker"><button type="button" class="xdsoft_prev"></button><button type="button" class="xdsoft_today_button"></button>' +
					'<div class="xdsoft_label xdsoft_month"><span></span><i></i></div>' +
					'<div class="xdsoft_label xdsoft_year"><span></span><i></i></div>' +
					'<button type="button" class="xdsoft_next"></button></div>'),
				calendar = $('<div class="xdsoft_calendar"></div>'),
				timepicker = $('<div class="xdsoft_timepicker active"><button type="button" class="xdsoft_prev"></button><div class="xdsoft_time_box"></div><button type="button" class="xdsoft_next"></button></div>'),
				timeboxparent = timepicker.find('.xdsoft_time_box').eq(0),
				timebox = $('<div class="xdsoft_time_variant"></div>'),
				applyButton = $('<button type="button" class="xdsoft_save_selected blue-gradient-button">Save Selected</button>'),

				monthselect = $('<div class="xdsoft_select xdsoft_monthselect"><div></div></div>'),
				yearselect = $('<div class="xdsoft_select xdsoft_yearselect"><div></div></div>'),
				triggerAfterOpen = false,
				XDSoft_datetime,

				xchangeTimer,
				timerclick,
				current_time_index,
				setPos,
				timer = 0,
				_xdsoft_datetime,
				forEachAncestorOf;

			if (options.id) {
				datetimepicker.attr('id', options.id);
			}
			if (options.style) {
				datetimepicker.attr('style', options.style);
			}
			if (options.weeks) {
				datetimepicker.addClass('xdsoft_showweeks');
			}
			if (options.rtl) {
				datetimepicker.addClass('xdsoft_rtl');
			}

			datetimepicker.addClass('xdsoft_' + options.theme);
			datetimepicker.addClass(options.className);

			month_picker
				.find('.xdsoft_month span')
				.after(monthselect);
			month_picker
				.find('.xdsoft_year span')
				.after(yearselect);

			month_picker
				.find('.xdsoft_month,.xdsoft_year')
				.on('touchstart mousedown.xdsoft', function (event) {
					var select = $(this).find('.xdsoft_select').eq(0),
						val = 0,
						top = 0,
						visible = select.is(':visible'),
						items,
						i;

					month_picker
						.find('.xdsoft_select')
						.hide();
					if (_xdsoft_datetime.currentTime) {
						val = _xdsoft_datetime.currentTime[$(this).hasClass('xdsoft_month') ? 'getMonth' : 'getFullYear']();
					}

					select[visible ? 'hide' : 'show']();
					for (items = select.find('div.xdsoft_option'), i = 0; i < items.length; i += 1) {
						if (items.eq(i).data('value') === val) {
							break;
						} else {
							top += items[0].offsetHeight;
						}
					}

					select.xdsoftScroller(options, top / (select.children()[0].offsetHeight - (select[0].clientHeight)));
					event.stopPropagation();
					return false;
				});

			var handleTouchMoved = function (event) {
				var evt = event.originalEvent;
				var touchPosition = evt.touches ? evt.touches[0] : evt;
				this.touchStartPosition = this.touchStartPosition || touchPosition;
				var xMovement = Math.abs(this.touchStartPosition.clientX - touchPosition.clientX);
				var yMovement = Math.abs(this.touchStartPosition.clientY - touchPosition.clientY);
				var distance = Math.sqrt(xMovement * xMovement + yMovement * yMovement);
				if(distance > options.touchMovedThreshold) {
					this.touchMoved = true;
				}
			}

			month_picker
				.find('.xdsoft_select')
				.xdsoftScroller(options)
				.on('touchstart mousedown.xdsoft', function (event) {
					var evt = event.originalEvent;
					this.touchMoved = false;
					this.touchStartPosition = evt.touches ? evt.touches[0] : evt;
					event.stopPropagation();
					event.preventDefault();
				})
				.on('touchmove', '.xdsoft_option', handleTouchMoved)
				.on('touchend mousedown.xdsoft', '.xdsoft_option', function () {
					if (!this.touchMoved) {
						if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
							_xdsoft_datetime.currentTime = _xdsoft_datetime.now();
						}

						var year = _xdsoft_datetime.currentTime.getFullYear();
						if (_xdsoft_datetime && _xdsoft_datetime.currentTime) {
							_xdsoft_datetime.currentTime[$(this).parent().parent().hasClass('xdsoft_monthselect') ? 'setMonth' : 'setFullYear']($(this).data('value'));
						}

						$(this).parent().parent().hide();

						datetimepicker.trigger('xchange.xdsoft');
						if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
							options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
						}

						if (year !== _xdsoft_datetime.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
							options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
						}
					}
				});

			datetimepicker.getValue = function () {
				return _xdsoft_datetime.getCurrentTime();
			};

			datetimepicker.setOptions = function (_options) {
				var highlightedDates = {};

				options = $.extend(true, {}, options, _options);

				if (_options.allowTimes && $.isArray(_options.allowTimes) && _options.allowTimes.length) {
					options.allowTimes = $.extend(true, [], _options.allowTimes);
				}

				if (_options.weekends && $.isArray(_options.weekends) && _options.weekends.length) {
					options.weekends = $.extend(true, [], _options.weekends);
				}

				if (_options.allowDates && $.isArray(_options.allowDates) && _options.allowDates.length) {
					options.allowDates = $.extend(true, [], _options.allowDates);
				}

				if (_options.allowDateRe && Object.prototype.toString.call(_options.allowDateRe)==="[object String]") {
					options.allowDateRe = new RegExp(_options.allowDateRe);
				}

				if (_options.highlightedDates && $.isArray(_options.highlightedDates) && _options.highlightedDates.length) {
					$.each(_options.highlightedDates, function (index, value) {
						var splitData = $.map(value.split(','), $.trim),
							exDesc,
							hDate = new HighlightedDate(dateHelper.parseDate(splitData[0], options.formatDate), splitData[1], splitData[2]), // date, desc, style
							keyDate = dateHelper.formatDate(hDate.date, options.formatDate);
						if (highlightedDates[keyDate] !== undefined) {
							exDesc = highlightedDates[keyDate].desc;
							if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
								highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
							}
						} else {
							highlightedDates[keyDate] = hDate;
						}
					});

					options.highlightedDates = $.extend(true, [], highlightedDates);
				}

				if (_options.highlightedPeriods && $.isArray(_options.highlightedPeriods) && _options.highlightedPeriods.length) {
					highlightedDates = $.extend(true, [], options.highlightedDates);
					$.each(_options.highlightedPeriods, function (index, value) {
						var dateTest, // start date
							dateEnd,
							desc,
							hDate,
							keyDate,
							exDesc,
							style;
						if ($.isArray(value)) {
							dateTest = value[0];
							dateEnd = value[1];
							desc = value[2];
							style = value[3];
						}
						else {
							var splitData = $.map(value.split(','), $.trim);
							dateTest = dateHelper.parseDate(splitData[0], options.formatDate);
							dateEnd = dateHelper.parseDate(splitData[1], options.formatDate);
							desc = splitData[2];
							style = splitData[3];
						}

						while (dateTest <= dateEnd) {
							hDate = new HighlightedDate(dateTest, desc, style);
							keyDate = dateHelper.formatDate(dateTest, options.formatDate);
							dateTest.setDate(dateTest.getDate() + 1);
							if (highlightedDates[keyDate] !== undefined) {
								exDesc = highlightedDates[keyDate].desc;
								if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
									highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
								}
							} else {
								highlightedDates[keyDate] = hDate;
							}
						}
					});

					options.highlightedDates = $.extend(true, [], highlightedDates);
				}

				if (_options.disabledDates && $.isArray(_options.disabledDates) && _options.disabledDates.length) {
					options.disabledDates = $.extend(true, [], _options.disabledDates);
				}

				if (_options.disabledWeekDays && $.isArray(_options.disabledWeekDays) && _options.disabledWeekDays.length) {
					options.disabledWeekDays = $.extend(true, [], _options.disabledWeekDays);
				}

				if ((options.open || options.opened) && (!options.inline)) {
					input.trigger('open.xdsoft');
				}

				if (options.inline) {
					triggerAfterOpen = true;
					datetimepicker.addClass('xdsoft_inline');
					input.after(datetimepicker).hide();
				}

				if (options.inverseButton) {
					options.next = 'xdsoft_prev';
					options.prev = 'xdsoft_next';
				}

				if (options.datepicker) {
					datepicker.addClass('active');
				} else {
					datepicker.removeClass('active');
				}

				if (options.timepicker) {
					timepicker.addClass('active');
				} else {
					timepicker.removeClass('active');
				}

				if (options.value) {
					_xdsoft_datetime.setCurrentTime(options.value);
					if (input && input.val) {
						input.val(_xdsoft_datetime.str);
					}
				}

				if (isNaN(options.dayOfWeekStart)) {
					options.dayOfWeekStart = 0;
				} else {
					options.dayOfWeekStart = parseInt(options.dayOfWeekStart, 10) % 7;
				}

				if (!options.timepickerScrollbar) {
					timeboxparent.xdsoftScroller(options, 'hide');
				}

				if (options.minDate && /^[\+\-](.*)$/.test(options.minDate)) {
					options.minDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.minDate), options.formatDate);
				}

				if (options.maxDate &&  /^[\+\-](.*)$/.test(options.maxDate)) {
					options.maxDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.maxDate), options.formatDate);
				}

                if (options.minDateTime &&  /^\+(.*)$/.test(options.minDateTime)) {
                	options.minDateTime = _xdsoft_datetime.strToDateTime(options.minDateTime).dateFormat(options.formatDate);
                }

                if (options.maxDateTime &&  /^\+(.*)$/.test(options.maxDateTime)) {
                	options.maxDateTime = _xdsoft_datetime.strToDateTime(options.maxDateTime).dateFormat(options.formatDate);
                }

				applyButton.toggle(options.showApplyButton);

				month_picker
					.find('.xdsoft_today_button')
					.css('visibility', !options.todayButton ? 'hidden' : 'visible');

				month_picker
					.find('.' + options.prev)
					.css('visibility', !options.prevButton ? 'hidden' : 'visible');

				month_picker
					.find('.' + options.next)
					.css('visibility', !options.nextButton ? 'hidden' : 'visible');

				setMask(options);

				if (options.validateOnBlur) {
					input
						.off('blur.xdsoft')
						.on('blur.xdsoft', function () {
							if (options.allowBlank && (!$.trim($(this).val()).length ||
									(typeof options.mask === "string" && $.trim($(this).val()) === options.mask.replace(/[0-9]/g, '_')))) {
								$(this).val(null);
								datetimepicker.data('xdsoft_datetime').empty();
							} else {
								var d = dateHelper.parseDate($(this).val(), options.format);
								if (d) { // parseDate() may skip some invalid parts like date or time, so make it clear for user: show parsed date/time
									$(this).val(dateHelper.formatDate(d, options.format));
								} else {
									var splittedHours   = +([$(this).val()[0], $(this).val()[1]].join('')),
										splittedMinutes = +([$(this).val()[2], $(this).val()[3]].join(''));

									// parse the numbers as 0312 => 03:12
									if (!options.datepicker && options.timepicker && splittedHours >= 0 && splittedHours < 24 && splittedMinutes >= 0 && splittedMinutes < 60) {
										$(this).val([splittedHours, splittedMinutes].map(function (item) {
											return item > 9 ? item : '0' + item;
										}).join(':'));
									} else {
										$(this).val(dateHelper.formatDate(_xdsoft_datetime.now(), options.format));
									}
								}
								datetimepicker.data('xdsoft_datetime').setCurrentTime($(this).val());
							}

							datetimepicker.trigger('changedatetime.xdsoft');
							datetimepicker.trigger('close.xdsoft');
						});
				}
				options.dayOfWeekStartPrev = (options.dayOfWeekStart === 0) ? 6 : options.dayOfWeekStart - 1;

				datetimepicker
					.trigger('xchange.xdsoft')
					.trigger('afterOpen.xdsoft');
			};

			datetimepicker
				.data('options', options)
				.on('touchstart mousedown.xdsoft', function (event) {
					event.stopPropagation();
					event.preventDefault();
					yearselect.hide();
					monthselect.hide();
					return false;
				});

			//scroll_element = timepicker.find('.xdsoft_time_box');
			timeboxparent.append(timebox);
			timeboxparent.xdsoftScroller(options);

			datetimepicker.on('afterOpen.xdsoft', function () {
				timeboxparent.xdsoftScroller(options);
			});

			datetimepicker
				.append(datepicker)
				.append(timepicker);

			if (options.withoutCopyright !== true) {
				datetimepicker
					.append(xdsoft_copyright);
			}

			datepicker
				.append(month_picker)
				.append(calendar)
				.append(applyButton);

			$(options.parentID)
				.append(datetimepicker);

			XDSoft_datetime = function () {
				var _this = this;
				_this.now = function (norecursion) {
					var d = new Date(),
						date,
						time;

					if (!norecursion && options.defaultDate) {
						date = _this.strToDateTime(options.defaultDate);
						d.setFullYear(date.getFullYear());
						d.setMonth(date.getMonth());
						d.setDate(date.getDate());
					}

					d.setFullYear(d.getFullYear());

					if (!norecursion && options.defaultTime) {
						time = _this.strtotime(options.defaultTime);
						d.setHours(time.getHours());
						d.setMinutes(time.getMinutes());
						d.setSeconds(time.getSeconds());
						d.setMilliseconds(time.getMilliseconds());
					}
					return d;
				};

				_this.isValidDate = function (d) {
					if (Object.prototype.toString.call(d) !== "[object Date]") {
						return false;
					}
					return !isNaN(d.getTime());
				};

				_this.setCurrentTime = function (dTime, requireValidDate) {
					if (typeof dTime === 'string') {
						_this.currentTime = _this.strToDateTime(dTime);
					}
					else if (_this.isValidDate(dTime)) {
						_this.currentTime = dTime;
					}
					else if (!dTime && !requireValidDate && options.allowBlank && !options.inline) {
						_this.currentTime = null;
					}
					else {
						_this.currentTime = _this.now();
					}

					datetimepicker.trigger('xchange.xdsoft');
				};

				_this.empty = function () {
					_this.currentTime = null;
				};

				_this.getCurrentTime = function () {
					return _this.currentTime;
				};

				_this.nextMonth = function () {

					if (_this.currentTime === undefined || _this.currentTime === null) {
						_this.currentTime = _this.now();
					}

					var month = _this.currentTime.getMonth() + 1,
						year;
					if (month === 12) {
						_this.currentTime.setFullYear(_this.currentTime.getFullYear() + 1);
						month = 0;
					}

					year = _this.currentTime.getFullYear();

					_this.currentTime.setDate(
						Math.min(
							new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(),
							_this.currentTime.getDate()
						)
					);
					_this.currentTime.setMonth(month);

					if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
						options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
					}

					if (year !== _this.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
						options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
					}

					datetimepicker.trigger('xchange.xdsoft');
					return month;
				};

				_this.prevMonth = function () {

					if (_this.currentTime === undefined || _this.currentTime === null) {
						_this.currentTime = _this.now();
					}

					var month = _this.currentTime.getMonth() - 1;
					if (month === -1) {
						_this.currentTime.setFullYear(_this.currentTime.getFullYear() - 1);
						month = 11;
					}
					_this.currentTime.setDate(
						Math.min(
							new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(),
							_this.currentTime.getDate()
						)
					);
					_this.currentTime.setMonth(month);
					if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
						options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
					}
					datetimepicker.trigger('xchange.xdsoft');
					return month;
				};

				_this.getWeekOfYear = function (datetime) {
					if (options.onGetWeekOfYear && $.isFunction(options.onGetWeekOfYear)) {
						var week = options.onGetWeekOfYear.call(datetimepicker, datetime);
						if (typeof week !== 'undefined') {
							return week;
						}
					}
					var onejan = new Date(datetime.getFullYear(), 0, 1);

					//First week of the year is th one with the first Thursday according to ISO8601
					if (onejan.getDay() !== 4) {
						onejan.setMonth(0, 1 + ((4 - onejan.getDay()+ 7) % 7));
					}

					return Math.ceil((((datetime - onejan) / 86400000) + onejan.getDay() + 1) / 7);
				};

				_this.strToDateTime = function (sDateTime) {
					var tmpDate = [], timeOffset, currentTime;

					if (sDateTime && sDateTime instanceof Date && _this.isValidDate(sDateTime)) {
						return sDateTime;
					}

					tmpDate = /^([+-]{1})(.*)$/.exec(sDateTime);

					if (tmpDate) {
						tmpDate[2] = dateHelper.parseDate(tmpDate[2], options.formatDate);
					}

					if (tmpDate  && tmpDate[2]) {
						timeOffset = tmpDate[2].getTime() - (tmpDate[2].getTimezoneOffset()) * 60000;
						currentTime = new Date((_this.now(true)).getTime() + parseInt(tmpDate[1] + '1', 10) * timeOffset);
					} else {
						currentTime = sDateTime ? dateHelper.parseDate(sDateTime, options.format) : _this.now();
					}

					if (!_this.isValidDate(currentTime)) {
						currentTime = _this.now();
					}

					return currentTime;
				};

				_this.strToDate = function (sDate) {
					if (sDate && sDate instanceof Date && _this.isValidDate(sDate)) {
						return sDate;
					}

					var currentTime = sDate ? dateHelper.parseDate(sDate, options.formatDate) : _this.now(true);
					if (!_this.isValidDate(currentTime)) {
						currentTime = _this.now(true);
					}
					return currentTime;
				};

				_this.strtotime = function (sTime) {
					if (sTime && sTime instanceof Date && _this.isValidDate(sTime)) {
						return sTime;
					}
					var currentTime = sTime ? dateHelper.parseDate(sTime, options.formatTime) : _this.now(true);
					if (!_this.isValidDate(currentTime)) {
						currentTime = _this.now(true);
					}
					return currentTime;
				};

				_this.str = function () {
					var format = options.format;
					if (options.yearOffset) {
						format = format.replace('Y', _this.currentTime.getFullYear() + options.yearOffset);
						format = format.replace('y', String(_this.currentTime.getFullYear() + options.yearOffset).substring(2, 4));
					}
					return dateHelper.formatDate(_this.currentTime, format);
				};
				_this.currentTime = this.now();
			};

			_xdsoft_datetime = new XDSoft_datetime();

			applyButton.on('touchend click', function (e) {//pathbrite
				e.preventDefault();
				datetimepicker.data('changed', true);
				_xdsoft_datetime.setCurrentTime(getCurrentValue());
				input.val(_xdsoft_datetime.str());
				datetimepicker.trigger('close.xdsoft');
			});
			month_picker
				.find('.xdsoft_today_button')
				.on('touchend mousedown.xdsoft', function () {
					datetimepicker.data('changed', true);
					_xdsoft_datetime.setCurrentTime(0, true);
					datetimepicker.trigger('afterOpen.xdsoft');
				}).on('dblclick.xdsoft', function () {
				var currentDate = _xdsoft_datetime.getCurrentTime(), minDate, maxDate;
				currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
				minDate = _xdsoft_datetime.strToDate(options.minDate);
				minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
				if (currentDate < minDate) {
					return;
				}
				maxDate = _xdsoft_datetime.strToDate(options.maxDate);
				maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());
				if (currentDate > maxDate) {
					return;
				}
				input.val(_xdsoft_datetime.str());
				input.trigger('change');
				datetimepicker.trigger('close.xdsoft');
			});
			month_picker
				.find('.xdsoft_prev,.xdsoft_next')
				.on('touchend mousedown.xdsoft', function () {
					var $this = $(this),
						timer = 0,
						stop = false;

					(function arguments_callee1(v) {
						if ($this.hasClass(options.next)) {
							_xdsoft_datetime.nextMonth();
						} else if ($this.hasClass(options.prev)) {
							_xdsoft_datetime.prevMonth();
						}
						if (options.monthChangeSpinner) {
							if (!stop) {
								timer = setTimeout(arguments_callee1, v || 100);
							}
						}
					}(500));

					$([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft', function arguments_callee2() {
						clearTimeout(timer);
						stop = true;
						$([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft', arguments_callee2);
					});
				});

			timepicker
				.find('.xdsoft_prev,.xdsoft_next')
				.on('touchend mousedown.xdsoft', function () {
					var $this = $(this),
						timer = 0,
						stop = false,
						period = 110;
					(function arguments_callee4(v) {
						var pheight = timeboxparent[0].clientHeight,
							height = timebox[0].offsetHeight,
							top = Math.abs(parseInt(timebox.css('marginTop'), 10));
						if ($this.hasClass(options.next) && (height - pheight) - options.timeHeightInTimePicker >= top) {
							timebox.css('marginTop', '-' + (top + options.timeHeightInTimePicker) + 'px');
						} else if ($this.hasClass(options.prev) && top - options.timeHeightInTimePicker >= 0) {
							timebox.css('marginTop', '-' + (top - options.timeHeightInTimePicker) + 'px');
						}
						/**
						 * Fixed bug:
						 * When using css3 transition, it will cause a bug that you cannot scroll the timepicker list.
						 * The reason is that the transition-duration time, if you set it to 0, all things fine, otherwise, this
						 * would cause a bug when you use jquery.css method.
						 * Let's say: * { transition: all .5s ease; }
						 * jquery timebox.css('marginTop') will return the original value which is before you clicking the next/prev button,
						 * meanwhile the timebox[0].style.marginTop will return the right value which is after you clicking the
						 * next/prev button.
						 *
						 * What we should do:
						 * Replace timebox.css('marginTop') with timebox[0].style.marginTop.
						 */
						timeboxparent.trigger('scroll_element.xdsoft_scroller', [Math.abs(parseInt(timebox[0].style.marginTop, 10) / (height - pheight))]);
						period = (period > 10) ? 10 : period - 10;
						if (!stop) {
							timer = setTimeout(arguments_callee4, v || period);
						}
					}(500));
					$([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft', function arguments_callee5() {
						clearTimeout(timer);
						stop = true;
						$([options.ownerDocument.body, options.contentWindow])
							.off('touchend mouseup.xdsoft', arguments_callee5);
					});
				});

			xchangeTimer = 0;
			// base handler - generating a calendar and timepicker
			datetimepicker
				.on('xchange.xdsoft', function (event) {
					clearTimeout(xchangeTimer);
					xchangeTimer = setTimeout(function () {

						if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
							_xdsoft_datetime.currentTime = _xdsoft_datetime.now();
						}

						var table =	'',
							start = new Date(_xdsoft_datetime.currentTime.getFullYear(), _xdsoft_datetime.currentTime.getMonth(), 1, 12, 0, 0),
							i = 0,
							j,
							today = _xdsoft_datetime.now(),
							maxDate = false,
							minDate = false,
							minDateTime = false,
							maxDateTime = false,
							hDate,
							day,
							d,
							y,
							m,
							w,
							classes = [],
							customDateSettings,
							newRow = true,
							time = '',
							h,
							line_time,
							description;

						while (start.getDay() !== options.dayOfWeekStart) {
							start.setDate(start.getDate() - 1);
						}

						table += '<table><thead><tr>';

						if (options.weeks) {
							table += '<th></th>';
						}

						for (j = 0; j < 7; j += 1) {
							table += '<th>' + options.i18n[globalLocale].dayOfWeekShort[(j + options.dayOfWeekStart) % 7] + '</th>';
						}

						table += '</tr></thead>';
						table += '<tbody>';

						if (options.maxDate !== false) {
							maxDate = _xdsoft_datetime.strToDate(options.maxDate);
							maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate(), 23, 59, 59, 999);
						}

						if (options.minDate !== false) {
							minDate = _xdsoft_datetime.strToDate(options.minDate);
							minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
						}

                        if (options.minDateTime !== false) {
							minDateTime = _xdsoft_datetime.strToDate(options.minDateTime);
							minDateTime = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), minDateTime.getHours(), minDateTime.getMinutes(), minDateTime.getSeconds());
						}

                        if (options.maxDateTime !== false) {
							maxDateTime = _xdsoft_datetime.strToDate(options.maxDateTime);
							maxDateTime = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), maxDateTime.getHours(), maxDateTime.getMinutes(), maxDateTime.getSeconds());
						}

						var maxDateTimeDay;
						if (maxDateTime !== false) {
							maxDateTimeDay = ((maxDateTime.getFullYear() * 12) + maxDateTime.getMonth()) * 31 + maxDateTime.getDate();
						}

						while (i < _xdsoft_datetime.currentTime.countDaysInMonth() || start.getDay() !== options.dayOfWeekStart || _xdsoft_datetime.currentTime.getMonth() === start.getMonth()) {
							classes = [];
							i += 1;

							day = start.getDay();
							d = start.getDate();
							y = start.getFullYear();
							m = start.getMonth();
							w = _xdsoft_datetime.getWeekOfYear(start);
							description = '';

							classes.push('xdsoft_date');

							if (options.beforeShowDay && $.isFunction(options.beforeShowDay.call)) {
								customDateSettings = options.beforeShowDay.call(datetimepicker, start);
							} else {
								customDateSettings = null;
							}

							if(options.allowDateRe && Object.prototype.toString.call(options.allowDateRe) === "[object RegExp]"){
								if(!options.allowDateRe.test(dateHelper.formatDate(start, options.formatDate))){
									classes.push('xdsoft_disabled');
								}
							}
							
							if(options.allowDates && options.allowDates.length>0){
								if(options.allowDates.indexOf(dateHelper.formatDate(start, options.formatDate)) === -1){
									classes.push('xdsoft_disabled');
								}
							}
							
							var currentDay = ((start.getFullYear() * 12) + start.getMonth()) * 31 + start.getDate();
							if ((maxDate !== false && start > maxDate) || (minDateTime !== false && start < minDateTime)  || (minDate !== false && start < minDate) || (maxDateTime !== false && currentDay > maxDateTimeDay) || (customDateSettings && customDateSettings[0] === false)) {
								classes.push('xdsoft_disabled');
							}
							
							if (options.disabledDates.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
								classes.push('xdsoft_disabled');
							}
							
							if (options.disabledWeekDays.indexOf(day) !== -1) {
								classes.push('xdsoft_disabled');
							}
							
							if (input.is('[disabled]')) {
								classes.push('xdsoft_disabled');
							}

							if (customDateSettings && customDateSettings[1] !== "") {
								classes.push(customDateSettings[1]);
							}

							if (_xdsoft_datetime.currentTime.getMonth() !== m) {
								classes.push('xdsoft_other_month');
							}

							if ((options.defaultSelect || datetimepicker.data('changed')) && dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
								classes.push('xdsoft_current');
							}

							if (dateHelper.formatDate(today, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
								classes.push('xdsoft_today');
							}

							if (start.getDay() === 0 || start.getDay() === 6 || options.weekends.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
								classes.push('xdsoft_weekend');
							}

							if (options.highlightedDates[dateHelper.formatDate(start, options.formatDate)] !== undefined) {
								hDate = options.highlightedDates[dateHelper.formatDate(start, options.formatDate)];
								classes.push(hDate.style === undefined ? 'xdsoft_highlighted_default' : hDate.style);
								description = hDate.desc === undefined ? '' : hDate.desc;
							}

							if (options.beforeShowDay && $.isFunction(options.beforeShowDay)) {
								classes.push(options.beforeShowDay(start));
							}

							if (newRow) {
								table += '<tr>';
								newRow = false;
								if (options.weeks) {
									table += '<th>' + w + '</th>';
								}
							}

							table += '<td data-date="' + d + '" data-month="' + m + '" data-year="' + y + '"' + ' class="xdsoft_date xdsoft_day_of_week' + start.getDay() + ' ' + classes.join(' ') + '" title="' + description + '">' +
								'<div>' + d + '</div>' +
								'</td>';

							if (start.getDay() === options.dayOfWeekStartPrev) {
								table += '</tr>';
								newRow = true;
							}

							start.setDate(d + 1);
						}
						table += '</tbody></table>';

						calendar.html(table);

						month_picker.find('.xdsoft_label span').eq(0).text(options.i18n[globalLocale].months[_xdsoft_datetime.currentTime.getMonth()]);
						month_picker.find('.xdsoft_label span').eq(1).text(_xdsoft_datetime.currentTime.getFullYear() + options.yearOffset);

						// generate timebox
						time = '';
						h = '';
						m = '';

						var minTimeMinutesOfDay = 0;
						if (options.minTime !== false) {
						    var t = _xdsoft_datetime.strtotime(options.minTime);
						    minTimeMinutesOfDay = 60 * t.getHours() + t.getMinutes();
						}
						var maxTimeMinutesOfDay = 24 * 60;
						if (options.maxTime !== false) {
						    var t = _xdsoft_datetime.strtotime(options.maxTime);
						    maxTimeMinutesOfDay = 60 * t.getHours() + t.getMinutes();
						}

						if (options.minDateTime !== false) {
							var t = _xdsoft_datetime.strToDateTime(options.minDateTime);
						        var currentDayIsMinDateTimeDay = dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(t, options.formatDate);
							if (currentDayIsMinDateTimeDay) {
								var m = 60 * t.getHours() + t.getMinutes();
								if (m > minTimeMinutesOfDay) minTimeMinutesOfDay = m;
							}
						}

						if (options.maxDateTime !== false) {
							var t = _xdsoft_datetime.strToDateTime(options.maxDateTime);
						        var currentDayIsMaxDateTimeDay = dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(t, options.formatDate);
							if (currentDayIsMaxDateTimeDay) {
								var m = 60 * t.getHours() + t.getMinutes();
								if (m < maxTimeMinutesOfDay) maxTimeMinutesOfDay = m;
							}
						}

						line_time = function line_time(h, m) {
							var now = _xdsoft_datetime.now(), current_time,
								isALlowTimesInit = options.allowTimes && $.isArray(options.allowTimes) && options.allowTimes.length;
							now.setHours(h);
							h = parseInt(now.getHours(), 10);
							now.setMinutes(m);
							m = parseInt(now.getMinutes(), 10);
							classes = [];
							var currentMinutesOfDay = 60 * h + m;
							if (input.is('[disabled]') || (currentMinutesOfDay >= maxTimeMinutesOfDay) || (currentMinutesOfDay < minTimeMinutesOfDay)) {
								classes.push('xdsoft_disabled');
							}

							current_time = new Date(_xdsoft_datetime.currentTime);
							current_time.setHours(parseInt(_xdsoft_datetime.currentTime.getHours(), 10));

							if (!isALlowTimesInit) {
								current_time.setMinutes(Math[options.roundTime](_xdsoft_datetime.currentTime.getMinutes() / options.step) * options.step);
							}

							if ((options.initTime || options.defaultSelect || datetimepicker.data('changed')) && current_time.getHours() === parseInt(h, 10) && ((!isALlowTimesInit && options.step > 59) || current_time.getMinutes() === parseInt(m, 10))) {
								if (options.defaultSelect || datetimepicker.data('changed')) {
									classes.push('xdsoft_current');
								} else if (options.initTime) {
									classes.push('xdsoft_init_time');
								}
							}
							if (parseInt(today.getHours(), 10) === parseInt(h, 10) && parseInt(today.getMinutes(), 10) === parseInt(m, 10)) {
								classes.push('xdsoft_today');
							}
							time += '<div class="xdsoft_time ' + classes.join(' ') + '" data-hour="' + h + '" data-minute="' + m + '">' + dateHelper.formatDate(now, options.formatTime) + '</div>';
						};

						if (!options.allowTimes || !$.isArray(options.allowTimes) || !options.allowTimes.length) {
							for (i = 0, j = 0; i < (options.hours12 ? 12 : 24); i += 1) {
								for (j = 0; j < 60; j += options.step) {
								        var currentMinutesOfDay = i * 60 + j;
								        if (currentMinutesOfDay < minTimeMinutesOfDay) continue;
								        if (currentMinutesOfDay >= maxTimeMinutesOfDay) continue;
									h = (i < 10 ? '0' : '') + i;
									m = (j < 10 ? '0' : '') + j;
									line_time(h, m);
								}
							}
						} else {
							for (i = 0; i < options.allowTimes.length; i += 1) {
								h = _xdsoft_datetime.strtotime(options.allowTimes[i]).getHours();
								m = _xdsoft_datetime.strtotime(options.allowTimes[i]).getMinutes();
								line_time(h, m);
							}
						}

						timebox.html(time);

						opt = '';

						for (i = parseInt(options.yearStart, 10); i <= parseInt(options.yearEnd, 10); i += 1) {
							opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getFullYear() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + (i + options.yearOffset) + '</div>';
						}
						yearselect.children().eq(0)
							.html(opt);

						for (i = parseInt(options.monthStart, 10), opt = ''; i <= parseInt(options.monthEnd, 10); i += 1) {
							opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getMonth() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + options.i18n[globalLocale].months[i] + '</div>';
						}
						monthselect.children().eq(0).html(opt);
						$(datetimepicker)
							.trigger('generate.xdsoft');
					}, 10);
					event.stopPropagation();
				})
				.on('afterOpen.xdsoft', function () {
					if (options.timepicker) {
						var classType, pheight, height, top;
						if (timebox.find('.xdsoft_current').length) {
							classType = '.xdsoft_current';
						} else if (timebox.find('.xdsoft_init_time').length) {
							classType = '.xdsoft_init_time';
						}
						if (classType) {
							pheight = timeboxparent[0].clientHeight;
							height = timebox[0].offsetHeight;
							top = timebox.find(classType).index() * options.timeHeightInTimePicker + 1;
							if ((height - pheight) < top) {
								top = height - pheight;
							}
							timeboxparent.trigger('scroll_element.xdsoft_scroller', [parseInt(top, 10) / (height - pheight)]);
						} else {
							timeboxparent.trigger('scroll_element.xdsoft_scroller', [0]);
						}
					}
				});

			timerclick = 0;
			calendar
				.on('touchend click.xdsoft', 'td', function (xdevent) {
					xdevent.stopPropagation();  // Prevents closing of Pop-ups, Modals and Flyouts in Bootstrap
					timerclick += 1;
					var $this = $(this),
						currentTime = _xdsoft_datetime.currentTime;

					if (currentTime === undefined || currentTime === null) {
						_xdsoft_datetime.currentTime = _xdsoft_datetime.now();
						currentTime = _xdsoft_datetime.currentTime;
					}

					if ($this.hasClass('xdsoft_disabled')) {
						return false;
					}

					currentTime.setDate(1);
					currentTime.setFullYear($this.data('year'));
					currentTime.setMonth($this.data('month'));
					currentTime.setDate($this.data('date'));

					datetimepicker.trigger('select.xdsoft', [currentTime]);

					input.val(_xdsoft_datetime.str());

					if (options.onSelectDate &&	$.isFunction(options.onSelectDate)) {
						options.onSelectDate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
					}

					datetimepicker.data('changed', true);
					datetimepicker.trigger('xchange.xdsoft');
					datetimepicker.trigger('changedatetime.xdsoft');
					if ((timerclick > 1 || (options.closeOnDateSelect === true || (options.closeOnDateSelect === false && !options.timepicker))) && !options.inline) {
						datetimepicker.trigger('close.xdsoft');
					}
					setTimeout(function () {
						timerclick = 0;
					}, 200);
				});

			timebox
				.on('touchstart', 'div', function (xdevent) {
					this.touchMoved = false;
				})
				.on('touchmove', 'div', handleTouchMoved)
				.on('touchend click.xdsoft', 'div', function (xdevent) {
					if (!this.touchMoved) {
						xdevent.stopPropagation();
						var $this = $(this),
							currentTime = _xdsoft_datetime.currentTime;

						if (currentTime === undefined || currentTime === null) {
							_xdsoft_datetime.currentTime = _xdsoft_datetime.now();
							currentTime = _xdsoft_datetime.currentTime;
						}

						if ($this.hasClass('xdsoft_disabled')) {
							return false;
						}
						currentTime.setHours($this.data('hour'));
						currentTime.setMinutes($this.data('minute'));
						datetimepicker.trigger('select.xdsoft', [currentTime]);

						datetimepicker.data('input').val(_xdsoft_datetime.str());

						if (options.onSelectTime && $.isFunction(options.onSelectTime)) {
							options.onSelectTime.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
						}
						datetimepicker.data('changed', true);
						datetimepicker.trigger('xchange.xdsoft');
						datetimepicker.trigger('changedatetime.xdsoft');
						if (options.inline !== true && options.closeOnTimeSelect === true) {
							datetimepicker.trigger('close.xdsoft');
						}
					}
				});

			datepicker
				.on('mousewheel.xdsoft', function (event) {
					if (!options.scrollMonth) {
						return true;
					}
					if (event.deltaY < 0) {
						_xdsoft_datetime.nextMonth();
					} else {
						_xdsoft_datetime.prevMonth();
					}
					return false;
				});

			input
				.on('mousewheel.xdsoft', function (event) {
					if (!options.scrollInput) {
						return true;
					}
					if (!options.datepicker && options.timepicker) {
						current_time_index = timebox.find('.xdsoft_current').length ? timebox.find('.xdsoft_current').eq(0).index() : 0;
						if (current_time_index + event.deltaY >= 0 && current_time_index + event.deltaY < timebox.children().length) {
							current_time_index += event.deltaY;
						}
						if (timebox.children().eq(current_time_index).length) {
							timebox.children().eq(current_time_index).trigger('mousedown');
						}
						return false;
					}
					if (options.datepicker && !options.timepicker) {
						datepicker.trigger(event, [event.deltaY, event.deltaX, event.deltaY]);
						if (input.val) {
							input.val(_xdsoft_datetime.str());
						}
						datetimepicker.trigger('changedatetime.xdsoft');
						return false;
					}
				});

			datetimepicker
				.on('changedatetime.xdsoft', function (event) {
					if (options.onChangeDateTime && $.isFunction(options.onChangeDateTime)) {
						var $input = datetimepicker.data('input');
						options.onChangeDateTime.call(datetimepicker, _xdsoft_datetime.currentTime, $input, event);
						delete options.value;
						$input.trigger('change');
					}
				})
				.on('generate.xdsoft', function () {
					if (options.onGenerate && $.isFunction(options.onGenerate)) {
						options.onGenerate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
					}
					if (triggerAfterOpen) {
						datetimepicker.trigger('afterOpen.xdsoft');
						triggerAfterOpen = false;
					}
				})
				.on('click.xdsoft', function (xdevent) {
					xdevent.stopPropagation();
				});

			current_time_index = 0;

			/**
			 * Runs the callback for each of the specified node's ancestors.
			 *
			 * Return FALSE from the callback to stop ascending.
			 *
			 * @param {DOMNode} node
			 * @param {Function} callback
			 * @returns {undefined}
			 */
			forEachAncestorOf = function (node, callback) {
				do {
					node = node.parentNode;

					if (!node || callback(node) === false) {
						break;
					}
				} while (node.nodeName !== 'HTML');
			};

			/**
			 * Sets the position of the picker.
			 *
			 * @returns {undefined}
			 */
			setPos = function () {
				var dateInputOffset,
					dateInputElem,
					verticalPosition,
					left,
					position,
					datetimepickerElem,
					dateInputHasFixedAncestor,
					$dateInput,
					windowWidth,
					verticalAnchorEdge,
					datetimepickerCss,
					windowHeight,
					windowScrollTop;

				$dateInput = datetimepicker.data('input');
				dateInputOffset = $dateInput.offset();
				dateInputElem = $dateInput[0];

				verticalAnchorEdge = 'top';
				verticalPosition = (dateInputOffset.top + dateInputElem.offsetHeight) - 1;
				left = dateInputOffset.left;
				position = "absolute";

				windowWidth = $(options.contentWindow).width();
				windowHeight = $(options.contentWindow).height();
				windowScrollTop = $(options.contentWindow).scrollTop();

				if ((options.ownerDocument.documentElement.clientWidth - dateInputOffset.left) < datepicker.parent().outerWidth(true)) {
					var diff = datepicker.parent().outerWidth(true) - dateInputElem.offsetWidth;
					left = left - diff;
				}

				if ($dateInput.parent().css('direction') === 'rtl') {
					left -= (datetimepicker.outerWidth() - $dateInput.outerWidth());
				}

				if (options.fixed) {
					verticalPosition -= windowScrollTop;
					left -= $(options.contentWindow).scrollLeft();
					position = "fixed";
				} else {
					dateInputHasFixedAncestor = false;

					forEachAncestorOf(dateInputElem, function (ancestorNode) {
						if (ancestorNode === null) {
							return false;
						}

						if (options.contentWindow.getComputedStyle(ancestorNode).getPropertyValue('position') === 'fixed') {
							dateInputHasFixedAncestor = true;
							return false;
						}
					});

					if (dateInputHasFixedAncestor) {
						position = 'fixed';

						//If the picker won't fit entirely within the viewport then display it above the date input.
						if (verticalPosition + datetimepicker.outerHeight() > windowHeight + windowScrollTop) {
							verticalAnchorEdge = 'bottom';
							verticalPosition = (windowHeight + windowScrollTop) - dateInputOffset.top;
						} else {
							verticalPosition -= windowScrollTop;
						}
					} else {
						if (verticalPosition + datetimepicker[0].offsetHeight > windowHeight + windowScrollTop) {
							verticalPosition = dateInputOffset.top - datetimepicker[0].offsetHeight + 1;
						}
					}

					if (verticalPosition < 0) {
						verticalPosition = 0;
					}

					if (left + dateInputElem.offsetWidth > windowWidth) {
						left = windowWidth - dateInputElem.offsetWidth;
					}
				}

				datetimepickerElem = datetimepicker[0];

				forEachAncestorOf(datetimepickerElem, function (ancestorNode) {
					var ancestorNodePosition;

					ancestorNodePosition = options.contentWindow.getComputedStyle(ancestorNode).getPropertyValue('position');

					if (ancestorNodePosition === 'relative' && windowWidth >= ancestorNode.offsetWidth) {
						left = left - ((windowWidth - ancestorNode.offsetWidth) / 2);
						return false;
					}
				});

				datetimepickerCss = {
					position: position,
					left: left,
					top: '',  //Initialize to prevent previous values interfering with new ones.
					bottom: ''  //Initialize to prevent previous values interfering with new ones.
				};

				datetimepickerCss[verticalAnchorEdge] = verticalPosition;

				datetimepicker.css(datetimepickerCss);
			};

			datetimepicker
				.on('open.xdsoft', function (event) {
					var onShow = true;
					if (options.onShow && $.isFunction(options.onShow)) {
						onShow = options.onShow.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
					}
					if (onShow !== false) {
						datetimepicker.show();
						setPos();
						$(options.contentWindow)
							.off('resize.xdsoft', setPos)
							.on('resize.xdsoft', setPos);

						if (options.closeOnWithoutClick) {
							$([options.ownerDocument.body, options.contentWindow]).on('touchstart mousedown.xdsoft', function arguments_callee6() {
								datetimepicker.trigger('close.xdsoft');
								$([options.ownerDocument.body, options.contentWindow]).off('touchstart mousedown.xdsoft', arguments_callee6);
							});
						}
					}
				})
				.on('close.xdsoft', function (event) {
					var onClose = true;
					month_picker
						.find('.xdsoft_month,.xdsoft_year')
						.find('.xdsoft_select')
						.hide();
					if (options.onClose && $.isFunction(options.onClose)) {
						onClose = options.onClose.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
					}
					if (onClose !== false && !options.opened && !options.inline) {
						datetimepicker.hide();
					}
					event.stopPropagation();
				})
				.on('toggle.xdsoft', function () {
					if (datetimepicker.is(':visible')) {
						datetimepicker.trigger('close.xdsoft');
					} else {
						datetimepicker.trigger('open.xdsoft');
					}
				})
				.data('input', input);

			timer = 0;

			datetimepicker.data('xdsoft_datetime', _xdsoft_datetime);
			datetimepicker.setOptions(options);

			function getCurrentValue() {
				var ct = false, time;

				if (options.startDate) {
					ct = _xdsoft_datetime.strToDate(options.startDate);
				} else {
					ct = options.value || ((input && input.val && input.val()) ? input.val() : '');
					if (ct) {
						ct = _xdsoft_datetime.strToDateTime(ct);
						if (options.yearOffset) {
							ct = new Date(ct.getFullYear() - options.yearOffset, ct.getMonth(), ct.getDate(), ct.getHours(), ct.getMinutes(), ct.getSeconds(), ct.getMilliseconds());
						}
					} else if (options.defaultDate) {
						ct = _xdsoft_datetime.strToDateTime(options.defaultDate);
						if (options.defaultTime) {
							time = _xdsoft_datetime.strtotime(options.defaultTime);
							ct.setHours(time.getHours());
							ct.setMinutes(time.getMinutes());
						}
					}
				}

				if (ct && _xdsoft_datetime.isValidDate(ct)) {
					datetimepicker.data('changed', true);
				} else {
					ct = '';
				}

				return ct || 0;
			}

			function setMask(options) {

				var isValidValue = function (mask, value) {
						var reg = mask
							.replace(/([\[\]\/\{\}\(\)\-\.\+]{1})/g, '\\$1')
							.replace(/_/g, '{digit+}')
							.replace(/([0-9]{1})/g, '{digit$1}')
							.replace(/\{digit([0-9]{1})\}/g, '[0-$1_]{1}')
							.replace(/\{digit[\+]\}/g, '[0-9_]{1}');
						return (new RegExp(reg)).test(value);
					},
					getCaretPos = function (input) {
						try {
							if (options.ownerDocument.selection && options.ownerDocument.selection.createRange) {
								var range = options.ownerDocument.selection.createRange();
								return range.getBookmark().charCodeAt(2) - 2;
							}
							if (input.setSelectionRange) {
								return input.selectionStart;
							}
						} catch (e) {
							return 0;
						}
					},
					setCaretPos = function (node, pos) {
						node = (typeof node === "string" || node instanceof String) ? options.ownerDocument.getElementById(node) : node;
						if (!node) {
							return false;
						}
						if (node.createTextRange) {
							var textRange = node.createTextRange();
							textRange.collapse(true);
							textRange.moveEnd('character', pos);
							textRange.moveStart('character', pos);
							textRange.select();
							return true;
						}
						if (node.setSelectionRange) {
							node.setSelectionRange(pos, pos);
							return true;
						}
						return false;
					};

				if(options.mask) {
					input.off('keydown.xdsoft');
				}

				if (options.mask === true) {
					if (dateHelper.formatMask) {
						options.mask = dateHelper.formatMask(options.format)
					} else {
						options.mask = options.format
							.replace(/Y/g, '9999')
							.replace(/F/g, '9999')
							.replace(/m/g, '19')
							.replace(/d/g, '39')
							.replace(/H/g, '29')
							.replace(/i/g, '59')
							.replace(/s/g, '59');
					}
				}

				if ($.type(options.mask) === 'string') {
					if (!isValidValue(options.mask, input.val())) {
						input.val(options.mask.replace(/[0-9]/g, '_'));
						setCaretPos(input[0], 0);
					}

					input.on('paste.xdsoft', function (event) {
					    // couple options here
					    // 1. return false - tell them they can't paste
					    // 2. insert over current characters - minimal validation
					    // 3. full fledged parsing and validation
					    // let's go option 2 for now

					    // fires multiple times for some reason

					    // https://stackoverflow.com/a/30496488/1366033
					    var clipboardData = event.clipboardData || event.originalEvent.clipboardData || window.clipboardData,
						pastedData = clipboardData.getData('text'),
						val = this.value,
						pos = this.selectionStart

					    var valueBeforeCursor = val.substr(0, pos);
					    var valueAfterPaste = val.substr(pos + pastedData.length);

					    val = valueBeforeCursor + pastedData + valueAfterPaste;           
					    pos += pastedData.length;

					    if (isValidValue(options.mask, val)) {
						this.value = val;
						setCaretPos(this, pos);
					    } else if ($.trim(val) === '') {
						this.value = options.mask.replace(/[0-9]/g, '_');
					    } else {
						input.trigger('error_input.xdsoft');
					    }

					    event.preventDefault();
					    return false;
					  });

					  input.on('keydown.xdsoft', function (event) {
					    var val = this.value,
						key = event.which,
						pos = this.selectionStart,
						selEnd = this.selectionEnd,
						hasSel = pos !== selEnd,
						digit;

					    // only alow these characters
					    if (((key >=  KEY0 && key <=  KEY9)  ||
						 (key >= _KEY0 && key <= _KEY9)) || 
						 (key === BACKSPACE || key === DEL)) {

					      // get char to insert which is new character or placeholder ('_')
					      digit = (key === BACKSPACE || key === DEL) ? '_' :
							  String.fromCharCode((_KEY0 <= key && key <= _KEY9) ? key - KEY0 : key);

						// we're deleting something, we're not at the start, and have normal cursor, move back one
						// if we have a selection length, cursor actually sits behind deletable char, not in front
						if (key === BACKSPACE && pos && !hasSel) {
						    pos -= 1;
						}

						// don't stop on a separator, continue whatever direction you were going
						//   value char - keep incrementing position while on separator char and we still have room
						//   del char   - keep decrementing position while on separator char and we still have room
						while (true) {
						  var maskValueAtCurPos = options.mask.substr(pos, 1);
						  var posShorterThanMaskLength = pos < options.mask.length;
						  var posGreaterThanZero = pos > 0;
						  var notNumberOrPlaceholder = /[^0-9_]/;
						  var curPosOnSep = notNumberOrPlaceholder.test(maskValueAtCurPos);
						  var continueMovingPosition = curPosOnSep && posShorterThanMaskLength && posGreaterThanZero

						  // if we hit a real char, stay where we are
						  if (!continueMovingPosition) break;

						  // hitting backspace in a selection, you can possibly go back any further - go forward
						  pos += (key === BACKSPACE && !hasSel) ? -1 : 1;

						}


						if (hasSel) {
						  // pos might have moved so re-calc length
						  var selLength = selEnd - pos

						  // if we have a selection length we will wipe out entire selection and replace with default template for that range
						  var defaultBlank = options.mask.replace(/[0-9]/g, '_');
						  var defaultBlankSelectionReplacement = defaultBlank.substr(pos, selLength); 
						  var selReplacementRemainder = defaultBlankSelectionReplacement.substr(1) // might be empty

						  var valueBeforeSel = val.substr(0, pos);
						  var insertChars = digit + selReplacementRemainder;
						  var charsAfterSelection = val.substr(pos + selLength);

						  val = valueBeforeSel + insertChars + charsAfterSelection

						} else {
						  var valueBeforeCursor = val.substr(0, pos);
						  var insertChar = digit;
						  var valueAfterNextChar = val.substr(pos + 1);

						  val = valueBeforeCursor + insertChar + valueAfterNextChar
						}

						if ($.trim(val) === '') {
						  // if empty, set to default
						    val = defaultBlank
						} else {
						  // if at the last character don't need to do anything
						    if (pos === options.mask.length) {
							event.preventDefault();
							return false;
						    }
						}

						// resume cursor location
						pos += (key === BACKSPACE) ? 0 : 1;
						// don't stop on a separator, continue whatever direction you were going
						while (/[^0-9_]/.test(options.mask.substr(pos, 1)) && pos < options.mask.length && pos > 0) {
						    pos += (key === BACKSPACE) ? 0 : 1;
						}

						if (isValidValue(options.mask, val)) {
						    this.value = val;
						    setCaretPos(this, pos);
						} else if ($.trim(val) === '') {
						    this.value = options.mask.replace(/[0-9]/g, '_');
						} else {
						    input.trigger('error_input.xdsoft');
						}
					    } else {
						if (([AKEY, CKEY, VKEY, ZKEY, YKEY].indexOf(key) !== -1 && ctrlDown) || [ESC, ARROWUP, ARROWDOWN, ARROWLEFT, ARROWRIGHT, F5, CTRLKEY, TAB, ENTER].indexOf(key) !== -1) {
						    return true;
						}
					    }

					    event.preventDefault();
					    return false;
					  });
				}
			}

			_xdsoft_datetime.setCurrentTime(getCurrentValue());

			input
				.data('xdsoft_datetimepicker', datetimepicker)
				.on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function () {
					if (input.is(':disabled') || (input.data('xdsoft_datetimepicker').is(':visible') && options.closeOnInputClick)) {
						return;
					}
					if (!options.openOnFocus) {
						return;
					}
					clearTimeout(timer);
					timer = setTimeout(function () {
						if (input.is(':disabled')) {
							return;
						}

						triggerAfterOpen = true;
						_xdsoft_datetime.setCurrentTime(getCurrentValue(), true);
						if(options.mask) {
							setMask(options);
						}
						datetimepicker.trigger('open.xdsoft');
					}, 100);
				})
				.on('keydown.xdsoft', function (event) {
					var elementSelector,
						key = event.which;
					if ([ENTER].indexOf(key) !== -1 && options.enterLikeTab) {
						elementSelector = $("input:visible,textarea:visible,button:visible,a:visible");
						datetimepicker.trigger('close.xdsoft');
						elementSelector.eq(elementSelector.index(this) + 1).focus();
						return false;
					}
					if ([TAB].indexOf(key) !== -1) {
						datetimepicker.trigger('close.xdsoft');
						return true;
					}
				})
				.on('blur.xdsoft', function () {
					datetimepicker.trigger('close.xdsoft');
				});
		};
		destroyDateTimePicker = function (input) {
			var datetimepicker = input.data('xdsoft_datetimepicker');
			if (datetimepicker) {
				datetimepicker.data('xdsoft_datetime', null);
				datetimepicker.remove();
				input
					.data('xdsoft_datetimepicker', null)
					.off('.xdsoft');
				$(options.contentWindow).off('resize.xdsoft');
				$([options.contentWindow, options.ownerDocument.body]).off('mousedown.xdsoft touchstart');
				if (input.unmousewheel) {
					input.unmousewheel();
				}
			}
		};
		$(options.ownerDocument)
			.off('keydown.xdsoftctrl keyup.xdsoftctrl')
			.on('keydown.xdsoftctrl', function (e) {
				if (e.keyCode === CTRLKEY) {
					ctrlDown = true;
				}
			})
			.on('keyup.xdsoftctrl', function (e) {
				if (e.keyCode === CTRLKEY) {
					ctrlDown = false;
				}
			});

		this.each(function () {
			var datetimepicker = $(this).data('xdsoft_datetimepicker'), $input;
			if (datetimepicker) {
				if ($.type(opt) === 'string') {
					switch (opt) {
						case 'show':
							$(this).select().focus();
							datetimepicker.trigger('open.xdsoft');
							break;
						case 'hide':
							datetimepicker.trigger('close.xdsoft');
							break;
						case 'toggle':
							datetimepicker.trigger('toggle.xdsoft');
							break;
						case 'destroy':
							destroyDateTimePicker($(this));
							break;
						case 'reset':
							this.value = this.defaultValue;
							if (!this.value || !datetimepicker.data('xdsoft_datetime').isValidDate(dateHelper.parseDate(this.value, options.format))) {
								datetimepicker.data('changed', false);
							}
							datetimepicker.data('xdsoft_datetime').setCurrentTime(this.value);
							break;
						case 'validate':
							$input = datetimepicker.data('input');
							$input.trigger('blur.xdsoft');
							break;
						default:
							if (datetimepicker[opt] && $.isFunction(datetimepicker[opt])) {
								result = datetimepicker[opt](opt2);
							}
					}
				} else {
					datetimepicker
						.setOptions(opt);
				}
				return 0;
			}
			if ($.type(opt) !== 'string') {
				if (!options.lazyInit || options.open || options.inline) {
					createDateTimePicker($(this));
				} else {
					lazyInit($(this));
				}
			}
		});

		return result;
	};

	$.fn.datetimepicker.defaults = default_options;

	function HighlightedDate(date, desc, style) {
		"use strict";
		this.date = date;
		this.desc = desc;
		this.style = style;
	}
};
;(function (factory) {
	if ( typeof define === 'function' && define.amd ) {
		// AMD. Register as an anonymous module.
		define('jquery.datetimepicker',['jquery', 'jquery-mousewheel'], factory);
	} else if (typeof exports === 'object') {
		// Node/CommonJS style for Browserify
		module.exports = factory(require('jquery'));;
	} else {
		// Browser globals
		factory(jQuery);
	}
}(datetimepickerFactory));



/*!
 * @copyright Copyright &copy; Kartik Visweswaran, Krajee.com, 2014 - 2016
 * @version 1.3.4
 *
 * Date formatter utility library that allows formatting date/time variables or Date objects using PHP DateTime format.
 * @see http://php.net/manual/en/function.date.php
 *
 * For more JQuery plugins visit http://plugins.krajee.com
 * For more Yii related demos visit http://demos.krajee.com
 */var DateFormatter;!function(){"use strict";var t,e,r,n,a,u,i;u=864e5,i=3600,t=function(t,e){return"string"==typeof t&&"string"==typeof e&&t.toLowerCase()===e.toLowerCase()},e=function(t,r,n){var a=n||"0",u=t.toString();return u.length<r?e(a+u,r):u},r=function(t){var e,n;for(t=t||{},e=1;e<arguments.length;e++)if(n=arguments[e])for(var a in n)n.hasOwnProperty(a)&&("object"==typeof n[a]?r(t[a],n[a]):t[a]=n[a]);return t},n=function(t,e){for(var r=0;r<e.length;r++)if(e[r].toLowerCase()===t.toLowerCase())return r;return-1},a={dateSettings:{days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],daysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],monthsShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],meridiem:["AM","PM"],ordinal:function(t){var e=t%10,r={1:"st",2:"nd",3:"rd"};return 1!==Math.floor(t%100/10)&&r[e]?r[e]:"th"}},separators:/[ \-+\/\.T:@]/g,validParts:/[dDjlNSwzWFmMntLoYyaABgGhHisueTIOPZcrU]/g,intParts:/[djwNzmnyYhHgGis]/g,tzParts:/\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,tzClip:/[^-+\dA-Z]/g},DateFormatter=function(t){var e=this,n=r(a,t);e.dateSettings=n.dateSettings,e.separators=n.separators,e.validParts=n.validParts,e.intParts=n.intParts,e.tzParts=n.tzParts,e.tzClip=n.tzClip},DateFormatter.prototype={constructor:DateFormatter,getMonth:function(t){var e,r=this;return e=n(t,r.dateSettings.monthsShort)+1,0===e&&(e=n(t,r.dateSettings.months)+1),e},parseDate:function(e,r){var n,a,u,i,s,o,c,f,l,h,d=this,g=!1,m=!1,p=d.dateSettings,y={date:null,year:null,month:null,day:null,hour:0,min:0,sec:0};if(!e)return null;if(e instanceof Date)return e;if("U"===r)return u=parseInt(e),u?new Date(1e3*u):e;switch(typeof e){case"number":return new Date(e);case"string":break;default:return null}if(n=r.match(d.validParts),!n||0===n.length)throw new Error("Invalid date format definition.");for(a=e.replace(d.separators,"\x00").split("\x00"),u=0;u<a.length;u++)switch(i=a[u],s=parseInt(i),n[u]){case"y":case"Y":if(!s)return null;l=i.length,y.year=2===l?parseInt((70>s?"20":"19")+i):s,g=!0;break;case"m":case"n":case"M":case"F":if(isNaN(s)){if(o=d.getMonth(i),!(o>0))return null;y.month=o}else{if(!(s>=1&&12>=s))return null;y.month=s}g=!0;break;case"d":case"j":if(!(s>=1&&31>=s))return null;y.day=s,g=!0;break;case"g":case"h":if(c=n.indexOf("a")>-1?n.indexOf("a"):n.indexOf("A")>-1?n.indexOf("A"):-1,h=a[c],c>-1)f=t(h,p.meridiem[0])?0:t(h,p.meridiem[1])?12:-1,s>=1&&12>=s&&f>-1?y.hour=s+f-1:s>=0&&23>=s&&(y.hour=s);else{if(!(s>=0&&23>=s))return null;y.hour=s}m=!0;break;case"G":case"H":if(!(s>=0&&23>=s))return null;y.hour=s,m=!0;break;case"i":if(!(s>=0&&59>=s))return null;y.min=s,m=!0;break;case"s":if(!(s>=0&&59>=s))return null;y.sec=s,m=!0}if(g===!0&&y.year&&y.month&&y.day)y.date=new Date(y.year,y.month-1,y.day,y.hour,y.min,y.sec,0);else{if(m!==!0)return null;y.date=new Date(0,0,0,y.hour,y.min,y.sec,0)}return y.date},guessDate:function(t,e){if("string"!=typeof t)return t;var r,n,a,u,i,s,o=this,c=t.replace(o.separators,"\x00").split("\x00"),f=/^[djmn]/g,l=e.match(o.validParts),h=new Date,d=0;if(!f.test(l[0]))return t;for(a=0;a<c.length;a++){if(d=2,i=c[a],s=parseInt(i.substr(0,2)),isNaN(s))return null;switch(a){case 0:"m"===l[0]||"n"===l[0]?h.setMonth(s-1):h.setDate(s);break;case 1:"m"===l[0]||"n"===l[0]?h.setDate(s):h.setMonth(s-1);break;case 2:if(n=h.getFullYear(),r=i.length,d=4>r?r:4,n=parseInt(4>r?n.toString().substr(0,4-r)+i:i.substr(0,4)),!n)return null;h.setFullYear(n);break;case 3:h.setHours(s);break;case 4:h.setMinutes(s);break;case 5:h.setSeconds(s)}u=i.substr(d),u.length>0&&c.splice(a+1,0,u)}return h},parseFormat:function(t,r){var n,a=this,s=a.dateSettings,o=/\\?(.?)/gi,c=function(t,e){return n[t]?n[t]():e};return n={d:function(){return e(n.j(),2)},D:function(){return s.daysShort[n.w()]},j:function(){return r.getDate()},l:function(){return s.days[n.w()]},N:function(){return n.w()||7},w:function(){return r.getDay()},z:function(){var t=new Date(n.Y(),n.n()-1,n.j()),e=new Date(n.Y(),0,1);return Math.round((t-e)/u)},W:function(){var t=new Date(n.Y(),n.n()-1,n.j()-n.N()+3),r=new Date(t.getFullYear(),0,4);return e(1+Math.round((t-r)/u/7),2)},F:function(){return s.months[r.getMonth()]},m:function(){return e(n.n(),2)},M:function(){return s.monthsShort[r.getMonth()]},n:function(){return r.getMonth()+1},t:function(){return new Date(n.Y(),n.n(),0).getDate()},L:function(){var t=n.Y();return t%4===0&&t%100!==0||t%400===0?1:0},o:function(){var t=n.n(),e=n.W(),r=n.Y();return r+(12===t&&9>e?1:1===t&&e>9?-1:0)},Y:function(){return r.getFullYear()},y:function(){return n.Y().toString().slice(-2)},a:function(){return n.A().toLowerCase()},A:function(){var t=n.G()<12?0:1;return s.meridiem[t]},B:function(){var t=r.getUTCHours()*i,n=60*r.getUTCMinutes(),a=r.getUTCSeconds();return e(Math.floor((t+n+a+i)/86.4)%1e3,3)},g:function(){return n.G()%12||12},G:function(){return r.getHours()},h:function(){return e(n.g(),2)},H:function(){return e(n.G(),2)},i:function(){return e(r.getMinutes(),2)},s:function(){return e(r.getSeconds(),2)},u:function(){return e(1e3*r.getMilliseconds(),6)},e:function(){var t=/\((.*)\)/.exec(String(r))[1];return t||"Coordinated Universal Time"},I:function(){var t=new Date(n.Y(),0),e=Date.UTC(n.Y(),0),r=new Date(n.Y(),6),a=Date.UTC(n.Y(),6);return t-e!==r-a?1:0},O:function(){var t=r.getTimezoneOffset(),n=Math.abs(t);return(t>0?"-":"+")+e(100*Math.floor(n/60)+n%60,4)},P:function(){var t=n.O();return t.substr(0,3)+":"+t.substr(3,2)},T:function(){var t=(String(r).match(a.tzParts)||[""]).pop().replace(a.tzClip,"");return t||"UTC"},Z:function(){return 60*-r.getTimezoneOffset()},c:function(){return"Y-m-d\\TH:i:sP".replace(o,c)},r:function(){return"D, d M Y H:i:s O".replace(o,c)},U:function(){return r.getTime()/1e3||0}},c(t,t)},formatDate:function(t,e){var r,n,a,u,i,s=this,o="",c="\\";if("string"==typeof t&&(t=s.parseDate(t,e),!t))return null;if(t instanceof Date){for(a=e.length,r=0;a>r;r++)i=e.charAt(r),"S"!==i&&i!==c&&(r>0&&e.charAt(r-1)===c?o+=i:(u=s.parseFormat(i,t),r!==a-1&&s.intParts.test(i)&&"S"===e.charAt(r+1)&&(n=parseInt(u)||0,u+=s.dateSettings.ordinal(n)),o+=u));return o}return""}}}();
define("php-date-formatter", function(){});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * OpenSearch service
 */
define('service/gui/OpenSearchService',["jquery", "underscore-min", "moment","text!templates/openSearchService.html", "text!templates/openSearchForm.html", "jquery.ui", "jquery.datetimepicker", "php-date-formatter"],
    function ($, _, moment, openSearchServiceHTMLTemplate, openSearchFormHTMLTemplate) {

        // Template generating the open search service div
        var openSearchServiceTemplate = _.template(openSearchServiceHTMLTemplate);

        // Template generating the form of properties
        var openSearchFormTemplate = _.template(openSearchFormHTMLTemplate);

        var layers = [];

        /**
         *    Handle submit event
         */
        function handleSubmit(event) {
            event.stopPropagation();
            event.preventDefault();
            var layer = $(this).closest(".osForm").data("layer");
            // Get array of changed inputs
            var notEmptyInputs = $(this).find(':input[value!=""]').serializeArray();
            // Create new properties
            var properties = {};
            for (var i = 0; i < notEmptyInputs.length; i++) {
                properties[notEmptyInputs[i].name.toString()] = notEmptyInputs[i].value.toString();
            }

            var selectOptions;
            $(this).find('select').each(function (i) {
                if ($(this).val())
                    properties[$(this).attr("name")] = $(this).val();

            });

            // Modify the request properties of choosen layer
            layer.setRequestProperties(properties);
        }


        /**
         *    Attach open search form to layer
         *
         *    @param layer GlobWeb layer
         */
        function attachForm(layer) {
            layer.openSearchForm = openSearchFormTemplate({ "layer": layer });
        }

        function createOpenSearchServiceInTabs(tabs) {
            if ((typeof $("#OpenSearchService").length === "number") && ($("#OpenSearchService").length === 0)) {
                // Append header
                $('<li style="display: none;"><a href="#OpenSearchService">OpenSearch</a></li>')
                    .appendTo(tabs.children(".ui-tabs-nav"))
                    .fadeIn(300);
                // Append content
                tabs.append('<div id="OpenSearchService"></div>');
                var openSearchService = openSearchServiceTemplate();
                $(openSearchService)
                    .appendTo('#OpenSearchService')
                    .tabs({
                        collapsible: true,
                        hide: { effect: "fadeOut", duration: 300 },
                        show: { effect: "fadeIn", duration: 300 }
                    });
            }
        }

        function handleQueryForm(layer) {
            // create tab for queryform
            var tabs = $('#openSearchTabs').tabs({
                collapsible: true,
                hide: { effect: "slideUp", duration: 300 },
                show: { effect: "slideDown", duration: 300 }
            });

            // append Header
            $('<li><a href="#osForm_' + layer.id + '">' + layer.name + "</a></li>")
                .appendTo(tabs.children(".ui-tabs-nav"));
            // append content
            tabs.append('<div id="osForm_' + layer.id + '">' + layer.openSearchForm + '</div>');
           
            // format date for date time picker
            $.datetimepicker.setDateFormatter({
                parseDate: function (date, format) {
                    var d = moment.utc(date,"YYYY-MM-DDTHH:mm:ss");
                    return d.isValid() ? d.toDate() : false;
                },
                formatDate: function (date, format) {
                    var datetime;
                    if(format === "Y-m-d") {
                        datetime = moment.utc(date).format(format);
                    } else if(format === "H:m") {
                        datetime = String(date.getHours()).padStart(2, "0")+":"+String(date.getMinutes()).padStart(2, "0");                     
                    } else {
                        datetime = moment(date,"Y-m-d H:m").format("YYYY-MM-DDTHH:mm");
                        datetime = datetime+":00";
                    }
                    return datetime;
                }
            });

            // attach data and datetimepicker to queryform
            $('#openSearchTabs')
                .find('#openSearchForm_' + layer.id)
                .data("layer", layer)
                .submit(handleSubmit).end()
                .find(".datetimepicker").datetimepicker({
                    lang: 'en',
                    timepicker: true,
                    format:'Y-m-d H:m',
                    formatDate:'Y-m-d',
                    formatTime:'H:m',                    
                });

            // refresh
            $('#openSearchTabs').tabs("refresh");

            // make enabled the queryform tab
            var index = $('#openSearchTabs').find('.ui-tabs-nav li[aria-controls="osForm_' + layer.id + '"]').index();
            tabs.tabs("option", "active", index);
        }

        return {
            init: function (m) {
                mizarWidgetAPI = m;
            },


            initTab: function (tabs) {
                createOpenSearchServiceInTabs(tabs);
            },

            destroyTab: function (tabs) {
                // if(layers.length === 0) {
                //     var index = $('#layerServices').find('.ui-tabs-nav li[aria-controls="OpenSearchService"]').index();
                //     $("#layerServices").find(".ui-tabs-nav li:eq("+index+")").remove();
                //     $("#layerServices").find("#OpenSearchService").remove();  
                //     $('#layerServices').tabs("refresh");                  
                // }
            },

            /**
             *    Add service to jQueryUI tabs
             *
             *    @param tabs jQueryUI tabs selector
             */
            addService: function (tabs, layer) {
                var isFound = _.find(layers, function (recordedLayer) { return recordedLayer.ID === layer.ID });
                if (isFound === undefined) {
                    layers.push(layer);
                    attachForm(layer);
                    handleQueryForm(layer);
                }
            },

            /**
             *    Remove service from jQueryUI tabs
             *
             *    @param tabs jQueryUI tabs selector
             */
            removeService: function (tabs, layer) {
                for (var i = 0; i < layers.length; i++) {
                    if (layers[i].id === layer.id) {
                        var index = $('#openSearchTabs').find('.ui-tabs-nav li[aria-controls="osForm_' + layer.id + '"]').index();
                        $("#openSearchTabs").find(".ui-tabs-nav li:eq(" + index + ")").remove();
                        $("#openSearchTabs").find("#osForm_" + layer.id).remove();
                        layers.splice(i, 1);
                        $('#openSearchTabs').tabs("refresh");
                        break;
                    }
                }

            }
        }

    });


define('text!templates/mocServiceItem.html',[],function () { return '<div class="mocLayer" id="mocLayer_<%=layer.ID%>">\n    <% if( display )\n    {\n    %>\n    <input class="display" id="display_<%=layer.ID%>" type="checkbox"/><label\n        for="display_<%=layer.ID%>">Display</label>\n    <%\n    }\n    else\n    {\n    %>\n    <input id="mocCheck_<%=layer.ID%>" type="checkbox"/><label for="mocCheck_<%=layer.ID%>">Check</label>\n    <%\n    }\n    %>\n    <span class="mocName"><%=layer.name%></span>\n    <span class="mocStatus"><% if ( layer.coverage == "Not available" ) print("(Not found)");%> </span>\n    <span class="mocCoverage">Sky coverage: <%=layer.coverage%></span>\n    <br/>\n</div>\n';});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Moc display & Moc xMatch services
 */
define('service/gui/MocService',["jquery", "underscore-min", "text!templates/mocServiceItem.html"],
    function ($, _, mocServiceHTMLTemplate) {

        // Template generating the services html
        var mocServiceTemplate = _.template(mocServiceHTMLTemplate);

        var mizarWidgetAPI;
        var layers = [];

        /**************************************************************************************************************/

        /**
         *    Event for display button
         */
        function displayClickEvent() {
            var serviceLayer = $(this).parent().data("layer");
            //var IDs = layer.split("#",2);
            //var serviceLayerID = IDs[1];
            //var serviceLayer = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MocBase).findMocSublayer(serviceLayerID);
            // Change visibility
            if (serviceLayer) {
                if (this.checked) {
                    serviceLayer.setVisible(true)
                }
                else {
                    serviceLayer.setVisible(false);
                }
            }
        }

        function convertToIDJquery(str) {
            return str.replace(/\:/g, "_");
        }

        /**************************************************************************************************************/

        /**
         *    Add HTML of moc layer
         */
        function addHTMLMocLayer(layer) {
            var content = mocServiceTemplate({layer: layer, display: true});
            $(content)
                .appendTo('#MocService .mocLayers')
                .data("layer", layer)
                .find('input[type="checkbox"]')
                .attr("checked", (layer && layer.visible) ? true : false)
                .attr("disabled", (layer) ? false : true)
                .button()
                .click(displayClickEvent);
        }

        /**************************************************************************************************************/

        return {

            init: function (m) {
                mizarWidgetAPI = m;
            },

            /**************************************************************************************************************/

            initTab: function (tabs) {
                
            },

            /**
             *    Add layer to the service
             *    TODO : remove the layers and the MOC in mizarAPI
             */
            addLayer: function (layer) {
                var mocDescribe = layer.getServices().Moc;
                // Create if doesn't exist
                if (mocDescribe && !_.find(layers, function(itemLayer){
                        var layerID = layer.ID;
                        return itemLayer.startsWith(layerID);
                    })) {
                    var serviceID = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MocBase).createMocSublayer(mocDescribe,
                        function (layer) {
                            $("#MocService #mocLayer_" + convertToIDJquery(layer.ID)).find('input[type="checkbox"]').removeAttr("disabled").button("refresh");
                            $("#MocService #mocLayer_" + convertToIDJquery(layer.ID)).find('.mocCoverage').html("Sky coverage: " + layer.coverage);
                    }, function (layer) {
                        $("#MocService #mocLayer_" + convertToIDJquery(layer.ID)).find('.mocCoverage').html("Sky coverage: Not available").end()
                            .find('.mocStatus').html('(Not found)');
                    });

                    layers.push(layer.ID+"#"+serviceID);
                    var mocLayer = mizarWidgetAPI.getLayerByID(serviceID);
                    mocLayer.name = layer.name+" MOC";
                    addHTMLMocLayer(mocLayer);
                }
            },

            /**************************************************************************************************************/

            /**
             *    Remove layer from the service
             */
            removeLayer: function (layer) {
                var serviceID="";
                for (var i = 0; i < layers.length; i++) {
                    var registeredLayer = layers[i];
                    var IDs = registeredLayer.split("#",2);
                    if (IDs[0] === layer.ID) {
                        layers.splice(i, 1);
                        serviceID = IDs[1];
                        break;
                    }
                }
                $("#MocService #mocLayer_" + convertToIDJquery(serviceID)).remove();
            },

            /**************************************************************************************************************/

            /**
             *    Add service to jQueryUI tabs
             *
             *    @param tabs jQueryUI tabs selector
             */
            addService: function (tabs) {
                // Append headers
                $('<li style="display: none;"><a href="#MocService">Moc</a></li>')
                    .appendTo(tabs.children(".ui-tabs-nav"))
                    .fadeIn(300);

                // Append content
                tabs.append('<div id="MocService">\
						<div class="mocLayers"></div>\
					</div>');

                for (var i = 0; i < layers.length; i++) {
                    var layerIDs = layers[i].split("#",2);
                    var layer = mizarWidgetAPI.getLayerByID(layerIDs[1]);
                    addHTMLMocLayer(layer);
                }
            },

            /**************************************************************************************************************/

            /**
             *    Remove service from jQueryUI tabs
             *
             *    @param tabs jQueryUI tabs selector
             */
            removeService: function (tabs) {
                // Remove MocService tab(content&header)
                $('li[aria-controls="MocService"]').remove();
                $("#MocService").remove();
                tabs.tabs("refresh");
            }
        }

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 *    Moc xMatch service
 */
define('service/gui/XMatchService',["jquery", "underscore-min", "gui/dialog/ErrorDialog", "../../utils/UtilsCore", "text!templates/mocServiceItem.html", "jquery.ui"],
    function ($, _, ErrorDialog, UtilsCore, mocServiceHTMLTemplate) {

// Template generating the services html
        var mocServiceTemplate = _.template(mocServiceHTMLTemplate);

        var coverageServiceUrl;
        var intersectionLayer;
        var mizarWidgetAPI;

        /**************************************************************************************************************/

        /**
         *    Event for display button
         */
        function displayClickEvent() {
            var layer = $(this).parent().data("layer");

            var serviceLayer;
            if (!(UtilsCore.isMocLayer(layer))) {
                serviceLayer = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MocBase).findMocSublayer(layer);
            } else {
                serviceLayer = layer;
            }

            // Change visibility
            if (serviceLayer) {
                if (this.checked) {
                    serviceLayer.setVisible(true)
                }
                else {
                    serviceLayer.setVisible(false);
                }
            }
        }

        /**************************************************************************************************************/

        /**
         *    Add HTML of xMatch layer
         */
        function addHTMLXMatchLayer(layer) {
            var content = mocServiceTemplate({layer: layer, display: false});
            $(content)
                .appendTo('#xMatchService .mocLayers')
                .data("layer", layer)
                .find('input[type="checkbox"]')
                .attr("disabled", (layer.coverage && layer.coverage != "Not available") ? false : true)
                .button({
                    text: false,
                    icons: {
                        primary: "ui-icon-empty"
                    }
                })
                .click(function () {
                    $(this).button("option", {
                        icons: {
                            primary: $(this).is(':checked') ? "ui-icon-check" : "ui-icon-empty"
                        }
                    });
                });
        }

        /**************************************************************************************************************/

        /**
         *    Add HTML of intersection layer
         */
        function addHTMLIntersectionLayer() {
            // Add HTML
            var form = mocServiceTemplate({layer: intersectionLayer, display: true});
            $(form)
                .appendTo('#intersectResult')
                .data("layer", intersectionLayer)
                .find(".display")
                .button()
                .click(displayClickEvent);
            $('#intersectResult').slideDown();
            $('#intersectMocBtn').removeAttr("disabled").button("refresh");
        }

        /**************************************************************************************************************/

        /**
         *    Create & add intersection layer
         *
         *    @param layersToIntersect Layers to intersect
         */
        function addIntersectionLayer(layersToIntersect) {
            if (coverageServiceUrl) {
                if (intersectionLayer)
                    mizarWidgetAPI.getScene().removeLayer(intersectionLayer);

                intersectionLayer = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MocBase).intersectLayers(layersToIntersect);

                mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MocBase).requestSkyCoverage(intersectionLayer, intersectionLayer.describeUrl + "&media=txt", function (layer) {
                    $("#xMatchService #mocLayer_" + layer.id).find('.mocCoverage').html("Sky coverage: " + layer.coverage);
                });
                addHTMLIntersectionLayer();
            }
            else {
                ErrorDialog.open("Coverage service URL isn't defined in configuration file");
                $('#intersectMocBtn').removeAttr("disabled").button("refresh");
            }
        }

        /**************************************************************************************************************/

        return {
            init: function (m, configuration) {
                mizarWidgetAPI = m;
                if (configuration.coverageService) {
                    coverageServiceUrl = configuration.coverageService.baseUrl;
                }
            },

            /**************************************************************************************************************/

            addLayer: function (layer) {
                // Check the layer to xMatch
                if (layer.coverage != "Not available") {
                    $('#xMatchService #mocCheck_' + layer.id)
                        .attr('checked', 'checked')
                        .button("option", {
                            icons: {
                                primary: "ui-icon-check"
                            }
                        }).button('refresh');
                }

                // Replace its div on top
                $('#xMatchService #mocLayer_' + layer.id).append('<br/>').prependTo('#xMatchService .mocLayers');


            },

            /**************************************************************************************************************/

            removeLayer: function (layer) {
                // Uncheck the given layer
                $('#xMatchService #mocCheck_' + layer.id).removeAttr('checked');
            },

            /**************************************************************************************************************/

            /**
             *    Add service to jQueryUI tabs
             *
             *    @param tabs jQueryUI tabs selector
             */
            addService: function (tabs) {
                $('<li style="display: none;"><a href="#xMatchService">xMatch</a></li>')
                    .appendTo(tabs.children(".ui-tabs-nav"))
                    .fadeIn(300);

                tabs.append('<div id="xMatchService">\
				<div class="mocLayers"></div>\
					<button id="intersectMocBtn">Intersect</button>\
				<div id="intersectResult"></div>\
			</div>');

                var allLayers = mizarWidgetAPI.getLayers(mizarWidgetAPI.CONTEXT.Sky);
                var allOSLayers = _.filter(allLayers, function (layer) {
                    return UtilsCore.isOpenSearchLayer(layer)
                });

                for (var i = 0; i < allOSLayers.length; i++) {
                    var layer = allOSLayers[i];
                    var serviceLayer = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MocBase).findMocSublayer(layer);
                    // Create if doesn't exist
                    if (!serviceLayer) {
                        mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MocBase).getSkyCoverage(layer, function (layer) {
                            $("#xMatchService #mocLayer_" + layer.id).find('.mocCoverage').html("Sky coverage: " + layer.coverage);
                            $("#xMatchService #mocLayer_" + layer.id).find('input[type="checkbox"]').removeAttr("disabled").button("refresh");
                        }, function (layer) {
                            $("#xMatchService #mocLayer_" + layer.id).find('.mocCoverage').html("Sky coverage: Not available").end()
                                .find('.mocStatus').html('(Not found)');
                            $("#xMatchService #mocLayer_" + layer.id).find('input[type="checkbox"]').removeAttr('checked').button("option", {
                                icons: {
                                    primary: "ui-icon-empty"
                                }
                            }).button("refresh");

                        });
                    }

                    addHTMLXMatchLayer(layer);
                }

                $('#intersectMocBtn')
                    .button()
                    .click(function () {
                        $(this).attr("disabled", "disabled").button("refresh");
                        $('#intersectResult').clearQueue().stop().slideUp(function () {
                            var checkedInputs = $(this).parent().find('.mocLayers .mocLayer input:checked');
                            if (checkedInputs.length < 2) {
                                $('#intersectResult').html('Check at least two layers')
                                    .slideDown().delay(700).slideUp(function () {
                                    $('#intersectMocBtn').removeAttr("disabled").button("refresh");
                                });
                            }
                            else {
                                $('#intersectResult').html('');
                                var checkedLayers = [];
                                checkedInputs.each(function (i) {
                                    checkedLayers.push($.data(checkedInputs[i].parentElement, "layer"));
                                });

                                addIntersectionLayer(checkedLayers);
                            }
                        });
                    });
            },

            /**************************************************************************************************************/

            /**
             *    Remove service from jQueryUI tabs
             *    @param tabs jQueryUI tabs selector
             */
            removeService: function (tabs) {
                // var index = $(this).index();
                // tabs.tabs("disable",index);
                tabs.find('.ui-tabs-nav li[aria-controls="xMatchService"]').remove();
                $("#xMatchService").remove();
                tabs.tabs("refresh");

                var allLayers = mizarWidgetAPI.getLayers(mizarWidgetAPI.CONTEXT.Sky);
                var allOSLayers = _.filter(allLayers, function (layer) {
                    return UtilsCore.isOpenSearchLayer(layer)
                });

                for (var i = 0; i < allOSLayers.length; i++) {
                    var layer = allOSLayers[i];
                    $("#xMatchService #mocLayer_" + layer.id).remove();
                }

                if (intersectionLayer) {
                    sky.removeLayer(intersectionLayer);
                    intersectionLayer = null;
                }
            }

            /**************************************************************************************************************/
        }
    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

define('uws/UWSBase',["jquery"], function ($) {

    /**************************************************************************************************************/

    /**
     * UWSBase service
     */
    var UWSBase = function (name, baseUrl, options) {
        this.name = name;
        this.baseUrl = baseUrl;

        this.successCallback = null;
        this.failCallback = null;
        this.onloadCallback = null;

        this.checkFn = null; // Interval function
        this.checkDelay = options && options.hasOwnProperty('checkDelay') ? options.checkDelay : 2000;
        this.currentJob;
    };

    /**************************************************************************************************************/

    /**
     *    Send xhr to get results of current job
     */
    UWSBase.prototype.getJobResults = function () {
        var self = this;
        $.ajax({
            type: "GET",
            url: this.baseUrl + "/" + this.currentJob + '/results?media=json',
            success: function (response, textStatus, xhr) {
                if (self.successCallback) {
                    self.successCallback(response, self.currentJob);
                }
            },
            error: function (xhr, textStatus, thrownError) {
                if (self.failCallback) {
                    self.failCallback('Internal server error');
                }
            }
        });
    };

    /**************************************************************************************************************/

    /**
     *    Send GET request to know the phase of current job
     */
    UWSBase.prototype.checkPhase = function () {
        var self = this;
        $.ajax({
            type: "GET",
            url: this.baseUrl + "/" + this.currentJob + '/phase',
            success: function (response, textStatus, xhr) {
                // Response is a phase
                if (self.onloadCallback) {
                    self.onloadCallback(response);
                }

                if (response === "COMPLETED") {
                    window.clearInterval(self.checkFn);

                    self.getJobResults();
                }
                else if (response === "ERROR") {
                    window.clearInterval(self.checkFn);
                    if (self.failCallback) {
                        self.failCallback('Internal server error');
                    }
                }
            },
            error: function (xhr, textStatus, thrownError) {
                window.clearInterval(self.checkFn);
                if (self.failCallback) {
                    self.failCallback(self.name + ' service: ' + thrownError);
                }
                console.error(xhr.responseText);
            }
        });
    };

    /**************************************************************************************************************/

    /**
     *    Send POST request to launch the job of current service
     */
    UWSBase.prototype.post = function (parameters, options) {
        this.successCallback = options.successCallback;
        this.onloadCallback = options.onloadCallback;
        this.failCallback = options.failCallback;

        if (!this.baseUrl) {
            if (this.failCallback) {
                this.failCallback(this.name + ' service: baseUrl is undefined');
            }
            console.error(this.name + ' service baseUrl is undefined');
        }
        else {
            window.clearInterval(this.checkFn);
            var self = this;
            $.ajax({
                type: "POST",
                url: this.baseUrl,
                dataType: "xml",
                data: parameters,
                success: function (response, textStatus, xhr) {
                    var xmlDoc = $.parseXML(xhr.responseText);
                    self.currentJob = $(xmlDoc).find('uws\\:jobId, jobId').text();

                    // Check job phase every "checkDelay" seconds
                    self.checkFn = window.setInterval(function () {
                        self.checkPhase.call(self);
                    }, self.checkDelay);
                },
                error: function (xhr, textStatus, thrownError) {
                    window.clearInterval(self.checkFn);
                    if (self.failCallback) {
                        self.failCallback(self.name + ' service: ' + thrownError);
                    }
                    console.error(xhr.responseText);
                }
            });
        }
    };

    /**************************************************************************************************************/

    /**
     *    Send DELETE request to remove the results of the given job
     */
    UWSBase.prototype.delete = function (jobId, options) {
        var successCallback = options.successCallback;
        var failCallback = options.failCallback;

        if (!this.baseUrl) {
            if (this.failCallback) {
                this.failCallback(this.name + ' service: baseUrl is undefined');
            }
            console.error(this.name + ' service baseUrl is undefined');
        }
        else {
            var self = this;
            $.ajax({
                type: "DELETE",
                url: this.baseUrl + "/" + jobId,
                success: function (response, textStatus, xhr) {
                    if (successCallback) {
                        successCallback();
                    }
                },
                error: function (xhr, textStatus, thrownError) {
                    if (failCallback) {
                        failCallback(self.name + ' service: ' + thrownError);
                    }
                    console.error(xhr.responseText);
                }
            });
        }
    };

    /**************************************************************************************************************/

    return UWSBase;

    /**************************************************************************************************************/

});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * UWS Manager
 */

define('uws/UWSManager',["./UWSBase"],
    function (UWSBase) {

        var cutOutService;
        var zScaleService;
        var healpixCutService;

        return {
            init: function (conf) {
                if (conf.cutOut) {
                    cutOutService = new UWSBase('CutOut', conf.cutOut.baseUrl);
                }

                if (conf.healpixcut) {
                    healpixCutService = new UWSBase('HealpixCut', conf.healpixcut.baseUrl);
                }

                if (conf.zScale) {
                    zScaleService = new UWSBase('ZScale', conf.zScale.baseUrl);
                }
            },

            post: function (serviceName, params, options) {
                switch (serviceName) {
                    case "cutout":
                        cutOutService.post(params, options);
                        break;
                    case "healpixcut":
                        healpixCutService.post(params, options);
                        break;
                    case "zscale":
                        zScaleService.post(params, options);
                        break;
                    default:
                        console.error("Not supported");
                }
            },

            delete: function (serviceName, jobId, options) {
                switch (serviceName) {
                    case "cutout":
                        cutOutService.delete(jobId, options);
                        break;
                    case "healpixcut":
                        healpixCutService.delete(jobId, options);
                        break;
                    case "zscale":
                        zScaleService.delete(jobId, options);
                        break;
                    default:
                        console.error("Not supported");
                }
            }
        };

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Samp module : performing communication between applications using SAMP protocol
 */
define('service/Samp',["jquery", "underscore-min", "samp", "jquery.ui"],
    function ($, _) {
        var mizarWidgetAPI;
        var imageManager;
        var SampCore;

//var tables = {};
//var highlightStyle = new FeatureStyle( {
//	strokeColor: [1., 1., 1., 1.],
//	fillColor: [1., 1., 1., 1.]
//} );
//var highlightedData;

        var connector;	// SAMP connector
        //var sampLayer;	// SAMP vector layer containing all incoming fits images
        var pointAtReceived = false; // Parameter avoiding looping while receiving coord.pointAt.sky SAMP event
        var votable2geojsonBaseUrl;
        var sitoolsBaseUrl;

        /**************************************************************************************************************/

        /**
         *    Create samp dialog, implement UI events
         */
        function initUI() {
            // Don't use connector.createRegButtons() because there is no unregistration callback
            // to refresh jquery UI buttons
            var dialogContent = '<div id="sampContent"><button id="registerSamp">Register</button>\
					<button id="unregisterSamp" disabled>Unregister</button>\
					<button id="sendVOTable">Send VO table</button>\
					<span><strong>Registered: </strong><span id="sampResult">No</span></span>\
					<br/>\
					<div style="display: none;" id="sampStatus"></div>\
					</div>';

            var $dialog = $(dialogContent).appendTo('body')
                .dialog({
                    title: 'Samp',
                    autoOpen: false,
                    show: {
                        effect: "fade",
                        duration: 300
                    },
                    hide: {
                        effect: "fade",
                        duration: 300
                    },
                    open: function () {
                        // Remove auto-focus
                        $(this).find('button:first-child').blur();
                    },
                    resizable: false,
                    width: 'auto',
                    minHeight: 'auto',
                    close: function (event, ui) {
                        $(this).dialog("close");
                    }
                });

            $dialog.find('#registerSamp').button()
                .click(function () {
                    connector.register();
                }).end()
                .find("#unregisterSamp").button()
                .click(function () {
                    connector.unregister();

                    // Update jQuery UI buttons
                    $('#registerSamp').removeAttr('disabled').button("refresh");
                    $(this).attr('disabled', 'disabled').button("refresh");
                    $('#sampInvoker').toggleClass('selected');
                }).end()
                .find('#sendVOTable').button()
                .click(function () {
                    // DEBUG:
                    var tableUrl = sitoolsBaseUrl + "/sia/search?order=3&healpix=293&coordSystem=EQUATORIAL&media=votable";
                    var msg = new samp.Message("table.load.votable", {"url": tableUrl});
                    connector.connection.notifyAll([msg]);
                });

            $('#sampInvoker').on('click', function () {
                $dialog.dialog("open");
            }).hover(function () {
                $(this).animate({left: '-10px'}, 100);
            }, function () {
                $(this).animate({left: '-20px'}, 100);
            });
        }

        /**************************************************************************************************************/

        /**
         *    Init SAMP module
         */
        function init(m, im, configuration) {
            mizarWidgetAPI = m;
            SampCore = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.Samp);
            imageManager = im;

            if (configuration.votable2geojson) {
                sitoolsBaseUrl = configuration.sitoolsBaseUrl;
                votable2geojsonBaseUrl = configuration.votable2geojson.baseUrl;
            }

            initUI();
            connector = SampCore.initSamp(mizarWidgetAPI.getMizarAPI());

            // Send pointAt messages when navigation modified
            mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.NAVIGATION_MODIFIED, function () {

                if (connector.connection) {
                    if (!pointAtReceived) {
                        // Mizar is connected to Hub
                        var geoPick = mizarWidgetAPI.getCrs().getWorldFrom3D(mizarWidgetAPI.getNavigation().center3d);
                        var message = new samp.Message("coord.pointAt.sky",
                            {"ra": geoPick[0].toString(), "dec": geoPick[1].toString()});
                        connector.connection.notifyAll([message]);
                    }
                    else {
                        pointAtReceived = false;
                    }
                }
            });

            var sampDesc = {
                type: mizarWidgetAPI.LAYER.Vector,
                name: "SAMP",
                pickable: true,
                dataType: "line"
            };

            mizarWidgetAPI.addLayer(sampDesc);

            window.onbeforeunload = function () {
                // Doesn't work onrefresh actually
                connector.unregister();
            }

        }

        /**************************************************************************************************************/

        return {
            init: init,
            sendImage: function() {SampCore.sendImage},
            sendVOTable: function() {SampCore.sendVOTable},
            highlightFeature: function() {SampCore.highlightFeature},
            isConnected: function() {SampCore.isConnected}
        }

    });


define('text!templates/healpixCutService.html',[],function () { return '<div id="HEALPixCut">\n    Arcsec per pixel of result:\n    <div style="margin-left: 20px; margin-bottom: 10px;" class="imageProperties">\n        <label for="cdelt1">X axis: </label><input type="text" id="cdelt1"/><br/>\n        <label for="cdelt2">Y axis: </label><input type="text" id="cdelt2"/>\n    </div>\n    <button style="margin-left: auto; margin-right: auto; display: block;" id="HEALPixCutBtn">Cut viewport</button>\n    <div style="display: inline-block; width: auto; height: 1em;" class="status"></div>\n    <div style="margin-top: 15px;">\n        <em style="font-size: 14px;">Results</em>\n\n        <div class="HEALPixCutResults">\n            <ul style="list-style-type: none;">\n                <%\n                for ( var i=0; i\n                <results.length\n                ; i++ )\n                {\n                print( itemTemplate( { result: results[i] } ) );\n                }\n                %>\n            </ul>\n        </div>\n    </div>\n</div>';});


define('text!templates/cutResultItem.html',[],function () { return '<li data-jobid="<%= result.jobId %>" class="cutResult" style="display: none;"><%= result.name %>:\n    <img data-url="<%= result.url %>" title="Export image by SAMP" class="sampExport" src="css/images/exportSamp.png"/>\n    <a href="<%= result.url %>"\n       download="<% (result.downloadName) ? print(result.downloadName) : print(result.name) %>"><img\n            style="vertical-align: middle; width: 20px; height: 20px;" title="Download" src="css/images/download1.png"></a>\n    <img title="Delete result" class="deleteResult" src="css/images/delete.png"/>\n</li>';});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Moc display & Moc xMatch services
 */
define('uws/HEALPixCutService',["jquery", "./UWSManager", "service/Samp", "gui/dialog/ErrorDialog", "../utils/UtilsCore", "underscore-min", "text!templates/healpixCutService.html", "text!templates/cutResultItem.html", "jquery.ui"],
    function ($, UWSManager, Samp, ErrorDialog, UtilsCore, _, healpixCutServiceHTMLTemplate, healpixCutServiceItemHTMLTemplate) {

        var mizarWidgetAPI;
        var results = [];

// Template generating the healpixCut service content
        var healpixCutServiceTemplate = _.template(healpixCutServiceHTMLTemplate);

// Template generating the result of healpix cut
        var healpixCutServiceItemTemplate = _.template(healpixCutServiceItemHTMLTemplate);

        return {
            init: function (m) {
                mizarWidgetAPI = m;
            },

            addService: function (tabs, context) {
                // Append headers
                $('<li style="display: none;"><a href="#HEALPixCut">HEALPixCut</a></li>')
                    .appendTo(tabs.children(".ui-tabs-nav"))
                    .fadeIn(300);

                // Append content
                var healpixCutServiceContent = healpixCutServiceTemplate({
                    itemTemplate: healpixCutServiceItemTemplate,
                    results: results
                });
                tabs.append(healpixCutServiceContent)
                    .find('li').fadeIn();


                tabs.find('input').on('focus', function () {
                    $(this).removeClass('inputError');
                });

                $('#HEALPixCut').on('click', '.sampExport', function (event) {
                    if (Samp.isConnected()) {
                        Samp.sendImage($(this).data('url'));
                    }
                    else {
                        ErrorDialog.open('You must be connected to SAMP Hub');
                    }
                });

                $('#HEALPixCut').on('click', '.deleteResult', function (event) {
                    var $job = $(this).parent();
                    var jobId = $job.data('jobid');
                    UWSManager.delete('healpixcut', jobId, {
                        successCallback: function () {
                            $job.fadeOut(function () {
                                $(this).remove();
                            });
                        },
                        failCallback: function (thrownError) {
                            console.error(thrownError);
                            // Fade out anyway
                            $job.fadeOut(function () {
                                $(this).remove();
                            });
                        }
                    });
                });

                $('#HEALPixCutBtn').button().click(function (event) {

                    var astro = UtilsCore.getAstroCoordinatesFromCursorLocation(mizarWidgetAPI.getContext(), mizarWidgetAPI.getNavigation());

                    var parameters = UtilsCore.getHEALPixCutCoordinates(event, mizarWidgetAPI.getScene(), mizarWidgetAPI.getNavigation());

                    $('#HEALPixCut').find('.status').html('Healpix cut is in progress, be patient, it may take some time.').fadeIn().css('display: inline-block');

                    UWSManager.post('healpixcut', parameters, {
                        successCallback: function (response, jobId) {
                            var name = 'Viewport ( ' + astro[0] + ' x ' + astro[1] + ' )';
                            var result = {
                                name: name,
                                url: response.results.result[0]['@xlink:href'],
                                downloadName: name.replace('"', '&quot;') + '.fits',
                                jobId: jobId
                            };
                            results.push(result);

                            $('#HEALPixCut').find('.status').hide();
                            var healpixCutItem = healpixCutServiceItemTemplate({result: result});
                            $(healpixCutItem)
                                .appendTo($('#HEALPixCut').find('.HEALPixCutResults ul')).fadeIn();
                        },
                        failCallback: function (message) {
                            $('#HEALPixCut').find('.status').hide();
                            ErrorDialog.open(message);
                        },
                        onloadCallback: function () {
                            $('#HEALPixCut').find('.status').animate({opacity: 0.}, 400, function () {
                                $(this).animate({opacity: 1.}, 400);
                            });
                        }
                    });

                });
            },

            removeService: function (tabs) {
                tabs.find('.ui-tabs-nav li[aria-controls="HEALPixCut"]').css("opacity", 0.);
                var index = $(this).index();
                tabs.tabs("remove", index);
            }
        };

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 *    Layer service view
 *    The view representing the services for each layer
 */
define('gui/LayerServiceView',["jquery", "service/gui/OpenSearchService", "../service/gui/MocService", "../service/gui/XMatchService", "uws/HEALPixCutService", "jquery.ui"],
    function ($, OpenSearchService, MocService, XMatchService, HEALPixCutService) {

        var layerServiceView = '<div id="layerServiceView" title="Available services">\
							        <div id="layerServices">\
								        <ul>\
								        </ul>\
							        </div>\
						        </div>';

// jQuery selectors
        var $layerServiceView;
        var tabs;

        var services = [OpenSearchService, MocService, XMatchService];

        var serviceMapping = {
            "queryForm": OpenSearchService,
            "Moc": MocService,
            "XMatch": XMatchService,
            "HEALPixCut": HEALPixCutService
        };

        var currentLayer;

        /**
         *    Get service object from configuration
         *    (could be string or object)
         */
        function getServiceFromConf(service) {
            if (typeof service === "string") {
                return serviceMapping[service];
            }
            else {
                if (service.name) {
                    return serviceMapping[service.name];
                }
                else {
                    console.error("Service must have name property in configuration");
                    return null;
                }
            }
        }

        /**
         *    Adds a service "key" related to the layer to the toolbar tabs
         *    Returns true when the service is added otherwise false
         */
		function addServiceToGUI(layer, tabs, key) {
			var serviceAdded;
			var service = getServiceFromConf(key);
			if (service == null) {
				serviceAdded = false;
			} else {
                service.initTab(tabs);
				service.addService(tabs, layer);
				serviceAdded = true;
			} 
			return serviceAdded;
		}

        /**
         *    Removes a service "key" related to the layer to the toolbar tabs
         *    Returns true when the service is removed otherwise false
         */
		function removeServiceFromGUI(layer, tabs, key) {
			var serviceRemoved;
			var service = getServiceFromConf(key);
			if (service == null) {
				serviceRemoved = false;
			} else {
                //service.removeLayer(currentLayer);
                service.removeService(tabs, layer);
                service.destroyTab();
				serviceRemoved = true;
			} 
			return serviceRemoved;
		}

        /**
         *    Removes services from GUI
         */
		function removesServicesFromGUI(currentLayer, tabs) {		
            Object.keys(currentLayer.getServices()).forEach(function (key) {
                removeServiceFromGUI(currentLayer, tabs, key);
            });
		}

        /**
         *    Creates services to GUI
         */
		function createServicesToGUI(layer, tabs) {
            Object.keys(layer.getServices()).forEach(function (key) {
                addServiceToGUI(layer, tabs, key);
            });			
		}		

        return {
            /**
             *    Initilize layer service view
             */
            init: function (mizar, configuration) {
                // Create jQuery UI dialog to represent layer service view
                $layerServiceView = $(layerServiceView)
                    .appendTo('body')
                    .dialog({
                        autoOpen: false,
                        resizable: false,
                        width: '600px',
                        show: {
                            effect: "fade",
                            duration: 300
                        },
                        hide: {
                            effect: "fade",
                            duration: 300
                        },
                        minHeight: 'auto',
                        position: ['middle', 20],
                        open: function () {
                            // Remove auto-focus
                            $(this).find('li:first-child').blur();
                        }
                    });

                tabs = $layerServiceView.find('#layerServices').tabs({
                    collapsible: true,
                    hide: {effect: "slideUp", duration: 300},
                    show: {effect: "slideDown", duration: 300}
                });
                OpenSearchService.init(mizar);
                MocService.init(mizar);
                XMatchService.init(mizar, configuration);
                HEALPixCutService.init(mizar);
                document.layerServiceView = this;
                
            },

            /**
             *    Remove created dialog
             */
            remove: function () {
                $layerServiceView.find('#layerServices').tabs("destroy");
                $layerServiceView.dialog("destroy").remove();
            },

            show: function (layer) {
                var service;			
                // Remove previous services
                if (currentLayer) {
					removesServicesFromGUI(currentLayer, tabs);
                }
				createServicesToGUI(layer, tabs);
                currentLayer = layer;

                tabs.tabs('refresh');
                tabs.tabs("option", "active", 0);

                $layerServiceView.dialog("open");
            },
            hide : function() {
                $(layerServiceView).end();
            }
        }

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Histogram module : create histogram to the given image
 */
define('gui/Histogram',[], function () {

    // Private variables
    //var nbBins;

    //var hist = [];
    //var hmax; // histogram max to scale in image space

    // Origin histogram point
    //var originX = 5.;
    //var originY;
    //var hwidth;
    //var paddingBottom = 15.;
    var mizarWidgetAPI;
    var serviceHisto;

    /**************************************************************************************************************/

    /**
     *    TODO: split on HistogramView and Histogram
     *    Histogram contructor
     *    @param options Histogram options
     *        <ul>
     *            <li>image: The image which is represented by current histogram(required)</li>
     *            <li>nbBins: Number of bins, representing the sampling of histogram(optional)</li>
     *            <li>onUpdate: On update callback
     *            <li>accuracy: The accuracy of histogram(numbers after floating point)
     *        </ul>
     */
    var Histogram = function (options) {
        //nbBins = options.nbBins || 256;
        mizarWidgetAPI = options.mizar;
        serviceHisto = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.Histogram);
        this.image = options.image;
        this.onUpdate = options.onUpdate;
        this.accuracy = options.accuracy || 6;

        serviceHisto.init(options);

    };

    /**************************************************************************************************************/

    /**
     *    Get histogram value from the given X-position on canvas
     */
    Histogram.prototype.getHistValue = function (position) {
        serviceHisto.getHistValue(position)
    };

    /**************************************************************************************************************/

    /**
     *    Draw threshold controls(two triangles which represents min/max of current histogram)
     */
    Histogram.prototype.drawThresholdControls = function () {
        serviceHisto.drawThresholdControls()
    };

    /**************************************************************************************************************/

    /**
     *    Draw histogram
     */
    Histogram.prototype.drawHistogram = function (options) {
        serviceHisto.drawHistogram(options)
    };

    /**************************************************************************************************************/

    /**
     *    Draw histogram axis
     */
    Histogram.prototype.drawAxes = function () {
        serviceHisto.drawAxes()
    };

    /**************************************************************************************************************/

    /**
     *    Draw transfer function(linear, log, asin, sqrt, sqr)
     */
    Histogram.prototype.drawTransferFunction = function (options) {
        serviceHisto.drawTransferFunction(options)
    };

    /**************************************************************************************************************/

    /**
     *    Draw the histogram in canvas
     */
    Histogram.prototype.draw = function () {
        serviceHisto.draw()
    };

    /**************************************************************************************************************/

    /**
     *    TODO : create different module
     *    Compute histogram values
     */
    Histogram.prototype.compute = function () {
        serviceHisto.compute()
    };

    /**************************************************************************************************************/

    /**
     *    Set image
     */
    Histogram.prototype.setImage = function (image) {
        serviceHisto.setImage(image)
    };

    /**************************************************************************************************************/

    return Histogram;
});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Animated button
 */
define('uws/AnimatedButton',["jquery", "jquery.ui"], function ($) {

    var AnimatedButton = function (element, options) {
        this.$element = $(element).button();
        this.stopped = true;
        if (options) {
            this.$element.on('click', $.proxy(options.onclick, this));
        }
    };

    /**************************************************************************************************************/

    /**
     *    Start animation
     */
    AnimatedButton.prototype.startAnimation = function () {
        this.stopped = false;
        this.iterateAnimation();
    };

    /**************************************************************************************************************/

    /**
     *    Stop animation
     */
    AnimatedButton.prototype.stopAnimation = function () {
        this.stopped = true;
    };

    /**************************************************************************************************************/

    /**
     *    Loading animation
     */
    AnimatedButton.prototype.iterateAnimation = function () {
        var self = this;
        this.$element.children('span').animate({backgroundColor: "rgb(255, 165, 0);"}, 300, function () {
            $(this).animate({backgroundColor: "transparent"}, 300, function () {
                if (!self.stopped) {
                    self.iterateAnimation();
                }
            });
        });
    };

    /**************************************************************************************************************/

    return AnimatedButton;

});


define('text!templates/dynamicImageView.html',[],function () { return '<div id="imageProcessing">\n    <div>\n        <span class="processOption">Contrast : </span>\n\n        <div class="contrast" style="display: inline-block;">\n            <input name="fitsScale_<%= id %>" type="radio" value="raw" id="raw_<%= id %>" checked="checked"/><label\n                for="raw_<%= id %>">Raw</label>\n            <input name="fitsScale_<%= id %>" type="radio" value="linear" id="linear_<%= id %>"/><label\n                for="linear_<%= id %>">Linear</label>\n            <input name="fitsScale_<%= id %>" type="radio" value="log" id="log_<%= id %>"/><label for="log_<%= id %>">Log</label>\n            <input name="fitsScale_<%= id %>" type="radio" value="sqrt" id="sqrt_<%= id %>"/><label\n                for="sqrt_<%= id %>">Sqrt</label>\n            <input name="fitsScale_<%= id %>" type="radio" value="sqr" id="sqr_<%= id %>"/><label for="sqr_<%= id %>">Pow2</label>\n            <input name="fitsScale_<%= id %>" type="radio" value="asin" id="asin_<%= id %>"/><label\n                for="asin_<%= id %>">AsinH</label>\n        </div>\n    </div>\n\n    <div>\n        <span class="processOption">Colormap : </span>\n        <select class="colormap" style="width:100px;" disabled>\n            <option value="grey">Grey</option>\n            <option value="rainbow">Rainbow</option>\n            <option value="stern">Stern</option>\n            <option value="fire">Fire</option>\n            <option value="eosb">EOSB</option>\n        </select>\n    </div>\n\n    <div>\n        <span class="processOption"> Threshold : </span>\n\n        <div class="thresholdSlider"></div>\n    </div>\n\n    <div>\n\t  \t<span class="thresholdInputs">\n\t  \t\t<label for="min">Min : </label><input type="text" id="min" disabled/>\n\t  \t\t<label for="max">Max : </label><input type="text" id="max" disabled/>\n\t  \t</span>\n    </div>\n\n    <div>\n        <button disabled class="zScale">ZScale</button>\n    </div>\n\n    <div>\n        <span style="width: auto" class="processOption"> Inverse : </span>\n        <input id="inverse_<%= id %>" class="inverse" type="checkbox" disabled/><label for="inverse_<%= id %>"></label>\n    </div>\n\n    <div>\n        <div class="processOption">Histogram :</div>\n        <canvas class="noSelect" id="histogram_<%= id %>" width="275" height="160"></canvas>\n    </div>\n</div>';});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

define('gui/DynamicImageView',['jquery', "underscore-min", "./Histogram", "uws/UWSManager", "uws/AnimatedButton", "./dialog/ErrorDialog", "text!templates/dynamicImageView.html", "jquery.ui"],
    function ($, _, Histogram, UWSManager, AnimatedButton, ErrorDialog, dynamicImageViewHTML) {

        /**************************************************************************************************************/

        /** @constructor
         *    DynamicImageView constructor
         *    Creates jQuery view of the given <GlobWeb.DynamicImage>
         *
         *    @param options
         *        <h3>Required:</h3>
         *        <ul>
         *            <li>id: Identifier</li>
         *        </ul>
         *        <h3>Optional:</h3>
         *        <ul>
         *            <li>image: The image represented by this view</li>
         *            <li>changeShaderCallback: Callback for shader changing</li>
         *        </ul>
         */
        var DynamicImageView = function (element, options) {
            this.id = options.id;
            this.mizarWidget = options.mizar;
            this.changeShaderCallback = options.changeShaderCallback;

            // Interaction parameters
            var selectedColormap = "grey";
            var selectedContrast = "raw";
            var isInversed = false;

            // Create dialog
            var self = this;

            var imageViewContent = _.template(dynamicImageViewHTML);
            this.$element = $('#' + element);
            this.$element.html(imageViewContent({id: this.id}));


            // Initialize contrast buttonset
            this.$element.find('.contrast').buttonset().find('input')
                .each(function (i) {
                    $(this).click(function () {
                        selectedContrast = $(this).val();
                        switch (selectedContrast) {
                            case "linear":
                            case "log":
                            case "sqrt":
                            case "sqr":
                            case "asin":
                                // Enable all interactive components
                                self.enableUI();
                                break;
                            case "raw":
                                // Disable all interactive components
                                self.disableUI();
                                break;
                            default:
                                break;
                        }

                        self.image.updateColormap(selectedContrast, selectedColormap, isInversed);
                        if (self.changeShaderCallback) {
                            self.changeShaderCallback(selectedContrast);
                        }
                        self.render();
                    });
                });

            // Initialize threshold
            var $slider = this.$element.find('.thresholdSlider').slider({
                range: true,
                slide: function (event, ui) {
                    self.$element.find("#min").val(ui.values[0]);
                    self.$element.find("#max").val(ui.values[1]);
                },
                // Compute histogram on stop, because it's more efficient with huge amount of data
                stop: function (event, ui) {
                    self.updateThreshold(ui.values[0], ui.values[1]);
                }
            }).slider("disable");

            this.$element.find('.thresholdInputs').change(function () {
                // Check validity
                var inputMin = parseFloat($(this).children('#min').val());
                if (isNaN(inputMin) || inputMin < self.image.min) {
                    $(this).children('#min').val(self.image.min);
                    inputMin = self.image.min;
                }

                var inputMax = parseFloat($(this).children('#max').val());
                if (isNaN(inputMax) || inputMax > self.image.max) {
                    $(this).children('#max').val(self.image.max);
                    inputMax = self.image.max;
                }

                self.updateThreshold(inputMin, inputMax);
            });

            // Initialize colormap selectmenu
            var $selectmenu = this.$element.find('.colormap').selectmenu({
                select: function (e) {
                    selectedColormap = $(this).children('option:selected').val();
                    self.image.colormap = selectedColormap;
                    self.image.updateColormap(selectedContrast, selectedColormap, isInversed);
                    self.image.renderContext.requestFrame();
                }
            });

            this.$element.find('.inverse').button({
                text: false,
                icons: {
                    primary: ""
                }
            });

            // Initialize inverse checkbox
            this.$element.find('.inverse').click(function () {

                $(this).button("option", {
                    icons: {
                        primary: $(this)[0].checked ? "ui-icon-check" : ""
                    }
                });
                isInversed = $(this).is(':checked');
                self.image.updateColormap(selectedContrast, selectedColormap, isInversed);

                self.render();
            });

            var zScaleButton = new AnimatedButton(this.$element.find('.zScale')[0], {
                onclick: function () {
                    var params = {
                        PHASE: "RUN",
                        uri: self.image.url
                    };

                    if (!self.image.url) {
                        ErrorDialog.open('ZScale can\'t find image url');
                    }

                    zScaleButton.startAnimation();
                    UWSManager.post('zscale', params, {
                        successCallback: function (response) {
                            zScaleButton.stopAnimation();
                            var z1 = parseFloat(response.results.result[0]['@xlink:href']);
                            var z2 = parseFloat(response.results.result[1]['@xlink:href']);

                            self.$element.find("#min").val(z1).animate({
                                color: '#6BCAFF',
                                'border-color': '#6BCAFF'
                            }, 300, function () {
                                $(this).animate({color: '#F8A102', 'border-color': 'transparent'});
                            });
                            self.$element.find("#max").val(z2).animate({
                                color: '#6BCAFF',
                                'border-color': '#6BCAFF'
                            }, 300, function () {
                                $(this).animate({color: '#F8A102', 'border-color': 'transparent'});
                            });

                            self.updateThreshold(z1, z2);
                        },
                        failCallback: function () {
                            zScaleButton.stopAnimation();
                            ErrorDialog.open("ZScale internal server error<br/>");
                        }
                    });
                }
            });

            // Create histogram attached to the canvas2d
            this.histogram = new Histogram({
                mizar : this.mizarWidget,
                canvas: 'histogram_' + this.id,
                nbBeans: 256,
                onUpdate: $.proxy(this.updateThreshold, this)
            });

            // Set image if defined
            if (options.image) {
                options.image.colormap = "grey";
                this.setImage(options.image);
            }
        };

        /**************************************************************************************************************/

        /**
         *    Enable all UI elements
         */
        DynamicImageView.prototype.enableUI = function () {
            this.$element.find('.colormap').selectmenu("enable");
            this.$element.find('.thresholdSlider').slider("enable");
            this.$element.find('.inverse').removeAttr('disabled').button("refresh");
            this.$element.find('.zScale').removeAttr('disabled').button("refresh");
            this.$element.find('.thresholdInputs input').each(function (i) {
                $(this).removeAttr('disabled');
            });
        };

        /**************************************************************************************************************/

        /**
         *    Disable all UI elements
         */
        DynamicImageView.prototype.disableUI = function () {
            this.$element.find('.colormap').selectmenu("disable");
            this.$element.find('.thresholdSlider').slider("disable");
            this.$element.find('.inverse').attr('disabled', 'disabled').button("refresh");
            this.$element.find('.zScale').attr('disabled', 'disabled').button("refresh");
            this.$element.find('.thresholdInputs input').each(function (i) {
                $(this).attr('disabled', 'disabled');
            });
        };

        /**************************************************************************************************************/

        /**
         *    Update threshold
         */
        DynamicImageView.prototype.updateThreshold = function (min, max) {
            this.image.tmin = min;
            this.image.tmax = max;

            this.$element.find("#min").val(min);
            this.$element.find("#max").val(max);

            // Update slider
            this.$element.find('.thresholdSlider').slider({
                values: [min, max]
            });

            this.histogram.compute();
            this.render();
        };

        /**************************************************************************************************************/

        /**
         *    Set image and update image related composants(histogram, slider, placeholder)
         */
        DynamicImageView.prototype.setImage = function (image) {
            var step = (image.max - image.min) / 1000;
            var self = this;
            this.$element.find('.thresholdSlider').slider('option', {
                values: [image.min, image.max],
                min: image.min,
                max: image.max,
                step: step
            });

            this.histogram.setImage(image);

            // Put min/max values into placeholder
            // Maybe not the most ergonomic way to do, but I found it cool J
            this.$element.find('#min').attr("placeholder", image.min).end()
                .find('#max').attr("placeholder", image.max);

            // Update UI values
            this.$element.find('.inverse').attr('checked', (image.inverse) ? 'checked' : false).button('refresh').end()
                .find('.contrast')
                .find('input[value=' + image.transferFn + ']').attr('checked', 'checked').end()
                .buttonset("refresh").end()
                .find('.colormap').val(image.colormap).selectmenu();

            if (image.transferFn === "raw") {
                this.disableUI();
            }
            else {
                this.enableUI();
            }

            this.image = image;
            this.updateThreshold(image.tmin, image.tmax);
            this.render();
        };

        /**************************************************************************************************************/

        /**
         *    Remove view
         */
        DynamicImageView.prototype.remove = function () {
            this.image.dispose();
        };

        /**************************************************************************************************************/

        /**
         *    Render
         */
        DynamicImageView.prototype.render = function () {
            this.histogram.draw();
            this.image.renderContext.requestFrame();
        };

        /**************************************************************************************************************/

        return DynamicImageView;
    });


define('text!templates/featureList.html',[],function () { return '<div id="overlappedObjects">\n    <% if ( selection.length > 1 ) {%>\n    <u><%= selection.length %> Overlapped observations:</u><br/>\n    <% } else { %>\n    <u>Object:</u><br/>\n    <% } %>\n    <div id="scroll-arrow-up" style="display: none" class="scroll-arrow-up"></div>\n    <div id="featureListDiv">\n        <div id="featureList">\n            <%\n            var title = "";\n            for ( var i=0; i < selection.length; i++ ) {\n                var properties = selection[i].feature.properties;\n                title = ( selection[i].feature.id ) ? selection[i].feature.id : ( properties.identifier ) ?\n                properties.identifier : ( properties.name ) ? properties.name : properties.title;\n            %>\n            <div title=<%= title %> class="featureTitle"> <%= title %> <br/></div>\n            <%\n                if (selection[i].layer.name === "Planets" && selection[i].feature.properties.name === "Mars") {\n                    %>\n                    <button id="goToMarsBtn" style="margin-top: 7px; font-size: 11px;">\n                        <span class="ui-button-text">Go to Mars</span>\n                    </button>\n                    <%\n                } else if (selection[i].layer.name === "Landing sites" && selection[i].feature.properties.name === "MSL Curiosity") {\n                    %>\n                    <button id="goToCuriosityBtn" style="margin-top: 7px; font-size: 11px;">\n                        <span class="ui-button-text">See it on Mars</span>\n                    </button>\n                    <%\n                } else if (selection[i].layer.name === "Planets" && selection[i].feature.properties.name === "Sun") {\n                    %>\n                    <button id="goToSunBtn" style="margin-top: 7px; font-size: 11px;">\n                        <span class="ui-button-text">Go to Sun</span>\n                    </button>\n                    <%\n                }\n            }\n            %>\n        </div>\n    </div>\n    <div id="scroll-arrow-down" style="display: none" class="scroll-arrow-down clickable"></div>\n</div>\n';});


define('text!templates/featureDescription.html',[],function () { return '<div class="detailedInfo">\n    <% if ( properties.thumbnail ) { %>\n    <div class="thumbnail"><img src="<%= properties.thumbnail %>"/></div>\n    <% }\n    else if (properties.quicklook) { %>\n    <div class="thumbnail"><img src="<%= properties.quicklook %>"/></div>\n    <% } %>\n    <div class="featureProperties">\n        <% if ( properties.abstract ) { %>\n        <%= properties[\'abstract\'] %>\n        <% } %>\n        <table class="propertiesTable" rules="rows">\n            <tbody>\n            <% print(descriptionTableTemplate( { properties: properties, descriptionTableTemplate:\n            descriptionTableTemplate, dictionary: dictionary }) ); %>\n            </tbody>\n        </table>\n    </div>\n\n    <% if (properties.quicklook || services ) {\n    %>\n    <div id="services">\n        <%\n        if ( properties.quicklook ) {\n        %>\n        <span class="featureService" title="Quicklook" id=\'quicklook\'\n              class="<%= (properties.quicklook && properties.style.fill ? \'selected\' : \'\' ) %>">\n        </span>\n        <% }\n        if ( services ) {\n        if (services.browse) {\n        if (services.browse.layer) {\n        if (services.browse.layer.type == "WMS") {\n        %>\n                    <span class="featureService <%= (hasServiceRunning ? \'selected\' : \'\' ) %>"\n                          title="Quicklook Wms" id=\'quicklookWms\' >\n\t\t\t\t\t</span>\n        <%\n        }\n        }\n        }\n        if ( services.healpix ) { %>\n        \t<span class="featureService"\n                  title="Healpix service" id=\'healpix\'\n                  class="<%= (services.healpix.layer.isVisible() ? \'selected\' : \'\' ) %>">\n\t\t\t</span>\n        <% }\n        if ( services.download && !isMobile) {\n        if ( services.download.mimetype == "image/fits" ) {\n        var fitsQuicklookOn = properties.style.fill && !properties.style.fillTextureUrl; %>\n            <span class="featureService"\n                  title="Fits quicklook" id=\'quicklookFits\'\n                  class="<%= (fitsQuicklookOn ? \'selected\' :\'\' ) %>">\n            </span>\n\t\t\t<span style="display: inline-block; position: relative;">\n\t\t\t\t<span class="featureService"\n                      title="Solar object service" id="solarObjects"\n                      class="<%= (services.solarObjects && services.solarObjects.layer.isVisible() ? \'selected\' : \'\' ) %>">\n\t\t\t\t</span>\n        \t\t<div style="display: none" id="solarObjectsSpinner"></div>\n        \t</span>\n            <span title="Image processing" id="dynamicImageView" class=\'dynamicAvailable\'/>\n        <%}%>\n\n        <a href="<%= services ? services.download.url : \'\' %>" target="_self"><span class="featureService" id="downloadImage" title="Download"/></a>\n\n        <% if ( mizarWidgetAPI.getContext().getComponentVisibility("sampContainer") ) { %>\n            <span class="featureService" title="Export image by SAMP" id="sendImage"></span>\n        <% } %>\n        <div style="display: none;" id="serviceStatus"></div>\n        <%}\n        }%>\n    </div>\n    <% } %>\n\n</div>\n';});


define('text!templates/descriptionTable.html',[],function () { return '<% for ( var key in properties )\n{\nif ( key != \'style\' && key != \'title\' && key != \'quicklook\' && key != \'thumbnail\' && key != \'abstract\' && key != \'style\' )\n{\nvar stringKey = key.toString(); %>\n<tr height="30%">\n    <% // Test if section\n    var title = dictionary[stringKey];\n    if (typeof (properties[key]) === "object" )\n    {\n    if ( key == \'crs\' )\n    {%>\n    <td id="<%=stringKey %>" title="<%= title%>" class="selectProperty"><em><%= stringKey %>:</em></td>\n    <td title="<%= properties[key].properties.name %>" class="selectValue"><%= properties[key].properties.name %></td>\n    <% } else { %>\n    <td id="<%=stringKey %>" title="<%= title%>" class="selectProperty" colspan="2">\n        <div id="arrow" class="arrow-right"></div>\n        <div class="section"><b><%= stringKey %></b></div>\n        <table class="propertiesTable" style="display: none; margin-left: 10px" rules="rows">\n            <tbody>\n            <% print( descriptionTableTemplate( { dictionary: dictionary, properties: properties[key],\n            descriptionTableTemplate: descriptionTableTemplate }) );\n            %>\n            </tbody>\n        </table>\n    </td>\n    <% }\n    }\n    else\n    {%>\n    <td id="<%=stringKey%>" title="<%= title%>" class="selectProperty"><em><%= stringKey %>:</em></td>\n    <%\n    var isUrl = ( typeof (properties[key]) === "string" && properties[key].substr(0,4) == \'http\' ) ? true : false;\n    if (isUrl) {%>\n    <td class="selectValue"><a href="<%= properties[key] %>"><%= properties[key] %></a></td>\n    <% } else { %>\n    <td class="selectValue" title="<%= properties[key] %>"><%= properties[key] %></td>\n    <% }\n    } %>\n</tr>\n<% }\n} %>';});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * FeaturePopup module
 */
define('gui/FeaturePopupCore',["jquery", "underscore-min", "text!templates/featureList.html", "text!templates/featureDescription.html", "text!templates/descriptionTable.html"],
    function ($, _, featureListHTMLTemplate, featureDescriptionHTMLTemplate, descriptionTableHTMLTemplate) {

        var mizarWidgetAPI;
        var featureListHTML = '';
        var pickingManager = null;
        var imageManager = null;
        var configuration;
        var $selectedFeatureDiv;
        var $leftDiv;
        var $rightDiv;
        var isMobile;

        // Template generating the list of selected features
        var featureListTemplate = _.template(featureListHTMLTemplate);

        // Template generating the detailed description of choosen feature
        var featureDescriptionTemplate = _.template(featureDescriptionHTMLTemplate);

        // Template generating the table of properties of choosen feature
        var descriptionTableTemplate = _.template(descriptionTableHTMLTemplate);


        /**********************************************************************************************/

        /**
         *    Insert HTML code of choosen feature
         */
        function createHTMLSelectedFeatureDiv(layer, feature) {
            if (!layer.hasOwnProperty('dictionary')) {
                createDictionary(layer, feature.properties);
            }
            var output = featureDescriptionTemplate({
                dictionary: layer.dictionary,
                services: feature.properties.services,
                properties: buildProperties(feature.properties, layer.displayProperties),
                descriptionTableTemplate: descriptionTableTemplate,
                hasServiceRunning : layer.hasServicesRunningOnRecord(feature.id),
                mizarWidgetAPI : mizarWidgetAPI,
                isMobile: isMobile
            });


            $rightDiv.html(output);

            // Stay in canvas
            $rightDiv.find('.featureProperties').css('max-height', computeHeight());

            $selectedFeatureDiv.find('.featureProperties').niceScroll({
                autohidemode: false
            }).hide();
        }

        /**********************************************************************************************/

        /**
         *    Insert HTML code of selected features
         *
         *    @param {<GlobWeb.Feature>[]} selection Array of features
         */
        function createFeatureList(selection) {
            featureListHTML = featureListTemplate({selection: selection});
            $leftDiv.html(featureListHTML);

            if (selection[0].layer.name === "Planets" && selection[0].feature.properties.name === "Mars") {
                var button = $('#goToMarsBtn');

                button.button().once().click(function () {
                    mizarWidgetAPI.createMarsContext();
                    $('#selectedFeatureDiv').hide();
                });
            } else if (selection[0].layer.name === "Landing sites" && selection[0].feature.properties.name === "MSL Curiosity") {
                var button = $('#goToCuriosityBtn');

                button.button().once().click(function () {
                    mizarWidgetAPI.createCuriosityContext();
                    $('#selectedFeatureDiv').hide();
                });
            } else if (selection[0].layer.name === "Planets" && selection[0].feature.properties.name === "Sun") {
                var button = $('#goToSunBtn');

                button.button().once().click(function () {
                    mizarWidgetAPI.createSunContext();
                    $('#selectedFeatureDiv').hide();
                });
            }
        }
        /**********************************************************************************************/

        /**
         *    Selected feature div position calculations
         *
         *    @param clientX event.clientX
         *    @param clientY event.clientY
         */
        function computeDivPosition(clientX, clientY) {

            var mousex = clientX; //Get X coodrinates
            var mousey = clientY; //Get Y coordinates

            mousex += 20;
            mousey -= 100;

            // Positionning
            $('#selectedFeatureDiv').css({
                position: 'absolute',
                left: mousex + 'px',
                top: mousey + 'px'
            });
        }

        /**********************************************************************************************/

        /**
         *    Compute optimal height of current viewport
         */
        function computeHeight() {
            return 2 * $('#' + mizarWidgetAPI.getRenderContext().canvas.id).height() / 5;
        }

        /**********************************************************************************************/

        /**
         *    Appropriate layout of properties depending on displayProperties
         *
         *    @param properties Feature properties to modify
         *    @param {String[]} displayProperties Array containing properties which must be displayed at first
         *
         *    @return Properties matching displayProperties
         */
        function buildProperties(properties, displayProperties) {
            var cleanedProperties = {};
            for (key in properties) {
                if(properties[key] == null || key === "services" || key === "links" || key === "storage") {
                    // do not display it
                } else {
                    cleanedProperties[key] = properties[key];
                }
            }
            if (displayProperties) {
                var handledProperties = {};
                handledProperties.title = cleanedProperties.title ? cleanedProperties.title : "";
                handledProperties.style = cleanedProperties.style;

                // Fill handledProperties in order
                var key;
                for (var j = 0; j < displayProperties.length; j++) {
                    key = displayProperties[j];
                    if (cleanedProperties[key]) {
                        handledProperties[key] = cleanedProperties[key];
                    }
                }

                handledProperties.others = {};
                // Handle the rest into sub-section "others"
                for (key in properties) {
                    if (!handledProperties[key]) {
                        handledProperties.others[key] = cleanedProperties[key];
                    }
                }

                return handledProperties;
            }
            else {
                return cleanedProperties;
            }
        }

        /**********************************************************************************************/

        /**
         *    Add property description to the dictionary
         *
         *    @param describeUrl Open Search describe document url
         *    @param property Property
         *    @param dictionary Dictionary to complete
         */
        function addPropertyDescription(describeUrl, property, dictionary) {
            $.ajax({
                type: "GET",
                url: describeUrl + property,
                dataType: 'text',
                success: function (response) {
                    dictionary[property] = response;
                    $('#' + property).attr("title", response);
                },
                error: function (xhr) {
                    console.error(xhr);
                }
            });
        }

        /**********************************************************************************************/

        /**
         *    Create dictionary
         *
         *    @param {Layer} layer
         *    @param properties Feature properties
         */
        function createDictionary(layer, properties) {
            layer.dictionary = {};
            // Get dictionary template from open search description document
            $.ajax({
                type: "GET",
                url: layer.serviceUrl,
                dataType: "xml",
                success: function (xml) {
                    var dicodesc = $(xml).find('Url[rel="dicodesc"]');
                    var describeUrl = $(dicodesc).attr("template");

                    if (describeUrl) {
                        // Cut unused part
                        var splitIndex = describeUrl.indexOf("{");
                        if (splitIndex !== -1) {
                            describeUrl = describeUrl.substring(0, splitIndex);
                        }
                        for (var key in properties) {
                            addPropertyDescription(describeUrl, key, layer.dictionary);
                        }
                    }
                    //else
                    //{
                    // No dico found
                    //}
                },
                error: function (xhr) {
                    // No dico found
                    //console.error(xhr);
                }
            });
        }

        /**********************************************************************************************/

        /**
         * Show or Hide a quicklook
         */
        function showOrHideQuicklook() {
            var selectedData = pickingManager.getSelectedData();

            var otherQuicklookOn = false;
            
            if (selectedData.layer.type === "OpenSearch") {
                // Special case OpenSearch
                otherQuicklookOn = selectedData.layer.isQuicklookDisplayed();
                selectedData.isFits = false;
                selectedData.isWms = false;
                if (otherQuicklookOn === true) {
                    imageManager.removeImage(selectedData);
                    // Check if feature id is different
                    if (selectedData.layer.currentIdDisplayed !== selectedData.feature.id) {
                        imageManager.addImage(selectedData);
                    }
                } else {
                    imageManager.addImage(selectedData);
                }
            } else {
                otherQuicklookOn = selectedData.feature.properties.style.fill && !selectedData.feature.properties.style.fillTextureUrl;

                if (otherQuicklookOn === true) {
                    // Remove fits quicklook
                    imageManager.removeImage(selectedData);
                }

                selectedData.isFits = false;
                selectedData.isWms = false;
                if (selectedData.feature.properties.style.fill === true) {
                    imageManager.removeImage(selectedData);
                } else {
                    imageManager.addImage(selectedData);
                }
            }
        }

        function showOrHideQuicklookWms() {
            var selectedData = pickingManager.getSelectedData();
            
            var otherQuicklookOn = false;
            
            if (selectedData.layer.type === "OpenSearch") {
                if (selectedData.layer.hasServicesRunningOnRecord(selectedData.feature.id)) {
                    $('#quicklookWms').removeClass('selected');
                    selectedData.layer.unloadWMS(selectedData);
                } else {
                    $('#quicklookWms').addClass('selected');
                    selectedData.layer.loadWMS(selectedData);
                }
            } else {
                otherQuicklookOn = selectedData.feature.properties.style.fill && !selectedData.feature.properties.style.fillTextureUrl;

                if (otherQuicklookOn === true) {
                    // Remove fits quicklook
                    imageManager.removeImage(selectedData);
                }

                selectedData.isFits = false;
                selectedData.isWms = false;
                if (selectedData.feature.properties.style.fill === true) {
                    imageManager.removeImage(selectedData);
                } else {
                    imageManager.addImage(selectedData);
                }
            }
        }

        
        /**********************************************************************************************/

        /**
         * Show or Hide a quicklook fits
         */
        function showOrHideQuicklookFits() {
            var selectedData = pickingManager.getSelectedData();

            var otherQuicklookOn = selectedData.feature.properties.style.fill && selectedData.feature.properties.style.fillTextureUrl;
            if (otherQuicklookOn) {
                // Remove quicklook
                imageManager.removeImage(selectedData);
            }

            selectedData.isFits = true;
            if (selectedData.feature.properties.style.fill === true) {
                imageManager.removeImage(selectedData);
            }
            else {
                imageManager.addImage(selectedData);
            }
        }

        /**********************************************************************************************/

        /**
         * Send image by Samp
         */
        function sendImageBySamp() {
            var selectedData = pickingManager.getSelectedData();
            var message = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.Samp).sendImage(selectedData.feature.services.download.url);
            $('#serviceStatus').html(message).slideDown().delay(1500).slideUp();
        }

        /**********************************************************************************************/

        /**
         * Show or Hide HEALPix Service
         * @param {Event} event
         */
        function showOrHideHEALPixService(event) {
            var selectedData = pickingManager.getSelectedData();
            var healpixLayer = selectedData.feature.services.healpix.layer;

            if ($('#healpix').is('.selected')) {
                $('#healpix').removeClass('selected');
                healpixLayer.setVisible(false);
            }
            else {
                $('#healpix').addClass('selected');
                healpixLayer.setVisible(true);
            }
        }
        

        /**********************************************************************************************/

        function showOrHideDynamicImageService() {
            $(this).toggleClass('selected');
            var selectedData = pickingManager.getSelectedData();
            mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.ImageProcessing).setData(selectedData);
        }

        /**********************************************************************************************/

        /**
         *    Hide popup
         *
         *    @param callback Callback
         */
        function hide(callback) {
            if ($selectedFeatureDiv.css('display') !== 'none') {
                $selectedFeatureDiv.find('.featureProperties').getNiceScroll().hide();

                $selectedFeatureDiv.fadeOut(300, function () {
                    $selectedFeatureDiv.find('.featureProperties').getNiceScroll().remove();

                    if (callback) {
                        callback();
                    }
                });
            }
            else if (callback) {
                callback();
            }
        }

        /**********************************************************************************************/

        /**
         *    Show popup
         *
         *    @param x X in window coordinate system
         *    @param y Y in window coordinate system
         *    @param callback Callback
         */
        function show(x, y, callback) {
            computeDivPosition(x, y);
            $selectedFeatureDiv.fadeIn(500, function () {
                $selectedFeatureDiv.find('.featureProperties').getNiceScroll().resize();
                if (callback) {
                    callback();
                }
            });
            var maxHeight = computeHeight();
            var popupMaxHeight = maxHeight - 60;
            $('#featureListDiv').css('max-height', popupMaxHeight);
            if ($leftDiv.find('#featureList').height() > popupMaxHeight) {
                $leftDiv.find('.scroll-arrow-up, .scroll-arrow-down').css('display', 'block');
            }
        }

        /**********************************************************************************************/

        /**
         * Choose a feature by clicking on its title
         */
        function selectFeatureOnTitle() {
            pickingManager.blurSelectedFeature();
            $('#featureList div.selected').removeClass('selected');

            var featureIndexToFocus = $(this).index();
            pickingManager.focusFeatureByIndex(featureIndexToFocus, {isExclusive: true});
            var selectedData = pickingManager.getSelectedData();

            $('#featureList div:eq(' + featureIndexToFocus + ')').addClass('selected');
            if (selectedData) {
                showFeatureInformation(selectedData.layer, selectedData.feature);
            }

            mizarWidgetAPI.getRenderContext().requestFrame();

            // TODO highlight is not fully implemented
            // Samp.highlightFeature(selectedData.layer, selectedData.feature);
        }

        /**********************************************************************************************/

        /**
         * Show feature information
         * @param {Layer} layer
         * @param {Feature} feature
         */
        function showFeatureInformation(layer, feature) {
            $rightDiv.find('.featureProperties').getNiceScroll().hide();
            $rightDiv.fadeOut(300, function () {
                $rightDiv.find('.featureProperties').getNiceScroll().remove();
                createHTMLSelectedFeatureDiv(layer, feature);
                $(this).fadeIn(300, function () {
                    $selectedFeatureDiv.find('.featureProperties').getNiceScroll().resize();
                    $selectedFeatureDiv.find('.featureProperties').getNiceScroll().show();
                });
            });
        }

        /**********************************************************************************************/

        /**
         * Generate feature meta data for the given feature
         * @param {Layer} layer
         * @param {Feature} feature
         */
        function generateFeatureMetadata(layer, feature) {
            return featureDescriptionTemplate({
                dictionary: layer.hasOwnProperty('dictionary') ? layer.dictionary : createDictionary(layer, feature.properties),
                services: false,
                properties: buildProperties(feature.properties, layer.displayProperties),
                descriptionTableTemplate: descriptionTableTemplate
            });
        }

        /**********************************************************************************************/

        return {
            init: function (m, selectFeatDiv, pm, im, conf) {
                mizarWidgetAPI = m;
                pickingManager = pm;
                imageManager = im;
                configuration = conf;
                isMobile = conf.isMobile;

                $selectedFeatureDiv = selectFeatDiv;
                $leftDiv = $('#leftDiv');
                $rightDiv = $('#rightDiv');
            },
            createFeatureList: createFeatureList,
            createDictionary: createDictionary,
            computeDivPosition: computeDivPosition,
            computeHeight: computeHeight,
            buildProperties: buildProperties,
            showOrHideQuicklook: showOrHideQuicklook,
            showOrHideQuicklookWms: showOrHideQuicklookWms,
            showOrHideQuicklookFits: showOrHideQuicklookFits,
            sendImageBySamp: sendImageBySamp,
            showOrHideHEALPixService: showOrHideHEALPixService,
            showOrHideDynamicImageService: showOrHideDynamicImageService,
            showFeatureInformation: showFeatureInformation,
            selectFeatureOnTitle: selectFeatureOnTitle,
            hide: hide,
            show: show
        }
    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * IFrame module : popup appearing when clicking on external link
 */
define('gui/IFrame',["jquery"], function ($) {

    var iframe =
        '<div id="externalIFrame" class="contentBox">\
            <div id="IFrameToolbar" class="ui-widget-header ui-widget-header ui-corner-all">\
              <button id="previous">Previous page</button>\
              <button id="next">Next page</button>\
            </div>\
            <div class="closeBtn">\
                <span class="defaultImg"></span>\
                <span style="opacity: 0" class="hoverImg"></span>\
            </div>\
            <iframe src="">Your browser does not support iframes.</iframe>\
        </div>';

    /**
     * Private variables for the module
     */
    var $iframeDiv;
    var history;

    /**
     * Init the module
     */
    function _init() {
        // Create the frame div and append it to the page
        $iframeDiv = $(iframe).appendTo('body');

        // Create the object to manage history
        history = {
            pile: [],
            index: 0,
            clicked: false,
            clean: function () {
                this.pile.length = 0;
                this.index = 0;
                this.clicked = false;
            }
        };

        $("#previous").button({
            width: 20,
            height: 20,
            text: false,
            icons: {
                primary: "ui-icon-circle-triangle-w"
            }
        }).click(function (event) {
            event.preventDefault();
            //console.log('prev : '+history.index);
            if (history.index > 1) {
                history.index--;
                history.clicked = true;
                $iframeDiv.find('iframe')[0].contentWindow.history.back();
            }
        });

        $("#next").button({
            width: 20,
            height: 20,
            text: false,
            icons: {
                secondary: "ui-icon-circle-triangle-e"
            }
        }).click(function (event) {
            event.preventDefault();
            //console.log('next : '+history.index);
            if (history.index != history.pile.length) {
                history.index++;
                history.clicked = true;
                $iframeDiv.find('iframe')[0].contentWindow.history.forward();
            }
        });

        $iframeDiv.find('iframe').on('load', function () {
            //console.log('onLoad : clicked: '+history.clicked+'index : '+history.index);
            if (history.clicked) {
                history.clicked = false;
                return false;
            }

            // Update history
            history.pile.splice(history.index);
            history.pile.push($iframeDiv.find('iframe')[0].attributes.src.nodeValue);
            history.index++;
        });
    }

    return {
        /**
         *    Hide iframe
         */
        hide: function () {
            if ($iframeDiv) {
                $iframeDiv.animate({top: -1000}, 800);
            }
        },

        /**
         *    Show iframe
         *
         *    @param html External link url
         */
        show: function (html) {

            if (!$iframeDiv) {
                _init();
            }

            history.clean();
            historyClick = false;
            var canvasWidth = parseInt($('#GlobWebCanvas').css("width"));
            var canvasHeight = parseInt($('#GlobWebCanvas').css("height"));
            var optimalWidth = canvasWidth * 0.8;
            var optimalHeight = canvasHeight * 0.8;
            var optimalTop = canvasHeight * 0.1;
            $iframeDiv.find('iframe').css({width: optimalWidth, height: optimalHeight}).attr('src', html);
            $iframeDiv.animate({top: optimalTop}, 800);
        }
    };

});


define('text!templates/cutOut.html',[],function () { return '<div class="cutOutService">\n    <div style="text-align: center;">\n        <button id="selectionTool">Select area</button>\n        <button id="clearSelection">Clear area</button>\n        <br/>\n        <button id="runJob">Cut</button>\n        <div style="display: none;" class="jobStatus"></div>\n    </div>\n    <hr/>\n    <em>Results</em>\n\n    <div class="cutoutResults">\n        <ul style="list-style-type: none;">\n        </ul>\n    </div>\n</div>';});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*global define: false */

define('gui/CutOutView',["jquery", "uws/UWSManager", "service/Samp", "uws/AnimatedButton", "./dialog/ErrorDialog", "underscore-min", "text!templates/cutOut.html", "text!templates/cutResultItem.html", "jquery.ui"],
    function ($, UWSManager, Samp, AnimatedButton, ErrorDialog, _, cutOutHTMLTemplate, cutResultHTMLTemplate) {

// Template generating UWS services div
        var cutOutTemplate = _.template(cutOutHTMLTemplate);

// Template generating the cutOut result li
        var cutResultTemplate = _.template(cutResultHTMLTemplate);

        /**
         * UWS CutOut View
         */
        var CutOutView = function (element, selectionTool, pickingManager) {
            this.pickingManager = pickingManager;
            // Initialize selection tool
            this.selectionTool = selectionTool;

            var cutOutContent = cutOutTemplate();
            var self = this;
            $('#' + element).html("");
            this.$content = $(cutOutContent)
                .appendTo('#' + element)
                .find('#selectionTool')
                .button()
                .click(function () {
                    self.$content.slideUp();
                    // Deactivate picking events
                    self.pickingManager.deactivate();
                    self.selectionTool.toggle();
                }).end()
                .find('#clearSelection')
                .button()
                .click(function () {
                    self.selectionTool.clear();
                }).end();

            this.runButton = new AnimatedButton($('#' + element).find('#runJob')[0], {
                onclick: $.proxy(this.runJob, this)
            });

            this.$content.on('click', '.sampExport', function (event) {
                if (Samp.isConnected()) {
                    Samp.sendImage($(this).data('url'));
                }
                else {
                    ErrorDialog.open('You must be connected to SAMP Hub');
                }
            });

            this.$content.on('click', '.deleteResult', function (event) {
                var $job = $(this).parent();
                var jobId = $job.data('jobid');

                UWSManager.delete('cutout', jobId, {
                    successCallback: function () {
                        // Remove all job-related results
                        $job.parent().find('li[data-jobid=' + $job.data('jobid') + ']').each(function () {
                            $(this).fadeOut(function () {
                                $(this).remove();
                            });
                        });
                    },
                    failCallback: function (thrownError) {
                        console.error(thrownError);
                        // Fade out anyway
                        $job.parent().find('li[data-jobid=' + $job.data('jobid') + ']').each(function () {
                            $(this).fadeOut(function () {
                                $(this).remove();
                            });
                        });
                    }
                });
            });
        };

        /**************************************************************************************************************/

        /**
         *    Run job
         */
        CutOutView.prototype.runJob = function () {
            if (this.selectionTool.selectionFeature) {
                this.runButton.startAnimation();

                var parameters = {
                    PHASE: "RUN",
                    uri: this.url,
                    ra: this.selectionTool.geoPickPoint[0],
                    dec: this.selectionTool.geoPickPoint[1],
                    radius: this.selectionTool.geoRadius
                };
                var self = this;
                UWSManager.post('cutout', parameters, {
                    successCallback: function (response, jobId) {
                        self.showMessage('Completed');
                        for (var i = 0; i < response.results.result.length; i++) {
                            var result = response.results.result[i];
                            var name = result['@id'];
                            var url = result['@xlink:href'];

                            //Encode special caracters(at least '?')
                            if (url.search("[?]") > 0) {
                                var lastSlash = url.lastIndexOf('/') + 1;
                                url = url.substr(0, lastSlash) + encodeURIComponent(name);
                            }

                            var proxyIndex = name.search('file_id=');
                            var shortName;
                            if (proxyIndex >= 0) {
                                shortName = name.substr(proxyIndex + 8);
                            }
                            else {
                                shortName = name;
                            }
                            self.runButton.stopAnimation();

                            result = {
                                name: shortName,
                                url: url,
                                jobId: jobId
                            };

                            var cutOutResult = cutResultTemplate({result: result});
                            $(cutOutResult)
                                .appendTo(self.$content.find('.cutoutResults').find('ul'))
                                .fadeIn(400);
                        }
                    },
                    failCallback: function (error) {
                        self.runButton.stopAnimation();
                        self.showMessage(error);
                    }
                });
            }
            else {
                this.showMessage('Please, select area to cut');
            }
        };

        /**************************************************************************************************************/

        CutOutView.prototype.showMessage = function (message) {
            this.$content.find('.jobStatus').html(message).stop().slideDown(300).delay(2000).slideUp();
        };

        /**************************************************************************************************************/

        CutOutView.prototype.setUrl = function (url) {
            this.url = url;
        };

        /**************************************************************************************************************/

        return CutOutView;

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*global define: false */

/**
 *    UWS CutOutViewFactory
 *    Designed to share selectionTool & picking manager between views
 */
define('gui/CutOutViewFactory',["jquery", "./CutOutView"],
    function ($, CutOutView) {

        var mizarWidgetAPI;
        var selectionTool;
        var pickingManager;
        var views = [];

        /**************************************************************************************************************/

        return {
            init: function (m, pm) {
                mizarWidgetAPI = m;
                pickingManager = pm;

                // Initialize selection tool
                selectionTool = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.SelectionTool, {
                    ctx: mizarWidgetAPI.getContext(),
                    onselect: function () {
                        $('.cutOutService').slideDown();
                        // Activate picking events
                        pickingManager.activate();
                        selectionTool.toggle();
                    }
                });
                views = [];
            },

            addView: function (element) {
                var view = new CutOutView(element, selectionTool, pickingManager);
                views.push(view);
                return view;
            },

            removeView: function (view) {
                var index = views.indexOf(view);
                views.splice(index, 1);
            }
        };

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 *    ImageProcessing module
 */
define('gui/ImageProcessing',["jquery", "./CutOutViewFactory", "./DynamicImageView", "jquery.ui"],
    function ($, CutOutViewFactory, DynamicImageView) {

        /**************************************************************************************************************/

        var unselect;
        var cutOutElement;
        var mizarWidgetAPI;

        /**************************************************************************************************************/

        /**
         *    Remove view
         */
        function remove() {
            CutOutViewFactory.removeView(cutOutElement);
        }

        /**************************************************************************************************************/

        return {

            /**
             *    Init ImageProcessing
             *
             *    @param options
             *        <ul>
             *            <li>unselect: Unselect callback</li>
             *        </ul>
             */
            init: function (options) {
                if (options) {
                    mizarWidgetAPI = options.mizar;
                    //this.id = options.id;

                    // Callbacks
                    unselect = options.unselect || null;
                }

                var dialog =
                    '<div>\
                        <div class="imageProcessing" id="imageProcessing" title="Image processing">\
                            <h3>Histogram</h3>\
                            <div class="histogramContent">\
                                <p> Fits isn\'t loaded, thus histogram information isn\'t available</p>\
                                <div style="display: none;" id="histogramView"></div>\
                            </div>\
                            <h3>Cutout</h3>\
                            <div id="cutOutView"></div>\
                        </div>\
                    </div>';

                var $dialog = $(dialog).appendTo('body').dialog({
                    title: 'Image processing',
                    autoOpen: false,
                    show: {
                        effect: "fade",
                        duration: 300
                    },
                    hide: {
                        effect: "fade",
                        duration: 300
                    },
                    width: 500,
                    resizable: false,
                    minHeight: 'auto',
                    close: function (event, ui) {
                        if (unselect) {
                            unselect();
                        }

                        $(this).dialog("close");

                    }
                }).find(".imageProcessing").accordion({
                    autoHeight: false,
                    active: 0,
                    collapsible: true,
                    heightStyle: "content"
                }).end();

                var histogramElement = new DynamicImageView("histogramView", {
                    id: "featureImageProcessing",
                    mizar : mizarWidgetAPI,
                    changeShaderCallback: mizarWidgetAPI.getMizarAPI().ServiceFactory.create(mizarWidgetAPI.SERVICE.ImageProcessing).changeShaderCallback
                });
                cutOutElement = CutOutViewFactory.addView("cutOutView");

                mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.ImageProcessing).init(options, $dialog, histogramElement, cutOutElement);

                mizarWidgetAPI.subscribeCtx("image:set", mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.ImageProcessing).setImage);
            }
        };
    });

/* jquery.nicescroll v3.7.6 InuYaksa - MIT - https://nicescroll.areaaperta.com */
!function(e){"function"==typeof define&&define.amd?define('jquery.nicescroll.min',["jquery"],e):"object"==typeof exports?module.exports=e(require("jquery")):e(jQuery)}(function(e){"use strict";var o=!1,t=!1,r=0,i=2e3,s=0,n=e,l=document,a=window,c=n(a),d=[],u=a.requestAnimationFrame||a.webkitRequestAnimationFrame||a.mozRequestAnimationFrame||!1,h=a.cancelAnimationFrame||a.webkitCancelAnimationFrame||a.mozCancelAnimationFrame||!1;if(u)a.cancelAnimationFrame||(h=function(e){});else{var p=0;u=function(e,o){var t=(new Date).getTime(),r=Math.max(0,16-(t-p)),i=a.setTimeout(function(){e(t+r)},r);return p=t+r,i},h=function(e){a.clearTimeout(e)}}var m=a.MutationObserver||a.WebKitMutationObserver||!1,f=Date.now||function(){return(new Date).getTime()},g={zindex:"auto",cursoropacitymin:0,cursoropacitymax:1,cursorcolor:"#424242",cursorwidth:"6px",cursorborder:"1px solid #fff",cursorborderradius:"5px",scrollspeed:40,mousescrollstep:27,touchbehavior:!1,emulatetouch:!1,hwacceleration:!0,usetransition:!0,boxzoom:!1,dblclickzoom:!0,gesturezoom:!0,grabcursorenabled:!0,autohidemode:!0,background:"",iframeautoresize:!0,cursorminheight:32,preservenativescrolling:!0,railoffset:!1,railhoffset:!1,bouncescroll:!0,spacebarenabled:!0,railpadding:{top:0,right:0,left:0,bottom:0},disableoutline:!0,horizrailenabled:!0,railalign:"right",railvalign:"bottom",enabletranslate3d:!0,enablemousewheel:!0,enablekeyboard:!0,smoothscroll:!0,sensitiverail:!0,enablemouselockapi:!0,cursorfixedheight:!1,directionlockdeadzone:6,hidecursordelay:400,nativeparentscrolling:!0,enablescrollonselection:!0,overflowx:!0,overflowy:!0,cursordragspeed:.3,rtlmode:"auto",cursordragontouch:!1,oneaxismousemode:"auto",scriptpath:function(){var e=l.currentScript||function(){var e=l.getElementsByTagName("script");return!!e.length&&e[e.length-1]}(),o=e?e.src.split("?")[0]:"";return o.split("/").length>0?o.split("/").slice(0,-1).join("/")+"/":""}(),preventmultitouchscrolling:!0,disablemutationobserver:!1,enableobserver:!0,scrollbarid:!1},v=!1,w=function(){if(v)return v;var e=l.createElement("DIV"),o=e.style,t=navigator.userAgent,r=navigator.platform,i={};return i.haspointerlock="pointerLockElement"in l||"webkitPointerLockElement"in l||"mozPointerLockElement"in l,i.isopera="opera"in a,i.isopera12=i.isopera&&"getUserMedia"in navigator,i.isoperamini="[object OperaMini]"===Object.prototype.toString.call(a.operamini),i.isie="all"in l&&"attachEvent"in e&&!i.isopera,i.isieold=i.isie&&!("msInterpolationMode"in o),i.isie7=i.isie&&!i.isieold&&(!("documentMode"in l)||7===l.documentMode),i.isie8=i.isie&&"documentMode"in l&&8===l.documentMode,i.isie9=i.isie&&"performance"in a&&9===l.documentMode,i.isie10=i.isie&&"performance"in a&&10===l.documentMode,i.isie11="msRequestFullscreen"in e&&l.documentMode>=11,i.ismsedge="msCredentials"in a,i.ismozilla="MozAppearance"in o,i.iswebkit=!i.ismsedge&&"WebkitAppearance"in o,i.ischrome=i.iswebkit&&"chrome"in a,i.ischrome38=i.ischrome&&"touchAction"in o,i.ischrome22=!i.ischrome38&&i.ischrome&&i.haspointerlock,i.ischrome26=!i.ischrome38&&i.ischrome&&"transition"in o,i.cantouch="ontouchstart"in l.documentElement||"ontouchstart"in a,i.hasw3ctouch=(a.PointerEvent||!1)&&(navigator.maxTouchPoints>0||navigator.msMaxTouchPoints>0),i.hasmstouch=!i.hasw3ctouch&&(a.MSPointerEvent||!1),i.ismac=/^mac$/i.test(r),i.isios=i.cantouch&&/iphone|ipad|ipod/i.test(r),i.isios4=i.isios&&!("seal"in Object),i.isios7=i.isios&&"webkitHidden"in l,i.isios8=i.isios&&"hidden"in l,i.isios10=i.isios&&a.Proxy,i.isandroid=/android/i.test(t),i.haseventlistener="addEventListener"in e,i.trstyle=!1,i.hastransform=!1,i.hastranslate3d=!1,i.transitionstyle=!1,i.hastransition=!1,i.transitionend=!1,i.trstyle="transform",i.hastransform="transform"in o||function(){for(var e=["msTransform","webkitTransform","MozTransform","OTransform"],t=0,r=e.length;t<r;t++)if(void 0!==o[e[t]]){i.trstyle=e[t];break}i.hastransform=!!i.trstyle}(),i.hastransform&&(o[i.trstyle]="translate3d(1px,2px,3px)",i.hastranslate3d=/translate3d/.test(o[i.trstyle])),i.transitionstyle="transition",i.prefixstyle="",i.transitionend="transitionend",i.hastransition="transition"in o||function(){i.transitionend=!1;for(var e=["webkitTransition","msTransition","MozTransition","OTransition","OTransition","KhtmlTransition"],t=["-webkit-","-ms-","-moz-","-o-","-o","-khtml-"],r=["webkitTransitionEnd","msTransitionEnd","transitionend","otransitionend","oTransitionEnd","KhtmlTransitionEnd"],s=0,n=e.length;s<n;s++)if(e[s]in o){i.transitionstyle=e[s],i.prefixstyle=t[s],i.transitionend=r[s];break}i.ischrome26&&(i.prefixstyle=t[1]),i.hastransition=i.transitionstyle}(),i.cursorgrabvalue=function(){var e=["grab","-webkit-grab","-moz-grab"];(i.ischrome&&!i.ischrome38||i.isie)&&(e=[]);for(var t=0,r=e.length;t<r;t++){var s=e[t];if(o.cursor=s,o.cursor==s)return s}return"url(https://cdnjs.cloudflare.com/ajax/libs/slider-pro/1.3.0/css/images/openhand.cur),n-resize"}(),i.hasmousecapture="setCapture"in e,i.hasMutationObserver=!1!==m,e=null,v=i,i},b=function(e,p){function v(){var e=T.doc.css(P.trstyle);return!(!e||"matrix"!=e.substr(0,6))&&e.replace(/^.*\((.*)\)$/g,"$1").replace(/px/g,"").split(/, +/)}function b(){var e=T.win;if("zIndex"in e)return e.zIndex();for(;e.length>0;){if(9==e[0].nodeType)return!1;var o=e.css("zIndex");if(!isNaN(o)&&0!==o)return parseInt(o);e=e.parent()}return!1}function x(e,o,t){var r=e.css(o),i=parseFloat(r);if(isNaN(i)){var s=3==(i=I[r]||0)?t?T.win.outerHeight()-T.win.innerHeight():T.win.outerWidth()-T.win.innerWidth():1;return T.isie8&&i&&(i+=1),s?i:0}return i}function S(e,o,t,r){T._bind(e,o,function(r){var i={original:r=r||a.event,target:r.target||r.srcElement,type:"wheel",deltaMode:"MozMousePixelScroll"==r.type?0:1,deltaX:0,deltaZ:0,preventDefault:function(){return r.preventDefault?r.preventDefault():r.returnValue=!1,!1},stopImmediatePropagation:function(){r.stopImmediatePropagation?r.stopImmediatePropagation():r.cancelBubble=!0}};return"mousewheel"==o?(r.wheelDeltaX&&(i.deltaX=-.025*r.wheelDeltaX),r.wheelDeltaY&&(i.deltaY=-.025*r.wheelDeltaY),!i.deltaY&&!i.deltaX&&(i.deltaY=-.025*r.wheelDelta)):i.deltaY=r.detail,t.call(e,i)},r)}function z(e,o,t,r){T.scrollrunning||(T.newscrolly=T.getScrollTop(),T.newscrollx=T.getScrollLeft(),D=f());var i=f()-D;if(D=f(),i>350?A=1:A+=(2-A)/10,e=e*A|0,o=o*A|0,e){if(r)if(e<0){if(T.getScrollLeft()>=T.page.maxw)return!0}else if(T.getScrollLeft()<=0)return!0;var s=e>0?1:-1;X!==s&&(T.scrollmom&&T.scrollmom.stop(),T.newscrollx=T.getScrollLeft(),X=s),T.lastdeltax-=e}if(o){if(function(){var e=T.getScrollTop();if(o<0){if(e>=T.page.maxh)return!0}else if(e<=0)return!0}()){if(M.nativeparentscrolling&&t&&!T.ispage&&!T.zoomactive)return!0;var n=T.view.h>>1;T.newscrolly<-n?(T.newscrolly=-n,o=-1):T.newscrolly>T.page.maxh+n?(T.newscrolly=T.page.maxh+n,o=1):o=0}var l=o>0?1:-1;B!==l&&(T.scrollmom&&T.scrollmom.stop(),T.newscrolly=T.getScrollTop(),B=l),T.lastdeltay-=o}(o||e)&&T.synched("relativexy",function(){var e=T.lastdeltay+T.newscrolly;T.lastdeltay=0;var o=T.lastdeltax+T.newscrollx;T.lastdeltax=0,T.rail.drag||T.doScrollPos(o,e)})}function k(e,o,t){var r,i;return!(t||!q)||(0===e.deltaMode?(r=-e.deltaX*(M.mousescrollstep/54)|0,i=-e.deltaY*(M.mousescrollstep/54)|0):1===e.deltaMode&&(r=-e.deltaX*M.mousescrollstep*50/80|0,i=-e.deltaY*M.mousescrollstep*50/80|0),o&&M.oneaxismousemode&&0===r&&i&&(r=i,i=0,t&&(r<0?T.getScrollLeft()>=T.page.maxw:T.getScrollLeft()<=0)&&(i=r,r=0)),T.isrtlmode&&(r=-r),z(r,i,t,!0)?void(t&&(q=!0)):(q=!1,e.stopImmediatePropagation(),e.preventDefault()))}var T=this;this.version="3.7.6",this.name="nicescroll",this.me=p;var E=n("body"),M=this.opt={doc:E,win:!1};if(n.extend(M,g),M.snapbackspeed=80,e)for(var L in M)void 0!==e[L]&&(M[L]=e[L]);if(M.disablemutationobserver&&(m=!1),this.doc=M.doc,this.iddoc=this.doc&&this.doc[0]?this.doc[0].id||"":"",this.ispage=/^BODY|HTML/.test(M.win?M.win[0].nodeName:this.doc[0].nodeName),this.haswrapper=!1!==M.win,this.win=M.win||(this.ispage?c:this.doc),this.docscroll=this.ispage&&!this.haswrapper?c:this.win,this.body=E,this.viewport=!1,this.isfixed=!1,this.iframe=!1,this.isiframe="IFRAME"==this.doc[0].nodeName&&"IFRAME"==this.win[0].nodeName,this.istextarea="TEXTAREA"==this.win[0].nodeName,this.forcescreen=!1,this.canshowonmouseevent="scroll"!=M.autohidemode,this.onmousedown=!1,this.onmouseup=!1,this.onmousemove=!1,this.onmousewheel=!1,this.onkeypress=!1,this.ongesturezoom=!1,this.onclick=!1,this.onscrollstart=!1,this.onscrollend=!1,this.onscrollcancel=!1,this.onzoomin=!1,this.onzoomout=!1,this.view=!1,this.page=!1,this.scroll={x:0,y:0},this.scrollratio={x:0,y:0},this.cursorheight=20,this.scrollvaluemax=0,"auto"==M.rtlmode){var C=this.win[0]==a?this.body:this.win,N=C.css("writing-mode")||C.css("-webkit-writing-mode")||C.css("-ms-writing-mode")||C.css("-moz-writing-mode");"horizontal-tb"==N||"lr-tb"==N||""===N?(this.isrtlmode="rtl"==C.css("direction"),this.isvertical=!1):(this.isrtlmode="vertical-rl"==N||"tb"==N||"tb-rl"==N||"rl-tb"==N,this.isvertical="vertical-rl"==N||"tb"==N||"tb-rl"==N)}else this.isrtlmode=!0===M.rtlmode,this.isvertical=!1;if(this.scrollrunning=!1,this.scrollmom=!1,this.observer=!1,this.observerremover=!1,this.observerbody=!1,!1!==M.scrollbarid)this.id=M.scrollbarid;else do{this.id="ascrail"+i++}while(l.getElementById(this.id));this.rail=!1,this.cursor=!1,this.cursorfreezed=!1,this.selectiondrag=!1,this.zoom=!1,this.zoomactive=!1,this.hasfocus=!1,this.hasmousefocus=!1,this.railslocked=!1,this.locked=!1,this.hidden=!1,this.cursoractive=!0,this.wheelprevented=!1,this.overflowx=M.overflowx,this.overflowy=M.overflowy,this.nativescrollingarea=!1,this.checkarea=0,this.events=[],this.saved={},this.delaylist={},this.synclist={},this.lastdeltax=0,this.lastdeltay=0,this.detected=w();var P=n.extend({},this.detected);this.canhwscroll=P.hastransform&&M.hwacceleration,this.ishwscroll=this.canhwscroll&&T.haswrapper,this.isrtlmode?this.isvertical?this.hasreversehr=!(P.iswebkit||P.isie||P.isie11):this.hasreversehr=!(P.iswebkit||P.isie&&!P.isie10&&!P.isie11):this.hasreversehr=!1,this.istouchcapable=!1,P.cantouch||!P.hasw3ctouch&&!P.hasmstouch?!P.cantouch||P.isios||P.isandroid||!P.iswebkit&&!P.ismozilla||(this.istouchcapable=!0):this.istouchcapable=!0,M.enablemouselockapi||(P.hasmousecapture=!1,P.haspointerlock=!1),this.debounced=function(e,o,t){T&&(T.delaylist[e]||!1||(T.delaylist[e]={h:u(function(){T.delaylist[e].fn.call(T),T.delaylist[e]=!1},t)},o.call(T)),T.delaylist[e].fn=o)},this.synched=function(e,o){T.synclist[e]?T.synclist[e]=o:(T.synclist[e]=o,u(function(){T&&(T.synclist[e]&&T.synclist[e].call(T),T.synclist[e]=null)}))},this.unsynched=function(e){T.synclist[e]&&(T.synclist[e]=!1)},this.css=function(e,o){for(var t in o)T.saved.css.push([e,t,e.css(t)]),e.css(t,o[t])},this.scrollTop=function(e){return void 0===e?T.getScrollTop():T.setScrollTop(e)},this.scrollLeft=function(e){return void 0===e?T.getScrollLeft():T.setScrollLeft(e)};var R=function(e,o,t,r,i,s,n){this.st=e,this.ed=o,this.spd=t,this.p1=r||0,this.p2=i||1,this.p3=s||0,this.p4=n||1,this.ts=f(),this.df=o-e};if(R.prototype={B2:function(e){return 3*(1-e)*(1-e)*e},B3:function(e){return 3*(1-e)*e*e},B4:function(e){return e*e*e},getPos:function(){return(f()-this.ts)/this.spd},getNow:function(){var e=(f()-this.ts)/this.spd,o=this.B2(e)+this.B3(e)+this.B4(e);return e>=1?this.ed:this.st+this.df*o|0},update:function(e,o){return this.st=this.getNow(),this.ed=e,this.spd=o,this.ts=f(),this.df=this.ed-this.st,this}},this.ishwscroll){this.doc.translate={x:0,y:0,tx:"0px",ty:"0px"},P.hastranslate3d&&P.isios&&this.doc.css("-webkit-backface-visibility","hidden"),this.getScrollTop=function(e){if(!e){var o=v();if(o)return 16==o.length?-o[13]:-o[5];if(T.timerscroll&&T.timerscroll.bz)return T.timerscroll.bz.getNow()}return T.doc.translate.y},this.getScrollLeft=function(e){if(!e){var o=v();if(o)return 16==o.length?-o[12]:-o[4];if(T.timerscroll&&T.timerscroll.bh)return T.timerscroll.bh.getNow()}return T.doc.translate.x},this.notifyScrollEvent=function(e){var o=l.createEvent("UIEvents");o.initUIEvent("scroll",!1,!1,a,1),o.niceevent=!0,e.dispatchEvent(o)};var _=this.isrtlmode?1:-1;P.hastranslate3d&&M.enabletranslate3d?(this.setScrollTop=function(e,o){T.doc.translate.y=e,T.doc.translate.ty=-1*e+"px",T.doc.css(P.trstyle,"translate3d("+T.doc.translate.tx+","+T.doc.translate.ty+",0)"),o||T.notifyScrollEvent(T.win[0])},this.setScrollLeft=function(e,o){T.doc.translate.x=e,T.doc.translate.tx=e*_+"px",T.doc.css(P.trstyle,"translate3d("+T.doc.translate.tx+","+T.doc.translate.ty+",0)"),o||T.notifyScrollEvent(T.win[0])}):(this.setScrollTop=function(e,o){T.doc.translate.y=e,T.doc.translate.ty=-1*e+"px",T.doc.css(P.trstyle,"translate("+T.doc.translate.tx+","+T.doc.translate.ty+")"),o||T.notifyScrollEvent(T.win[0])},this.setScrollLeft=function(e,o){T.doc.translate.x=e,T.doc.translate.tx=e*_+"px",T.doc.css(P.trstyle,"translate("+T.doc.translate.tx+","+T.doc.translate.ty+")"),o||T.notifyScrollEvent(T.win[0])})}else this.getScrollTop=function(){return T.docscroll.scrollTop()},this.setScrollTop=function(e){T.docscroll.scrollTop(e)},this.getScrollLeft=function(){return T.hasreversehr?T.detected.ismozilla?T.page.maxw-Math.abs(T.docscroll.scrollLeft()):T.page.maxw-T.docscroll.scrollLeft():T.docscroll.scrollLeft()},this.setScrollLeft=function(e){return setTimeout(function(){if(T)return T.hasreversehr&&(e=T.detected.ismozilla?-(T.page.maxw-e):T.page.maxw-e),T.docscroll.scrollLeft(e)},1)};this.getTarget=function(e){return!!e&&(e.target?e.target:!!e.srcElement&&e.srcElement)},this.hasParent=function(e,o){if(!e)return!1;for(var t=e.target||e.srcElement||e||!1;t&&t.id!=o;)t=t.parentNode||!1;return!1!==t};var I={thin:1,medium:3,thick:5};this.getDocumentScrollOffset=function(){return{top:a.pageYOffset||l.documentElement.scrollTop,left:a.pageXOffset||l.documentElement.scrollLeft}},this.getOffset=function(){if(T.isfixed){var e=T.win.offset(),o=T.getDocumentScrollOffset();return e.top-=o.top,e.left-=o.left,e}var t=T.win.offset();if(!T.viewport)return t;var r=T.viewport.offset();return{top:t.top-r.top,left:t.left-r.left}},this.updateScrollBar=function(e){var o,t;if(T.ishwscroll)T.rail.css({height:T.win.innerHeight()-(M.railpadding.top+M.railpadding.bottom)}),T.railh&&T.railh.css({width:T.win.innerWidth()-(M.railpadding.left+M.railpadding.right)});else{var r=T.getOffset();if(o={top:r.top,left:r.left-(M.railpadding.left+M.railpadding.right)},o.top+=x(T.win,"border-top-width",!0),o.left+=T.rail.align?T.win.outerWidth()-x(T.win,"border-right-width")-T.rail.width:x(T.win,"border-left-width"),(t=M.railoffset)&&(t.top&&(o.top+=t.top),t.left&&(o.left+=t.left)),T.railslocked||T.rail.css({top:o.top,left:o.left,height:(e?e.h:T.win.innerHeight())-(M.railpadding.top+M.railpadding.bottom)}),T.zoom&&T.zoom.css({top:o.top+1,left:1==T.rail.align?o.left-20:o.left+T.rail.width+4}),T.railh&&!T.railslocked){o={top:r.top,left:r.left},(t=M.railhoffset)&&(t.top&&(o.top+=t.top),t.left&&(o.left+=t.left));var i=T.railh.align?o.top+x(T.win,"border-top-width",!0)+T.win.innerHeight()-T.railh.height:o.top+x(T.win,"border-top-width",!0),s=o.left+x(T.win,"border-left-width");T.railh.css({top:i-(M.railpadding.top+M.railpadding.bottom),left:s,width:T.railh.width})}}},this.doRailClick=function(e,o,t){var r,i,s,n;T.railslocked||(T.cancelEvent(e),"pageY"in e||(e.pageX=e.clientX+l.documentElement.scrollLeft,e.pageY=e.clientY+l.documentElement.scrollTop),o?(r=t?T.doScrollLeft:T.doScrollTop,s=t?(e.pageX-T.railh.offset().left-T.cursorwidth/2)*T.scrollratio.x:(e.pageY-T.rail.offset().top-T.cursorheight/2)*T.scrollratio.y,T.unsynched("relativexy"),r(0|s)):(r=t?T.doScrollLeftBy:T.doScrollBy,s=t?T.scroll.x:T.scroll.y,n=t?e.pageX-T.railh.offset().left:e.pageY-T.rail.offset().top,i=t?T.view.w:T.view.h,r(s>=n?i:-i)))},T.newscrolly=T.newscrollx=0,T.hasanimationframe="requestAnimationFrame"in a,T.hascancelanimationframe="cancelAnimationFrame"in a,T.hasborderbox=!1,this.init=function(){if(T.saved.css=[],P.isoperamini)return!0;if(P.isandroid&&!("hidden"in l))return!0;M.emulatetouch=M.emulatetouch||M.touchbehavior,T.hasborderbox=a.getComputedStyle&&"border-box"===a.getComputedStyle(l.body)["box-sizing"];var e={"overflow-y":"hidden"};if((P.isie11||P.isie10)&&(e["-ms-overflow-style"]="none"),T.ishwscroll&&(this.doc.css(P.transitionstyle,P.prefixstyle+"transform 0ms ease-out"),P.transitionend&&T.bind(T.doc,P.transitionend,T.onScrollTransitionEnd,!1)),T.zindex="auto",T.ispage||"auto"!=M.zindex?T.zindex=M.zindex:T.zindex=b()||"auto",!T.ispage&&"auto"!=T.zindex&&T.zindex>s&&(s=T.zindex),T.isie&&0===T.zindex&&"auto"==M.zindex&&(T.zindex="auto"),!T.ispage||!P.isieold){var i=T.docscroll;T.ispage&&(i=T.haswrapper?T.win:T.doc),T.css(i,e),T.ispage&&(P.isie11||P.isie)&&T.css(n("html"),e),!P.isios||T.ispage||T.haswrapper||T.css(E,{"-webkit-overflow-scrolling":"touch"});var d=n(l.createElement("div"));d.css({position:"relative",top:0,float:"right",width:M.cursorwidth,height:0,"background-color":M.cursorcolor,border:M.cursorborder,"background-clip":"padding-box","-webkit-border-radius":M.cursorborderradius,"-moz-border-radius":M.cursorborderradius,"border-radius":M.cursorborderradius}),d.addClass("nicescroll-cursors"),T.cursor=d;var u=n(l.createElement("div"));u.attr("id",T.id),u.addClass("nicescroll-rails nicescroll-rails-vr");var h,p,f=["left","right","top","bottom"];for(var g in f)p=f[g],(h=M.railpadding[p]||0)&&u.css("padding-"+p,h+"px");u.append(d),u.width=Math.max(parseFloat(M.cursorwidth),d.outerWidth()),u.css({width:u.width+"px",zIndex:T.zindex,background:M.background,cursor:"default"}),u.visibility=!0,u.scrollable=!0,u.align="left"==M.railalign?0:1,T.rail=u,T.rail.drag=!1;var v=!1;!M.boxzoom||T.ispage||P.isieold||(v=l.createElement("div"),T.bind(v,"click",T.doZoom),T.bind(v,"mouseenter",function(){T.zoom.css("opacity",M.cursoropacitymax)}),T.bind(v,"mouseleave",function(){T.zoom.css("opacity",M.cursoropacitymin)}),T.zoom=n(v),T.zoom.css({cursor:"pointer",zIndex:T.zindex,backgroundImage:"url("+M.scriptpath+"zoomico.png)",height:18,width:18,backgroundPosition:"0 0"}),M.dblclickzoom&&T.bind(T.win,"dblclick",T.doZoom),P.cantouch&&M.gesturezoom&&(T.ongesturezoom=function(e){return e.scale>1.5&&T.doZoomIn(e),e.scale<.8&&T.doZoomOut(e),T.cancelEvent(e)},T.bind(T.win,"gestureend",T.ongesturezoom))),T.railh=!1;var w;if(M.horizrailenabled&&(T.css(i,{overflowX:"hidden"}),(d=n(l.createElement("div"))).css({position:"absolute",top:0,height:M.cursorwidth,width:0,backgroundColor:M.cursorcolor,border:M.cursorborder,backgroundClip:"padding-box","-webkit-border-radius":M.cursorborderradius,"-moz-border-radius":M.cursorborderradius,"border-radius":M.cursorborderradius}),P.isieold&&d.css("overflow","hidden"),d.addClass("nicescroll-cursors"),T.cursorh=d,(w=n(l.createElement("div"))).attr("id",T.id+"-hr"),w.addClass("nicescroll-rails nicescroll-rails-hr"),w.height=Math.max(parseFloat(M.cursorwidth),d.outerHeight()),w.css({height:w.height+"px",zIndex:T.zindex,background:M.background}),w.append(d),w.visibility=!0,w.scrollable=!0,w.align="top"==M.railvalign?0:1,T.railh=w,T.railh.drag=!1),T.ispage)u.css({position:"fixed",top:0,height:"100%"}),u.css(u.align?{right:0}:{left:0}),T.body.append(u),T.railh&&(w.css({position:"fixed",left:0,width:"100%"}),w.css(w.align?{bottom:0}:{top:0}),T.body.append(w));else{if(T.ishwscroll){"static"==T.win.css("position")&&T.css(T.win,{position:"relative"});var x="HTML"==T.win[0].nodeName?T.body:T.win;n(x).scrollTop(0).scrollLeft(0),T.zoom&&(T.zoom.css({position:"absolute",top:1,right:0,"margin-right":u.width+4}),x.append(T.zoom)),u.css({position:"absolute",top:0}),u.css(u.align?{right:0}:{left:0}),x.append(u),w&&(w.css({position:"absolute",left:0,bottom:0}),w.css(w.align?{bottom:0}:{top:0}),x.append(w))}else{T.isfixed="fixed"==T.win.css("position");var S=T.isfixed?"fixed":"absolute";T.isfixed||(T.viewport=T.getViewport(T.win[0])),T.viewport&&(T.body=T.viewport,/fixed|absolute/.test(T.viewport.css("position"))||T.css(T.viewport,{position:"relative"})),u.css({position:S}),T.zoom&&T.zoom.css({position:S}),T.updateScrollBar(),T.body.append(u),T.zoom&&T.body.append(T.zoom),T.railh&&(w.css({position:S}),T.body.append(w))}P.isios&&T.css(T.win,{"-webkit-tap-highlight-color":"rgba(0,0,0,0)","-webkit-touch-callout":"none"}),M.disableoutline&&(P.isie&&T.win.attr("hideFocus","true"),P.iswebkit&&T.win.css("outline","none"))}if(!1===M.autohidemode?(T.autohidedom=!1,T.rail.css({opacity:M.cursoropacitymax}),T.railh&&T.railh.css({opacity:M.cursoropacitymax})):!0===M.autohidemode||"leave"===M.autohidemode?(T.autohidedom=n().add(T.rail),P.isie8&&(T.autohidedom=T.autohidedom.add(T.cursor)),T.railh&&(T.autohidedom=T.autohidedom.add(T.railh)),T.railh&&P.isie8&&(T.autohidedom=T.autohidedom.add(T.cursorh))):"scroll"==M.autohidemode?(T.autohidedom=n().add(T.rail),T.railh&&(T.autohidedom=T.autohidedom.add(T.railh))):"cursor"==M.autohidemode?(T.autohidedom=n().add(T.cursor),T.railh&&(T.autohidedom=T.autohidedom.add(T.cursorh))):"hidden"==M.autohidemode&&(T.autohidedom=!1,T.hide(),T.railslocked=!1),P.cantouch||T.istouchcapable||M.emulatetouch||P.hasmstouch){T.scrollmom=new y(T);T.ontouchstart=function(e){if(T.locked)return!1;if(e.pointerType&&("mouse"===e.pointerType||e.pointerType===e.MSPOINTER_TYPE_MOUSE))return!1;if(T.hasmoving=!1,T.scrollmom.timer&&(T.triggerScrollEnd(),T.scrollmom.stop()),!T.railslocked){var o=T.getTarget(e);if(o&&/INPUT/i.test(o.nodeName)&&/range/i.test(o.type))return T.stopPropagation(e);var t="mousedown"===e.type;if(!("clientX"in e)&&"changedTouches"in e&&(e.clientX=e.changedTouches[0].clientX,e.clientY=e.changedTouches[0].clientY),T.forcescreen){var r=e;(e={original:e.original?e.original:e}).clientX=r.screenX,e.clientY=r.screenY}if(T.rail.drag={x:e.clientX,y:e.clientY,sx:T.scroll.x,sy:T.scroll.y,st:T.getScrollTop(),sl:T.getScrollLeft(),pt:2,dl:!1,tg:o},T.ispage||!M.directionlockdeadzone)T.rail.drag.dl="f";else{var i={w:c.width(),h:c.height()},s=T.getContentSize(),l=s.h-i.h,a=s.w-i.w;T.rail.scrollable&&!T.railh.scrollable?T.rail.drag.ck=l>0&&"v":!T.rail.scrollable&&T.railh.scrollable?T.rail.drag.ck=a>0&&"h":T.rail.drag.ck=!1}if(M.emulatetouch&&T.isiframe&&P.isie){var d=T.win.position();T.rail.drag.x+=d.left,T.rail.drag.y+=d.top}if(T.hasmoving=!1,T.lastmouseup=!1,T.scrollmom.reset(e.clientX,e.clientY),o&&t){if(!/INPUT|SELECT|BUTTON|TEXTAREA/i.test(o.nodeName))return P.hasmousecapture&&o.setCapture(),M.emulatetouch?(o.onclick&&!o._onclick&&(o._onclick=o.onclick,o.onclick=function(e){if(T.hasmoving)return!1;o._onclick.call(this,e)}),T.cancelEvent(e)):T.stopPropagation(e);/SUBMIT|CANCEL|BUTTON/i.test(n(o).attr("type"))&&(T.preventclick={tg:o,click:!1})}}},T.ontouchend=function(e){if(!T.rail.drag)return!0;if(2==T.rail.drag.pt){if(e.pointerType&&("mouse"===e.pointerType||e.pointerType===e.MSPOINTER_TYPE_MOUSE))return!1;T.rail.drag=!1;var o="mouseup"===e.type;if(T.hasmoving&&(T.scrollmom.doMomentum(),T.lastmouseup=!0,T.hideCursor(),P.hasmousecapture&&l.releaseCapture(),o))return T.cancelEvent(e)}else if(1==T.rail.drag.pt)return T.onmouseup(e)};var z=M.emulatetouch&&T.isiframe&&!P.hasmousecapture,k=.3*M.directionlockdeadzone|0;T.ontouchmove=function(e,o){if(!T.rail.drag)return!0;if(e.targetTouches&&M.preventmultitouchscrolling&&e.targetTouches.length>1)return!0;if(e.pointerType&&("mouse"===e.pointerType||e.pointerType===e.MSPOINTER_TYPE_MOUSE))return!0;if(2==T.rail.drag.pt){"changedTouches"in e&&(e.clientX=e.changedTouches[0].clientX,e.clientY=e.changedTouches[0].clientY);var t,r;if(r=t=0,z&&!o){var i=T.win.position();r=-i.left,t=-i.top}var s=e.clientY+t,n=s-T.rail.drag.y,a=e.clientX+r,c=a-T.rail.drag.x,d=T.rail.drag.st-n;if(T.ishwscroll&&M.bouncescroll)d<0?d=Math.round(d/2):d>T.page.maxh&&(d=T.page.maxh+Math.round((d-T.page.maxh)/2));else if(d<0?(d=0,s=0):d>T.page.maxh&&(d=T.page.maxh,s=0),0===s&&!T.hasmoving)return T.ispage||(T.rail.drag=!1),!0;var u=T.getScrollLeft();if(T.railh&&T.railh.scrollable&&(u=T.isrtlmode?c-T.rail.drag.sl:T.rail.drag.sl-c,T.ishwscroll&&M.bouncescroll?u<0?u=Math.round(u/2):u>T.page.maxw&&(u=T.page.maxw+Math.round((u-T.page.maxw)/2)):(u<0&&(u=0,a=0),u>T.page.maxw&&(u=T.page.maxw,a=0))),!T.hasmoving){if(T.rail.drag.y===e.clientY&&T.rail.drag.x===e.clientX)return T.cancelEvent(e);var h=Math.abs(n),p=Math.abs(c),m=M.directionlockdeadzone;if(T.rail.drag.ck?"v"==T.rail.drag.ck?p>m&&h<=k?T.rail.drag=!1:h>m&&(T.rail.drag.dl="v"):"h"==T.rail.drag.ck&&(h>m&&p<=k?T.rail.drag=!1:p>m&&(T.rail.drag.dl="h")):h>m&&p>m?T.rail.drag.dl="f":h>m?T.rail.drag.dl=p>k?"f":"v":p>m&&(T.rail.drag.dl=h>k?"f":"h"),!T.rail.drag.dl)return T.cancelEvent(e);T.triggerScrollStart(e.clientX,e.clientY,0,0,0),T.hasmoving=!0}return T.preventclick&&!T.preventclick.click&&(T.preventclick.click=T.preventclick.tg.onclick||!1,T.preventclick.tg.onclick=T.onpreventclick),T.rail.drag.dl&&("v"==T.rail.drag.dl?u=T.rail.drag.sl:"h"==T.rail.drag.dl&&(d=T.rail.drag.st)),T.synched("touchmove",function(){T.rail.drag&&2==T.rail.drag.pt&&(T.prepareTransition&&T.resetTransition(),T.rail.scrollable&&T.setScrollTop(d),T.scrollmom.update(a,s),T.railh&&T.railh.scrollable?(T.setScrollLeft(u),T.showCursor(d,u)):T.showCursor(d),P.isie10&&l.selection.clear())}),T.cancelEvent(e)}return 1==T.rail.drag.pt?T.onmousemove(e):void 0},T.ontouchstartCursor=function(e,o){if(!T.rail.drag||3==T.rail.drag.pt){if(T.locked)return T.cancelEvent(e);T.cancelScroll(),T.rail.drag={x:e.touches[0].clientX,y:e.touches[0].clientY,sx:T.scroll.x,sy:T.scroll.y,pt:3,hr:!!o};var t=T.getTarget(e);return!T.ispage&&P.hasmousecapture&&t.setCapture(),T.isiframe&&!P.hasmousecapture&&(T.saved.csspointerevents=T.doc.css("pointer-events"),T.css(T.doc,{"pointer-events":"none"})),T.cancelEvent(e)}},T.ontouchendCursor=function(e){if(T.rail.drag){if(P.hasmousecapture&&l.releaseCapture(),T.isiframe&&!P.hasmousecapture&&T.doc.css("pointer-events",T.saved.csspointerevents),3!=T.rail.drag.pt)return;return T.rail.drag=!1,T.cancelEvent(e)}},T.ontouchmoveCursor=function(e){if(T.rail.drag){if(3!=T.rail.drag.pt)return;if(T.cursorfreezed=!0,T.rail.drag.hr){T.scroll.x=T.rail.drag.sx+(e.touches[0].clientX-T.rail.drag.x),T.scroll.x<0&&(T.scroll.x=0);var o=T.scrollvaluemaxw;T.scroll.x>o&&(T.scroll.x=o)}else{T.scroll.y=T.rail.drag.sy+(e.touches[0].clientY-T.rail.drag.y),T.scroll.y<0&&(T.scroll.y=0);var t=T.scrollvaluemax;T.scroll.y>t&&(T.scroll.y=t)}return T.synched("touchmove",function(){T.rail.drag&&3==T.rail.drag.pt&&(T.showCursor(),T.rail.drag.hr?T.doScrollLeft(Math.round(T.scroll.x*T.scrollratio.x),M.cursordragspeed):T.doScrollTop(Math.round(T.scroll.y*T.scrollratio.y),M.cursordragspeed))}),T.cancelEvent(e)}}}if(T.onmousedown=function(e,o){if(!T.rail.drag||1==T.rail.drag.pt){if(T.railslocked)return T.cancelEvent(e);T.cancelScroll(),T.rail.drag={x:e.clientX,y:e.clientY,sx:T.scroll.x,sy:T.scroll.y,pt:1,hr:o||!1};var t=T.getTarget(e);return P.hasmousecapture&&t.setCapture(),T.isiframe&&!P.hasmousecapture&&(T.saved.csspointerevents=T.doc.css("pointer-events"),T.css(T.doc,{"pointer-events":"none"})),T.hasmoving=!1,T.cancelEvent(e)}},T.onmouseup=function(e){if(T.rail.drag)return 1!=T.rail.drag.pt||(P.hasmousecapture&&l.releaseCapture(),T.isiframe&&!P.hasmousecapture&&T.doc.css("pointer-events",T.saved.csspointerevents),T.rail.drag=!1,T.cursorfreezed=!1,T.hasmoving&&T.triggerScrollEnd(),T.cancelEvent(e))},T.onmousemove=function(e){if(T.rail.drag){if(1!==T.rail.drag.pt)return;if(P.ischrome&&0===e.which)return T.onmouseup(e);if(T.cursorfreezed=!0,T.hasmoving||T.triggerScrollStart(e.clientX,e.clientY,0,0,0),T.hasmoving=!0,T.rail.drag.hr){T.scroll.x=T.rail.drag.sx+(e.clientX-T.rail.drag.x),T.scroll.x<0&&(T.scroll.x=0);var o=T.scrollvaluemaxw;T.scroll.x>o&&(T.scroll.x=o)}else{T.scroll.y=T.rail.drag.sy+(e.clientY-T.rail.drag.y),T.scroll.y<0&&(T.scroll.y=0);var t=T.scrollvaluemax;T.scroll.y>t&&(T.scroll.y=t)}return T.synched("mousemove",function(){T.cursorfreezed&&(T.showCursor(),T.rail.drag.hr?T.scrollLeft(Math.round(T.scroll.x*T.scrollratio.x)):T.scrollTop(Math.round(T.scroll.y*T.scrollratio.y)))}),T.cancelEvent(e)}T.checkarea=0},P.cantouch||M.emulatetouch)T.onpreventclick=function(e){if(T.preventclick)return T.preventclick.tg.onclick=T.preventclick.click,T.preventclick=!1,T.cancelEvent(e)},T.onclick=!P.isios&&function(e){return!T.lastmouseup||(T.lastmouseup=!1,T.cancelEvent(e))},M.grabcursorenabled&&P.cursorgrabvalue&&(T.css(T.ispage?T.doc:T.win,{cursor:P.cursorgrabvalue}),T.css(T.rail,{cursor:P.cursorgrabvalue}));else{var L=function(e){if(T.selectiondrag){if(e){var o=T.win.outerHeight(),t=e.pageY-T.selectiondrag.top;t>0&&t<o&&(t=0),t>=o&&(t-=o),T.selectiondrag.df=t}if(0!==T.selectiondrag.df){var r=-2*T.selectiondrag.df/6|0;T.doScrollBy(r),T.debounced("doselectionscroll",function(){L()},50)}}};T.hasTextSelected="getSelection"in l?function(){return l.getSelection().rangeCount>0}:"selection"in l?function(){return"None"!=l.selection.type}:function(){return!1},T.onselectionstart=function(e){T.ispage||(T.selectiondrag=T.win.offset())},T.onselectionend=function(e){T.selectiondrag=!1},T.onselectiondrag=function(e){T.selectiondrag&&T.hasTextSelected()&&T.debounced("selectionscroll",function(){L(e)},250)}}if(P.hasw3ctouch?(T.css(T.ispage?n("html"):T.win,{"touch-action":"none"}),T.css(T.rail,{"touch-action":"none"}),T.css(T.cursor,{"touch-action":"none"}),T.bind(T.win,"pointerdown",T.ontouchstart),T.bind(l,"pointerup",T.ontouchend),T.delegate(l,"pointermove",T.ontouchmove)):P.hasmstouch?(T.css(T.ispage?n("html"):T.win,{"-ms-touch-action":"none"}),T.css(T.rail,{"-ms-touch-action":"none"}),T.css(T.cursor,{"-ms-touch-action":"none"}),T.bind(T.win,"MSPointerDown",T.ontouchstart),T.bind(l,"MSPointerUp",T.ontouchend),T.delegate(l,"MSPointerMove",T.ontouchmove),T.bind(T.cursor,"MSGestureHold",function(e){e.preventDefault()}),T.bind(T.cursor,"contextmenu",function(e){e.preventDefault()})):P.cantouch&&(T.bind(T.win,"touchstart",T.ontouchstart,!1,!0),T.bind(l,"touchend",T.ontouchend,!1,!0),T.bind(l,"touchcancel",T.ontouchend,!1,!0),T.delegate(l,"touchmove",T.ontouchmove,!1,!0)),M.emulatetouch&&(T.bind(T.win,"mousedown",T.ontouchstart,!1,!0),T.bind(l,"mouseup",T.ontouchend,!1,!0),T.bind(l,"mousemove",T.ontouchmove,!1,!0)),(M.cursordragontouch||!P.cantouch&&!M.emulatetouch)&&(T.rail.css({cursor:"default"}),T.railh&&T.railh.css({cursor:"default"}),T.jqbind(T.rail,"mouseenter",function(){if(!T.ispage&&!T.win.is(":visible"))return!1;T.canshowonmouseevent&&T.showCursor(),T.rail.active=!0}),T.jqbind(T.rail,"mouseleave",function(){T.rail.active=!1,T.rail.drag||T.hideCursor()}),M.sensitiverail&&(T.bind(T.rail,"click",function(e){T.doRailClick(e,!1,!1)}),T.bind(T.rail,"dblclick",function(e){T.doRailClick(e,!0,!1)}),T.bind(T.cursor,"click",function(e){T.cancelEvent(e)}),T.bind(T.cursor,"dblclick",function(e){T.cancelEvent(e)})),T.railh&&(T.jqbind(T.railh,"mouseenter",function(){if(!T.ispage&&!T.win.is(":visible"))return!1;T.canshowonmouseevent&&T.showCursor(),T.rail.active=!0}),T.jqbind(T.railh,"mouseleave",function(){T.rail.active=!1,T.rail.drag||T.hideCursor()}),M.sensitiverail&&(T.bind(T.railh,"click",function(e){T.doRailClick(e,!1,!0)}),T.bind(T.railh,"dblclick",function(e){T.doRailClick(e,!0,!0)}),T.bind(T.cursorh,"click",function(e){T.cancelEvent(e)}),T.bind(T.cursorh,"dblclick",function(e){T.cancelEvent(e)})))),M.cursordragontouch&&(this.istouchcapable||P.cantouch)&&(T.bind(T.cursor,"touchstart",T.ontouchstartCursor),T.bind(T.cursor,"touchmove",T.ontouchmoveCursor),T.bind(T.cursor,"touchend",T.ontouchendCursor),T.cursorh&&T.bind(T.cursorh,"touchstart",function(e){T.ontouchstartCursor(e,!0)}),T.cursorh&&T.bind(T.cursorh,"touchmove",T.ontouchmoveCursor),T.cursorh&&T.bind(T.cursorh,"touchend",T.ontouchendCursor)),M.emulatetouch||P.isandroid||P.isios?(T.bind(P.hasmousecapture?T.win:l,"mouseup",T.ontouchend),T.onclick&&T.bind(l,"click",T.onclick),M.cursordragontouch?(T.bind(T.cursor,"mousedown",T.onmousedown),T.bind(T.cursor,"mouseup",T.onmouseup),T.cursorh&&T.bind(T.cursorh,"mousedown",function(e){T.onmousedown(e,!0)}),T.cursorh&&T.bind(T.cursorh,"mouseup",T.onmouseup)):(T.bind(T.rail,"mousedown",function(e){e.preventDefault()}),T.railh&&T.bind(T.railh,"mousedown",function(e){e.preventDefault()}))):(T.bind(P.hasmousecapture?T.win:l,"mouseup",T.onmouseup),T.bind(l,"mousemove",T.onmousemove),T.onclick&&T.bind(l,"click",T.onclick),T.bind(T.cursor,"mousedown",T.onmousedown),T.bind(T.cursor,"mouseup",T.onmouseup),T.railh&&(T.bind(T.cursorh,"mousedown",function(e){T.onmousedown(e,!0)}),T.bind(T.cursorh,"mouseup",T.onmouseup)),!T.ispage&&M.enablescrollonselection&&(T.bind(T.win[0],"mousedown",T.onselectionstart),T.bind(l,"mouseup",T.onselectionend),T.bind(T.cursor,"mouseup",T.onselectionend),T.cursorh&&T.bind(T.cursorh,"mouseup",T.onselectionend),T.bind(l,"mousemove",T.onselectiondrag)),T.zoom&&(T.jqbind(T.zoom,"mouseenter",function(){T.canshowonmouseevent&&T.showCursor(),T.rail.active=!0}),T.jqbind(T.zoom,"mouseleave",function(){T.rail.active=!1,T.rail.drag||T.hideCursor()}))),M.enablemousewheel&&(T.isiframe||T.mousewheel(P.isie&&T.ispage?l:T.win,T.onmousewheel),T.mousewheel(T.rail,T.onmousewheel),T.railh&&T.mousewheel(T.railh,T.onmousewheelhr)),T.ispage||P.cantouch||/HTML|^BODY/.test(T.win[0].nodeName)||(T.win.attr("tabindex")||T.win.attr({tabindex:++r}),T.bind(T.win,"focus",function(e){o=T.getTarget(e).id||T.getTarget(e)||!1,T.hasfocus=!0,T.canshowonmouseevent&&T.noticeCursor()}),T.bind(T.win,"blur",function(e){o=!1,T.hasfocus=!1}),T.bind(T.win,"mouseenter",function(e){t=T.getTarget(e).id||T.getTarget(e)||!1,T.hasmousefocus=!0,T.canshowonmouseevent&&T.noticeCursor()}),T.bind(T.win,"mouseleave",function(e){t=!1,T.hasmousefocus=!1,T.rail.drag||T.hideCursor()})),T.onkeypress=function(e){if(T.railslocked&&0===T.page.maxh)return!0;e=e||a.event;var r=T.getTarget(e);if(r&&/INPUT|TEXTAREA|SELECT|OPTION/.test(r.nodeName)&&(!(r.getAttribute("type")||r.type||!1)||!/submit|button|cancel/i.tp))return!0;if(n(r).attr("contenteditable"))return!0;if(T.hasfocus||T.hasmousefocus&&!o||T.ispage&&!o&&!t){var i=e.keyCode;if(T.railslocked&&27!=i)return T.cancelEvent(e);var s=e.ctrlKey||!1,l=e.shiftKey||!1,c=!1;switch(i){case 38:case 63233:T.doScrollBy(72),c=!0;break;case 40:case 63235:T.doScrollBy(-72),c=!0;break;case 37:case 63232:T.railh&&(s?T.doScrollLeft(0):T.doScrollLeftBy(72),c=!0);break;case 39:case 63234:T.railh&&(s?T.doScrollLeft(T.page.maxw):T.doScrollLeftBy(-72),c=!0);break;case 33:case 63276:T.doScrollBy(T.view.h),c=!0;break;case 34:case 63277:T.doScrollBy(-T.view.h),c=!0;break;case 36:case 63273:T.railh&&s?T.doScrollPos(0,0):T.doScrollTo(0),c=!0;break;case 35:case 63275:T.railh&&s?T.doScrollPos(T.page.maxw,T.page.maxh):T.doScrollTo(T.page.maxh),c=!0;break;case 32:M.spacebarenabled&&(l?T.doScrollBy(T.view.h):T.doScrollBy(-T.view.h),c=!0);break;case 27:T.zoomactive&&(T.doZoom(),c=!0)}if(c)return T.cancelEvent(e)}},M.enablekeyboard&&T.bind(l,P.isopera&&!P.isopera12?"keypress":"keydown",T.onkeypress),T.bind(l,"keydown",function(e){(e.ctrlKey||!1)&&(T.wheelprevented=!0)}),T.bind(l,"keyup",function(e){e.ctrlKey||!1||(T.wheelprevented=!1)}),T.bind(a,"blur",function(e){T.wheelprevented=!1}),T.bind(a,"resize",T.onscreenresize),T.bind(a,"orientationchange",T.onscreenresize),T.bind(a,"load",T.lazyResize),P.ischrome&&!T.ispage&&!T.haswrapper){var C=T.win.attr("style"),N=parseFloat(T.win.css("width"))+1;T.win.css("width",N),T.synched("chromefix",function(){T.win.attr("style",C)})}if(T.onAttributeChange=function(e){T.lazyResize(T.isieold?250:30)},M.enableobserver&&(T.isie11||!1===m||(T.observerbody=new m(function(e){if(e.forEach(function(e){if("attributes"==e.type)return E.hasClass("modal-open")&&E.hasClass("modal-dialog")&&!n.contains(n(".modal-dialog")[0],T.doc[0])?T.hide():T.show()}),T.me.clientWidth!=T.page.width||T.me.clientHeight!=T.page.height)return T.lazyResize(30)}),T.observerbody.observe(l.body,{childList:!0,subtree:!0,characterData:!1,attributes:!0,attributeFilter:["class"]})),!T.ispage&&!T.haswrapper)){var R=T.win[0];!1!==m?(T.observer=new m(function(e){e.forEach(T.onAttributeChange)}),T.observer.observe(R,{childList:!0,characterData:!1,attributes:!0,subtree:!1}),T.observerremover=new m(function(e){e.forEach(function(e){if(e.removedNodes.length>0)for(var o in e.removedNodes)if(T&&e.removedNodes[o]===R)return T.remove()})}),T.observerremover.observe(R.parentNode,{childList:!0,characterData:!1,attributes:!1,subtree:!1})):(T.bind(R,P.isie&&!P.isie9?"propertychange":"DOMAttrModified",T.onAttributeChange),P.isie9&&R.attachEvent("onpropertychange",T.onAttributeChange),T.bind(R,"DOMNodeRemoved",function(e){e.target===R&&T.remove()}))}!T.ispage&&M.boxzoom&&T.bind(a,"resize",T.resizeZoom),T.istextarea&&(T.bind(T.win,"keydown",T.lazyResize),T.bind(T.win,"mouseup",T.lazyResize)),T.lazyResize(30)}if("IFRAME"==this.doc[0].nodeName){var _=function(){T.iframexd=!1;var o;try{(o="contentDocument"in this?this.contentDocument:this.contentWindow._doc).domain}catch(e){T.iframexd=!0,o=!1}if(T.iframexd)return"console"in a&&console.log("NiceScroll error: policy restriced iframe"),!0;if(T.forcescreen=!0,T.isiframe&&(T.iframe={doc:n(o),html:T.doc.contents().find("html")[0],body:T.doc.contents().find("body")[0]},T.getContentSize=function(){return{w:Math.max(T.iframe.html.scrollWidth,T.iframe.body.scrollWidth),h:Math.max(T.iframe.html.scrollHeight,T.iframe.body.scrollHeight)}},T.docscroll=n(T.iframe.body)),!P.isios&&M.iframeautoresize&&!T.isiframe){T.win.scrollTop(0),T.doc.height("");var t=Math.max(o.getElementsByTagName("html")[0].scrollHeight,o.body.scrollHeight);T.doc.height(t)}T.lazyResize(30),T.css(n(T.iframe.body),e),P.isios&&T.haswrapper&&T.css(n(o.body),{"-webkit-transform":"translate3d(0,0,0)"}),"contentWindow"in this?T.bind(this.contentWindow,"scroll",T.onscroll):T.bind(o,"scroll",T.onscroll),M.enablemousewheel&&T.mousewheel(o,T.onmousewheel),M.enablekeyboard&&T.bind(o,P.isopera?"keypress":"keydown",T.onkeypress),P.cantouch?(T.bind(o,"touchstart",T.ontouchstart),T.bind(o,"touchmove",T.ontouchmove)):M.emulatetouch&&(T.bind(o,"mousedown",T.ontouchstart),T.bind(o,"mousemove",function(e){return T.ontouchmove(e,!0)}),M.grabcursorenabled&&P.cursorgrabvalue&&T.css(n(o.body),{cursor:P.cursorgrabvalue})),T.bind(o,"mouseup",T.ontouchend),T.zoom&&(M.dblclickzoom&&T.bind(o,"dblclick",T.doZoom),T.ongesturezoom&&T.bind(o,"gestureend",T.ongesturezoom))};this.doc[0].readyState&&"complete"===this.doc[0].readyState&&setTimeout(function(){_.call(T.doc[0],!1)},500),T.bind(this.doc,"load",_)}},this.showCursor=function(e,o){if(T.cursortimeout&&(clearTimeout(T.cursortimeout),T.cursortimeout=0),T.rail){if(T.autohidedom&&(T.autohidedom.stop().css({opacity:M.cursoropacitymax}),T.cursoractive=!0),T.rail.drag&&1==T.rail.drag.pt||(void 0!==e&&!1!==e&&(T.scroll.y=e/T.scrollratio.y|0),void 0!==o&&(T.scroll.x=o/T.scrollratio.x|0)),T.cursor.css({height:T.cursorheight,top:T.scroll.y}),T.cursorh){var t=T.hasreversehr?T.scrollvaluemaxw-T.scroll.x:T.scroll.x;T.cursorh.css({width:T.cursorwidth,left:!T.rail.align&&T.rail.visibility?t+T.rail.width:t}),T.cursoractive=!0}T.zoom&&T.zoom.stop().css({opacity:M.cursoropacitymax})}},this.hideCursor=function(e){T.cursortimeout||T.rail&&T.autohidedom&&(T.hasmousefocus&&"leave"===M.autohidemode||(T.cursortimeout=setTimeout(function(){T.rail.active&&T.showonmouseevent||(T.autohidedom.stop().animate({opacity:M.cursoropacitymin}),T.zoom&&T.zoom.stop().animate({opacity:M.cursoropacitymin}),T.cursoractive=!1),T.cursortimeout=0},e||M.hidecursordelay)))},this.noticeCursor=function(e,o,t){T.showCursor(o,t),T.rail.active||T.hideCursor(e)},this.getContentSize=T.ispage?function(){return{w:Math.max(l.body.scrollWidth,l.documentElement.scrollWidth),h:Math.max(l.body.scrollHeight,l.documentElement.scrollHeight)}}:T.haswrapper?function(){return{w:T.doc[0].offsetWidth,h:T.doc[0].offsetHeight}}:function(){return{w:T.docscroll[0].scrollWidth,h:T.docscroll[0].scrollHeight}},this.onResize=function(e,o){if(!T||!T.win)return!1;var t=T.page.maxh,r=T.page.maxw,i=T.view.h,s=T.view.w;if(T.view={w:T.ispage?T.win.width():T.win[0].clientWidth,h:T.ispage?T.win.height():T.win[0].clientHeight},T.page=o||T.getContentSize(),T.page.maxh=Math.max(0,T.page.h-T.view.h),T.page.maxw=Math.max(0,T.page.w-T.view.w),T.page.maxh==t&&T.page.maxw==r&&T.view.w==s&&T.view.h==i){if(T.ispage)return T;var n=T.win.offset();if(T.lastposition){var l=T.lastposition;if(l.top==n.top&&l.left==n.left)return T}T.lastposition=n}return 0===T.page.maxh?(T.hideRail(),T.scrollvaluemax=0,T.scroll.y=0,T.scrollratio.y=0,T.cursorheight=0,T.setScrollTop(0),T.rail&&(T.rail.scrollable=!1)):(T.page.maxh-=M.railpadding.top+M.railpadding.bottom,T.rail.scrollable=!0),0===T.page.maxw?(T.hideRailHr(),T.scrollvaluemaxw=0,T.scroll.x=0,T.scrollratio.x=0,T.cursorwidth=0,T.setScrollLeft(0),T.railh&&(T.railh.scrollable=!1)):(T.page.maxw-=M.railpadding.left+M.railpadding.right,T.railh&&(T.railh.scrollable=M.horizrailenabled)),T.railslocked=T.locked||0===T.page.maxh&&0===T.page.maxw,T.railslocked?(T.ispage||T.updateScrollBar(T.view),!1):(T.hidden||(T.rail.visibility||T.showRail(),T.railh&&!T.railh.visibility&&T.showRailHr()),T.istextarea&&T.win.css("resize")&&"none"!=T.win.css("resize")&&(T.view.h-=20),T.cursorheight=Math.min(T.view.h,Math.round(T.view.h*(T.view.h/T.page.h))),T.cursorheight=M.cursorfixedheight?M.cursorfixedheight:Math.max(M.cursorminheight,T.cursorheight),T.cursorwidth=Math.min(T.view.w,Math.round(T.view.w*(T.view.w/T.page.w))),T.cursorwidth=M.cursorfixedheight?M.cursorfixedheight:Math.max(M.cursorminheight,T.cursorwidth),T.scrollvaluemax=T.view.h-T.cursorheight-(M.railpadding.top+M.railpadding.bottom),T.hasborderbox||(T.scrollvaluemax-=T.cursor[0].offsetHeight-T.cursor[0].clientHeight),T.railh&&(T.railh.width=T.page.maxh>0?T.view.w-T.rail.width:T.view.w,T.scrollvaluemaxw=T.railh.width-T.cursorwidth-(M.railpadding.left+M.railpadding.right)),T.ispage||T.updateScrollBar(T.view),T.scrollratio={x:T.page.maxw/T.scrollvaluemaxw,y:T.page.maxh/T.scrollvaluemax},T.getScrollTop()>T.page.maxh?T.doScrollTop(T.page.maxh):(T.scroll.y=T.getScrollTop()/T.scrollratio.y|0,T.scroll.x=T.getScrollLeft()/T.scrollratio.x|0,T.cursoractive&&T.noticeCursor()),T.scroll.y&&0===T.getScrollTop()&&T.doScrollTo(T.scroll.y*T.scrollratio.y|0),T)},this.resize=T.onResize;var O=0;this.onscreenresize=function(e){clearTimeout(O);var o=!T.ispage&&!T.haswrapper;o&&T.hideRails(),O=setTimeout(function(){T&&(o&&T.showRails(),T.resize()),O=0},120)},this.lazyResize=function(e){return clearTimeout(O),e=isNaN(e)?240:e,O=setTimeout(function(){T&&T.resize(),O=0},e),T},this.jqbind=function(e,o,t){T.events.push({e:e,n:o,f:t,q:!0}),n(e).on(o,t)},this.mousewheel=function(e,o,t){var r="jquery"in e?e[0]:e;if("onwheel"in l.createElement("div"))T._bind(r,"wheel",o,t||!1);else{var i=void 0!==l.onmousewheel?"mousewheel":"DOMMouseScroll";S(r,i,o,t||!1),"DOMMouseScroll"==i&&S(r,"MozMousePixelScroll",o,t||!1)}};var Y=!1;if(P.haseventlistener){try{var H=Object.defineProperty({},"passive",{get:function(){Y=!0}});a.addEventListener("test",null,H)}catch(e){}this.stopPropagation=function(e){return!!e&&((e=e.original?e.original:e).stopPropagation(),!1)},this.cancelEvent=function(e){return e.cancelable&&e.preventDefault(),e.stopImmediatePropagation(),e.preventManipulation&&e.preventManipulation(),!1}}else Event.prototype.preventDefault=function(){this.returnValue=!1},Event.prototype.stopPropagation=function(){this.cancelBubble=!0},a.constructor.prototype.addEventListener=l.constructor.prototype.addEventListener=Element.prototype.addEventListener=function(e,o,t){this.attachEvent("on"+e,o)},a.constructor.prototype.removeEventListener=l.constructor.prototype.removeEventListener=Element.prototype.removeEventListener=function(e,o,t){this.detachEvent("on"+e,o)},this.cancelEvent=function(e){return(e=e||a.event)&&(e.cancelBubble=!0,e.cancel=!0,e.returnValue=!1),!1},this.stopPropagation=function(e){return(e=e||a.event)&&(e.cancelBubble=!0),!1};this.delegate=function(e,o,t,r,i){var s=d[o]||!1;s||(s={a:[],l:[],f:function(e){for(var o=s.l,t=!1,r=o.length-1;r>=0;r--)if(!1===(t=o[r].call(e.target,e)))return!1;return t}},T.bind(e,o,s.f,r,i),d[o]=s),T.ispage?(s.a=[T.id].concat(s.a),s.l=[t].concat(s.l)):(s.a.push(T.id),s.l.push(t))},this.undelegate=function(e,o,t,r,i){var s=d[o]||!1;if(s&&s.l)for(var n=0,l=s.l.length;n<l;n++)s.a[n]===T.id&&(s.a.splice(n),s.l.splice(n),0===s.a.length&&(T._unbind(e,o,s.l.f),d[o]=null))},this.bind=function(e,o,t,r,i){var s="jquery"in e?e[0]:e;T._bind(s,o,t,r||!1,i||!1)},this._bind=function(e,o,t,r,i){T.events.push({e:e,n:o,f:t,b:r,q:!1}),Y&&i?e.addEventListener(o,t,{passive:!1,capture:r}):e.addEventListener(o,t,r||!1)},this._unbind=function(e,o,t,r){d[o]?T.undelegate(e,o,t,r):e.removeEventListener(o,t,r)},this.unbindAll=function(){for(var e=0;e<T.events.length;e++){var o=T.events[e];o.q?o.e.unbind(o.n,o.f):T._unbind(o.e,o.n,o.f,o.b)}},this.showRails=function(){return T.showRail().showRailHr()},this.showRail=function(){return 0===T.page.maxh||!T.ispage&&"none"==T.win.css("display")||(T.rail.visibility=!0,T.rail.css("display","block")),T},this.showRailHr=function(){return T.railh&&(0===T.page.maxw||!T.ispage&&"none"==T.win.css("display")||(T.railh.visibility=!0,T.railh.css("display","block"))),T},this.hideRails=function(){return T.hideRail().hideRailHr()},this.hideRail=function(){return T.rail.visibility=!1,T.rail.css("display","none"),T},this.hideRailHr=function(){return T.railh&&(T.railh.visibility=!1,T.railh.css("display","none")),T},this.show=function(){return T.hidden=!1,T.railslocked=!1,T.showRails()},this.hide=function(){return T.hidden=!0,T.railslocked=!0,T.hideRails()},this.toggle=function(){return T.hidden?T.show():T.hide()},this.remove=function(){T.stop(),T.cursortimeout&&clearTimeout(T.cursortimeout);for(var e in T.delaylist)T.delaylist[e]&&h(T.delaylist[e].h);T.doZoomOut(),T.unbindAll(),P.isie9&&T.win[0].detachEvent("onpropertychange",T.onAttributeChange),!1!==T.observer&&T.observer.disconnect(),!1!==T.observerremover&&T.observerremover.disconnect(),!1!==T.observerbody&&T.observerbody.disconnect(),T.events=null,T.cursor&&T.cursor.remove(),T.cursorh&&T.cursorh.remove(),T.rail&&T.rail.remove(),T.railh&&T.railh.remove(),T.zoom&&T.zoom.remove();for(var o=0;o<T.saved.css.length;o++){var t=T.saved.css[o];t[0].css(t[1],void 0===t[2]?"":t[2])}T.saved=!1,T.me.data("__nicescroll","");var r=n.nicescroll;r.each(function(e){if(this&&this.id===T.id){delete r[e];for(var o=++e;o<r.length;o++,e++)r[e]=r[o];--r.length&&delete r[r.length]}});for(var i in T)T[i]=null,delete T[i];T=null},this.scrollstart=function(e){return this.onscrollstart=e,T},this.scrollend=function(e){return this.onscrollend=e,T},this.scrollcancel=function(e){return this.onscrollcancel=e,T},this.zoomin=function(e){return this.onzoomin=e,T},this.zoomout=function(e){return this.onzoomout=e,T},this.isScrollable=function(e){var o=e.target?e.target:e;if("OPTION"==o.nodeName)return!0;for(;o&&1==o.nodeType&&o!==this.me[0]&&!/^BODY|HTML/.test(o.nodeName);){var t=n(o),r=t.css("overflowY")||t.css("overflowX")||t.css("overflow")||"";if(/scroll|auto/.test(r))return o.clientHeight!=o.scrollHeight;o=!!o.parentNode&&o.parentNode}return!1},this.getViewport=function(e){for(var o=!(!e||!e.parentNode)&&e.parentNode;o&&1==o.nodeType&&!/^BODY|HTML/.test(o.nodeName);){var t=n(o);if(/fixed|absolute/.test(t.css("position")))return t;var r=t.css("overflowY")||t.css("overflowX")||t.css("overflow")||"";if(/scroll|auto/.test(r)&&o.clientHeight!=o.scrollHeight)return t;if(t.getNiceScroll().length>0)return t;o=!!o.parentNode&&o.parentNode}return!1},this.triggerScrollStart=function(e,o,t,r,i){if(T.onscrollstart){var s={type:"scrollstart",current:{x:e,y:o},request:{x:t,y:r},end:{x:T.newscrollx,y:T.newscrolly},speed:i};T.onscrollstart.call(T,s)}},this.triggerScrollEnd=function(){if(T.onscrollend){var e=T.getScrollLeft(),o=T.getScrollTop(),t={type:"scrollend",current:{x:e,y:o},end:{x:e,y:o}};T.onscrollend.call(T,t)}};var B=0,X=0,D=0,A=1,q=!1;if(this.onmousewheel=function(e){if(T.wheelprevented||T.locked)return!1;if(T.railslocked)return T.debounced("checkunlock",T.resize,250),!1;if(T.rail.drag)return T.cancelEvent(e);if("auto"===M.oneaxismousemode&&0!==e.deltaX&&(M.oneaxismousemode=!1),M.oneaxismousemode&&0===e.deltaX&&!T.rail.scrollable)return!T.railh||!T.railh.scrollable||T.onmousewheelhr(e);var o=f(),t=!1;if(M.preservenativescrolling&&T.checkarea+600<o&&(T.nativescrollingarea=T.isScrollable(e),t=!0),T.checkarea=o,T.nativescrollingarea)return!0;var r=k(e,!1,t);return r&&(T.checkarea=0),r},this.onmousewheelhr=function(e){if(!T.wheelprevented){if(T.railslocked||!T.railh.scrollable)return!0;if(T.rail.drag)return T.cancelEvent(e);var o=f(),t=!1;return M.preservenativescrolling&&T.checkarea+600<o&&(T.nativescrollingarea=T.isScrollable(e),t=!0),T.checkarea=o,!!T.nativescrollingarea||(T.railslocked?T.cancelEvent(e):k(e,!0,t))}},this.stop=function(){return T.cancelScroll(),T.scrollmon&&T.scrollmon.stop(),T.cursorfreezed=!1,T.scroll.y=Math.round(T.getScrollTop()*(1/T.scrollratio.y)),T.noticeCursor(),T},this.getTransitionSpeed=function(e){return 80+e/72*M.scrollspeed|0},M.smoothscroll)if(T.ishwscroll&&P.hastransition&&M.usetransition&&M.smoothscroll){var j="";this.resetTransition=function(){j="",T.doc.css(P.prefixstyle+"transition-duration","0ms")},this.prepareTransition=function(e,o){var t=o?e:T.getTransitionSpeed(e),r=t+"ms";return j!==r&&(j=r,T.doc.css(P.prefixstyle+"transition-duration",r)),t},this.doScrollLeft=function(e,o){var t=T.scrollrunning?T.newscrolly:T.getScrollTop();T.doScrollPos(e,t,o)},this.doScrollTop=function(e,o){var t=T.scrollrunning?T.newscrollx:T.getScrollLeft();T.doScrollPos(t,e,o)},this.cursorupdate={running:!1,start:function(){var e=this;if(!e.running){e.running=!0;var o=function(){e.running&&u(o),T.showCursor(T.getScrollTop(),T.getScrollLeft()),T.notifyScrollEvent(T.win[0])};u(o)}},stop:function(){this.running=!1}},this.doScrollPos=function(e,o,t){var r=T.getScrollTop(),i=T.getScrollLeft();if(((T.newscrolly-r)*(o-r)<0||(T.newscrollx-i)*(e-i)<0)&&T.cancelScroll(),M.bouncescroll?(o<0?o=o/2|0:o>T.page.maxh&&(o=T.page.maxh+(o-T.page.maxh)/2|0),e<0?e=e/2|0:e>T.page.maxw&&(e=T.page.maxw+(e-T.page.maxw)/2|0)):(o<0?o=0:o>T.page.maxh&&(o=T.page.maxh),e<0?e=0:e>T.page.maxw&&(e=T.page.maxw)),T.scrollrunning&&e==T.newscrollx&&o==T.newscrolly)return!1;T.newscrolly=o,T.newscrollx=e;var s=T.getScrollTop(),n=T.getScrollLeft(),l={};l.x=e-n,l.y=o-s;var a=0|Math.sqrt(l.x*l.x+l.y*l.y),c=T.prepareTransition(a);T.scrollrunning||(T.scrollrunning=!0,T.triggerScrollStart(n,s,e,o,c),T.cursorupdate.start()),T.scrollendtrapped=!0,P.transitionend||(T.scrollendtrapped&&clearTimeout(T.scrollendtrapped),T.scrollendtrapped=setTimeout(T.onScrollTransitionEnd,c)),T.setScrollTop(T.newscrolly),T.setScrollLeft(T.newscrollx)},this.cancelScroll=function(){if(!T.scrollendtrapped)return!0;var e=T.getScrollTop(),o=T.getScrollLeft();return T.scrollrunning=!1,P.transitionend||clearTimeout(P.transitionend),T.scrollendtrapped=!1,T.resetTransition(),T.setScrollTop(e),T.railh&&T.setScrollLeft(o),T.timerscroll&&T.timerscroll.tm&&clearInterval(T.timerscroll.tm),T.timerscroll=!1,T.cursorfreezed=!1,T.cursorupdate.stop(),T.showCursor(e,o),T},this.onScrollTransitionEnd=function(){if(T.scrollendtrapped){var e=T.getScrollTop(),o=T.getScrollLeft();if(e<0?e=0:e>T.page.maxh&&(e=T.page.maxh),o<0?o=0:o>T.page.maxw&&(o=T.page.maxw),e!=T.newscrolly||o!=T.newscrollx)return T.doScrollPos(o,e,M.snapbackspeed);T.scrollrunning&&T.triggerScrollEnd(),T.scrollrunning=!1,T.scrollendtrapped=!1,T.resetTransition(),T.timerscroll=!1,T.setScrollTop(e),T.railh&&T.setScrollLeft(o),T.cursorupdate.stop(),T.noticeCursor(!1,e,o),T.cursorfreezed=!1}}}else this.doScrollLeft=function(e,o){var t=T.scrollrunning?T.newscrolly:T.getScrollTop();T.doScrollPos(e,t,o)},this.doScrollTop=function(e,o){var t=T.scrollrunning?T.newscrollx:T.getScrollLeft();T.doScrollPos(t,e,o)},this.doScrollPos=function(e,o,t){var r=T.getScrollTop(),i=T.getScrollLeft();((T.newscrolly-r)*(o-r)<0||(T.newscrollx-i)*(e-i)<0)&&T.cancelScroll();var s=!1;if(T.bouncescroll&&T.rail.visibility||(o<0?(o=0,s=!0):o>T.page.maxh&&(o=T.page.maxh,s=!0)),T.bouncescroll&&T.railh.visibility||(e<0?(e=0,s=!0):e>T.page.maxw&&(e=T.page.maxw,s=!0)),T.scrollrunning&&T.newscrolly===o&&T.newscrollx===e)return!0;T.newscrolly=o,T.newscrollx=e,T.dst={},T.dst.x=e-i,T.dst.y=o-r,T.dst.px=i,T.dst.py=r;var n=0|Math.sqrt(T.dst.x*T.dst.x+T.dst.y*T.dst.y),l=T.getTransitionSpeed(n);T.bzscroll={};var a=s?1:.58;T.bzscroll.x=new R(i,T.newscrollx,l,0,0,a,1),T.bzscroll.y=new R(r,T.newscrolly,l,0,0,a,1);f();var c=function(){if(T.scrollrunning){var e=T.bzscroll.y.getPos();T.setScrollLeft(T.bzscroll.x.getNow()),T.setScrollTop(T.bzscroll.y.getNow()),e<=1?T.timer=u(c):(T.scrollrunning=!1,T.timer=0,T.triggerScrollEnd())}};T.scrollrunning||(T.triggerScrollStart(i,r,e,o,l),T.scrollrunning=!0,T.timer=u(c))},this.cancelScroll=function(){return T.timer&&h(T.timer),T.timer=0,T.bzscroll=!1,T.scrollrunning=!1,T};else this.doScrollLeft=function(e,o){var t=T.getScrollTop();T.doScrollPos(e,t,o)},this.doScrollTop=function(e,o){var t=T.getScrollLeft();T.doScrollPos(t,e,o)},this.doScrollPos=function(e,o,t){var r=e>T.page.maxw?T.page.maxw:e;r<0&&(r=0);var i=o>T.page.maxh?T.page.maxh:o;i<0&&(i=0),T.synched("scroll",function(){T.setScrollTop(i),T.setScrollLeft(r)})},this.cancelScroll=function(){};this.doScrollBy=function(e,o){z(0,e)},this.doScrollLeftBy=function(e,o){z(e,0)},this.doScrollTo=function(e,o){var t=o?Math.round(e*T.scrollratio.y):e;t<0?t=0:t>T.page.maxh&&(t=T.page.maxh),T.cursorfreezed=!1,T.doScrollTop(e)},this.checkContentSize=function(){var e=T.getContentSize();e.h==T.page.h&&e.w==T.page.w||T.resize(!1,e)},T.onscroll=function(e){T.rail.drag||T.cursorfreezed||T.synched("scroll",function(){T.scroll.y=Math.round(T.getScrollTop()/T.scrollratio.y),T.railh&&(T.scroll.x=Math.round(T.getScrollLeft()/T.scrollratio.x)),T.noticeCursor()})},T.bind(T.docscroll,"scroll",T.onscroll),this.doZoomIn=function(e){if(!T.zoomactive){T.zoomactive=!0,T.zoomrestore={style:{}};var o=["position","top","left","zIndex","backgroundColor","marginTop","marginBottom","marginLeft","marginRight"],t=T.win[0].style;for(var r in o){var i=o[r];T.zoomrestore.style[i]=void 0!==t[i]?t[i]:""}T.zoomrestore.style.width=T.win.css("width"),T.zoomrestore.style.height=T.win.css("height"),T.zoomrestore.padding={w:T.win.outerWidth()-T.win.width(),h:T.win.outerHeight()-T.win.height()},P.isios4&&(T.zoomrestore.scrollTop=c.scrollTop(),c.scrollTop(0)),T.win.css({position:P.isios4?"absolute":"fixed",top:0,left:0,zIndex:s+100,margin:0});var n=T.win.css("backgroundColor");return(""===n||/transparent|rgba\(0, 0, 0, 0\)|rgba\(0,0,0,0\)/.test(n))&&T.win.css("backgroundColor","#fff"),T.rail.css({zIndex:s+101}),T.zoom.css({zIndex:s+102}),T.zoom.css("backgroundPosition","0 -18px"),T.resizeZoom(),T.onzoomin&&T.onzoomin.call(T),T.cancelEvent(e)}},this.doZoomOut=function(e){if(T.zoomactive)return T.zoomactive=!1,T.win.css("margin",""),T.win.css(T.zoomrestore.style),P.isios4&&c.scrollTop(T.zoomrestore.scrollTop),T.rail.css({"z-index":T.zindex}),T.zoom.css({"z-index":T.zindex}),T.zoomrestore=!1,T.zoom.css("backgroundPosition","0 0"),T.onResize(),T.onzoomout&&T.onzoomout.call(T),T.cancelEvent(e)},this.doZoom=function(e){return T.zoomactive?T.doZoomOut(e):T.doZoomIn(e)},this.resizeZoom=function(){if(T.zoomactive){var e=T.getScrollTop();T.win.css({width:c.width()-T.zoomrestore.padding.w+"px",height:c.height()-T.zoomrestore.padding.h+"px"}),T.onResize(),T.setScrollTop(Math.min(T.page.maxh,e))}},this.init(),n.nicescroll.push(this)},y=function(e){var o=this;this.nc=e,this.lastx=0,this.lasty=0,this.speedx=0,this.speedy=0,this.lasttime=0,this.steptime=0,this.snapx=!1,this.snapy=!1,this.demulx=0,this.demuly=0,this.lastscrollx=-1,this.lastscrolly=-1,this.chkx=0,this.chky=0,this.timer=0,this.reset=function(e,t){o.stop(),o.steptime=0,o.lasttime=f(),o.speedx=0,o.speedy=0,o.lastx=e,o.lasty=t,o.lastscrollx=-1,o.lastscrolly=-1},this.update=function(e,t){var r=f();o.steptime=r-o.lasttime,o.lasttime=r;var i=t-o.lasty,s=e-o.lastx,n=o.nc.getScrollTop()+i,l=o.nc.getScrollLeft()+s;o.snapx=l<0||l>o.nc.page.maxw,o.snapy=n<0||n>o.nc.page.maxh,o.speedx=s,o.speedy=i,o.lastx=e,o.lasty=t},this.stop=function(){o.nc.unsynched("domomentum2d"),o.timer&&clearTimeout(o.timer),o.timer=0,o.lastscrollx=-1,o.lastscrolly=-1},this.doSnapy=function(e,t){var r=!1;t<0?(t=0,r=!0):t>o.nc.page.maxh&&(t=o.nc.page.maxh,r=!0),e<0?(e=0,r=!0):e>o.nc.page.maxw&&(e=o.nc.page.maxw,r=!0),r?o.nc.doScrollPos(e,t,o.nc.opt.snapbackspeed):o.nc.triggerScrollEnd()},this.doMomentum=function(e){var t=f(),r=e?t+e:o.lasttime,i=o.nc.getScrollLeft(),s=o.nc.getScrollTop(),n=o.nc.page.maxh,l=o.nc.page.maxw;o.speedx=l>0?Math.min(60,o.speedx):0,o.speedy=n>0?Math.min(60,o.speedy):0;var a=r&&t-r<=60;(s<0||s>n||i<0||i>l)&&(a=!1);var c=!(!o.speedy||!a)&&o.speedy,d=!(!o.speedx||!a)&&o.speedx;if(c||d){var u=Math.max(16,o.steptime);if(u>50){var h=u/50;o.speedx*=h,o.speedy*=h,u=50}o.demulxy=0,o.lastscrollx=o.nc.getScrollLeft(),o.chkx=o.lastscrollx,o.lastscrolly=o.nc.getScrollTop(),o.chky=o.lastscrolly;var p=o.lastscrollx,m=o.lastscrolly,g=function(){var e=f()-t>600?.04:.02;o.speedx&&(p=Math.floor(o.lastscrollx-o.speedx*(1-o.demulxy)),o.lastscrollx=p,(p<0||p>l)&&(e=.1)),o.speedy&&(m=Math.floor(o.lastscrolly-o.speedy*(1-o.demulxy)),o.lastscrolly=m,(m<0||m>n)&&(e=.1)),o.demulxy=Math.min(1,o.demulxy+e),o.nc.synched("domomentum2d",function(){if(o.speedx){o.nc.getScrollLeft();o.chkx=p,o.nc.setScrollLeft(p)}if(o.speedy){o.nc.getScrollTop();o.chky=m,o.nc.setScrollTop(m)}o.timer||(o.nc.hideCursor(),o.doSnapy(p,m))}),o.demulxy<1?o.timer=setTimeout(g,u):(o.stop(),o.nc.hideCursor(),o.doSnapy(p,m))};g()}else o.doSnapy(o.nc.getScrollLeft(),o.nc.getScrollTop())}},x=e.fn.scrollTop;e.cssHooks.pageYOffset={get:function(e,o,t){var r=n.data(e,"__nicescroll")||!1;return r&&r.ishwscroll?r.getScrollTop():x.call(e)},set:function(e,o){var t=n.data(e,"__nicescroll")||!1;return t&&t.ishwscroll?t.setScrollTop(parseInt(o)):x.call(e,o),this}},e.fn.scrollTop=function(e){if(void 0===e){var o=!!this[0]&&(n.data(this[0],"__nicescroll")||!1);return o&&o.ishwscroll?o.getScrollTop():x.call(this)}return this.each(function(){var o=n.data(this,"__nicescroll")||!1;o&&o.ishwscroll?o.setScrollTop(parseInt(e)):x.call(n(this),e)})};var S=e.fn.scrollLeft;n.cssHooks.pageXOffset={get:function(e,o,t){var r=n.data(e,"__nicescroll")||!1;return r&&r.ishwscroll?r.getScrollLeft():S.call(e)},set:function(e,o){var t=n.data(e,"__nicescroll")||!1;return t&&t.ishwscroll?t.setScrollLeft(parseInt(o)):S.call(e,o),this}},e.fn.scrollLeft=function(e){if(void 0===e){var o=!!this[0]&&(n.data(this[0],"__nicescroll")||!1);return o&&o.ishwscroll?o.getScrollLeft():S.call(this)}return this.each(function(){var o=n.data(this,"__nicescroll")||!1;o&&o.ishwscroll?o.setScrollLeft(parseInt(e)):S.call(n(this),e)})};var z=function(e){var o=this;if(this.length=0,this.name="nicescrollarray",this.each=function(e){return n.each(o,e),o},this.push=function(e){o[o.length]=e,o.length++},this.eq=function(e){return o[e]},e)for(var t=0;t<e.length;t++){var r=n.data(e[t],"__nicescroll")||!1;r&&(this[this.length]=r,this.length++)}return this};!function(e,o,t){for(var r=0,i=o.length;r<i;r++)t(e,o[r])}(z.prototype,["show","hide","toggle","onResize","resize","remove","stop","doScrollPos"],function(e,o){e[o]=function(){var e=arguments;return this.each(function(){this[o].apply(this,e)})}}),e.fn.getNiceScroll=function(e){return void 0===e?new z(this):this[e]&&n.data(this[e],"__nicescroll")||!1},(e.expr.pseudos||e.expr[":"]).nicescroll=function(e){return void 0!==n.data(e,"__nicescroll")},n.fn.niceScroll=function(e,o){void 0!==o||"object"!=typeof e||"jquery"in e||(o=e,e=!1);var t=new z;return this.each(function(){var r=n(this),i=n.extend({},o);if(e){var s=n(e);i.doc=s.length>1?n(e,r):s,i.win=r}!("doc"in i)||"win"in i||(i.win=r);var l=r.data("__nicescroll")||!1;l||(i.doc=i.doc||r,l=new b(i,r),r.data("__nicescroll",l)),t.push(l)}),1===t.length?t[0]:t},a.NiceScroll={getjQuery:function(){return e}},n.nicescroll||(n.nicescroll=new z,n.nicescroll.options=g)});
/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * FeaturePopup module
 */
define('gui/FeaturePopup',["jquery", "./FeaturePopupCore", "./IFrame", "./ImageProcessing", "service/Samp", "underscore-min", "text!templates/featureList.html", "text!templates/featureDescription.html", "text!templates/descriptionTable.html", "jquery.nicescroll.min", "jquery.ui"],
    function ($, FeaturePopupCore, IFrame, ImageProcessing, Samp, _, featureListHTMLTemplate, featureDescriptionHTMLTemplate, descriptionTableHTMLTemplate) {

        var featureListHTML = '';
        var mizarWidgetAPI;
        var pickingManager = null;
        var imageManager = null;
        var configuration;

// Create selected feature div
        /*jshint multistr: true */
        var selectedFeatureDiv = '<div id="selectedFeatureDiv" class="contentBox ui-widget-content" style="display: none">\
				<div id="leftDiv"></div>\
				<div id="rightDiv"></div>\
				<div class="closeBtn">\
					<span class="defaultImg"></span>\
					<span style="opacity: 0" class="hoverImg"></span>\
				</div>\
				<div class="arrow-left"></div>\
			</div>';

        var $selectedFeatureDiv;
        var $leftDiv;
        var $rightDiv;

// Template generating the list of selected features
        var featureListTemplate = _.template(featureListHTMLTemplate);

// Template generating the detailed description of choosen feature
        var featureDescriptionTemplate = _.template(featureDescriptionHTMLTemplate);

// Template generating the table of properties of choosen feature
        var descriptionTableTemplate = _.template(descriptionTableHTMLTemplate);

// PileStash help HTML
        var pileStashHelp = '<div id="pileStashHelp"> Some observations are overlapped. <br/> Click on the observation to see detailed informations about each observation. <br/> </div>';

        /**********************************************************************************************/

        return {

            /**
             *    Init
             */
            init: function (mizar, pm, im, conf) {
                mizarWidgetAPI = mizar;
                pickingManager = pm;
                imageManager = im;
                configuration = conf;

                $selectedFeatureDiv = $(selectedFeatureDiv).appendTo('body');
                $leftDiv = $('#leftDiv');
                $rightDiv = $('#rightDiv');

                FeaturePopupCore.init(mizarWidgetAPI, $selectedFeatureDiv, pm, im, conf);

                // Initialize image processing popup
                ImageProcessing.init({
                    mizar: mizarWidgetAPI,
                    disable: function () {
                        $('#dynamicImageView').removeClass('dynamicAvailable').addClass('dynamicNotAvailable');
                    },
                    unselect: function () {
                        $('#dynamicImageView').removeClass('selected');
                    }
                });

                // Show/hide quicklook
                $selectedFeatureDiv.on("click", '#quicklook', FeaturePopupCore.showOrHideQuicklook);

                // Show/hide quicklook wms
                $selectedFeatureDiv.on("click", '#quicklookWms', FeaturePopupCore.showOrHideQuicklookWms);

                // Show/hide quicklook fits
                $selectedFeatureDiv.on('click', "#quicklookFits", FeaturePopupCore.showOrHideQuicklookFits);

                // Show/hide Dynamic image service
                $selectedFeatureDiv.on("click", '#dynamicImageView', FeaturePopupCore.showOrHideDynamicImageService);

                // Send image by Samp
                $selectedFeatureDiv.on("click", '#sendImage', FeaturePopupCore.sendImageBySamp);

                // Show/hide HEALPix service
                $selectedFeatureDiv.on("click", '#healpix', FeaturePopupCore.showOrHideHEALPixService);

                // Arrow scroll events
                $selectedFeatureDiv.on("mousedown", '#scroll-arrow-down.clickable', function () {
                    $('#selectedFeatureDiv #scroll-arrow-up').css("border-bottom-color", "orange").addClass("clickable");
                    var $featureList = $('#featureList');
                    var animationStep = parseInt($('#featureListDiv').css('max-height')) / 2;
                    var topValue = parseInt($featureList.css("top"), 10) - animationStep;
                    var height = $featureList.height();
                    var maxHeight = parseInt($('#featureListDiv').css("max-height"));
                    if (topValue <= -(height - maxHeight)) {
                        topValue = -(height - maxHeight);
                        $(this).css("border-top-color", "gray").removeClass("clickable");
                    }
                    $featureList.stop().animate({top: topValue + "px"}, 300);
                }).disableSelection();

                $selectedFeatureDiv.on("mousedown", '#scroll-arrow-up.clickable', function () {
                    $('#selectedFeatureDiv #scroll-arrow-down').css("border-top-color", "orange").addClass("clickable");
                    var $featureList = $('#featureList');
                    var animationStep = parseInt($('#featureListDiv').css('max-height')) / 2;
                    var topValue = parseInt($featureList.css("top"), 10) + animationStep;
                    if (topValue >= 0) {
                        topValue = 0;
                        $(this).css("border-bottom-color", "gray").removeClass("clickable");
                    }
                    $featureList.stop().animate({top: topValue + "px"}, 300);
                }).disableSelection();

                // Show/hide subsection properties
                $selectedFeatureDiv.on("click", '.section', function () {

                    $selectedFeatureDiv.find('.featureProperties').getNiceScroll().hide();
                    // TODO slideToggle works with div -> add div to the tab generation
                    $(this).siblings('table').fadeToggle("slow", "linear", function () {
                        $selectedFeatureDiv.find('.featureProperties').getNiceScroll().show();
                        $selectedFeatureDiv.find('.featureProperties').getNiceScroll().resize();
                    });
                    /*slideToggle(300)*/
                    if ($(this).siblings('#arrow').is('.arrow-right')) {
                        $(this).siblings('#arrow').removeClass('arrow-right').addClass('arrow-bottom');
                    }
                    else {
                        $(this).siblings('#arrow').removeClass('arrow-bottom').addClass('arrow-right');
                    }
                });

                // Choose feature by clicking on its title
                var self = this;
                $selectedFeatureDiv.on("click", '.featureTitle', FeaturePopupCore.selectFeatureOnTitle);

                // Show/hide external resource
                $selectedFeatureDiv.on("click", '.propertiesTable a', function (event) {
                    event.preventDefault();
                    IFrame.show(event.target.innerHTML);
                });

                $selectedFeatureDiv.on("click", '.featureProperties a', function (event) {
                    event.preventDefault();
                    IFrame.show(event.target.href);
                });

                $rightDiv.css('max-width', $('#' + mizarWidgetAPI.getRenderContext().canvas.id).width() / 4);

                // Make rightDiv always visible depending on viewport
                $(window).on('resize', function () {
                    $rightDiv.find('.featureProperties').css('max-height', FeaturePopupCore.computeHeight());
                    $rightDiv.css('max-width', $('#' + mizarWidgetAPI.getRenderContext().canvas.id).width() / 4);
                });

            },

            // Exposing FeaturePopupCore methods to keep existing API
            hide: FeaturePopupCore.hide,
            show: FeaturePopupCore.show,
            createFeatureList: FeaturePopupCore.createFeatureList,
            showFeatureInformation: FeaturePopupCore.showFeatureInformation,


            /**********************************************************************************************/

            /**
             *    Insert HTML code of help to iterate on each feature
             */
            createHelp: function () {
                $rightDiv.html(pileStashHelp);
            }

            /**********************************************************************************************/

        };

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Image manager
 */
define('gui/ImageManager',["jquery", "./ImageProcessing"],
    function ($, ImageProcessing) {

        var mizarWidgetAPI;
        var fitsVisu;

        /**********************************************************************************************/

        /**
         *    Handle fits data on the given feature
         */
        function handleFits(fitsData, featureData) {

            var image = fitsVisu.handleFits(fitsData, featureData);

            // Set image on image processing popup
            ImageProcessing.setImage(image);
        }

        /**********************************************************************************************/

        /**
         *    Parse fits file
         *
         *    @param response XHR response containing fits
         *
         *    @return Parsed data
         */
        function parseFits(response) {
            fitsVisu.parseFits(response);
        }

        /**********************************************************************************************/

        return {

            /**
             *    Initialize
             */
            init: function (mizar, configuration) {
                mizarWidgetAPI = mizar;
                fitsVisu = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.FitsVisu);
                fitsVisu.init(mizarWidgetAPI.getMizarAPI(), configuration);
                // Enable float texture extension to have higher luminance range
                var ext = mizarWidgetAPI.getRenderContext().gl.getExtension("OES_texture_float");
            },

            /**********************************************************************************************/

            /**
             *    Hide image
             */
            hideImage: function () {
                fitsVisu.hideImage()
            },

            /**********************************************************************************************/

            /**
             *    Show image
             */
            showImage: function (featureData) {
                fitsVisu.showImage(featureData)
            },

            /**********************************************************************************************/

            /**
             *    Remove image from renderer
             */
            removeImage: function (featureData) {
                fitsVisu.removeImage(featureData)
            },

            /**********************************************************************************************/

            /**
             *    Start download of texture
             */
            addImage: function (featureData) {
                fitsVisu.addImage(featureData)
            },

            computeFits: function () {
                fitsVisu.computeFits()
            },
            handleFits: handleFits
        };

        /**********************************************************************************************/

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * PickingManager module
 */
define('gui/PickingManager',["jquery", "underscore-min",
        "./FeaturePopup", "./ImageManager", "./CutOutViewFactory"],
    function ($, _,
              FeaturePopup, ImageManager, CutOutViewFactory) {

        var mizarWidgetAPI;
        var currentContext;
        var self;
        var pickingManagerCore;

        var mouseXStart;
        var mouseYStart;
        var timeStart;

        var isMobile;

        /**
         * The maximum field of view that the camera can reach
         * @type {number} Field of view in degree.
         */
        const FOV_MAX = 25;

        /**
         * The maximum distance from the center of the planet that the camera can reach.
         * @type {number} distance in meters
         */
        const DISTANCE_MAX =  1800000;

        /**
         * Time of the animation in milliseconds.
         * @type {number} time in milliseconds
         */
        const DURATION_TIME = 3000;

        /**************************************************************************************************************/

        /**
         *    Event handler for mouse down
         */
        function _handleMouseDown(event) {
            if (isMobile && event.type.search("touch") >= 0) {
                event.layerX = event.changedTouches[0].clientX;
                event.layerY = event.changedTouches[0].clientY;
            }

            timeStart = new Date();
            mouseXStart = event.layerX;
            mouseYStart = event.layerY;
            pickingManagerCore.clearSelection();
        }

        /**************************************************************************************************************/

        /**
         * Event handler for mouse up
         */
        function _handleMouseUp(event) {
            var timeEnd = new Date();
            var epsilon = 5;
            var diff = timeEnd - timeStart;

            if (isMobile && event.type.search("touch") >= 0) {
                event.layerX = event.changedTouches[0].clientX;
                event.layerY = event.changedTouches[0].clientY;
            }

            // If not pan and not reverse name resolver call
            if (diff < 500 && Math.abs(mouseXStart - event.layerX) < epsilon && Math.abs(mouseYStart - event.layerY) < epsilon) {
                var pickPoint = mizarWidgetAPI.getContext().getLonLatFromPixel(event.layerX, event.layerY);
                // Remove selected style for previous selection
                pickingManagerCore.clearSelection();
                var newSelection = pickingManagerCore.computePickSelection(pickPoint, {eventPos: [event.layerX, event.layerY]});

                if (!_.isEmpty(newSelection) && newSelection.length > 0) {
                    var navigation = mizarWidgetAPI.getNavigation();
                    // Hide previous popup if any
                    FeaturePopup.hide(function () {
                        // View on center
                        if (navigation.inertia) {
                            navigation.inertia.stop();
                        }

                        var showPopup = function () {
                            var select = pickingManagerCore.setSelection(newSelection);

                            // Add selected style for new selection
                            pickingManagerCore.focusSelection(select);
                            FeaturePopup.createFeatureList(select);
                            if (select.length > 1) {
                                // Create dialogue for the first selection call
                                FeaturePopup.createHelp();
                                pickingManagerCore.stackSelectionIndex = -1;
                            }
                            else {
                                // only one layer, no pile needed, create feature dialogue
                                pickingManagerCore.focusFeatureByIndex(0, {isExclusive: true});
                                $('#featureList div:eq(0)').addClass('selected');
                                FeaturePopup.showFeatureInformation(select[pickingManagerCore.stackSelectionIndex].layer, select[pickingManagerCore.stackSelectionIndex].feature)
                            }
                            var offset = $(mizarWidgetAPI.getRenderContext().canvas).offset();
                            FeaturePopup.show(offset.left + mizarWidgetAPI.getRenderContext().canvas.width / 2, offset.top + mizarWidgetAPI.getRenderContext().canvas.height / 2);
                        };

                        if (navigation.getType() === mizarWidgetAPI.NAVIGATION.AstroNavigation) {
                            // Astro
                            //navigation.moveTo(pickPoint, 800, showPopup);
                            var currentFov = navigation.getFov()[1];
                            var targetFov = (currentFov > FOV_MAX) ? FOV_MAX : currentFov;
                            navigation.zoomTo(pickPoint, {fov: targetFov, duration: DURATION_TIME, callback: showPopup});
                        }
                        else {
                            var currentDistance = navigation.getDistance();
                            var targetDistance = (currentDistance < DISTANCE_MAX) ? currentDistance : DISTANCE_MAX;
                            if (false) {
                                if (pickPoint) {
                                    navigation.zoomTo(pickPoint, {distance: targetDistance, duration: DURATION_TIME, callback: showPopup});
                                } else {
                                    showPopup();
                                }
                            } else {
                                var zoomToPoint = pickPoint;
                                if (!zoomToPoint) {
                                    for (var selection of newSelection) {
                                        if (selection.feature.geometry.type === "Point") {
                                            zoomToPoint = selection.feature.geometry.coordinates;
                                            if (zoomToPoint) break;
                                        }
                                    }
                                }
                                navigation.zoomTo(zoomToPoint, {duration: DURATION_TIME, callback: showPopup});
                            }
                        }
                    });
                } else {
                    FeaturePopup.hide();
                }
                mizarWidgetAPI.refresh();
            }
        }

        /**************************************************************************************************************/

        /**
         *    Activate picking
         */
        function activate() {
            currentContext.getRenderContext().canvas.addEventListener("mousedown", _handleMouseDown);
            currentContext.getRenderContext().canvas.addEventListener("mouseup", _handleMouseUp);

            if (isMobile) {
                currentContext.getRenderContext().canvas.addEventListener("touchstart", _handleMouseDown);
                currentContext.getRenderContext().canvas.addEventListener("touchend", _handleMouseUp);
            }

            // Hide popup and blur selection when pan/zoom or animation
            mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.NAVIGATION_STARTED, function () {
                pickingManagerCore.clearSelection();
                FeaturePopup.hide();
            });
        }

        /**************************************************************************************************************/

        /**
         *    Deactivate picking
         */
        function deactivate() {
            currentContext.getRenderContext().canvas.removeEventListener("mousedown", _handleMouseDown);
            currentContext.getRenderContext().canvas.removeEventListener("mouseup", _handleMouseUp);

            if (isMobile) {
                currentContext.getRenderContext().canvas.removeEventListener("touchstart", _handleMouseDown);
                currentContext.getRenderContext().canvas.removeEventListener("touchend", _handleMouseUp);
            }

            // Hide popup and blur selection when pan/zoom or animation
            mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.NAVIGATION_STARTED, function () {
                pickingManagerCore.clearSelection();
                FeaturePopup.hide();
            });
        }

        /**************************************************************************************************************/

        return {
            /**
             * Init picking manager
             *
             * @param {Mizar} m mizarWidgetAPI
             * @param {Object} configuration PickingManager configuration
             * @param {Boolean} configuration.isMobile For mobile navigation
             * @param {?Object} configuration.cutout cutout service
             * @param {String} configuration.sitoolsBaseUrl serviceBaseUrl for ImageManager module
             *
             */
            init: function (m, configuration) {
                mizarWidgetAPI = m;
                currentContext = mizarWidgetAPI.getContext();
                self = this;
                isMobile = configuration.isMobile;
                pickingManagerCore = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.PickingManager);

                activate();

                mizarWidgetAPI.subscribeMizar(mizarWidgetAPI.EVENT_MSG.MIZAR_MODE_TOGGLE, this.updateContext);
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.CRS_MODIFIED, this.updateContext);

                // Initialize the fits manager
                ImageManager.init(mizarWidgetAPI, configuration);

                if (configuration.cutOut) {
                    // CutOutView factory ... TODO : move it/refactor it/do something with it...
                    CutOutViewFactory.init(mizarWidgetAPI, this);
                }
                FeaturePopup.init(mizarWidgetAPI, this, ImageManager, configuration);
            },

            /**************************************************************************************************************/

            /**
             *    Update picking context
             */
            updateContext: function () {
                //if(currentContext)
                //    deactivate();
                currentContext = mizarWidgetAPI.getContext();
                pickingManagerCore.updateContext(currentContext);
                activate();
            },

            /**************************************************************************************************************/

            /**
             *    Add pickable layer
             */
            addPickableLayer: function (layer) {
                pickingManagerCore.addPickableLayer(layer);
            },

            /**************************************************************************************************************/

            /**
             *    Remove pickable layers
             */
            removePickableLayer: function (layer) {
                pickingManagerCore.removePickableLayer(layer);
            },

            /**************************************************************************************************************/

            /**
             *    Apply selected style to the given feature
             */
            focusFeature: function (selectedData, options) {
                pickingManagerCore.getSelection().push(selectedData);
                this.focusFeatureByIndex(pickingManagerCore.getSelection().length - 1, options);
            },

            /**************************************************************************************************************/

            getSelectedData: function () {
                return pickingManagerCore.getSelection()[pickingManagerCore.stackSelectionIndex];
            },

            /**************************************************************************************************************/

            getSelection: function () {
                return pickingManagerCore.getSelection();
            },

            /**************************************************************************************************************/

            blurSelectedFeature: function () {
                pickingManagerCore.blurSelectedFeature();
            },

            /**************************************************************************************************************/

            focusFeatureByIndex: function (index, options) {
                pickingManagerCore.focusFeatureByIndex(index, options);
            },

            /**************************************************************************************************************/

            computePickSelection: function (pickPoint) {
                pickingManagerCore.computePickSelection(pickPoint);
            },

            /**************************************************************************************************************/

            blurSelection: function () {
                pickingManagerCore.blurSelection();
            },

            /**************************************************************************************************************/

            activate: activate,
            deactivate: deactivate
        };

    });


define('text!templates/backgroundLayers.html',[],function () { return '<div>\n    <h3>Background layer</h3>\n\n    <div id="backgroundLayers">\n        <fieldset>\n            <select style="display: none;" id="backgroundLayersSelect">\n            </select>\n        </fieldset>\n\n        <div style="display: none" id="backgroundSpinner"></div>\n        <br/>\n\n        <div id="backgroundOptions">\n            <input type="checkbox" id="fitsType"/><label for="fitsType">Fits</label>\n            <input type="checkbox" id="fitsView"/><label for="fitsView">Image processing</label>\n            <button class="layerServices">Available services</button>\n            <button class="exportLayer">Send viewport by SAMP</button>\n        </div>\n\n        <button class="backToSky">Back to sky</button>\n    </div>\n</div>\n';});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * BackgroundLayersView module
 */
define('gui/BackgroundLayersView',["jquery", "underscore-min","./DynamicImageView", "./PickingManager", "./LayerServiceView", "service/Samp", "./dialog/ErrorDialog", "../utils/UtilsCore", "text!templates/backgroundLayers.html", "jquery.ui"],
    function ($, _, DynamicImageView, PickingManager, LayerServiceView, Samp, ErrorDialog, UtilsCore, backgroundLayersHTML) {

        var nbBackgroundLayers = 0; // required because background id is always equal to 0
        var sky; // TODO: remove sky parameter, use activatedContext instead..
        var parentElement;
        var $el;

        var backgroundDiv;
        var selectedLayer;
        var mizarWidgetAPI;


        /**************************************************************************************************************/


        function createBackgroundItemList() {
            $.widget("custom.iconselectmenu", $.ui.selectmenu, {
                _renderItem: function (ul, item) {
                    var li = $("<li>", {text: item.label});

                    if (item.disabled) {
                        li.addClass("ui-state-disabled");
                    }

                    $("<span>", {
                        style: item.element.attr("data-style"),
                        "class": "ui-icon " + item.element.attr("data-class")
                    }).appendTo(li);

                    return li.appendTo(ul);
                }
            });
        }

        function createBackToSkyButtonFromPlanet() {
            if(mizarWidgetAPI.hasSkyContext()) {
                $el.find('.backToSky').button().click(function (event) {
                    mizarWidgetAPI.toggleToSky();
                });
            } else {
                $el.find('.backToSky').hide();
            }
            $el.find("#backgroundOptions").hide();
        }

        function createBackToSkyButtonFromGround() {
            if(mizarWidgetAPI.hasPlanetContext()) {
                $el.find('.backToSky').button().click(function (event) {
                    mizarWidgetAPI.toggleToSky();
                });
            } else {
                $el.find('.backToSky').hide();
            }
            $el.find("#backgroundOptions").hide();
        }

        function createServiceButton() {
            $el.find('.layerServices').button({
                text: false,
                icons: {
                    primary: "ui-icon-wrench"
                }
            }).click(function (event) {
                LayerServiceView.show(selectedLayer);
            });
        }

        function createExportSampButton(){
            $el.find('.exportLayer').button({
                text: false,
                icons: {
                    primary: "ui-icon-extlink"
                }
            }).click(function (event) {
                if (Samp.isConnected()) {
                    var healpixLayer = sky.baseImagery;
                    for (var i = 0; i < sky.tileManager.tilesToRender.length; i++) {
                        var tile = sky.tileManager.tilesToRender[i];
                        var url = healpixLayer.getUrl(tile);
                        Samp.sendImage(url);
                    }
                }
                else {
                    ErrorDialog.open('You must be connected to SAMP Hub');
                }
            });
        }

        function createImageProcessingButton() {
            var dialogId = "backgroundDiv";

            var $dialog = $('<div id="' + dialogId + '"></div>').appendTo('body').dialog({
                title: 'Image processing',
                autoOpen: false,
                show: {
                    effect: "fade",
                    duration: 300
                },
                hide: {
                    effect: "fade",
                    duration: 300
                },
                width: 400,
                resizable: false,
                minHeight: 'auto',
                close: function (event, ui) {
                    $('#fitsView').removeAttr("checked").button("refresh");
                    $(this).dialog("close");
                }
            });
            backgroundDiv = new DynamicImageView(dialogId, {
                id: 'backgroundFitsView',
                mizar: mizarWidgetAPI
            });
            var self = this;
            mizarWidgetAPI.subscribeCtx("baseLayersReady", function(imageryProvider) {
                if(imageryProvider.format === "fits") {
                    backgroundDiv.setImage(imageryProvider.levelZeroImage);
                }
            });

            // Show/hide Dynamic image service
            $el.find('#fitsView').button({
                text: false,
                icons: {
                    primary: "ui-icon-image"
                }
            }).click(function (event) {

                if ($dialog.dialog("isOpen")) {
                    $dialog.dialog("close");
                }
                else {
                    $dialog.dialog("open");
                }
            });
            return $dialog;
        }

        function createFitsButton($dialog) {
            $el.find('#fitsType')
                .button()
                .click(function () {
                    var isFits = $('#fitsType').is(':checked');
                    var fitsHipsService = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.FitsHips);
                    var mizarAPI = mizarWidgetAPI.getMizarAPI();
                    fitsHipsService.init(mizarAPI, {});
                    if (isFits) {
                        $('#fitsType').removeAttr(":checked").button("refresh");
                        fitsHipsService.createFitsLayer(selectedLayer);
                        $('#fitsView').button('enable');
                    } else {
                        $('#fitsType').attr(':checked', true).button("refresh");
                        fitsHipsService.removeFitsLayer(selectedLayer.ID);
                        if ($dialog.dialog("isOpen")) {
                            $dialog.dialog("close");
                            $('#fitsView').removeAttr("checked").button("refresh");
                        }
                        $('#fitsView').button('disable');
                    }
                    $('#loading').show();
                });
        }


        function createBackgroundButtons() {
            if(mizarWidgetAPI.isGroundContext()) {
                createBackToSkyButtonFromGround();
            } else if(mizarWidgetAPI.isPlanetContext()) {
                createBackToSkyButtonFromPlanet();
            } else {
                // we are in skyContext
                $el.find('.backToSky').hide();
                //$el.find('.toggleDimension').hide();

                createServiceButton();
                createExportSampButton();
                var $dialog = createImageProcessingButton();
                createFitsButton($dialog);
            }
        }

        function selectBackgroundItem(){
            $el.find('#backgroundLayersSelect').iconselectmenu({
                select: function (event, ui) {
                    var index = ui.item.index;
                    var layer = $(this).children().eq(index).data("layer");
                    if (layer !== mizarWidgetAPI.getContext().globe.baseImagery) {
                        mizarWidgetAPI.setBackgroundLayer(layer.name);
                    }
                }
            }).iconselectmenu("menuWidget").addClass("ui-menu-icons customicons");
        }

        /**
         *    Update layout of background layer options (HEALPixFITSLayer only for now)
         */
        function updateBackgroundOptions(layer) {
            if ($el.find("#backgroundOptions").is(":visible")) {
                if (UtilsCore.isHipsFitsLayer(layer)) {
                    if(layer.format!=="fits") {
                        $el.find("#fitsType").removeAttr('disabled').removeAttr('checked').button("refresh");
                    }
                } else {
                    $el.find("#fitsType").attr('disabled', 'disabled').button("refresh");
                    $el.find('#fitsView').button("disable");
                }

                var $layerServices = $el.find('.layerServices');
                if (!layer.services) {
                    $layerServices.attr('disabled', 'disabled').button('refresh');
                } else {
                    $layerServices.removeAttr('disabled').button('refresh');
                }
            }
        }

        /**************************************************************************************************************/

        /**
         *    Create the Html for the given background layer
         */
        function createHtmlForBackgroundLayer(gwLayer) {
            if(gwLayer.type === "WCSElevation" || gwLayer.type === "WMSElevation") {
                // skip it, we do not want to see it in the client
            } else {
                // Add HTML
                var $layerDiv = $('<option ' + (gwLayer.isVisible() ? "selected" : "") + '>' + gwLayer.name + '</option>')
                    .appendTo($el.find('#backgroundLayersSelect'))
                    .data("layer", gwLayer);

                if (gwLayer.icon) {
                    $layerDiv.addClass('backgroundLayer_' + nbBackgroundLayers)
                        .attr("data-style", "background-image: url(" + gwLayer.icon + ")");
                }
                else {
                    // Use default style for icon
                    $layerDiv.addClass('backgroundLayer_' + nbBackgroundLayers).attr("data-class", "unknown");
                }
                if (gwLayer.isVisible()) {
                    selectedLayer = gwLayer;
                    updateBackgroundOptions(gwLayer);
                }
                $el.find('#backgroundLayersSelect').iconselectmenu("refresh");
                nbBackgroundLayers++;
            }

        }

        /**************************************************************************************************************/

        /**
         *    Show spinner on loading
         */
        function onLoadStart(layer) {
            $el.find('#backgroundSpinner').fadeIn('fast');
        }

        /**************************************************************************************************************/

        /**
         *    Hide spinner when layer is loaded
         */
        function onLoadEnd(layer) {
            $el.find('#backgroundSpinner').fadeOut('fast');
        }


        /**************************************************************************************************************/

        return {
            /**
             *    Initialization options
             */
            init: function (options) {

                mizarWidgetAPI = options.mizar;
                sky = mizarWidgetAPI.getContext().globe;
                parentElement = options.configuration.element;
                this.updateUI();

                // Background spinner events
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_START_BACKGROUND_LOAD, onLoadStart);
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_END_BACKGROUND_LOAD, onLoadEnd);
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_BACKGROUND_CHANGED, this.selectLayer);
            },
            remove: function () {
                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_START_BACKGROUND_LOAD, onLoadStart);
                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_END_BACKGROUND_LOAD, onLoadEnd);
                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_BACKGROUND_CHANGED, this.selectLayer);
                $('#backgroundDiv').dialog("destroy").remove();
                $el.remove();
                nbBackgroundLayers = 0;
            },
            addView: createHtmlForBackgroundLayer,

            /**
             *    Select the given layer
             */
            selectLayer: function (layer) {
                // Update selectmenu ui by choosen layer(if called programmatically)
                $el.children().removeAttr("selected");
                var option = _.find($el.children(), function (item) {
                    return item.text === layer.name;
                });
                $(option).attr("selected", "selected");

                selectedLayer = layer;

                // Show background loading spinner
                //$('#loading').show(300);

                // Set shader callback for choosen layer
                if (!_.isEmpty(backgroundDiv)) {
                    backgroundDiv.changeShaderCallback = function (contrast) {
                        if (contrast === "raw") {
                            layer.customShader.fragmentCode = layer.rawFragShader;
                        } else {
                            layer.customShader.fragmentCode = layer.colormapFragShader;
                        }
                    };
                }

                // Change dynamic image view button
                updateBackgroundOptions(layer);

            },

            /**
             *    Create select menu
             *    Synchonize background spinner with background survey events
             */
            updateUI: function () {
                $el = $(backgroundLayersHTML).prependTo($(parentElement));
                // Add custion icon select menu
                createBackgroundItemList();
                createBackgroundButtons();
                selectBackgroundItem();
            },
            getDiv: function () {
                return backgroundDiv;
            }
        };

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * AdditionalLayersView module
 * @class AdditionalLayersCore
 */
define('gui/AdditionalLayersCore',["jquery", "underscore-min", "./dialog/ErrorDialog", "../utils/UtilsCore"],
    function ($, _, ErrorDialog, UtilsCore) {

        var mizarWidgetAPI;
        var globe;

        /**************************************************************************************************************/

        /**
         *    Generate point legend in canvas 2d
         *
         *    @param gwLayer GlobWeb layer
         *    @param canvas Canvas
         *    @param imageUrl Image source url used for point texture
         */
        function generatePointLegend(gwLayer, canvas, imageUrl) {
            var context = canvas.getContext('2d');
            var icon = new Image();
            icon.crossOrigin = '';
            icon.onload = function () {
                // var width = (icon.width > canvas.width) ? canvas.width : icon.width;
                // var height = (icon.height > canvas.height) ? canvas.height : icon.height;
                context.drawImage(icon, 5, 0, 10, 10);

                // colorize icon
                var data = context.getImageData(0, 0, canvas.width, canvas.height);
                for (var i = 0, length = data.data.length; i < length; i += 4) {
                    data.data[i] = gwLayer.style.fillColor[0] * 255;
                    data.data[i + 1] = gwLayer.style.fillColor[1] * 255;
                    data.data[i + 2] = gwLayer.style.fillColor[2] * 255;
                }

                context.putImageData(data, 0, 0);
            };
            icon.src = imageUrl;
        }

        /**************************************************************************************************************/

        /**
         *    Generate line legend in canvas 2d
         */
        function generateLineLegend(gwLayer, canvas) {
            var context = canvas.getContext('2d');

            var margin = 2;
            context.beginPath();
            context.moveTo(margin, canvas.height - margin);
            context.lineTo(canvas.width / 2 - margin, margin);
            context.lineTo(canvas.width / 2 + margin, canvas.height - margin);
            context.lineTo(canvas.width - margin, margin);
            context.lineWidth = 1;

            // set line color
            context.strokeStyle = mizarWidgetAPI.getMizarAPI().UtilityFactory.create(mizarWidgetAPI.UTILITY.FeatureStyle).fromColorToString(gwLayer.style.fillColor);
            context.stroke();
        }

        /**************************************************************************************************************/

        /**
         * Generate HTML from layer and template
         * @param template
         * @param gwLayer
         * @param shortName
         * @param isMobile
         * @returns {*}
         */
        function createHTMLFromTemplate(template, gwLayer, shortName, isMobile) {
            return template({
                layer: gwLayer,
                shortName: shortName,
                isMobile: isMobile
            });
        }

        /**************************************************************************************************************/

        /**
         * Set sublayers visibility
         * @param gwLayer
         * @param isOn
         */
        function setSublayersVisibility(gwLayer, isOn) {
            var i;
            if (isOn) {
                for (i = 0; i < gwLayer.subLayers.length; i++) {
                    globe.addLayer(gwLayer.subLayers[i]);
                }
            }
            else {
                for (i = 0; i < gwLayer.subLayers.length; i++) {
                    globe.removeLayer(gwLayer.subLayers[i]);
                }
            }
        }

        /**************************************************************************************************************/

        /**
         *    Build visible tiles url
         */
        function buildVisibleTilesUrl(layer) {
            // Find max visible order & visible pixel indices
            var maxOrder = 3;
            var pixelIndices = "";
            for (var i = 0; i < globe.tileManager.visibleTiles.length; i++) {
                var tile = globe.tileManager.visibleTiles[i];
                if (maxOrder < tile.order) {
                    maxOrder = tile.order;
                }

                pixelIndices += tile.pixelIndex;
                if (i < globe.tileManager.visibleTiles.length - 1) {
                    pixelIndices += ",";
                }
            }
            return layer.serviceUrl + "/search?order=" + maxOrder + "&healpix=" + pixelIndices + "&coordSystem=EQUATORIAL";
        }

        /**************************************************************************************************************/

        /**
         * Zoom to barycenter of all features contained by layer
         *    (available for GlobWeb.VectorLayers only)
         * @param {Layer} layer
         */
        function zoomTo(layer) {
            var sLon = 0;
            var sLat = 0;
            var nbGeometries = 0;

            if (layer.features.length > 0) {
                for (var i = 0; i < layer.features.length; i++) {
                    var barycenter = UtilsCore.computeGeometryBarycenter(layer.features[i].geometry);
                    sLon += barycenter[0];
                    sLat += barycenter[1];
                    nbGeometries++;
                }
                //TODO : compute the fov of the zoomTo according to the shape.
                mizarWidgetAPI.getNavigation().zoomTo([sLon / nbGeometries, sLat / nbGeometries]);
            }
        }

        /**************************************************************************************************************/

        return {
            /**
             * @constructor
             * @param m
             * @param s
             * @param nav
             */
            init: function (m) {
                mizarWidgetAPI = m;
                globe = mizarWidgetAPI.getContext().globe;
            },
            generatePointLegend: generatePointLegend,
            generateLineLegend: generateLineLegend,
            buildVisibleTilesUrl: buildVisibleTilesUrl,
            createHTMLFromTemplate: createHTMLFromTemplate,
            setSublayersVisibility: setSublayersVisibility,
            zoomTo: zoomTo
        };
    });


define('text!templates/additionalLayers.html',[],function () { return '<div style="display: none;" class="category">\n    <h3>Other</h3>\n\n    <div id="otherLayers"></div>\n</div>\n\n<div style="display: none;" class="category">\n    <h3>Coordinate systems</h3>\n\n    <div id="coordinateSystems">\n        <em>Default coordinate system:</em>\n        <select id="defaultCoordSystem">\n            <option value="Equatorial">Equatorial</option>\n            <option value="Galactic">Galactic</option>\n        </select>\n\n        <div id="coordinateGrids">\n        </div>\n    </div>\n</div>';});


define('text!templates/additionalLayer.html',[],function () { return '<div class="ui-widget addLayer" id="addLayer_<%= shortName %>">\n\n\t<span id="visible_<%= shortName %>"\n          class="<% if (layer.isVisible()) print(\'ui-state-active\'); else print(\'ui-state-default\'); %> ui-corner-all ui-button">\n\t\t<span class="ui-icon <% if (layer.isVisible()) print(\'ui-icon-check\'); else print(\'ui-icon-empty\'); %>"></span>\n\t</span>\n\n    <canvas width="20" height="10" class="legend"></canvas>\n\n    <label title="<%= layer.description %>" for="addLayerInput_<%= shortName %>"><%= layer.name %></label>\n\n    <span style="display: none;" class="spinner"></span>\n\n    <div style="display: none;" class="layerTools" class="ui-widget-header ui-corner-all">\n        <%\n        if( layer.deletable )\n        {\n        %>\n\n        <button class="deleteLayer">Delete</button>\n        <%\n        }\n        %>\n\n\n        <% if ( layer.type == "GeoJSON" )\n        {\n        %>\n\n        <button class="zoomTo">zoomTo</button>\n        <%\n        }\n\n        if ( layer.services )\n        {\n        %>\n        <button class="layerServices">Available services</button>\n        <%\n        }\n        if ( layer.type == "OpenSearch" ) \n        {\n        %>\n        <button class="exportLayer">Export visible tiles by SAMP</button>\n        <a href="" download="">\n            <button class="downloadAsVO">Download visible tiles as VOTable</button>\n        </a>\n        <%\n        }\n        %>\n\n        <% if ( layer.type == "Hips" && layer.fitsSupported == true && !isMobile )\n        {\n        %>\n        <input type="checkbox" class="isFits" id="isFits_<%= shortName %>"/><label\n            for="isFits_<%= shortName %>">Fits</label>\n        <input type="checkbox" class="addFitsView" id="addFitsView_<%= shortName %>" disabled="disabled"/><label\n            for="addFitsView_<%= shortName %>"></label>\n        <%\n        }\n        if ( layer.type == "OpenSearch" )\n        {\n        %>\n        <div id="os_navigation_<%= shortName %>">\n            &nbsp;&nbsp;&nbsp;<label class="labelPage_<%= layer.getShortName() %>">Page 1</label>&nbsp;&nbsp;&nbsp;<button class="osNext">Next</button><br/>\n        </div>\n        <div class="QLWMS_<%= shortName %>" style="display:none">\n            <button class="removeWMS">Remove quicklook WMS layers</button>\n        </div>\n        <%\n        }\n        %>\n\n        <div id="opacity_<%= shortName %>">\n            <div>\n                <label for="percentInput_<%= shortName %>">Opacity: </label>\n                <input class="percentInput" type="text" id="percentInput_<%= shortName %>"/>\n            </div>\n            <div class="slider" id="slider_<%= shortName %>"></div>\n        </div>\n\n        <!--<div id="seaLevel_<%= shortName %>">-->\n            <!--<div>-->\n                <!--<label for="seaLevelInput_<%= shortName %>">Sea level: </label>-->\n                <!--<input class="percentInput" type="text" id="seaLevelInput_<%= shortName %>"/>-->\n            <!--</div>-->\n            <!--<div class="slider" id="seaLevelSlider_<%= shortName %>"></div>-->\n        <!--</div>-->\n        <div id="time_<%= shortName %>">\n            <div>\n                <label for="timeInput_<%= shortName %>">Time: </label>\n                <input class="dateInput" type="text" id="timeInput_<%= shortName %>"/>\n            </div>\n            <div class="sliderTime" id="timeSlider_<%= shortName %>"></div>\n        </div>\n    </div>\n\n</div>\n';});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * AdditionalLayersView module
 */
define('gui/AdditionalLayersView',["jquery", "moment", "./AdditionalLayersCore", "./PickingManager", "./DynamicImageView", "./LayerServiceView", "service/Samp", "./dialog/ErrorDialog", "../utils/UtilsCore", "underscore-min", "text!templates/additionalLayers.html", "text!templates/additionalLayer.html", "jquery.nicescroll.min", "jquery.ui"],
    function ($, moment, AdditionalLayersCore, PickingManager, DynamicImageView, LayerServiceView, Samp, ErrorDialog, UtilsCore, _, additionalLayersHTML, additionalLayerHTMLTemplate) {

        var mizarWidgetAPI;
        var configuration;
        var globe;
        var navigation;
        var parentElement;
        var categories = {
            "Other": 'otherLayers',
            "Coordinate systems": 'coordinateSystems'
        };
        var isMobile = false;

        // Template generating the additional layer div in sidemenu
        var additionalLayerTemplate = _.template(additionalLayerHTMLTemplate);

        /**************************************************************************************************************/

        /**
         *    Initialize nice scroll for the given category
         */
        function initNiceScroll(categoryId) {
            // Nice scrollbar initialization
            $('#' + categoryId).niceScroll({
                autohidemode: false
            });
            // Hide scroll while accordion animation
            $(parentElement).on("accordionbeforeactivate", function () {
                $('#' + categoryId).niceScroll().hide();
            });
            // Show&resize scroll on the end of accordion animation
            $(parentElement).on("accordionactivate", function () {
                $('#' + categoryId).niceScroll().show();
                updateScroll(categoryId);
            });
        }

        /**************************************************************************************************************/

        /**
         *    Update scroll event
         */
        function updateScroll(categoryId) {
            $(parentElement).find('#' + categoryId).getNiceScroll().resize();
        }

        /**************************************************************************************************************/

        function initializeSliderOpacity($layerDiv, shortName, gwLayer) {
            // Slider initialisation
            $layerDiv.find('#slider_' + shortName).slider({
                value: gwLayer.getOpacity() * 100,
                min: 20,
                max: 100,
                step: 20,
                slide: function (event, ui) {
                    $("#percentInput_" + shortName).val(ui.value + "%");
                    gwLayer.setOpacity(ui.value / 100);
                    if (gwLayer.subLayers) {
                        for (var i = 0; i < gwLayer.subLayers.length; i++) {
                            gwLayer.subLayers[i].setOpacity(ui.value / 100);
                        }
                    }
                }
            }).slider("option", "disabled", !gwLayer.isVisible());

            // Init percent input of slider
            $("#percentInput_" + shortName).val($("#slider_" + shortName).slider("value") + "%");
        }

        function initializeSliderTime($layerDiv, shortName, gwLayer) {
            var startDate, stopDate, nbValues, resolution, timeDefinitionArray;
            var timeDimension = gwLayer.getDimensions().time;
            var isInterval = false;
            if (timeDimension) {
                var timeUtility = mizarWidgetAPI.getMizarAPI().TimeUtility;
                timeDefinitionArray = timeDimension.value.split(",");
                if(timeUtility.isSampling(timeDefinitionArray[0])) {
                    var minMaxRes = timeDefinitionArray[0].split("/");
                    startDate = moment.utc(minMaxRes[0]);
                    stopDate = moment.utc(minMaxRes[1]);
                    resolution = timeUtility.timeResolution(minMaxRes[2]);
                    nbValues = Math.floor(stopDate.diff(startDate, resolution.unit) / parseInt(resolution.step));
                    isInterval = true;
                } else {
                    startDate = moment.utc(timeDefinitionArray[0]);
                    nbValues = timeDefinitionArray.length-1;
                    isInterval = false;
                }
            }

            $layerDiv.find('#timeSlider_' + shortName).slider({
                value: 0,
                min: 0,
                max: nbValues,
                step: 1,
                slide: function (event, ui) {
                    var isoDate;
                    if(isInterval) {
                        var currentDate = moment.utc(startDate);
                        currentDate.add(parseInt(ui.value) * resolution.step, resolution.unit);
                        isoDate = currentDate.toISOString();
                    } else {
                        isoDate = timeDefinitionArray[parseInt(ui.value)];
                    }
                    $("#timeInput_" + shortName).val(isoDate);
                    gwLayer.setParameter("time",isoDate);
                }
            }).slider("option", "disabled", !gwLayer.isVisible());

            if(timeDimension) {
                $("#timeInput_" + shortName).val(startDate.toISOString());
                $('#time_' + shortName).css('visibility',"show");
                gwLayer.setParameter("time",startDate.toISOString());
            } else {
                $('#time_' + shortName).css('visibility',"hidden");
            }
        }

        /**
         *    Initialize UI of  slider for the given layer
         */
        function initializeSliders($layerDiv, gwLayer) {
            if (typeof gwLayer === 'undefined') {
                return;
            }
            /*var shortName = UtilsCore.formatId(gwLayer.name);
             if (typeof shortName === 'string') {
             shortName = shortName.replace(/[^a-z0-9\s]/gi, '').replace(/[_\s]/gwLayer);, '-');
             }
             */
            var shortName = gwLayer.getShortName();

            // Slider initialisation
            initializeSliderOpacity($layerDiv, shortName, gwLayer);

            initializeSliderTime($layerDiv, shortName, gwLayer);

            //if(gwLayer.name === "Palavas Digital Elevation Model") {
            //    $layerDiv.find('#seaLevelSlider_' + shortName).slider({
            //        value: 0,
            //        min: 0,
            //        max: 6,
            //        step: 1,
            //        slide: function (event, ui) {
            //            $("#seaLevelInput_" + shortName).val((0.5 * ui.value).toFixed(1) + " m");
            //            gwLayer.setParameter("styles", (0.5 * ui.value).toFixed(1) + "m");
            //        }
            //    }).slider("option", "disabled", !gwLayer.isVisible());
            //
            //    // Init percent input of slider
            //    $("#seaLevelInput_" + shortName).val("+" + $("#seaLevelSlider_" + shortName).slider("value") + " m");
            //
            //}

        }



        /**************************************************************************************************************/

        /**
         *    Update all toolbar buttons UI
         */
        function updateButtonsUI($layerDiv) {
            // Init buttons of tool bar
            $layerDiv
                .find('.deleteLayer').button({
                    text: false,
                    icons: {
                        primary: "ui-icon-trash"
                    }
                }).end()
                .find('.zoomTo').button({
                    text: false,
                    icons: {
                        primary: "ui-icon-zoomin"
                    }
                }).end()
                .find('.exportLayer').button({
                    text: false,
                    icons: {
                        primary: "ui-icon-extlink"
                    }
                }).end()
                .find('.downloadAsVO').button({
                    text: false,
                    icons: {
                        primary: "ui-icon-arrowthickstop-1-s"
                    }
                }).end()
                .find('.removeWMS').button({
                    text: false,
                    icons: {
                        primary: "ui-icon-newwin"
                    }
                }).end()
                .find('.isFits').button().end()
                .find('.addFitsView').button({
                    text: false,
                    icons: {
                        primary: "ui-icon-image"
                    }
                }).end()
                .find('.layerServices').button({
                    text: false,
                    icons: {
                        primary: "ui-icon-wrench"
                    }
                }).end()
                .find('.osNext').button({
                    text: true,
                    icons: {
                        primary: "ui-icon-triangle-1-e"
                    }
                });
        }

        /**************************************************************************************************************/

        /**
         *    Add legend for the given layer if possible
         *    Legend represents the "line" for polygon data or image from "iconUrl" for point data
         */
        function addLegend($layerDiv, gwLayer) {
            var $canvas = $layerDiv.find('.legend');
            var canvas = $canvas[0];

            if (UtilsCore.isOpenSearchLayer(gwLayer) || UtilsCore.isMocLayer(gwLayer)
                || UtilsCore.isVectorLayer(gwLayer) || UtilsCore.isGeoJsonLayer(gwLayer) || UtilsCore.isHipsCatLayer(gwLayer)) {
                if (gwLayer.dataType === mizarWidgetAPI.GEOMETRY.Point) {
                    AdditionalLayersCore.generatePointLegend(gwLayer, canvas, gwLayer.style.iconUrl);
                }
                else if (gwLayer.dataType === mizarWidgetAPI.GEOMETRY.LineString) {
                    AdditionalLayersCore.generateLineLegend(gwLayer, canvas);
                }
                else {
                    $canvas.css("display", "none");
                }
            }
            else {
                $canvas.css("display", "none");
            }
        }

        /**************************************************************************************************************/

        /**
         *    Create dialog to modify contrast/colormap of fits layers
         */
        function createDynamicImageDialog(gwLayer) {
            if (typeof gwLayer === 'undefined') {
                return;
            }
            /*var shortName = UtilsCore.formatId(gwLayer.name);
             if (typeof shortName === 'string') {
             shortName = shortName.replace(/[^a-z0-9\s]/gi, '').replace(/[_\s]/gwLayer);, '-');
             }*/
            var shortName = gwLayer.getShortName();
            // Supports fits, so create dynamic image view in dialog
            var dialogId = "addFitsViewDialog_" + shortName;
            var $dialog = $('<div id="' + dialogId + '"></div>').appendTo('body').dialog({
                title: 'Image processing',
                autoOpen: false,
                show: {
                    effect: "fade",
                    duration: 300
                },
                hide: {
                    effect: "fade",
                    duration: 300
                },
                resizable: false,
                width: 'auto',
                minHeight: 'auto',
                close: function () {
                    $('#addFitsView_' + shortName).removeAttr("checked").button("refresh");
                    $(this).dialog("close");
                }
            });

            // Dialog activator
            $('#addFitsView_' + shortName).click(function () {

                if ($dialog.dialog("isOpen")) {
                    $dialog.dialog("close");
                }
                else {
                    $dialog.dialog("open");
                }
            });

            // Add dynamic image view content to dialog
            gwLayer.div = new DynamicImageView(dialogId, {
                id: shortName,
                mizar: mizarWidgetAPI,
                changeShaderCallback: function (contrast) {
                    if (contrast === "raw") {
                        gwLayer.customShader.fragmentCode = gwLayer.rawFragShader;
                    }
                    else {
                        gwLayer.customShader.fragmentCode = gwLayer.colormapFragShader;
                    }
                }
            });
        }

        /**************************************************************************************************************/

        /**
         *    Handler managing BaseLayer "visibility:changed" event
         *    TODO: create view object
         */
        function onVisibilityChange(gwLayer) {
            if (typeof gwLayer === 'undefined') {
                return;
            }
            var isOn = gwLayer.isVisible();
            if (isOn === true) {
                /*              console.log("Visibility set to on for "+gwLayer.name+" with id="+gwLayer.ID);
                 console.log("Change z-index !");
                 console.log("mizar",mizarWidgetAPI);
                 */
                var layers = mizarWidgetAPI.mizarWidgetGui.activatedContext.layers;
                var foundIndex = -1;
                var foundLayer = null;
                for (var i = 0; ((i < layers.length) && (foundIndex < 0)); i++) {
                    if (layers[i].ID === gwLayer.ID) {
                        foundIndex = i;
                        foundLayer = layers[i];
                        //console.log("Found id = "+foundLayer.ID+" for i="+foundIndex);
                    }
                }
                // Place it at top of array
                if (foundIndex >= 1) {
                    // if foundIndex is zro, layer is still at top
                    for (var j = (foundIndex - 1); j >= 0; j--) {
                        layers[j + 1] = layers[j];
                    }
                    layers[0] = foundLayer;
                }
            }
            /*var shortName = UtilsCore.formatId(gwLayer.name);
             if (typeof shortName === 'string') {
             shortName = shortName.replace(/[^a-z0-9\s]/gi, '').replace(/[_\s]/gwLayer);, '-');
             }*/
            var shortName = gwLayer.getShortName();
            // Manage 'custom' checkbox
            // jQuery UI button is not sexy enough :)
            // Toggle some classes when the user clicks on the visibility checkbox
            if (gwLayer.subLayers) {
                AdditionalLayersCore.setSublayersVisibility(gwLayer, isOn);
            }

            var toolsDiv = $("#addLayer_" + shortName).find('.layerTools');
            $("#addLayer_" + shortName).find('.slider').slider(isOn ? "enable" : "disable");
            $("#addLayer_" + shortName).find('.sliderTime').slider(isOn ? "enable" : "disable");
            if (isOn) {
                $('.layerTools').slideUp();
                toolsDiv.slideDown();

                // Change button's state
                $('#visible_' + shortName).addClass('ui-state-active').removeClass('ui-state-default')
                    .find('span').addClass('ui-icon-check').removeClass('ui-icon-empty');
            }
            else {
                toolsDiv.slideUp();
                // Change button's state
                $('#visible_' + shortName).removeClass('ui-state-active').addClass('ui-state-default')
                    .find('span').removeClass('ui-icon-check').addClass('ui-icon-empty');
            }

            globe.refresh();
        }

        /**************************************************************************************************************/

        /**
         *    Show/hide layer tools depending on layer visibility
         *    Set visibility event handlers
         */
        function manageLayerVisibility($layerDiv, gwLayer, categoryId) {
            if (typeof gwLayer === 'undefined') {
                return;
            }
            /*var shortName = UtilsCore.formatId(gwLayer.name);
             if (typeof shortName === 'string') {
             shortName = shortName.replace(/[^a-z0-9\s]/gi, '').replace(/[_\s]/gwLayer);, '-');
             }*/
            var shortName = gwLayer.getShortName();
            // Open tools div when the user clicks on the layer label
            var toolsDiv = $layerDiv.find('.layerTools');
            $layerDiv.children('label').click(function () {
                toolsDiv.slideToggle(updateScroll.bind(this, categoryId));
            });

            if (gwLayer.isVisible()) {
                toolsDiv.slideDown();
            }
            if (shortName === "Atmosphere") {
                mizarWidgetAPI.getContext()._atmosphereLayer = gwLayer;
            }

            // Layer visibility management
            $layerDiv.find('#visible_' + shortName).click(function () {
                    var isOn = !$(this).hasClass('ui-state-active');
                    gwLayer.setVisible(isOn);
                
            });
        }

        /**************************************************************************************************************/

        /**
         *    Create the Html for addtionnal layer
         */
        function createHtmlForAdditionalLayer(gwLayer, categoryId) {
            if (typeof gwLayer === 'undefined' || (gwLayer.getType() === mizarWidgetAPI.LAYER.Vector && gwLayer.isDraw() )) {
                // returns when undefined or a draw such as selection, arrow to represent a distance, ... something which is not a data
                return;
            }
            /*var shortName = UtilsCore.formatId(gwLayer.name);
             if (typeof shortName === 'string') {
             shortName = shortName.replace(/[^a-z0-9\s]/gi, '').replace(/[_\s]/gwLayer);, '-');
             }
             */
            var layerDiv = AdditionalLayersCore.createHTMLFromTemplate(additionalLayerTemplate, gwLayer, gwLayer.getShortName(), isMobile);

            var $layerDiv = $(layerDiv)
                .appendTo('#' + categoryId)
                .data("layer", gwLayer);

            // Add legend
            addLegend($layerDiv, gwLayer);

            // Create UI of sliders
            initializeSliders($layerDiv, gwLayer);

            manageLayerVisibility($layerDiv, gwLayer, categoryId);

            updateButtonsUI($layerDiv);

            if (UtilsCore.isHipsFitsLayer(gwLayer) && !isMobile) {
                //createDynamicImageDialog(gwLayer);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Create HTML for the given layer
         */
        function addView(gwLayer) {
            if (gwLayer.linkedTo !== "" || gwLayer.type === "WCSElevation" || gwLayer.type === "WMSElevation" || gwLayer.type === "Moc") {
                // skip it
            } else {
                var category = gwLayer.category;
                // Other as default
                if (!category) {
                    category = 'Other';
                }

                // Create new category if doesn't exists
                var categoryId;
                if (!categories[category]) {
                    categoryId = UtilsCore.formatId(category);
                    $('<div class="category"><h3>' + category + '</h3>\
			<div id="' + categoryId + '"></div></div>')
                        .insertBefore($('#otherLayers').parent());

                    categories[category] = categoryId;

                    // Refresh accordion
                    $(parentElement).accordion("refresh");
                    // Add scroll to the new category
                    initNiceScroll(categoryId);
                }
                else {
                    categoryId = categories[category];
                    // If it's the first added layer, show the category
                    if ($('#' + categoryId + " .addLayer").length === 0) {
                        $('#' + categoryId).closest(".category").show();
                    }
                }

                // Add HTML
                createHtmlForAdditionalLayer(gwLayer, categoryId);

                gwLayer.subscribe(mizarWidgetAPI.EVENT_MSG.LAYER_VISIBILITY_CHANGED, onVisibilityChange);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Remove HTML view of the given layer
         *    Remove the category if the given layer is the last layer of category
         */
        function removeView(gwLayer) {
            if (typeof gwLayer === 'undefined') {
                return;
            }
            /*var shortName = UtilsCore.formatId(gwLayer.name);
             if (typeof shortName === 'string') {
             shortName = shortName.replace(/[^a-z0-9\s]/gi, '').replace(/[_\s]/gwLayer);, '-');
             }
             */
            var addLayerDiv = $(parentElement).find('#addLayer_' + gwLayer.getShortName());
            if (addLayerDiv.parent().children().length === 1) {
                // Last child to remove -> remove the category
                addLayerDiv.closest('.category').remove();
            } else {
                addLayerDiv.remove();
            }

            if (gwLayer.div) {
                $('#addFitsView_' + gwLayer.div.id).dialog("destroy").remove();
                gwLayer.div = null;
            }

            gwLayer.unsubscribe(mizarWidgetAPI.EVENT_MSG.LAYER_VISIBILITY_CHANGED, onVisibilityChange);
        }

        /**************************************************************************************************************/

        /**
         *    Delete layer handler
         */
        function deleteLayer() {
            $(this).parent().parent().fadeOut(300, function () {
                $(this).remove();
            });

            var layer = $(this).closest(".addLayer").data("layer");
            mizarWidgetAPI.removeLayer(layer.ID);

            updateScroll('otherLayers');
        }

        /**************************************************************************************************************/

        /**
         *    Go to open search next page
         */
        function nextPage() {
            var layer = $(this).closest(".addLayer").data("layer");
            if (layer !== null) {
                layer.nextPage();
            }
        }

        /**************************************************************************************************************/

        /**
         *    Show layer services popup
         */
        function showLayerServices() {
            var layer = $(this).closest(".addLayer").data("layer");
            LayerServiceView.show(layer);
        }

        /**************************************************************************************************************/

        /**
         *    Export the given layer by SAMP
         */
        function exportLayer() {
            if (Samp.isConnected()) {
                var layer = $(this).closest(".addLayer").data("layer");
                var url = AdditionalLayersCore.buildVisibleTilesUrl(layer);
                Samp.sendVOTable(layer, url);
            }
            else {
                ErrorDialog.open("You must be connected to SAMP Hub");
            }
        }

        /**************************************************************************************************************/

        /**
         *    Remove WMS linked layers
         */
        function removeWms() {
            var layer = $(this).closest(".addLayer").data("layer");
            layer.unloadAllWMS();
        }

        /**************************************************************************************************************/

        /**
         *    Download features on visible tiles of the given layer as VO table
         */
        function downloadAsVO() {
            var layer = $(this).closest(".addLayer").data("layer");
            var url = AdditionalLayersCore.buildVisibleTilesUrl(layer);
            url += "&media=votable";
            var posGeo = layer.globe.coordinateSystem.getWorldFrom3D(navigation.center3d);
            var astro = UtilsCore.formatCoordinates(posGeo);
            $(this).parent().attr('href', url)
                .attr('download', layer.name + "_" + astro[0] + '_' + astro[1]);
        }

        /**************************************************************************************************************/

        /**
         *    Zoom to barycenter of all features contained by layer
         *    (available for GlobWeb.VectorLayers only)
         */
        function zoomTo() {
            var layer = $(this).closest(".addLayer").data("layer");
            AdditionalLayersCore.zoomTo(layer);
        }

        /**************************************************************************************************************/

        /**
         *    Toggle layer to fits rendering
         */
        function toggleFits() {
            var isFits = $(this).is(':checked');
            var layer = $(this).closest(".addLayer").data("layer");
            layer.format = isFits ? 'fits' : 'jpg';
            if (!isFits) {
                $(this).nextAll('.addFitsView').button('disable');
            }

            // TODO: make reset function ?
            // layer.setFormat( format );

            var prevId = layer.ID;
            globe.removeLayer(layer);
            globe.addLayer(layer);

            // HACK : Layer id will be changed by remove/add so we need to change the html id
            $('#addLayer_' + prevId).attr('id', 'addLayer_' + layer.ID);
        }

        /**************************************************************************************************************/

        /**
         *    Initialize toolbar events
         */
        function registerEvents() {
            mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_START_LOAD, onLoadStart);
            mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_END_LOAD, onLoadEnd);

            $(parentElement)
                .on("click", '.category .deleteLayer', deleteLayer)
                .on('click', ".category .layerServices", showLayerServices)
                .on('click', ".category .exportLayer", exportLayer)
                .on('click', '.category .downloadAsVO', downloadAsVO)
                .on('click', '.removeWMS', removeWms)
                .on("click", ".category .zoomTo", zoomTo)
                .on('click', '.category .isFits', toggleFits)
                .on('click', '.category .osNext', nextPage);
        }

        /**************************************************************************************************************/

        /**
         *    Show spinner on layer loading
         */
        function onLoadStart(layer) {
            if (typeof layer === 'undefined') {
                return;
            }
            /*var shortName = UtilsCore.formatId(layer.name);
             if (typeof shortName === 'string') {
             shortName = shortName.replace(/[^a-z0-9\s]/gi, '').replace(/[_\s]/gwLayer);, '-');
             }
             */
            $('#addLayer_' + layer.getShortName()).find('.spinner').stop(true, true).fadeIn('fast');
        }

        /**************************************************************************************************************/

        /**
         *    Hide spinner when layer is loaded
         */
        function onLoadEnd(layer) {
            if (typeof layer === 'undefined') {
                return;
            }
            /*var shortName = UtilsCore.formatId(layer.name);
             if (typeof shortName === 'string') {
             shortName = shortName.replace(/[^a-z0-9\s]/gi, '').replace(/[_\s]/gwLayer);, '-');
             }
             */
            $('#addLayer_' + layer.getShortName()).find('.spinner').fadeOut(500);
        }

        /**************************************************************************************************************/

        return {
            /**
             *    Initialize additional layers view
             */
            init: function (options) {
                // Set some globals
                mizarWidgetAPI = options.mizar;
                globe = mizarWidgetAPI.getContext().globe;
                navigation = mizarWidgetAPI.getNavigation();
                isMobile = options.configuration.isMobile;
                configuration = options.configuration;

                AdditionalLayersCore.init(mizarWidgetAPI);

                // Append content to parent element
                parentElement = options.configuration.element;
                $(parentElement).append(additionalLayersHTML);

                // Select default coordinate system event
                $('#defaultCoordSystem').selectmenu({
                    select: function () {
                        var newCoordSystem = $(this).children('option:selected').val();
                        mizarWidgetAPI.setCrs({geoideName: newCoordSystem});
                    },
                    width: 100
                });

                registerEvents();
            },

            /**
             *    Unregister all event handlers
             */
            remove: function () {
                var self = this;
                $(parentElement).find(".addLayer").each(function () {
                    self.removeView($(this).data("layer"));
                });
                $(parentElement).find(".category").remove();

                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_START_LOAD, onLoadStart);
                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_END_LOAD, onLoadEnd);

                $(parentElement)
                    .off("click", '.category .deleteLayer', deleteLayer)
                    .off('click', ".category .layerServices", showLayerServices)
                    .off('click', ".category .exportLayer", exportLayer)
                    .off('click', '.category .downloadAsVO', downloadAsVO)
                    .off('click', '.featureService .removeWMS', removeWms)
                    .off("click", ".category .zoomTo", zoomTo)
                    .off('click', '.category .isFits', toggleFits)
                    .off('click', ".category .osNext", nextPage);

                // Remove all created dialogs
                var layers = mizarWidgetAPI.getLayers();
                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i];
                    if (layer.div) {
                        $('#addFitsViewDialog_' + layer.div.id).dialog("destroy").remove();
                    }
                }

                // Reinit categories
                categories = {
                    "Other": 'otherLayers',
                    "Coordinate systems": 'coordinateSystems'
                };

            },

            addView: addView,
            removeView: removeView,
            hideView: function (layer) {
                $('#addLayer_' + layer.getShortName()).hide();
            },
            showView: function (layer) {
                $('#addLayer_' + layer.getShortName()).show();
            }
        };

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Layer manager view module
 */
define('gui/LayerManagerView',["jquery", "underscore-min", "../utils/UtilsCore",
        "./dialog/ErrorDialog", "./LayerServiceView", "./BackgroundLayersView", "./AdditionalLayersView", "./ImageProcessing", "jquery.ui"],
    function ($, _, UtilsCore,
              ErrorDialog, LayerServiceView, BackgroundLayersView, AdditionalLayersView, ImageProcessing) {

        /**
         * Private variables
         */
        var mizarWidgetAPI;
        var configuration;

        // GeoJSON data providers
        var votable2geojsonBaseUrl;
        var parentElement;
        var $el;




        /**
         * Private functions
         */

        /**************************************************************************************************************/

        /**
         *    Drop event
         */
        function handleDrop(evt) {
            evt.stopPropagation();
            evt.preventDefault();
            $.event.props.push('dataTransfer');

            var files = evt.dataTransfer.files; // FileList object.

            // Files is a FileList of File objects.
            loadLayersFromFITSFile(files);
        }

        function loadLayersFromFITSFile(files) {
            $.each(files, function (index, f) {

                var name = f.name;
                var reader = new FileReader();
                $('#loading').show();

                if (f.type === "image/fits") {
                    // Handle fits image
                    reader.onloadend = function (e) {
                        var arrayBuffer = this.result;
                        var fits = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.FitsVisu).parseFits(arrayBuffer);

                        var gwLayer = mizarWidgetAPI.createLayerFromFits(name, fits);

                        // Add fits texture
                        var featureData = {
                            layer: gwLayer,
                            feature: gwLayer.features[0],
                            isFits: true
                        };
                        var fitsData = fits.getHDU().data;
                        mizarWidgetAPI.publish("image:added", featureData);

                        var image = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.FitsVisu).handleFits(fitsData, featureData);
                        ImageProcessing.setImage(image);

                        $('#loading').hide();
                    };
                    reader.readAsArrayBuffer(f);
                }
                else {
                    reader.onloadend = function (e) {
                        if (this.result.search('<?xml') > 0) {
                            // Handle xml votable
                            UtilsCore.convertVotable2JsonFromXML(this.result, function (response) {
                                var gwLayer = mizarWidgetAPI.addLayerByDragNDrop(name, response);
                                $('#loading').hide();
                            });
                        }
                        else {
                            // Handle as json if possible
                            var response;
                            //try {
                                response = $.parseJSON(this.result);
                                mizarWidgetAPI.addLayerByDragNDrop(name, response);
                                $('#loading').hide();
                            /*} catch (e) {
                                var message = (e.type) ? e.type : e;
                                ErrorDialog.open("JSON parsing error : " + message + "<br/> For more details see http://jsonlint.com/.");
                                $('#loading').hide();
                                return false;
                            }*/
                        }
                    };
                    reader.readAsText(f);
                }
            });
        }

        /**************************************************************************************************************/

        /**
         *    Drag over event
         */
        function handleDragOver(evt) {
            evt.stopPropagation();
            evt.preventDefault();
        }

        /**
         *    Drag enter event
         */
        function handleDragEnter(evt) {
            evt.stopPropagation();
            evt.preventDefault();
        }        

        /**************************************************************************************************************/

        /**
         *    Initialize view with layers stored in <LayerManager>
         */
        function initLayers(context) {
            mizarWidgetAPI.getMizarWidgetGui().setUpdatedActivatedContext(context);
            var sum=0;
            var layers = context.getLayers();

            // Add view depending on category of each layer
            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i];
                if (layer.isBackground()) {
                    BackgroundLayersView.addView(layer);
                } else {
                    AdditionalLayersView.addView(layer);
                }
            }
            //var backLayerSelect = $el.find('#backgroundLayersSelect');
            //if(backLayerSelect != null) {
            //    backLayerSelect.iconselectmenu("refresh");
            //}
        }

        return {

            /**
             *    Init
             *
             *    @param m
             *        Mizar API object
             *    @param conf
             *        Mizar configuration
             */
            init: function (widget, conf) {
                mizarWidgetAPI = widget;
                configuration = conf;
                parentElement = configuration.element;
                // Add invoker
                $('<input type="button" id="lmInvoker" />').appendTo(parentElement);
                $el = $('<div id="accordion" style="display: none;"></div>').appendTo(parentElement);
                configuration.element = $el;

                BackgroundLayersView.init({mizar: mizarWidgetAPI, configuration: configuration});
                AdditionalLayersView.init({mizar: mizarWidgetAPI, configuration: configuration});

                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_BACKGROUND_ADDED, BackgroundLayersView.addView);
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_ADDED, AdditionalLayersView.addView);
                mizarWidgetAPI.subscribeMizar(mizarWidgetAPI.EVENT_MSG.MIZAR_MODE_TOGGLE, this.toggleMode);

                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_UPDATE_STATS_ATTRIBUTES, this.updateStatsAttributes);
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_TOGGLE_WMS, this.toggleWMS);
                                    
                

                // Necessary to drag&drop option while using jQuery
                $.event.props.push('dataTransfer');

                // Due to scroll initialization which corrumps accordion UI init in additional layers view,
                // accordion UI must be initialized before
                $el.accordion({
                    header: "> div > h3",
                    autoHeight: false,
                    active: 0,
                    collapsible: true,
                    heightStyle: "content"
                }).show().accordion("refresh");

                LayerServiceView.init(mizarWidgetAPI, configuration);

                // Setup the drag & drop listeners.
                $('canvas').on('dragover', handleDragOver);
                $('canvas').on('dragenter', handleDragEnter);
                $('canvas').on('drop', handleDrop);

                // Layer manager invoker onclick animations
                $('#lmInvoker').click(function () {
                    if (parseFloat($(this).siblings('#accordion').css('left')) < 0) {
                        // Show layer manager
                        $(this).animate({left: '-10px'}, 300).addClass('selected');
                        $(this).siblings('#accordion').animate({left: '15px'}, 300);
                    }
                    else {
                        // Hide layer manager
                        $(this).animate({left: '0px'}, 300).removeClass('selected');
                        $(this).siblings('#accordion').animate({left: '-255px'}, 300);
                    }
                });

                if (!configuration.isMobile) {
                    $('#lmInvoker').trigger("click");
                }

                if (configuration.votable2geojson) {
                    votable2geojsonBaseUrl = configuration.votable2geojson.baseUrl;
                }
            },
            updateStatsAttributes: function(options) {                
                // if (typeof options.nb_loaded !== "undefined") {
                //     $(".labelLoaded_"+options.shortName)[0].innerText = "loaded : "+ options.nb_loaded;
                // }
                // if (typeof options.nb_total !== "undefined") {
                //     $(".labelTotal_"+options.shortName)[0].innerText = "total : ~ "+ options.nb_total;
                // }
                if (typeof options.page !== "undefined") {
                    $(".labelPage_"+options.shortName)[0].innerText = "Page "+options.page;
                }
            },
            toggleWMS: function(options) {
                if ( (typeof options.layer_name !== "undefined") && (typeof options.visible !== "undefined") ) {
                    $(".QLWMS_"+options.layer_name)[0].style = (options.visible === true) ? "display:inline" : "display:none";
                }
            },
            refresh: function() {
                $el.find('#backgroundLayersSelect').iconselectmenu("refresh");
            },
            /**
             *    Unregister all event handlers and remove view
             */
            remove: function () {
                AdditionalLayersView.remove();
                BackgroundLayersView.remove();
                LayerServiceView.remove();
                $(parentElement).empty();

                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_BACKGROUND_ADDED, BackgroundLayersView.addView);
                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_ADDED, AdditionalLayersView.addView);
                mizarWidgetAPI.unsubscribeMizar(mizarWidgetAPI.EVENT_MSG.MIZAR_MODE_TOGGLE, this.toggleMode);

                $('canvas').off('dragover', handleDragOver);
                $('canvas').off('dragenter', handleDragEnter);
                $('canvas').off('drop', handleDrop);
            },

            /**
             *    Update view depending on mizar mode
             *
             *    @param context
             */
            toggleMode: function (context) {
                BackgroundLayersView.remove();
                AdditionalLayersView.remove();
                BackgroundLayersView.init({mizar: mizarWidgetAPI, configuration: configuration});
                AdditionalLayersView.init({mizar: mizarWidgetAPI, configuration: configuration});
                initLayers(context);
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_BACKGROUND_ADDED, BackgroundLayersView.addView);
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_ADDED, AdditionalLayersView.addView);
                $el.accordion("option", "active", 0).accordion("refresh");
            },

            /**
             *    Returns the state of view
             */
            isInitialized: function () {
                return mizarWidgetAPI ? true : false;
            }
        };

    });


define('text!templates/nameResolverResult.html',[],function () { return '<% if (properties.type == "layer") { %>\n    <% if (first) { %>\n    <div class="firstNameResolverResult"><hr/><span>Layers</span><hr/></div>\n    <% }%>\n    <div class="layerResolverResult" mizar_feature_index="<%= index %>">\n        <div class="nameResolverResult">\n            <em>Type:</em> <%= properties.layerType %><br/>\n            <em>Name:</em> <%= properties.name %><br/>\n            <% if(properties.description) { %>\n                <span title="<%= properties.description %>"><em>Description:</em><% var String=require(\'string\');  print (String(properties.description).truncate(50).s) %></span><br/>\n            <% } %>\n        </div>\n        <button class="show_or_hide"><span>Show</span></button>\n    </div>\n<% } %>\n<% if (properties.type != "layer") {%>\n    <% if (first) { %>\n    <div class="firstNameResolverResult"><hr/><span>Objects</span><hr/></div>\n    <% }%>\n    <div class="nameResolverResult coordinatesResolverResult" mizar_feature_index="<%= index %>">\n        <% if (properties.type) { %>\n            <em>Type:</em> <%= properties.type %><br/>\n        <% } %>\n        <em>Name: </em><%= properties.name %><br/>\n        <em><% (type == "Sky") ? print("RA: ") : print("Longitude: ") %></em><%= lon %><br/>\n        <em><% (type == "Sky") ? print("Dec: ") : print("Latitude: ") %></em><%= lat %><br/>\n        <div class="credits"><%= properties.credits %></div>\n    </div>\n<% } %>\n';});

/*!
 * jQuery Once v2.2.1 - http://github.com/robloach/jquery-once
 * @license MIT, GPL-2.0
 *   http://opensource.org/licenses/MIT
 *   http://opensource.org/licenses/GPL-2.0
 */
(function(e){"use strict";if(typeof exports==="object"){e(require("jquery"))}else if(typeof define==="function"&&define.amd){define('jquery.once',["jquery"],e)}else{e(jQuery)}})(function(t){"use strict";var r=function(e){e=e||"once";if(typeof e!=="string"){throw new TypeError("The jQuery Once id parameter must be a string")}return e};t.fn.once=function(e){var n="jquery-once-"+r(e);return this.filter(function(){return t(this).data(n)!==true}).data(n,true)};t.fn.removeOnce=function(e){return this.findOnce(e).removeData("jquery-once-"+r(e))};t.fn.findOnce=function(e){var n="jquery-once-"+r(e);return this.filter(function(){return t(this).data(n)===true})}});
//# sourceMappingURL=jquery.once.min.js.map;
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define('string',e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.S=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(_dereq_,module,exports){function count(self,substr){var count=0;var pos=self.indexOf(substr);while(pos>=0){count+=1;pos=self.indexOf(substr,pos+1)}return count}module.exports=count},{}],2:[function(_dereq_,module,exports){function splitLeft(self,sep,maxSplit,limit){if(typeof maxSplit==="undefined"){var maxSplit=-1}var splitResult=self.split(sep);var splitPart1=splitResult.slice(0,maxSplit);var splitPart2=splitResult.slice(maxSplit);if(splitPart2.length===0){splitResult=splitPart1}else{splitResult=splitPart1.concat(splitPart2.join(sep))}if(typeof limit==="undefined"){return splitResult}else if(limit<0){return splitResult.slice(limit)}else{return splitResult.slice(0,limit)}}module.exports=splitLeft},{}],3:[function(_dereq_,module,exports){function splitRight(self,sep,maxSplit,limit){if(typeof maxSplit==="undefined"){var maxSplit=-1}if(typeof limit==="undefined"){var limit=0}var splitResult=[self];for(var i=self.length-1;i>=0;i--){if(splitResult[0].slice(i).indexOf(sep)===0&&(splitResult.length<=maxSplit||maxSplit===-1)){splitResult.splice(1,0,splitResult[0].slice(i+sep.length));splitResult[0]=splitResult[0].slice(0,i)}}if(limit>=0){return splitResult.slice(-limit)}else{return splitResult.slice(0,-limit)}}module.exports=splitRight},{}],4:[function(_dereq_,module,exports){!function(){"use strict";var VERSION="3.3.3";var ENTITIES={};var latin_map={"":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"AA","":"AE","":"AE","":"AE","":"AO","":"AU","":"AV","":"AV","":"AY","":"B","":"B","":"B","":"B","":"B","":"B","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"DZ","":"DZ","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"ET","":"F","":"F","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"D","":"F","":"G","":"R","":"S","":"T","":"IS","":"J","":"J","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"LJ","":"M","":"M","":"M","":"M","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"NJ","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"OI","":"OO","":"E","":"O","":"OU","":"P","":"P","":"P","":"P","":"P","":"P","":"P","":"Q","":"Q","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"C","":"E","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"SS","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"A","":"L","":"M","":"V","":"TZ","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"V","":"V","":"V","":"V","":"VY","":"W","":"W","":"W","":"W","":"W","":"W","":"W","":"X","":"X","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"IJ","":"OE","":"A","":"AE","":"B","":"B","":"C","":"D","":"E","":"F","":"G","":"G","":"H","":"I","":"R","":"J","":"K","":"L","":"L","":"M","":"N","":"O","":"OE","":"O","":"OU","":"P","":"R","":"N","":"R","":"S","":"T","":"E","":"R","":"U","":"V","":"W","":"Y","":"Z","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"aa","":"ae","":"ae","":"ae","":"ao","":"au","":"av","":"av","":"ay","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"o","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"i","":"j","":"j","":"j","":"dz","":"dz","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"et","":"f","":"f","":"f","":"f","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"hv","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"d","":"f","":"g","":"r","":"s","":"t","":"is","":"j","":"j","":"j","":"j","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"lj","":"s","":"s","":"s","":"s","":"m","":"m","":"m","":"m","":"m","":"m","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"nj","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"oi","":"oo","":"e","":"e","":"o","":"o","":"ou","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"q","":"q","":"q","":"q","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"c","":"c","":"e","":"r","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"g","":"ss","":"o","":"o","":"u","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"th","":"a","":"ae","":"e","":"g","":"h","":"h","":"h","":"i","":"k","":"l","":"m","":"m","":"oe","":"r","":"r","":"r","":"r","":"t","":"v","":"w","":"y","":"tz","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"ue","":"um","":"v","":"v","":"v","":"v","":"v","":"v","":"v","":"vy","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"x","":"x","":"x","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"ff","":"ffi","":"ffl","":"fi","":"fl","":"ij","":"oe","":"st","":"a","":"e","":"i","":"j","":"o","":"r","":"u","":"v","":"x"};function initialize(object,s){if(s!==null&&s!==undefined){if(typeof s==="string")object.s=s;else object.s=s.toString()}else{object.s=s}object.orig=s;if(s!==null&&s!==undefined){if(object.__defineGetter__){object.__defineGetter__("length",function(){return object.s.length})}else{object.length=s.length}}else{object.length=-1}}function S(s){initialize(this,s)}var __nsp=String.prototype;var __sp=S.prototype={between:function(left,right){var s=this.s;var startPos=s.indexOf(left);var endPos=s.indexOf(right,startPos+left.length);if(endPos==-1&&right!=null)return new this.constructor("");else if(endPos==-1&&right==null)return new this.constructor(s.substring(startPos+left.length));else return new this.constructor(s.slice(startPos+left.length,endPos))},camelize:function(){var s=this.trim().s.replace(/(\-|_|\s)+(.)?/g,function(mathc,sep,c){return c?c.toUpperCase():""});return new this.constructor(s)},capitalize:function(){return new this.constructor(this.s.substr(0,1).toUpperCase()+this.s.substring(1).toLowerCase())},charAt:function(index){return this.s.charAt(index)},chompLeft:function(prefix){var s=this.s;if(s.indexOf(prefix)===0){s=s.slice(prefix.length);return new this.constructor(s)}else{return this}},chompRight:function(suffix){if(this.endsWith(suffix)){var s=this.s;s=s.slice(0,s.length-suffix.length);return new this.constructor(s)}else{return this}},collapseWhitespace:function(){var s=this.s.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"");return new this.constructor(s)},contains:function(ss){return this.s.indexOf(ss)>=0},count:function(ss){return _dereq_("./_count")(this.s,ss)},dasherize:function(){var s=this.trim().s.replace(/[_\s]+/g,"-").replace(/([A-Z])/g,"-$1").replace(/-+/g,"-").toLowerCase();return new this.constructor(s)},equalsIgnoreCase:function(prefix){var s=this.s;return s.toLowerCase()==prefix.toLowerCase()},latinise:function(){var s=this.replace(/[^A-Za-z0-9\[\] ]/g,function(x){return latin_map[x]||x});return new this.constructor(s)},decodeHtmlEntities:function(){var s=this.s;s=s.replace(/&#(\d+);?/g,function(_,code){return String.fromCharCode(code)}).replace(/&#[xX]([A-Fa-f0-9]+);?/g,function(_,hex){return String.fromCharCode(parseInt(hex,16))}).replace(/&([^;\W]+;?)/g,function(m,e){var ee=e.replace(/;$/,"");var target=ENTITIES[e]||e.match(/;$/)&&ENTITIES[ee];if(typeof target==="number"){return String.fromCharCode(target)}else if(typeof target==="string"){return target}else{return m}});return new this.constructor(s)},endsWith:function(){var suffixes=Array.prototype.slice.call(arguments,0);for(var i=0;i<suffixes.length;++i){var l=this.s.length-suffixes[i].length;if(l>=0&&this.s.indexOf(suffixes[i],l)===l)return true}return false},escapeHTML:function(){return new this.constructor(this.s.replace(/[&<>"']/g,function(m){return"&"+reversedEscapeChars[m]+";"}))},ensureLeft:function(prefix){var s=this.s;if(s.indexOf(prefix)===0){return this}else{return new this.constructor(prefix+s)}},ensureRight:function(suffix){var s=this.s;if(this.endsWith(suffix)){return this}else{return new this.constructor(s+suffix)}},humanize:function(){if(this.s===null||this.s===undefined)return new this.constructor("");var s=this.underscore().replace(/_id$/,"").replace(/_/g," ").trim().capitalize();return new this.constructor(s)},isAlpha:function(){return!/[^a-z\xDF-\xFF]|^$/.test(this.s.toLowerCase())},isAlphaNumeric:function(){return!/[^0-9a-z\xDF-\xFF]/.test(this.s.toLowerCase())},isEmpty:function(){return this.s===null||this.s===undefined?true:/^[\s\xa0]*$/.test(this.s)},isLower:function(){return this.isAlpha()&&this.s.toLowerCase()===this.s},isNumeric:function(){return!/[^0-9]/.test(this.s)},isUpper:function(){return this.isAlpha()&&this.s.toUpperCase()===this.s},left:function(N){if(N>=0){var s=this.s.substr(0,N);return new this.constructor(s)}else{return this.right(-N)}},lines:function(){return this.replaceAll("\r\n","\n").s.split("\n")},pad:function(len,ch){if(ch==null)ch=" ";if(this.s.length>=len)return new this.constructor(this.s);len=len-this.s.length;var left=Array(Math.ceil(len/2)+1).join(ch);var right=Array(Math.floor(len/2)+1).join(ch);return new this.constructor(left+this.s+right)},padLeft:function(len,ch){if(ch==null)ch=" ";if(this.s.length>=len)return new this.constructor(this.s);return new this.constructor(Array(len-this.s.length+1).join(ch)+this.s)},padRight:function(len,ch){if(ch==null)ch=" ";if(this.s.length>=len)return new this.constructor(this.s);return new this.constructor(this.s+Array(len-this.s.length+1).join(ch))},parseCSV:function(delimiter,qualifier,escape,lineDelimiter){delimiter=delimiter||",";escape=escape||"\\";if(typeof qualifier=="undefined")qualifier='"';var i=0,fieldBuffer=[],fields=[],len=this.s.length,inField=false,inUnqualifiedString=false,self=this;var ca=function(i){return self.s.charAt(i)};if(typeof lineDelimiter!=="undefined")var rows=[];if(!qualifier)inField=true;while(i<len){var current=ca(i);switch(current){case escape:if(inField&&(escape!==qualifier||ca(i+1)===qualifier)){i+=1;fieldBuffer.push(ca(i));break}if(escape!==qualifier)break;case qualifier:inField=!inField;break;case delimiter:if(inUnqualifiedString){inField=false;inUnqualifiedString=false}if(inField&&qualifier)fieldBuffer.push(current);else{fields.push(fieldBuffer.join(""));fieldBuffer.length=0}break;case lineDelimiter:if(inUnqualifiedString){inField=false;inUnqualifiedString=false;fields.push(fieldBuffer.join(""));rows.push(fields);fields=[];fieldBuffer.length=0}else if(inField){fieldBuffer.push(current)}else{if(rows){fields.push(fieldBuffer.join(""));rows.push(fields);fields=[];fieldBuffer.length=0}}break;case" ":if(inField)fieldBuffer.push(current);break;default:if(inField)fieldBuffer.push(current);else if(current!==qualifier){fieldBuffer.push(current);inField=true;inUnqualifiedString=true}break}i+=1}fields.push(fieldBuffer.join(""));if(rows){rows.push(fields);return rows}return fields},replaceAll:function(ss,r){var s=this.s.split(ss).join(r);return new this.constructor(s)},splitLeft:function(sep,maxSplit,limit){return _dereq_("./_splitLeft")(this.s,sep,maxSplit,limit)},splitRight:function(sep,maxSplit,limit){return _dereq_("./_splitRight")(this.s,sep,maxSplit,limit)},strip:function(){var ss=this.s;for(var i=0,n=arguments.length;i<n;i++){ss=ss.split(arguments[i]).join("")}return new this.constructor(ss)},stripLeft:function(chars){var regex;var pattern;var ss=ensureString(this.s);if(chars===undefined){pattern=/^\s+/g}else{regex=escapeRegExp(chars);pattern=new RegExp("^["+regex+"]+","g")}return new this.constructor(ss.replace(pattern,""))},stripRight:function(chars){var regex;var pattern;var ss=ensureString(this.s);if(chars===undefined){pattern=/\s+$/g}else{regex=escapeRegExp(chars);pattern=new RegExp("["+regex+"]+$","g")}return new this.constructor(ss.replace(pattern,""))},right:function(N){if(N>=0){var s=this.s.substr(this.s.length-N,N);return new this.constructor(s)}else{return this.left(-N)}},setValue:function(s){initialize(this,s);return this},slugify:function(){var sl=new S(new S(this.s).latinise().s.replace(/[^\w\s-]/g,"").toLowerCase()).dasherize().s;if(sl.charAt(0)==="-")sl=sl.substr(1);return new this.constructor(sl)},startsWith:function(){var prefixes=Array.prototype.slice.call(arguments,0);for(var i=0;i<prefixes.length;++i){if(this.s.lastIndexOf(prefixes[i],0)===0)return true}return false},stripPunctuation:function(){return new this.constructor(this.s.replace(/[^\w\s]|_/g,"").replace(/\s+/g," "))},stripTags:function(){var s=this.s,args=arguments.length>0?arguments:[""];multiArgs(args,function(tag){s=s.replace(RegExp("</?"+tag+"[^<>]*>","gi"),"")});return new this.constructor(s)},template:function(values,opening,closing){var s=this.s;var opening=opening||Export.TMPL_OPEN;var closing=closing||Export.TMPL_CLOSE;var open=opening.replace(/[-[\]()*\s]/g,"\\$&").replace(/\$/g,"\\$");var close=closing.replace(/[-[\]()*\s]/g,"\\$&").replace(/\$/g,"\\$");var r=new RegExp(open+"(.+?)"+close,"g");var matches=s.match(r)||[];matches.forEach(function(match){var key=match.substring(opening.length,match.length-closing.length).trim();var value=typeof values[key]=="undefined"?"":values[key];s=s.replace(match,value)});return new this.constructor(s)},times:function(n){return new this.constructor(new Array(n+1).join(this.s))},titleCase:function(){var s=this.s;if(s){s=s.replace(/(^[a-z]| [a-z]|-[a-z]|_[a-z])/g,function($1){return $1.toUpperCase()})}return new this.constructor(s)},toBoolean:function(){if(typeof this.orig==="string"){var s=this.s.toLowerCase();return s==="true"||s==="yes"||s==="on"||s==="1"}else return this.orig===true||this.orig===1},toFloat:function(precision){var num=parseFloat(this.s);if(precision)return parseFloat(num.toFixed(precision));else return num},toInt:function(){return/^\s*-?0x/i.test(this.s)?parseInt(this.s,16):parseInt(this.s,10)},trim:function(){var s;if(typeof __nsp.trim==="undefined")s=this.s.replace(/(^\s*|\s*$)/g,"");else s=this.s.trim();return new this.constructor(s)},trimLeft:function(){var s;if(__nsp.trimLeft)s=this.s.trimLeft();else s=this.s.replace(/(^\s*)/g,"");return new this.constructor(s)},trimRight:function(){var s;if(__nsp.trimRight)s=this.s.trimRight();else s=this.s.replace(/\s+$/,"");return new this.constructor(s)},truncate:function(length,pruneStr){var str=this.s;length=~~length;pruneStr=pruneStr||"...";if(str.length<=length)return new this.constructor(str);var tmpl=function(c){return c.toUpperCase()!==c.toLowerCase()?"A":" "},template=str.slice(0,length+1).replace(/.(?=\W*\w*$)/g,tmpl);if(template.slice(template.length-2).match(/\w\w/))template=template.replace(/\s*\S+$/,"");else template=new S(template.slice(0,template.length-1)).trimRight().s;return(template+pruneStr).length>str.length?new S(str):new S(str.slice(0,template.length)+pruneStr)},toCSV:function(){var delim=",",qualifier='"',escape="\\",encloseNumbers=true,keys=false;var dataArray=[];function hasVal(it){return it!==null&&it!==""}if(typeof arguments[0]==="object"){delim=arguments[0].delimiter||delim;delim=arguments[0].separator||delim;qualifier=arguments[0].qualifier||qualifier;encloseNumbers=!!arguments[0].encloseNumbers;escape=arguments[0].escape||escape;keys=!!arguments[0].keys}else if(typeof arguments[0]==="string"){delim=arguments[0]}if(typeof arguments[1]==="string")qualifier=arguments[1];if(arguments[1]===null)qualifier=null;if(this.orig instanceof Array)dataArray=this.orig;else{for(var key in this.orig)if(this.orig.hasOwnProperty(key))if(keys)dataArray.push(key);else dataArray.push(this.orig[key])}var rep=escape+qualifier;var buildString=[];for(var i=0;i<dataArray.length;++i){var shouldQualify=hasVal(qualifier);if(typeof dataArray[i]=="number")shouldQualify&=encloseNumbers;if(shouldQualify)buildString.push(qualifier);if(dataArray[i]!==null&&dataArray[i]!==undefined){var d=new S(dataArray[i]).replaceAll(qualifier,rep).s;buildString.push(d)}else buildString.push("");if(shouldQualify)buildString.push(qualifier);if(delim)buildString.push(delim)}buildString.length=buildString.length-1;return new this.constructor(buildString.join(""))},toString:function(){return this.s},underscore:function(){var s=this.trim().s.replace(/([a-z\d])([A-Z]+)/g,"$1_$2").replace(/([A-Z\d]+)([A-Z][a-z])/g,"$1_$2").replace(/[-\s]+/g,"_").toLowerCase();return new this.constructor(s)},unescapeHTML:function(){return new this.constructor(this.s.replace(/\&([^;]+);/g,function(entity,entityCode){var match;if(entityCode in escapeChars){return escapeChars[entityCode]}else if(match=entityCode.match(/^#x([\da-fA-F]+)$/)){return String.fromCharCode(parseInt(match[1],16))}else if(match=entityCode.match(/^#(\d+)$/)){return String.fromCharCode(~~match[1])}else{return entity}}))},valueOf:function(){return this.s.valueOf()},wrapHTML:function(tagName,tagAttrs){var s=this.s,el=tagName==null?"span":tagName,elAttr="",wrapped="";if(typeof tagAttrs=="object")for(var prop in tagAttrs)elAttr+=" "+prop+'="'+new this.constructor(tagAttrs[prop]).escapeHTML()+'"';s=wrapped.concat("<",el,elAttr,">",this,"</",el,">");return new this.constructor(s)}};var methodsAdded=[];function extendPrototype(){for(var name in __sp){(function(name){var func=__sp[name];if(!__nsp.hasOwnProperty(name)){methodsAdded.push(name);__nsp[name]=function(){String.prototype.s=this;return func.apply(this,arguments)}}})(name)}}function restorePrototype(){for(var i=0;i<methodsAdded.length;++i)delete String.prototype[methodsAdded[i]];methodsAdded.length=0}var nativeProperties=getNativeStringProperties();for(var name in nativeProperties){(function(name){var stringProp=__nsp[name];if(typeof stringProp=="function"){if(!__sp[name]){if(nativeProperties[name]==="string"){__sp[name]=function(){return new this.constructor(stringProp.apply(this,arguments))}}else{__sp[name]=stringProp}}}})(name)}__sp.repeat=__sp.times;__sp.include=__sp.contains;__sp.toInteger=__sp.toInt;__sp.toBool=__sp.toBoolean;__sp.decodeHTMLEntities=__sp.decodeHtmlEntities;__sp.constructor=S;function getNativeStringProperties(){var names=getNativeStringPropertyNames();var retObj={};for(var i=0;i<names.length;++i){var name=names[i];if(name==="to"||name==="toEnd")continue;var func=__nsp[name];try{var type=typeof func.apply("teststring");retObj[name]=type}catch(e){}}return retObj}function getNativeStringPropertyNames(){var results=[];if(Object.getOwnPropertyNames){results=Object.getOwnPropertyNames(__nsp);results.splice(results.indexOf("valueOf"),1);results.splice(results.indexOf("toString"),1);return results}else{var stringNames={};var objectNames=[];for(var name in String.prototype)stringNames[name]=name;for(var name in Object.prototype)delete stringNames[name];for(var name in stringNames){results.push(name)}return results}}function Export(str){return new S(str)}Export.extendPrototype=extendPrototype;Export.restorePrototype=restorePrototype;Export.VERSION=VERSION;Export.TMPL_OPEN="{{";Export.TMPL_CLOSE="}}";Export.ENTITIES=ENTITIES;if(typeof module!=="undefined"&&typeof module.exports!=="undefined"){module.exports=Export}else{if(typeof define==="function"&&define.amd){define([],function(){return Export})}else{window.S=Export}}function multiArgs(args,fn){var result=[],i;for(i=0;i<args.length;i++){result.push(args[i]);if(fn)fn.call(args,args[i],i)}return result}var escapeChars={lt:"<",gt:">",quot:'"',apos:"'",amp:"&"};function escapeRegExp(s){var c;var i;var ret=[];var re=/^[A-Za-z0-9]+$/;s=ensureString(s);for(i=0;i<s.length;++i){c=s.charAt(i);if(re.test(c)){ret.push(c)}else{if(c==="\\000"){ret.push("\\000")}else{ret.push("\\"+c)}}}return ret.join("")}function ensureString(string){return string==null?"":""+string}var reversedEscapeChars={};for(var key in escapeChars){reversedEscapeChars[escapeChars[key]]=key}ENTITIES={amp:"&",gt:">",lt:"<",quot:'"',apos:"'",AElig:198,Aacute:193,Acirc:194,Agrave:192,Aring:197,Atilde:195,Auml:196,Ccedil:199,ETH:208,Eacute:201,Ecirc:202,Egrave:200,Euml:203,Iacute:205,Icirc:206,Igrave:204,Iuml:207,Ntilde:209,Oacute:211,Ocirc:212,Ograve:210,Oslash:216,Otilde:213,Ouml:214,THORN:222,Uacute:218,Ucirc:219,Ugrave:217,Uuml:220,Yacute:221,aacute:225,acirc:226,aelig:230,agrave:224,aring:229,atilde:227,auml:228,ccedil:231,eacute:233,ecirc:234,egrave:232,eth:240,euml:235,iacute:237,icirc:238,igrave:236,iuml:239,ntilde:241,oacute:243,ocirc:244,ograve:242,oslash:248,otilde:245,ouml:246,szlig:223,thorn:254,uacute:250,ucirc:251,ugrave:249,uuml:252,yacute:253,yuml:255,copy:169,reg:174,nbsp:160,iexcl:161,cent:162,pound:163,curren:164,yen:165,brvbar:166,sect:167,uml:168,ordf:170,laquo:171,not:172,shy:173,macr:175,deg:176,plusmn:177,sup1:185,sup2:178,sup3:179,acute:180,micro:181,para:182,middot:183,cedil:184,ordm:186,raquo:187,frac14:188,frac12:189,frac34:190,iquest:191,times:215,divide:247,"OElig;":338,"oelig;":339,"Scaron;":352,"scaron;":353,"Yuml;":376,"fnof;":402,"circ;":710,"tilde;":732,"Alpha;":913,"Beta;":914,"Gamma;":915,"Delta;":916,"Epsilon;":917,"Zeta;":918,"Eta;":919,"Theta;":920,"Iota;":921,"Kappa;":922,"Lambda;":923,"Mu;":924,"Nu;":925,"Xi;":926,"Omicron;":927,"Pi;":928,"Rho;":929,"Sigma;":931,"Tau;":932,"Upsilon;":933,"Phi;":934,"Chi;":935,"Psi;":936,"Omega;":937,"alpha;":945,"beta;":946,"gamma;":947,"delta;":948,"epsilon;":949,"zeta;":950,"eta;":951,"theta;":952,"iota;":953,"kappa;":954,"lambda;":955,"mu;":956,"nu;":957,"xi;":958,"omicron;":959,"pi;":960,"rho;":961,"sigmaf;":962,"sigma;":963,"tau;":964,"upsilon;":965,"phi;":966,"chi;":967,"psi;":968,"omega;":969,"thetasym;":977,"upsih;":978,"piv;":982,"ensp;":8194,"emsp;":8195,"thinsp;":8201,"zwnj;":8204,"zwj;":8205,"lrm;":8206,"rlm;":8207,"ndash;":8211,"mdash;":8212,"lsquo;":8216,"rsquo;":8217,"sbquo;":8218,"ldquo;":8220,"rdquo;":8221,"bdquo;":8222,"dagger;":8224,"Dagger;":8225,"bull;":8226,"hellip;":8230,"permil;":8240,"prime;":8242,"Prime;":8243,"lsaquo;":8249,"rsaquo;":8250,"oline;":8254,"frasl;":8260,"euro;":8364,"image;":8465,"weierp;":8472,"real;":8476,"trade;":8482,"alefsym;":8501,"larr;":8592,"uarr;":8593,"rarr;":8594,"darr;":8595,"harr;":8596,"crarr;":8629,"lArr;":8656,"uArr;":8657,"rArr;":8658,"dArr;":8659,"hArr;":8660,"forall;":8704,"part;":8706,"exist;":8707,"empty;":8709,"nabla;":8711,"isin;":8712,"notin;":8713,"ni;":8715,"prod;":8719,"sum;":8721,"minus;":8722,"lowast;":8727,"radic;":8730,"prop;":8733,"infin;":8734,"ang;":8736,"and;":8743,"or;":8744,"cap;":8745,"cup;":8746,"int;":8747,"there4;":8756,"sim;":8764,"cong;":8773,"asymp;":8776,"ne;":8800,"equiv;":8801,"le;":8804,"ge;":8805,"sub;":8834,"sup;":8835,"nsub;":8836,"sube;":8838,"supe;":8839,"oplus;":8853,"otimes;":8855,"perp;":8869,"sdot;":8901,"lceil;":8968,"rceil;":8969,"lfloor;":8970,"rfloor;":8971,"lang;":9001,"rang;":9002,"loz;":9674,"spades;":9824,"clubs;":9827,"hearts;":9829,"diams;":9830}}.call(this)},{"./_count":1,"./_splitLeft":2,"./_splitRight":3}]},{},[4])(4)});
/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Name resolver module : search object name and zoom to them
 */
define('gui/NameResolverView',["jquery", "underscore-min","../utils/UtilsCore",
        "text!templates/nameResolverResult.html", "jquery.ui", "jquery.once","string"],
    function ($, _, UtilsCore,
              nameResolverResultHTMLTemplate) {

        var nameResolverHTML = '<form id="searchForm">\
				<fieldset>\
					<div class="searchInputDiv">\
						<input title="Enter an object name (e.g. m31) or coordinate (e.g 23h45m30.5s -45&#186;30\'30&rdquo;)" type="text" name="searchInput" id="searchInput" value="Object name or coordinates" />\
					</div>\
					<input type="submit" id="searchSubmit" value="" />\
					<div style="display: none" id="searchSpinner"></div>\
					<input type="button" id="searchClear" value="" style="display: none;"/>\
				</fieldset>\
			</form>\
			<div style="display: none" id="resolverSearchResult"></div>';


// Template generating the list of selected features
        var nameResolverResultTemplate = _.template(nameResolverResultHTMLTemplate);

// jQuery selectors
        var $nameResolver;
        var $input;
        var $clear;
        var $resolverSearchResult;

// Name resolver globals
        var response;
        var animationDuration = 300;
        var mizarWidgetAPI;
        var NameResolver;
        var self;


        /**************************************************************************************************************/

        /**
         *    Stylized focus effect on input
         */
        function _focusInput() {
            var defaultText = $input.attr("value");
            if ($input.val() === defaultText) {
                $input.val('');
            }

            $(this).animate({color: '#000'}, animationDuration).parent().animate({backgroundColor: '#fff'}, animationDuration, function () {
                if (!($input.val() === '' || $input.val() === defaultText)) {
                    $clear.fadeIn(animationDuration);
                }
            }).addClass('focus');
        }

        /**************************************************************************************************************/

        /**
         *    Stylized blur effect on input
         */
        function _blurInput(event) {
            var defaultText = $input.attr("value");
            $(this).animate({color: '#b4bdc4'}, animationDuration, function () {
                if ($input.val() === '') {
                    $input.val(defaultText)
                }
            }).parent().animate({backgroundColor: '#e8edf1'}, animationDuration).removeClass('focus');
        }

        /**************************************************************************************************************/

        /**
         *    Toggle visibility of clear button
         *    Designed to clear text in search input
         */
        function _toggleClear() {
            if ($input.val() === '') {
                $clear.fadeOut(animationDuration);
            } else {
                $clear.fadeIn(animationDuration);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Show found results
         */
        function _showResults(data) {
            if (data) {
                response = data;
                // Fill search result field
                var output = "";
                var layers = false;
                var firstLayer = true;
                var firstObject = true;
                for (var i = 0; i < response.features.length; i++) {
                    if(response.features[i].properties.type == "layer") {
                        layers = true;
                        output += nameResolverResultTemplate({
                            first : firstLayer,
                            properties: response.features[i].properties,
                            lon: 0,
                            lat: 0,
                            type: mizarWidgetAPI.getCrs().getType(),
                            index : i
                        });
                        firstLayer = false;
                    } else {
                        var astro = mizarWidgetAPI.getCrs().formatCoordinates([response.features[i].geometry.coordinates[0], response.features[i].geometry.coordinates[1]]);
                        output += nameResolverResultTemplate({
                            first: firstObject,
                            properties: response.features[i].properties,
                            lon: astro[0],
                            lat: astro[1],
                            type: mizarWidgetAPI.getCrs().getType(),
                            index : i
                        });
                        firstObject = false;
                    }
                }

                // Show it
                $resolverSearchResult.html(output).fadeIn(animationDuration);
                if(!layers) {
                    $resolverSearchResult.find('div:nth-child(2)').addClass('selected');
                }

            }
            $nameResolver.find("#searchSpinner").fadeOut(animationDuration);
            $clear.fadeIn(animationDuration);
        }

        /**************************************************************************************************************/

        /**
         *    Show error message
         */
        function _showError() {
            $resolverSearchResult
                .html("<div class='errorNameResolver'>Bad input or object not found</div>")
                .fadeIn(0);

            $nameResolver.find("#searchSpinner").fadeOut(animationDuration).end();
            $clear.fadeIn(animationDuration);
        }

        /**
         *    Show error message
         */
        function _showErrorOutOfBound() {
            $resolverSearchResult
                .html("<div class='errorNameResolver'>Bad input parameters (coordinates out of extent)</div>")
                .fadeIn(0);

            $nameResolver.find("#searchSpinner").fadeOut(animationDuration).end();
            $clear.fadeIn(animationDuration);
        }

        /**************************************************************************************************************/

        /**
         *    Submit request with string from input
         */
        function _submitRequest(event) {
            event.preventDefault();
            $input.blur();
            var objectName = $input.val();

            if (objectName != $input.attr("value") && objectName != '') {
                $nameResolver
                    .find("#searchSpinner").fadeIn(animationDuration).end()
                    .find('#searchClear').fadeOut(animationDuration);

                $resolverSearchResult.fadeOut(animationDuration);
                NameResolver.goTo(objectName, _showResults, _showError,_showErrorOutOfBound);
            }
            else {
                $resolverSearchResult.html("Enter object name").fadeIn(animationDuration);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Zoom to result by clicking on item of #resolverSearchResult list
         */
        function _zoomToResult(event) {
            $('#resolverSearchResult').find('.selected').removeClass('selected');
            $(this).addClass('selected');

            var index = $(this).attr("mizar_feature_index");
            var selectedFeature = response.features[index];
            NameResolver.zoomTo(selectedFeature.geometry.coordinates[0], selectedFeature.geometry.coordinates[1], null, selectedFeature.geometry.crs.properties.name);
        }

        /**************************************************************************************************************/

        /**
         *    Clear results list
         */
        function _clearResults() {
            $('#resolverSearchResult').fadeOut(animationDuration);
        }

        /**************************************************************************************************************/

        /**
         *    Clear search input
         */
        function _clearInput() {
            var defaultText = $input.attr("value");
            if ($input.val() !== defaultText) {
                $input.val(defaultText);
            }
            $clear.fadeOut(animationDuration);
            $('#searchInput').animate({color: '#b4bdc4'}, animationDuration)
                .parent().animate({backgroundColor: '#e8edf1'}, animationDuration).removeClass('focus');
        }

        /**************************************************************************************************************/

        /**
         *    Initialize events for name resolver
         */
        function setSearchBehavior() {
            // Set style animations
            $input.on('focus', _focusInput)
                .on('blur', _blurInput)
                .keyup(_toggleClear);

            // Submit event
            $('#searchDiv').find('#searchForm').submit(_submitRequest);

            // Clear search result field when pan
            $('canvas').on('click', _clearResults);

            $('#navigationDiv').on('mousewheel','',_mousewheel);
            $('#searchDiv').find('#resolverSearchResult').on("click", '.nameResolverResult.coordinatesResolverResult', _zoomToResult);

            $('#searchDiv').find('#resolverSearchResult').on("click", '.layerResolverResult .nameResolverResult', _selectLayer);
            $nameResolver.find('#searchClear').on('click', _clearInput);
        }

        /**************************************************************************************************************/

        /**
         *    Manage mousewheel event to scroll list of name resolver results
         */
        function _mousewheel(event) {
          var d = $('#navigationDiv');
          var top = d.scrollTop();
          var delta = event.originalEvent.deltaY;
          d.scrollTop( top + delta );
        }

        function _selectLayer(event) {
            var current = $(this).parent();
            if(current.hasClass("selected")) {
                return;
            }
            $('#resolverSearchResult').find('.selected').removeClass('selected');
            $('#resolverSearchResult').find('button').removeAttr('style');

            current.addClass('selected');

            var index = $(current).attr("mizar_feature_index");
            var selectedFeature = response.features[index];
            var layerName = selectedFeature.properties.name;
            var layer = mizarWidgetAPI.getLayerByName(layerName);

            var visible = layer.isVisible();
            var button = $(current).find('.show_or_hide');

            toggleButtonVisibility(layer, button);
            button.button().once().click(function(event) {
                toggleLayer(layer);
                toggleButtonVisibility(layer, button);
            });
        }

        function toggleLayer (layer) {
            if(layer.category == "background") {
                $('#backgroundLayersSelect').val(layer.name).iconselectmenu("refresh");
                //BackgroundLayersView.selectLayer(layer);
            }
            else {
                var visible = layer.isVisible();
                layer.setVisible(!visible);
            }
            return;
        }

        function toggleButtonVisibility(layer, button) {
            var visible = layer.isVisible();
            if(layer.category == "background") {
                if(visible) {
                    button.hide();
                }
                else {
                    button.show();
                    $("span", button).text("Show");
                }
            }
            else {
                $("span", button).text(visible ? "Hide" : "Show");
            }
        }

        /**************************************************************************************************************/

        return {
            /**
             *    Init
             *
             *    @param m
             *        Mizar
             */
            init: function (m) {
                mizarWidgetAPI = m;
                NameResolver = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.NameResolver);
                self = this;
                if (!$nameResolver) {

                    // Update name resolver context when mizar mode has been toggled
                    mizarWidgetAPI.subscribeMizar(mizarWidgetAPI.EVENT_MSG.MIZAR_MODE_TOGGLE, this.onModeToggle);

                    // TODO : replace searchDiv by "parentElement"
                    $nameResolver = $(nameResolverHTML).appendTo('#searchDiv');
                    $input = $nameResolver.find('#searchInput');
                    $clear = $nameResolver.find('#searchClear');
                    $resolverSearchResult = $nameResolver.siblings('#resolverSearchResult');

                    setSearchBehavior();
                } else {
                    console.error("Name resolver view is already initialized");
                }
            },

            /**
             *    Unregister all event handlers
             */
            remove: function () {
                if ($nameResolver) {
                    // Set style animations
                    $input.off('focus', _focusInput)
                        .off('blur', _blurInput)
                        .unbind('keyup', _toggleClear);

                    // Clear search result field when pan
                    $('canvas').off('click', _clearResults);

                    $resolverSearchResult.off("click", '.nameResolverResult.coordinatesResolverResult', _zoomToResult);
                    $resolverSearchResult.off("click", '.nameResolverResult.layerResolverResult', _selectLayer);
                    $nameResolver.find('#searchClear').off('click', _clearInput);
                    $nameResolver.remove();
                    $nameResolver = null;

                    mizarWidgetAPI.unsubscribeMizar(mizarWidgetAPI.EVENT_MSG.MIZAR_MODE_TOGGLE, this.onModeToggle);
                    mizarWidgetAPI = null;
                }
            },

            /**
             *    Handler on mizar mode toggle
             */
            onModeToggle: function (ctx) {
                //if (!ctx.planetLayer || (ctx.planetLayer.nameResolver != undefined && ctx.planetLayer.nameResolver.baseUrl)) {
                    $nameResolver.show();
                    self.setContext(ctx);
                //}
                //else {
                    //$nameResolver.hide();
                //}
            },

            /**
             *    Set new context
             */
            setContext: function (ctx) {
                NameResolver.setContext(ctx);
                _clearInput();
                $resolverSearchResult.css("display", "none");
            },

            toggleButtonVisibility : toggleButtonVisibility,
            toggleLayer : toggleLayer,
            isInitialized : function() {
                return mizarWidgetAPI ? true : false;
            }
        };

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Reverse name resolver view using ReverseNameResolver services
 */
define('gui/ReverseNameResolverView',["jquery", "underscore-min", "../utils/UtilsCore",
        "./IFrame", "./dialog/ErrorDialog",
        "text!templates/featureDescription.html", "text!templates/descriptionTable.html", "jquery.ui"],
    function ($, _, UtilsCore,
              IFrame, ErrorDialog, 
              featureDescriptionHTMLTemplate, descriptionTableHTMLTemplate) {

        var mizarWidgetAPI;

        var geoPick = [];
        var self;
        var isMobile = false;

        var timeStart;
        var mouseXStart;
        var mouseYStart;

// Template generating the detailed description of choosen feature
        var featureDescriptionTemplate = _.template(featureDescriptionHTMLTemplate);

// Template generating the table of properties of choosen feature
        var descriptionTableTemplate = _.template(descriptionTableHTMLTemplate);

        var reverseNameResolverHTML =
            '<div id="reverseNameResolver" class="contentBox ui-widget-content" style="display: none;">\
                <div id="reverseSearchField">\
                    <input type="submit" value="Find Object Name" />\
                    <div id="coordinatesInfo"></div>\
                    <div id="healpixInfo"></div>\
                </div>\
                <div id="reverseSearchResult"></div>\
                <div class="closeBtn">\
                    <span class="defaultImg"></span>\
                    <span style="opacity: 0" class="hoverImg"></span>\
                </div>\
            </div>';

        var $reverseNameResolver;

        /**************************************************************************************************************/

        /**
         *    Mouse down handler
         *    Registers the position of the mouse and time of click
         */
        function _handleMouseDown(event) {
            //$reverseNameResolver.fadeOut();
            timeStart = new Date();

            if (event.type.search("touch") >= 0) {
                event.clientX = event.changedTouches[0].clientX;
                event.clientY = event.changedTouches[0].clientY;
            }

            mouseXStart = event.clientX;
            mouseYStart = event.clientY;
        }

        /**************************************************************************************************************/

        /**
         *    Mouse up handler
         *    Opens reverse name resolver popup if mouse has been clicked at least 0.5s and hasn't been moved
         */
        function _handleMouseUp(event) {
            var epsilon = 5;

            var timeEnd = new Date();
            var diff = timeEnd - timeStart;

            if (event.type.search("touch") >= 0) {
                event.clientX = event.changedTouches[0].clientX;
                event.clientY = event.changedTouches[0].clientY;
            }

            // More than 0.5 second and the mouse position is approximatively the same
            if (diff > 500 && Math.abs(mouseXStart - event.clientX) < epsilon && Math.abs(mouseYStart - event.clientY) < epsilon) {
                geoPick = mizarWidgetAPI.getContext().getLonLatFromPixel(event.clientX, event.clientY);
                _onCoordinatePicked(event);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Mouse up handler
         *    Opens reverse name resolver popup if mouse has been clicked at least 0.5s and hasn't been moved
         */
        function _onCoordinatePicked(event) {
            var padding = 15;
            var mHeight = window.innerHeight - event.clientY - padding * 2;
            $('#reverseSearchField').css('max-height', mHeight);
            $('#reverseSearchResult').css('max-height', mHeight);
            $('#reverseSearchResult').css("display", "none");

            var astro = mizarWidgetAPI.getCrs().formatCoordinates([geoPick[0], geoPick[1]]);

            if (mizarWidgetAPI.getCrs().getGeoideName() === mizarWidgetAPI.CRS.Equatorial) {
                $("#coordinatesInfo").html("<em>Right ascension:</em><br/>&nbsp;&nbsp;&nbsp;&nbsp;" + astro[0] +
                    "<br/><em>Declination :</em><br/>&nbsp;&nbsp;&nbsp;&nbsp;" + astro[1]);
            } else if (mizarWidgetAPI.getCrs().getGeoideName() == mizarWidgetAPI.CRS.Galactic) {
                $("#coordinatesInfo").html("<em>Longitude:</em><br/>&nbsp;&nbsp;&nbsp;&nbsp;" + astro[0] +
                    "<br/><em>Latitude:</em><br/>&nbsp;&nbsp;&nbsp;&nbsp;" + astro[1]);
            } else {
                $("#coordinatesInfo").html("<em>Longitude:</em><br/>&nbsp;&nbsp;&nbsp;&nbsp;" + geoPick[0] +
                    "<br/><em>Latitude:</em><br/>&nbsp;&nbsp;&nbsp;&nbsp;" + geoPick[1]);
            }

            // Use debug mode only for HEALPix tiling
            if (mizarWidgetAPI.options.gui.debug && mizarWidgetAPI.getTileManager().tiling.findInsideTile) {
                var selectedTile = mizarWidgetAPI.getTileManager().getVisibleTile(geoPick[0], geoPick[1]);
                $('#reverseSearchField #healpixInfo').html('<em>Healpix index/order: </em>&nbsp;&nbsp;&nbsp;&nbsp;' + selectedTile.pixelIndex + '/' + selectedTile.order);
            }

            $('#reverseSearchField').css("display", "block");
            $reverseNameResolver.css({
                position: 'absolute',
                left: event.clientX + 'px',
                top: event.clientY + 'px'
            }).fadeIn(100);
        }

        /**************************************************************************************************************/

        /**
         *    Show feature information in popup
         */
        function showFeature(response) {
            // Show only one feature for the moment
            var feature = response.features[0];
            var output = featureDescriptionTemplate({
                dictionary: {},
                services: feature.services,
                properties: feature.properties,
                descriptionTableTemplate: descriptionTableTemplate
            });
            var title = ( feature.properties.title ) ? feature.properties.title : feature.properties.identifier;
            output = '<div class="title">' + title + '</div><div class="credit">Found in CDS database</div>' + output;
            $('#reverseSearchResult')
                .html(output)
                .find('#sendViewport').button();
            $('#reverseSearchField').fadeOut(300, function () {
                $('#reverseSearchResult').fadeIn(300);
            });
            $('#reverseSearchField input[type="submit"]').removeAttr('disabled');
        }

        /**************************************************************************************************************/

        /**
         *    Show error dialog with the status
         */
        function showError(xhr) {
            if (xhr) {
                switch (xhr.status) {
                    case 503:
                        ErrorDialog.open("Please wait at least 6 seconds between each request to reverse name resolver");
                        break;
                    case 500:
                        ErrorDialog.open("Internal server error");
                        break;
                    case 404:
                        ErrorDialog.open("Object not found");
                        break;
                    case 400:
                        ErrorDialog.open("Bad input");
                        break;
                    default:
                        break;
                }
            }
            $('#reverseSearchField input[type="submit"]').removeAttr('disabled');
        }

        /**************************************************************************************************************/

        /**
         *    External link event handler
         */
        function _showIFrame(event) {
            event.preventDefault();
            IFrame.show(event.target.innerHTML);
        }

        /**************************************************************************************************************/

        /**
         *    Hide reverse name resolver popup handler
         */
        function _hidePopup(event) {
            if ($reverseNameResolver && $reverseNameResolver.hasOwnProperty("css") && $reverseNameResolver.css('display') != 'none') {
                $reverseNameResolver.fadeOut(300);
            }
        }

        /**************************************************************************************************************/

        return {
            /**
             *    Init reverse name resolver
             */
            init: function (m) {
                self = this;
                if (!$reverseNameResolver) {
                    mizarWidgetAPI = m;
                    isMobile = mizarWidgetAPI.getMizarWidgetGui().isMobile;

                    $reverseNameResolver = $(reverseNameResolverHTML).appendTo('body');

                    $reverseNameResolver.find("input[type=submit]")
                        .button()
                        .click(function (event) {
                            event.preventDefault();

                            $('#reverseSearchField input[type="submit"]').attr('disabled', 'disabled');

                            mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.ReverseNameResolver).sendRequest(geoPick, {
                                success: showFeature,
                                error: showError
                            });
                        });

                    // External link event
                    $reverseNameResolver.on("click", '.propertiesTable a', _showIFrame);
                    mizarWidgetAPI.subscribeMizar(mizarWidgetAPI.EVENT_MSG.MIZAR_MODE_TOGGLE, self.updateContext);
                    this.updateContext();
                } else {
                    console.error("Reverse name resolver is already initialized");
                }
            },

            /**
             *    Update context to activated one
             */
            updateContext: function () {
                // Activate reverese name resolver if base url is defined for the given layer
                if (mizarWidgetAPI.getContext().getContextConfiguration().reverseNameResolver && mizarWidgetAPI.getContext().getContextConfiguration().reverseNameResolver.baseUrl) {
                    if (mizarWidgetAPI.getContext())
                        self.deactivate();
                    self.activate();
                    mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.ReverseNameResolver).setContext(mizarWidgetAPI.getContext());
                }
                else {
                    self.deactivate();
                }

            },

            /**
             *    Activate reverse name resolver canvas listeners
             */
            activate: function () {
                mizarWidgetAPI.getRenderContext().canvas.addEventListener("mousedown", _handleMouseDown);
                mizarWidgetAPI.getRenderContext().canvas.addEventListener("mouseup", _handleMouseUp);

                if (isMobile) {
                    mizarWidgetAPI.getRenderContext().canvas.addEventListener("touchstart", _handleMouseDown);
                    mizarWidgetAPI.getRenderContext().canvas.addEventListener("touchend", _handleMouseUp);
                }

                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.NAVIGATION_MODIFIED, _hidePopup);
            },

            /**
             *    Deactivate reverse name resolver canvas listeners
             */
            deactivate: function () {
                mizarWidgetAPI.getRenderContext().canvas.removeEventListener("mousedown", _handleMouseDown);
                mizarWidgetAPI.getRenderContext().canvas.removeEventListener("mouseup", _handleMouseUp);

                if (isMobile) {
                    mizarWidgetAPI.getRenderContext().canvas.removeEventListener("touchstart", _handleMouseDown);
                    mizarWidgetAPI.getRenderContext().canvas.removeEventListener("touchend", _handleMouseUp);
                }

                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.NAVIGATION_MODIFIED, _hidePopup);
            },

            /**
             *    Unregister all binded events
             */
            unregisterEvents: function () {
                this.deactivate();
                // External link event
                $reverseNameResolver.off("click", '.propertiesTable a', _showIFrame);
                mizarWidgetAPI.unsubscribeMizar(mizarWidgetAPI.EVENT_MSG.MIZAR_MODE_TOGGLE, self.updateContext);
            },

            /**
             *    Remove view
             */
            remove: function () {
                if ($reverseNameResolver) {
                    this.unregisterEvents();
                    $reverseNameResolver.remove();
                    $reverseNameResolver = null;
                    mizarWidgetAPI = null;
                }
            },

            isInitialized: function() {
                return mizarWidgetAPI ? true : false
            }
        };

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Mollweider viewer module : Sky representation in mollweide coordinate system
 */
define('gui/MollweideViewer',["jquery"],
    function ($) {

    /*************************************************************************/

    var MollweideViewer = function (options) {

        this.mizarBaseUrl = options.mizarBaseUrl;
        var mizarWidgetAPI = options.mizar;

        var MollweideViewerCore = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MollweideViewer);

        var mollweideOptions = $.extend({}, options);
        mollweideOptions['mizar'] = mizarWidgetAPI.getMizarAPI();
        MollweideViewerCore.init(mollweideOptions);

        // Interaction parameters
        var dragging = false;

        // Init image background
        var canvas = document.getElementById('mollweideCanvas');
        mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.CRS_MODIFIED, MollweideViewerCore.updateGalaxyProjection);
        MollweideViewerCore.updateGalaxyProjection(mizarWidgetAPI.getContext());

        /**********************************************************************************************/

        /**
         * Get mouse position on canvas
         */
        function getMousePos(event) {
            // Difference between chrome and firefox;
            var offX = (event.offsetX) ? event.offsetX : (event.layerX - event.target.offsetLeft);
            var offY = (event.offsetY) ? event.offsetY : (event.layerY - event.target.offsetTop);

            return [offX, offY];
        }

        /**********************************************************************************************/

        // Interact with mollweide projection
        canvas.addEventListener('mousedown', function (event) {
            var mPos = getMousePos(event);
            MollweideViewerCore.updateNavigation(mPos);
            dragging = true;
            return true;
        });

        canvas.addEventListener('mousemove', function (event) {
            if (!dragging)
                return;
            var mPos = getMousePos(event);
            MollweideViewerCore.updateNavigation(mPos);
        });

        canvas.addEventListener('mouseup', function () {
            dragging = false;
        });

        /**********************************************************************************************/

        // Show/hide mollweide projection
        $('#slideArrow').click(function () {

            if (parseFloat($(this).parent().css('left')) < 0) {
                // Show
                $('#mollweideContent').css({boxShadow: "0px 0px 8px 1px rgba(255, 158, 82, 0.92)"});
                $(this).css('background-position', '0px 0px');
                $(this).parent().animate({left: '0px'}, 300);
                // Update fov when navigation modified
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.NAVIGATION_MODIFIED, MollweideViewerCore.updateMollweideFov);
                MollweideViewerCore.updateMollweideFov(MollweideViewerCore.getImageObj());
            }
            else {
                // Hide
                $('#mollweideContent').css({boxShadow: "none"});
                $(this).css('background-position', '0px -20px');
                $(this).parent().animate({left: '-266px'}, 300);
                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.NAVIGATION_MODIFIED, MollweideViewerCore.updateMollweideFov);
            }
        });

        // Fix for Google Chrome : avoid dragging
        canvas.addEventListener("dragstart", function (event) {
            event.preventDefault();
            return false;
        });
    };

    /**********************************************************************************************/

    return MollweideViewer;

});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Simple progress bar
 */
define('gui/SimpleProgressBar',["jquery"], function ($) {

    var SimpleProgressBar = function (options) {
        var id = options.id;
        this.percentOutput = options.hasOwnProperty('percentOutput') ? options.percentOutput : false;

        this.$element = $('<div style="display: none;" class="progress"><div></div></div>')
            .appendTo('#' + id)
            .fadeIn();
    };

    SimpleProgressBar.prototype.onprogress = function (evt) {
        if (evt.lengthComputable) {
            var percentComplete = Math.floor((evt.loaded / evt.total) * 100);
            var progressBarWidth = percentComplete * this.$element.width() / 100;
            this.$element.find('div').css('width', progressBarWidth);

            if (this.percentOut) {
                this.$element.find('div').html(percentComplete + "%&nbsp;");
            }

            if (percentComplete >= 99) {
                this.$element.delay(1000).fadeOut('slow');
            }
        }
        else {
            this.$element.fadeOut();
        }
    };

    return SimpleProgressBar;

});


define('text!templates/imageViewer.html',[],function () { return '<div id="imageViewerContent">\n    <span id="imageViewInvoker"></span>\n\n    <div id="loadedImages">\n        <h3>Images</h3>\n\n        <div>\n            <p style="color: white; text-align: center;">No image was loaded</p>\n\n            <div class="imageLayers">\n            </div>\n        </div>\n    </div>\n</div>';});


define('text!templates/imageViewerLayerItem.html',[],function () { return '<div class="layer" id="imageLayer_<%= id %>" style="display: none;">\n    <input class="layerVisibility" id="layerVisibility_<%= id %>" type="checkbox" checked/>\n    <label for="layerVisibility_<%= id %>"></label>\n    <label class="layerName" title=<%= name %>><%= name %></label>\n    <ul>\n    </ul>\n</div>';});


define('text!templates/imageViewerImageItem.html',[],function () { return '<li class="image" id="imageView_<%= id %>" style="display: none;">\n    <input type="checkbox" name="imageView" id="<%= id %>" checked/>\n    <label style="width: 15px; height: 15px;" for="<%= id %>"></label>\n    <label class="imageName" title="<%= name %>"><%= name %></label>\n\n    <div style="display: none;" class="options">\n        <button class="zoomTo">Zoom to..</button>\n        <button class="<% if (!isFits) print(\'fitsUnavailable\') %> imageProcessing" id="imageProcessing_<%= id %>">Image\n            processing\n        </button>\n        <button class="sampExport">Send image by SAMP</button>\n        <button class="metadata">Show metadata</button>\n        <button class="delete">Delete</button>\n    </div>\n</li>';});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

define('gui/ImageViewer',["require", "jquery", "underscore-min","../utils/UtilsCore",
        "./PickingManager", "./ImageManager", "./ImageProcessing", "./SimpleProgressBar", "service/Samp", "./dialog/ErrorDialog",
        "text!templates/imageViewer.html", "text!templates/imageViewerLayerItem.html", "text!templates/imageViewerImageItem.html", "jquery.ui"],
    function (require, $, _, UtilsCore,
              PickingManager, ImageManager, ImageProcessing, SimpleProgressBar, Samp, ErrorDialog,
              imageViewerHTML, imageViewerLayerItemHTMLTemplate, imageViewerImageItemHTMLTemplate) {

        var mizarWidgetAPI;
        var navigation;

// jQuery selector
        var $imageViewer;

        var layers = [];
        var featuresWithImages = [];

// Template generating the div representing layer which contains loaded images
        var imageViewerLayerItemTemplate = _.template(imageViewerLayerItemHTMLTemplate);
// Template generating the li representing image
        var imageViewerImageItemTemplate = _.template(imageViewerImageItemHTMLTemplate);

        /**************************************************************************************************************/

        /**
         *    Disable image toolbar inputs
         */
        function disableImageUI(layer) {
            $imageViewer.find('.imageLayers div[id="imageLayer_' + layer.id + '"] ul')
                .find('button, input').each(function () {
                    $(this).attr('disabled', 'disabled').button('refresh');
                });
        }

        /**************************************************************************************************************/

        /**
         *    Enable image toolbar inputs
         */
        function enableImageUI(layer) {
            $imageViewer.find('.imageLayers div[id="imageLayer_' + layer.id + '"] ul')
                .find('button, input').each(function () {
                    // Don't enable image processing for not fits files
                    if (!$(this).hasClass('fitsUnavailable')) {
                        $(this).removeAttr('disabled').button('refresh');
                    }
                });
        }

        /**************************************************************************************************************/

        /**
         *    Handler to manage BaseLayer "visibility:change" event
         */
        function onVisibilityChange(layer) {
            var $layer = $imageViewer.find('.imageLayers div[id="imageLayer_' + layer.id + '"]');
            var $layerVisibility = $layer.find('#layerVisibility_' + layer.id);
            $layerVisibility.button("option", {
                icons: {
                    primary: layer.isVisible() ? "ui-icon-check" : ""
                }
            }).button('refresh');

            // TODO: still tiny bug with label "ui-state-active" class toggling

            if (layer.isVisible()) {
                enableImageUI(layer);
            }
            else {
                disableImageUI(layer);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Create layer view
         *    This view will contain all the loaded images for the given layer
         */
        function createLayerView(layer) {
            var imageViewerLayerItemContent = imageViewerLayerItemTemplate({id: layer.id, name: layer.name});
            var $layer = $(imageViewerLayerItemContent)
                .appendTo($imageViewer.find('.imageLayers'));

            // Slide loaded images for current layer onclick
            $layer.find('label.layerName').click(function () {
                $("#imageLayer_" + layer.id + " > ul").slideToggle();
            });

            // Stylize layer visibility checkbox
            var $layerVisibility = $layer.find('#layerVisibility_' + layer.id);
            // Layer visibility management
            $layerVisibility.button({
                text: false,
                icons: {
                    primary: "ui-icon-check"
                }
            }).click(function () {
                var isChecked = !($layerVisibility.button('option', 'icons').primary === "ui-icon-check");
                layer.setVisible(isChecked);
            });

            if (layers.length === 0) {
                $imageViewer.find('#loadedImages p').fadeOut(function () {
                    $layer.fadeIn();
                });
            }
            else {
                $layer.fadeIn();
            }

            layers.push(layer);
            mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_VISIBILITY_CHANGED, onVisibilityChange);

            return $layer;
        }

        /**************************************************************************************************************/

        /**
         *    Show image viewer
         */
        function showImageViewer() {
            $imageViewer.find('#loadedImages').css({boxShadow: "0px 0px 8px 1px rgba(255, 158, 82, 0.92)"});
            $imageViewer.find('#imageViewInvoker').css('background-position', '0px -20px')
                .parent().animate({right: '0px'}, 300);
        }

        /**************************************************************************************************************/

        /**
         *    Hide image viewer
         */
        function hideImageViewer() {
            $imageViewer.find('#loadedImages').css({boxShadow: "none"});
            $imageViewer.find('#imageViewInvoker').css('background-position', '0px 0px')
                .parent().animate({right: '-254px'}, 300);
        }

        /**************************************************************************************************************/

        return {

            /**
             *    Init image viewer
             */
            init: function (m) {
                mizarWidgetAPI = m;
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.IMAGE_ADDED, this.addView);
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.IMAGE_REMOVED, this.removeView);
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.IMAGE_DOWNLOADED, this.addProgressBar);
                mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_REMOVED, this.removeLayer);
                navigation = mizarWidgetAPI.getNavigation();

                $imageViewer = $(imageViewerHTML).appendTo('#imageViewerDiv');

                // Show/hide image viewer
                $imageViewer.find('#imageViewInvoker').click(function () {
                    if (parseFloat($(this).parent().css('right')) < 0) {
                        showImageViewer();
                    }
                    else {
                        hideImageViewer();
                    }
                });
                // Create accordion
                $imageViewer.find("#loadedImages").accordion({
                    heightStyle: "content",
                    active: 0,
                    collapsible: true
                }).show();
            },

            /**
             *    Remove UI and unregister all the events
             */
            remove: function () {
                for (var i = 0; i < layer.length; i++) {
                    layer.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_VISIBILITY_CHANGED, onVisibilityChange);
                }

                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.IMAGE_ADDED, this.addView);
                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.IMAGE_REMOVED, this.removeView);
                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.IMAGE_DOWNLOADED, this.addProgressBar);
                mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_REMOVED, this.removeLayer);
                $imageViewer.remove();
                navigation = null;
            },

            /**
             *    Add progress bar
             *
             *    @param featureData
             *        Contains feature data(layer, feature) and its XMLHttpRequest
             */
            addProgressBar: function (featureData) {
                var id = "imageView_" + UtilsCore.formatId(featureData.feature.properties.identifier) + "_fits";
                var progressBar = new SimpleProgressBar({id: id});
                featureData.xhr.onprogress = progressBar.onprogress.bind(progressBar);
            },

            /**
             *    Add view for the given feature
             *
             *    @returns jQuery element of view
             */
            addView: function (selectedData) {
                console.log("addView",selectedData);
                showImageViewer();

                // Get or create layer view
                var $layer;
                var layer = selectedData.layer;
                if (layers.indexOf(selectedData.layer) < 0) {
                    $layer = createLayerView(selectedData.layer);
                }
                else {
                    $layer = $imageViewer.find('.imageLayers div[id="imageLayer_' + layer.id + '"]');
                }

                var feature = selectedData.feature;
                // Remove special caracters from feature id
                var id = UtilsCore.formatId(selectedData.feature.properties.identifier);
                // Add isFits property for correct progress bar handling
                if (selectedData.isFits) {
                    id += "_fits";
                }

                var name = selectedData.feature.properties.identifier;
                var $li;
                var $metadataDialog;

                if ($layer.find('ul li[id="' + id + '"]').length === 0) {
                    // Create only if not already added
                    var imageViewerItemContent = imageViewerImageItemTemplate({
                        id: id,
                        name: name,
                        isFits: selectedData.isFits
                    });
                    $li = $(imageViewerItemContent)
                        .appendTo($layer.find('ul'))
                        // ZoomTo
                        .find('.zoomTo').button({
                            text: false,
                            icons: {
                                primary: "ui-icon-zoomin"
                            }
                        }).click(function () {

                            var barycenter = UtilsCore.computeGeometryBarycenter(feature.geometry);
                            navigation.zoomTo([barycenter[0], barycenter[1]], 0.1, 2000, function () {
                                // Update selection
                                PickingManager.focusFeature(selectedData, {isExclusive: true});
                            });

                        }).end()
                        // Image visibility
                        .find('input').button({
                            text: false,
                            icons: {
                                primary: "ui-icon-check"
                            }
                        }).click(function () {

                            $(this).button("option", {
                                icons: {
                                    primary: $(this)[0].checked ? "ui-icon-check" : ""
                                }
                            });
                            if ($(this).is(':checked')) {
                                ImageManager.showImage(selectedData);
                            }
                            else {
                                ImageManager.hideImage(selectedData);
                            }
                            mizarWidgetAPI.getRenderContext().requestFrame();
                        }).end()
                        // Delete fits
                        .find('.delete').button({
                            text: false,
                            icons: {
                                primary: "ui-icon-trash"
                            }
                        }).click(function () {
                            // Remove image
                            ImageManager.removeImage(selectedData, selectedData.isFits);
                            if (selectedData.isFits) {
                                ImageProcessing.removeData(selectedData);
                            }
                            mizarWidgetAPI.getRenderContext().requestFrame();
                        }).end()
                        // Image processing
                        .find('.imageProcessing').button({
                            text: false,
                            icons: {
                                primary: "ui-icon-image"
                            }
                        }).click(function () {
                            ImageProcessing.setData(selectedData);
                        }).end()
                        .find('.metadata').button({
                            text: false,
                            icons: {
                                primary: "ui-icon-info"
                            }
                        }).click(function () {

                            // Create metadata dialog if doesn't exist
                            if (!$metadataDialog) {
                                // TODO : refactor this circular dependency...
                                var featurePopup = require("FeaturePopup");
                                var output = featurePopup.generateFeatureMetadata(selectedData.layer, selectedData.feature);
                                $metadataDialog = $('<div>' + output + '</div>').dialog({
                                    autoOpen: true,
                                    show: {
                                        effect: "fade",
                                        duration: 300
                                    },
                                    hide: {
                                        effect: "fade",
                                        duration: 300
                                    },
                                    title: "Metadata",
                                    width: 350,
                                    resizable: false,
                                    zIndex: 12,
                                    stack: false,
                                    close: function () {
                                        $(this).find('.featureProperties').getNiceScroll().remove();
                                        $(this).dialog("destroy").remove();
                                        $metadataDialog = null;
                                    },
                                    drag: function () {
                                        $(this).find('.featureProperties').getNiceScroll().resize();
                                    }
                                });
                                $metadataDialog.find('.featureProperties').niceScroll({
                                    autohidemode: false
                                });
                            }
                            else {
                                if ($metadataDialog.dialog("isOpen")) {
                                    $metadataDialog.dialog("close");
                                }
                            }
                        }).end()
                        .find('.sampExport').button({
                            text: false,
                            icons: {
                                primary: "ui-icon-extlink"
                            }
                        }).click(function () {
                            if (Samp.isConnected()) {
                                Samp.sendImage(feature.services.download.url);
                            }
                            else {
                                ErrorDialog.open("You must be connected to SAMP Hub");
                            }
                        }).end()
                        .fadeIn();

                    $li.find('label.imageName').click(function () {
                        $(this).siblings('.options').slideToggle();
                    });

                    // Disable image processing button for not fits images
                    if (!selectedData.isFits) {
                        $li.find('.imageProcessing').button("disable");
                    }

                    featuresWithImages.push(selectedData);

                    return $li;
                }
            },

            /**
             *    Remove view of the given feature
             */
            removeView: function (selectedData) {
                var id = "imageView_" + UtilsCore.formatId(selectedData.feature.properties.identifier);
                if (selectedData.isFits) {
                    id += "_fits";
                }

                $imageViewer.find('#loadedImages').find('li.image[id="' + id + '"]').fadeOut(function () {

                    // No more loaded image views for current layer
                    if ($(this).siblings().length === 0) {
                        // Remove layer view
                        $imageViewer.find('.imageLayers div[id="imageLayer_' + selectedData.layer.id + '"]').fadeOut(300, function () {
                            // Remove layer view
                            $(this).remove();

                            // Show "No image was loaded"
                            if (layers.length === 0) {
                                $imageViewer.find('#loadedImages p').fadeIn();
                            }
                        });

                        var index = layers.indexOf(selectedData.layer);
                        layers.splice(index, 1);
                    }

                    $(this).remove();
                });

                var featureIndex = featuresWithImages.indexOf(selectedData);
                featuresWithImages.splice(featureIndex, 1);

                selectedData.layer.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.LAYER_VISIBILITY_CHANGED, onVisibilityChange);
            },

            /**
             *    Remove all image views of the given layer
             */
            removeLayer: function (layer) {
                var $layer = $imageViewer.find('.imageLayers div[id="imageLayer_' + layer.id + '"]');
                $layer.find('ul li').each(function () {
                    $(this).find('.delete').trigger("click");
                });
            },

            getFeatures: function () {
                return featuresWithImages;
            },

            isInitialized : function() {
                return mizarWidgetAPI ? true : false;
            }
        };

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to measure the distance between two points
 */

define('gui/MeasureToolSky',["jquery", "underscore-min", "jquery.ui"],
    function ($, _) {

        var mizarWidgetAPI, self;

        var MeasureToolSky = function (options) {
            // Required options
            mizarWidgetAPI = options.mizar;

            if( options.mode !== mizarWidgetAPI.CONTEXT.Sky ) {
                return;
            }

            var measureToolSkyOptions = $.extend({}, options);
            measureToolSkyOptions['mizar'] = mizarWidgetAPI.getMizarAPI();

            mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky).init(measureToolSkyOptions);

            mizarWidgetAPI.subscribeMizar(mizarWidgetAPI.EVENT_MSG.MIZAR_MODE_TOGGLE, function() {
                if(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky).activated) {
                    self.toggle();
                }
            });
            mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.CRS_MODIFIED, function() {
                if(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky).activated) {
                    self.toggle();
                }
            });

            this.renderContext = mizarWidgetAPI.getRenderContext();

            self = this;

            self.renderContext.canvas.addEventListener("mousedown", $.proxy(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky)._handleMouseDown, this));
            self.renderContext.canvas.addEventListener("mouseup", $.proxy(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky)._handleMouseUp, this));
            self.renderContext.canvas.addEventListener("mousemove", $.proxy(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky)._handleMouseMove, this));

            if (options.isMobile) {
                self.renderContext.canvas.addEventListener("touchend", $.proxy(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky)._handleMouseUp, this));
                self.renderContext.canvas.addEventListener("touchmove", $.proxy(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky)._handleMouseMove, this));
                self.renderContext.canvas.addEventListener("touchstart", $.proxy(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky)._handleMouseDown, this));
            }
            $('#measureSkyInvoker').on('click', function () {
                self.toggle();
            }).hover(function () {
                $(this).animate({left: '-10px'}, 100);
            }, function () {
                $(this).animate({left: '-20px'}, 100);
            });
        };


        /**
         *    Enable/disable the tool
         */
        MeasureToolSky.prototype.toggle = function () {
            mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky).activated = !mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky).activated;
            if (mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky).activated) {
                $(self.renderContext.canvas).css('cursor', 'url(css/images/selectionCursor.png)');
            }
            else {
                $(self.renderContext.canvas).css('cursor', 'default');
                mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky).clear();
            }
            $('#measureSkyInvoker').toggleClass('selected');
        };

        MeasureToolSky.prototype.remove = function() {
            mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky).remove();
            mizarWidgetAPI.unsubscribeMizar(mizarWidgetAPI.EVENT_MSG.MIZAR_MODE_TOGGLE, function() {
                if(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky).activated) {
                    self.toggle();
                }
            });
            mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.CRS_MODIFIED, function() {
                if(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolSky).activated) {
                    self.toggle();
                }
            });
        };

        return MeasureToolSky;

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to measure the distance between two points in planet mode
 */

define('gui/MeasureToolPlanet',["jquery", "jquery.ui"],
    function ($) {

        var mizarWidgetAPI, self;

        var MeasureToolPlanet = function (options) {
            // Required options
            mizarWidgetAPI = options.mizar;

            if( options.mode !== mizarWidgetAPI.CONTEXT.Planet ) {
                return;
            }

            var measureToolPlanetOptions = $.extend({}, options);
            measureToolPlanetOptions['mizar'] = mizarWidgetAPI.getMizarAPI();
            mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).init(measureToolPlanetOptions);

            this.renderContext = mizarWidgetAPI.getRenderContext();

            self = this;

            mizarWidgetAPI.subscribeCtx(mizarWidgetAPI.EVENT_MSG.CRS_MODIFIED, function() {
                if(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).activated) {
                    self.toggle();
                }
            });

            mizarWidgetAPI.subscribeMizar(mizarWidgetAPI.EVENT_MSG.MIZAR_MODE_TOGGLE, function() {
                if(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).activated) {
                    self.toggle();
                }
            });


            var _handleMouseUp = function (event) {

                if (!mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).activated) {
                    return;
                }
                mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet)._handleMouseUp(event);
                var baseElevation = mizarWidgetAPI.getMizarAPI().getBaseElevation();
                if(baseElevation != null && baseElevation.isRequested()) {
                    $.proxy(self.displayButtonElevation(event), self);
                }

            };


            $('a#elevationTrackingBtn').text('Calculate elevation');
            $('#elevationTrackingBtn').button()
                .click($.proxy(self.displayPopupElevation, this));


            self.renderContext.canvas.addEventListener("contextmenu", function () {
                return false;
            });
            self.renderContext.canvas.addEventListener("mousedown", $.proxy(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet)._handleMouseDown, this));
            self.renderContext.canvas.addEventListener("mouseup", $.proxy(_handleMouseUp, this));
            self.renderContext.canvas.addEventListener("mousemove", $.proxy(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet)._handleMouseMove, this));

            if (options.isMobile) {
                self.renderContext.canvas.addEventListener("touchend", $.proxy(_handleMouseUp, this));
                self.renderContext.canvas.addEventListener("touchmove", $.proxy(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet)._handleMouseMove, this));
                self.renderContext.canvas.addEventListener("touchstart", $.proxy(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet)._handleMouseDown, this));
            }

            $('#measurePlanetInvoker').on('click', function () {
                self.toggle();
            }).hover(function () {
                $(this).animate({left: '-10px'}, 100);
            }, function () {
                $(this).animate({left: '-20px'}, 100);
            });
        };

        MeasureToolPlanet.prototype.updateContext = function (mizarWidget) {
            mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).updateContext(mizarWidget.getMizarAPI());
        };
        /**
         *    Enable/disable the tool
         */
        MeasureToolPlanet.prototype.toggle = function () {
            mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).activated = !mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).activated;
            if (mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).activated) {
                $(self.renderContext.canvas).css('cursor', 'url(css/images/selectionCursor.png)');
            }
            else {
                $(self.renderContext.canvas).css('cursor', 'default');
                $('#elevationTrackingBtn').hide();
                try {
                    $('#popupElevation').dialog('close');
                } catch (e) {
                }

                mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).clear();
            }
            $('#measurePlanetInvoker').toggleClass('selected');
        };

        MeasureToolPlanet.prototype.remove = function() {
            mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).remove();
            mizarWidgetAPI.unsubscribeCtx(mizarWidgetAPI.EVENT_MSG.CRS_MODIFIED, function() {
                if(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).activated) {
                    self.toggle();
                }
            });
            mizarWidgetAPI.unsubscribeMizar(mizarWidgetAPI.EVENT_MSG.MIZAR_MODE_TOGGLE, function() {
                if(mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).activated) {
                    self.toggle();
                }
            });
        };

        /**************************************************************************************************************/

        /**
         * Display a popup proposing to display elevation tracking
         */
        MeasureToolPlanet.prototype.displayButtonElevation = function (event) {

            $('#elevationTrackingBtn').button()
                .show()
                .position({
                    my: "left+3 bottom-3",
                    of: event,
                    collision: "fit"
                });

        };

        /**************************************************************************************************************/

        /**
         * Display a popup proposing to display elevation tracking
         */
        MeasureToolPlanet.prototype.displayPopupElevation = function (event) {

            var options = {};
            var intermediatePoints = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).calculateIntermediateElevationPoint(options, mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).geoPickPoint, mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).secondGeoPickPoint);

            mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).storeDistanceAndElevation(intermediatePoints[0], intermediatePoints[0]);
            for (var i = 0; i < intermediatePoints.length; i++) {
                mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).storeDistanceAndElevation(intermediatePoints[0], intermediatePoints[i]);
            }

            $("#popupElevation").dialog({
                width: 500,
                height: 400,
                position: {
                    my: "right top",
                    at: "right top",
                    of: window
                }
            });

            $.plot("#popupElevation", [{
                data: mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.MeasureToolPlanet).elevations, label: "elevation (m)"
            }], {
                series: {
                    color: "#F68D12",
                    lines: {
                        show: true
                    },
                    points: {
                        show: true
                    }
                },
                grid: {
                    hoverable: true
                },
                tooltip: {
                    show: true,
                    content: "Distance: %x | Elevation: %y",
                    cssClass: "flotTip",
                    shifts: {
                        x: -25,
                        y: -60
                    }
                },
                xaxis: {
                    axisLabel: 'Distance (km)',
                    axisLabelUseCanvas: false,
                    axisLabelFontSizePixels: 20
                },
                yaxis: {
                    axisLabel: 'Elevation (m)',
                    axisLabelUseCanvas: false,
                    axisLabelFontSizePixels: 20
                },
                zoom: {
                    interactive: true
                },
                pan: {
                    interactive: true
                }
            });
        };

        return MeasureToolPlanet;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('gui/DistanceNavigationView',["jquery"],
    function ($) {

        var mizarWidgetAPI = null;
        var opts = null;
        var elt = null;
        var distanceDivHTML = "<input type=\"submit\" id=\"distanceButtom\" value=\"\" /><div id=\"distTracker\"></div>";

        var _formatDistance = function(distance) {
            var dist;
            var unit;
            if(distance >= 10000) {
                dist = distance/1000.0;
                dist = dist.toFixed(1);
                unit = "Km";
            } else {
                dist = distance;
                dist = dist.toFixed(0);
                unit = "m";
            }
            return dist+" "+unit;
        };

        var _distanceEvent = function(distance) {
            var result;
            if(distance) {
                result = _formatDistance(distance);
            } else {
                result = "waiting ..."
            }
            document.getElementById(elt).innerHTML = result;
        };

        return {
            init: function (m, element, options) {
                opts = options;
                elt = element;
                mizarWidgetAPI = m;
                $(distanceDivHTML).appendTo("#distanceDiv");
                var ctx = mizarWidgetAPI.getContext();
                var initNav = ctx.getNavigation();
                var initDistance = initNav.getDistance();
                document.getElementById(elt).innerHTML = _formatDistance(initDistance);
                ctx.subscribe(mizarWidgetAPI.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE, _distanceEvent);
            },
            isInitialized: function() {
                return mizarWidgetAPI ? true : false
            },
            update : function(m) {
                this.unregisterEvents();
                mizarWidgetAPI = m;
                var ctx = mizarWidgetAPI.getContext();
                ctx.subscribe(mizarWidgetAPI.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE, _distanceEvent)
            },
            unregisterEvents: function() {
                if(mizarWidgetAPI) {
                    var ctx = mizarWidgetAPI.getContext();
                    ctx.unsubscribe(mizarWidgetAPI.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE, _distanceEvent);
                }
            },
            remove: function() {
                this.unregisterEvents();
                elt = null;
                opts = null;
                mizarWidgetAPI = null;
            }

        };

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool used to switch between 3D and 2D in planet mode
 * TODO Redondant avec 2D/3D dans background
 */

define('gui/SwitchTo2D',["jquery", "jquery.ui"],
    function ($) {

        var SwitchTo2D = function (options) {

            this.mizarWidgetAPI = options.mizar;

            var self = this;

            $('#switch2DButton').on('click', function () {
                self.toggle2DSwitch();
            }).hover(function () {
                $(this).animate({left: '-10px'}, 100);
            }, function () {
                $(this).animate({left: '-20px'}, 100);
            });
        };

        /**********************************************************************************************/

        /**
         *    Switch between modes
         */
        SwitchTo2D.prototype.toggle2DSwitch = function () {
            this.mizarWidgetAPI.toggleDimension();
            $('#switch2DButton').toggleClass('selected');
        };

        /**************************************************************************************************************/

        return SwitchTo2D;

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to select areas on planet
 */

define('gui/ExportTool',["jquery", "underscore-min", "./PickingManager"],
    function ($, _, PickingManager) {


        /**
         *    @constructor
         *    @param options Configuration options
         *        <ul>
         *            <li>planet: planet</li>
         *            <li>navigation: Navigation</li>
         *            <li>onselect: On selection callback</li>
         *            <li>style: Selection tool style</li>
         *        </ul>
         */

        //var layerServiceOption = _.template('<div class="addLayer_<%=layerName%>" style="padding:2px;" name="<%=layerName%>">' +
        //    '<button class="layerServices ui-button ui-widget ui-state-default ui-corner-all ui-button-icon-only">' +
        //    '<span class="ui-button-icon-primary ui-icon ui-icon-wrench"></span>' +
        //    '<span class="ui-button-text">Available services</span>' +
        //    '</button>' +
        //    ' <label title="<%=layerDescription%>" ><%=layer.name%></label></div>');

        var layerServiceOption = _.template('<div class="addLayer_<%=layerName%>" style="padding:2px;" name="<%=layerName%>">' +
            '<input id="<%=layer.layerId%>" type="checkbox" class="ui-checkbox"/>' +
            ' <label title="<%=layerDescription%>" ><%=layer.name%></label></div>');

        var self, navigation, selectionTool, layers, availableLayers, mizarWidgetAPI, exportToolCore;

        var ExportTool = function (options) {
            // Required options
            mizarWidgetAPI = options.mizar;
            navigation = mizarWidgetAPI.getNavigation();
            self = this;
            exportToolCore = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.ExportTool);
            exportToolCore.init(mizarWidgetAPI.getMizarAPI(), options);

            this.activated = false;
            this.renderContext = mizarWidgetAPI.getRenderContext();
            this.coordinateSystem = mizarWidgetAPI.getCrs();

            $('#exportInvoker').on('click', function () {
                self.toggle();
            }).hover(function () {
                $(this).animate({left: '-10px'}, 100);
            }, function () {
                $(this).animate({left: '-20px'}, 100);
            });
        };

        /**************************************************************************************************************/

        /**
         *    Activate/deactivate the tool
         */
        ExportTool.prototype.toggle = function () {
            this.activated = !this.activated;

            if (this.activated)
                this.activate();
            else
                this.deactivate();

            $('#exportInvoker').toggleClass('selected');
        };

        /**************************************************************************************************************/

        ExportTool.prototype.activate = function () {
            $(this.renderContext.canvas).css('cursor', 'url(css/images/selectionCursor.png)');

            $('#GlobWebCanvas').css('cursor', 'crosshair');

            mizarWidgetAPI.getContext().hideComponents(["exportContainer"]);

            $('#rightTopPopup').append('<p class="zoneToExport">Draw a zone to export</p>');
            $('#rightTopPopup').dialog({
                draggable: false,
                resizable: false,
                width: 280,
                maxHeight: 400,
                dialogClass: 'popupService noTitlePopup',
                position: {
                    my: "right top",
                    at: "right top",
                    of: window
                }
            });

            PickingManager.deactivate();
            navigation.stop();

            selectionTool = mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.SelectionTool, {
                ctx: mizarWidgetAPI.getContext(),
                activated: true,
                onselect: function (coordinates) {
                    $('.cutOutService').slideDown();
                    availableLayers = exportToolCore.filterServicesAvailableOnLayers();
                    self.displayAvailableServices();

                    self.coordinates = coordinates;

                    // Activate picking events
                    $(self.renderContext.canvas).css('cursor', 'default');
                    $('#GlobWebCanvas').css('cursor', 'default');
                    $('#exportToolBtn').on('click', self.coordinates, exportToolCore.exportSelection);

                    PickingManager.activate();
                    navigation.start();
                    selectionTool.toggle();
                }
            });
        };

        /**************************************************************************************************************/

        ExportTool.prototype.deactivate = function () {
            $(this.renderContext.canvas).css('cursor', 'default');
            $('#GlobWebCanvas').css('cursor', 'default');

            mizarWidgetAPI.getContext().showComponents();

            $('#rightTopPopup').empty().dialog('close');

            PickingManager.activate();
            navigation.start();
            selectionTool.clear();
        };

        /**************************************************************************************************************/

        /**
         *    Display available services from layers in the middle top popup
         */
        ExportTool.prototype.displayAvailableServices = function () {

            $('#rightTopPopup').empty();
            $('#rightTopPopup').append('<p>Select from available layers to export images/data : </p>');


            _.each(availableLayers, function (layer) {

                var layerHtml = layerServiceOption({
                    layerName: layer.layerId,
                    layerDescription: layer.description,
                    layer: layer
                });
                $('#rightTopPopup').append(layerHtml);

                $("." + layer.layerId).data("layer", layer);

            });

            $('#rightTopPopup').append('<button id="exportToolBtn" class="ui-button ui-widget ui-state-default ui-corner-all">Export Selection</button>');
        };

        /**************************************************************************************************************/

        return ExportTool;

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Share url module : creating url with current navigation properties
 */
define('service/ShareCore',["jquery", "gui/dialog/ErrorDialog"],
    function ($, ErrorDialog) {

        // Globals
        var mizarWidgetAPI;
        var navigation;
        var baseUrl;

        /**
         *    Generate url with current navigation parameters as : fov, eye, visibility, rotation(TODO)
         */
        function generateURL() {
            var url = window.document.documentURI;

            var splitEndIndex = url.search(/[&|?]sharedParameters=/);
            // If url is almost a shared link
            if (splitEndIndex !== -1) {
                // Cut it
                url = url.substr(0, splitEndIndex);
            }

            var splitIndex = url.indexOf("?conf=");
            if (splitIndex !== -1) {
                // If configuration is defined by SiTools2
                if (url !== 'undefined' && url !== '') {
                    url += "&";
                }
                else {
                    // Cut 'undefined'
                    url = url.substr(0, splitIndex);
                    url += "?";
                }
            }
            else {
                url += "?";
            }

            // Get navigation parameters
            var geo = [];
            mizarWidgetAPI.getCrs().getWorldFrom3D(navigation.center3d, geo);

            // Get layer visibility parameters
            var currentLayers = mizarWidgetAPI.getLayers(mizarWidgetAPI.CONTEXT.Sky);
            var visibility = {};
            for (var i = 0; i < currentLayers.length; i++) {
                visibility[currentLayers[i].name] = currentLayers[i].isVisible();
            }

            // Create shared parameters object to concat
            var sharedParameters = {
                initTarget: geo,
                fov: navigation.renderContext.fov,
                visibility: visibility,
                up: navigation.up
            };

            if (baseUrl) {
                // Use SiTools shortener plugin
                $.ajax({
                    type: "POST",
                    url: baseUrl,
                    async: false,
                    data: {context: JSON.stringify(sharedParameters)},
                    success: function (response) {
                        url += 'sharedParameters=' + response;
                    },
                    error: function (thrownError) {
                        ErrorDialog.open("Shortener service: " + thrownError.statusText);
                        console.error(thrownError);
                    }
                });
            }
            else {
                // No shortener plugin, stringify shared parameters
                url += "sharedParameters=" + JSON.stringify(sharedParameters);
            }

            return url;
        }

        function init(options) {
            mizarWidgetAPI = options.mizar;
            navigation = mizarWidgetAPI.getNavigation();
            if (options.configuration.hasOwnProperty('shortener')) {
                baseUrl = options.configuration.shortener.baseUrl;
            }
        }

        return {
            init: init,
            generateURL : generateURL
        };

    });

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Share url module : creating url with current navigation properties
 */
define('service/Share',["jquery", "service/ShareCore"],
    function ($, ShareCore) {

        /**
         * Init share mode
         * @param {Object} options configuration for Sharing module
         * @param {Object} options.mizar mizar API
         * @param {Object} options.configuration configuration for Share mode
         * @param {Object} options.configuration.shortener service end point for Sharing module
         * @param {Object} options.navigation TO BE REMOVED
         */
        function init(options) {

            ShareCore.init(options);

            $('#share').on('click', function () {
                var url = ShareCore.generateURL();
                $('#shareInput').val(url);
                $(this).fadeOut(300, function () {
                    $(this).next().fadeIn();
                    $('#shareInput').select();
                });
            });

            $('#shareClear').on('click', function () {
                $(this).parent().fadeOut(300, function () {
                    $("#share").fadeIn();
                });
            });

            $('#share').hover(function () {
                $(this).animate({left: '-10px'}, 100);
            }, function () {
                $(this).animate({left: '-20px'}, 100);
            });
        }

        return {
            init: init
        };

    });

/* Javascript plotting library for jQuery, version 0.8.3.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

*/
(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return"rgb("+[o.r,o.g,o.b].join(",")+")"}else{return"rgba("+[o.r,o.g,o.b,o.a].join(",")+")"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=""&&c!="transparent")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),"body"));if(c=="rgba(0, 0, 0, 0)")c="transparent";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name=="transparent")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);(function($){var hasOwnProperty=Object.prototype.hasOwnProperty;if(!$.fn.detach){$.fn.detach=function(){return this.each(function(){if(this.parentNode){this.parentNode.removeChild(this)}})}}function Canvas(cls,container){var element=container.children("."+cls)[0];if(element==null){element=document.createElement("canvas");element.className=cls;$(element).css({direction:"ltr",position:"absolute",left:0,top:0}).appendTo(container);if(!element.getContext){if(window.G_vmlCanvasManager){element=window.G_vmlCanvasManager.initElement(element)}else{throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.")}}}this.element=element;var context=this.context=element.getContext("2d");var devicePixelRatio=window.devicePixelRatio||1,backingStoreRatio=context.webkitBackingStorePixelRatio||context.mozBackingStorePixelRatio||context.msBackingStorePixelRatio||context.oBackingStorePixelRatio||context.backingStorePixelRatio||1;this.pixelRatio=devicePixelRatio/backingStoreRatio;this.resize(container.width(),container.height());this.textContainer=null;this.text={};this._textCache={}}Canvas.prototype.resize=function(width,height){if(width<=0||height<=0){throw new Error("Invalid dimensions for plot, width = "+width+", height = "+height)}var element=this.element,context=this.context,pixelRatio=this.pixelRatio;if(this.width!=width){element.width=width*pixelRatio;element.style.width=width+"px";this.width=width}if(this.height!=height){element.height=height*pixelRatio;element.style.height=height+"px";this.height=height}context.restore();context.save();context.scale(pixelRatio,pixelRatio)};Canvas.prototype.clear=function(){this.context.clearRect(0,0,this.width,this.height)};Canvas.prototype.render=function(){var cache=this._textCache;for(var layerKey in cache){if(hasOwnProperty.call(cache,layerKey)){var layer=this.getTextLayer(layerKey),layerCache=cache[layerKey];layer.hide();for(var styleKey in layerCache){if(hasOwnProperty.call(layerCache,styleKey)){var styleCache=layerCache[styleKey];for(var key in styleCache){if(hasOwnProperty.call(styleCache,key)){var positions=styleCache[key].positions;for(var i=0,position;position=positions[i];i++){if(position.active){if(!position.rendered){layer.append(position.element);position.rendered=true}}else{positions.splice(i--,1);if(position.rendered){position.element.detach()}}}if(positions.length==0){delete styleCache[key]}}}}}layer.show()}}};Canvas.prototype.getTextLayer=function(classes){var layer=this.text[classes];if(layer==null){if(this.textContainer==null){this.textContainer=$("<div class='flot-text'></div>").css({position:"absolute",top:0,left:0,bottom:0,right:0,"font-size":"smaller",color:"#545454"}).insertAfter(this.element)}layer=this.text[classes]=$("<div></div>").addClass(classes).css({position:"absolute",top:0,left:0,bottom:0,right:0}).appendTo(this.textContainer)}return layer};Canvas.prototype.getTextInfo=function(layer,text,font,angle,width){var textStyle,layerCache,styleCache,info;text=""+text;if(typeof font==="object"){textStyle=font.style+" "+font.variant+" "+font.weight+" "+font.size+"px/"+font.lineHeight+"px "+font.family}else{textStyle=font}layerCache=this._textCache[layer];if(layerCache==null){layerCache=this._textCache[layer]={}}styleCache=layerCache[textStyle];if(styleCache==null){styleCache=layerCache[textStyle]={}}info=styleCache[text];if(info==null){var element=$("<div></div>").html(text).css({position:"absolute","max-width":width,top:-9999}).appendTo(this.getTextLayer(layer));if(typeof font==="object"){element.css({font:textStyle,color:font.color})}else if(typeof font==="string"){element.addClass(font)}info=styleCache[text]={width:element.outerWidth(true),height:element.outerHeight(true),element:element,positions:[]};element.detach()}return info};Canvas.prototype.addText=function(layer,x,y,text,font,angle,width,halign,valign){var info=this.getTextInfo(layer,text,font,angle,width),positions=info.positions;if(halign=="center"){x-=info.width/2}else if(halign=="right"){x-=info.width}if(valign=="middle"){y-=info.height/2}else if(valign=="bottom"){y-=info.height}for(var i=0,position;position=positions[i];i++){if(position.x==x&&position.y==y){position.active=true;return}}position={active:true,rendered:false,element:positions.length?info.element.clone():info.element,x:x,y:y};positions.push(position);position.element.css({top:Math.round(y),left:Math.round(x),"text-align":halign})};Canvas.prototype.removeText=function(layer,x,y,text,font,angle){if(text==null){var layerCache=this._textCache[layer];if(layerCache!=null){for(var styleKey in layerCache){if(hasOwnProperty.call(layerCache,styleKey)){var styleCache=layerCache[styleKey];for(var key in styleCache){if(hasOwnProperty.call(styleCache,key)){var positions=styleCache[key].positions;for(var i=0,position;position=positions[i];i++){position.active=false}}}}}}}else{var positions=this.getTextInfo(layer,text,font,angle).positions;for(var i=0,position;position=positions[i];i++){if(position.x==x&&position.y==y){position.active=false}}}};function Plot(placeholder,data_,options_,plugins){var series=[],options={colors:["#edc240","#afd8f8","#cb4b4b","#4da74d","#9440ed"],legend:{show:true,noColumns:1,labelFormatter:null,labelBoxBorderColor:"#ccc",container:null,position:"ne",margin:5,backgroundColor:null,backgroundOpacity:.85,sorted:null},xaxis:{show:null,position:"bottom",mode:null,font:null,color:null,tickColor:null,transform:null,inverseTransform:null,min:null,max:null,autoscaleMargin:null,ticks:null,tickFormatter:null,labelWidth:null,labelHeight:null,reserveSpace:null,tickLength:null,alignTicksWithAxis:null,tickDecimals:null,tickSize:null,minTickSize:null},yaxis:{autoscaleMargin:.02,position:"left"},xaxes:[],yaxes:[],series:{points:{show:false,radius:3,lineWidth:2,fill:true,fillColor:"#ffffff",symbol:"circle"},lines:{lineWidth:2,fill:false,fillColor:null,steps:false},bars:{show:false,lineWidth:2,barWidth:1,fill:true,fillColor:null,align:"left",horizontal:false,zero:true},shadowSize:3,highlightColor:null},grid:{show:true,aboveData:false,color:"#545454",backgroundColor:null,borderColor:null,tickColor:null,margin:0,labelMargin:5,axisMargin:8,borderWidth:2,minBorderMargin:null,markings:null,markingsColor:"#f4f4f4",markingsLineWidth:2,clickable:false,hoverable:false,autoHighlight:true,mouseActiveRadius:10},interaction:{redrawOverlayInterval:1e3/60},hooks:{}},surface=null,overlay=null,eventHolder=null,ctx=null,octx=null,xaxes=[],yaxes=[],plotOffset={left:0,right:0,top:0,bottom:0},plotWidth=0,plotHeight=0,hooks={processOptions:[],processRawData:[],processDatapoints:[],processOffset:[],drawBackground:[],drawSeries:[],draw:[],bindEvents:[],drawOverlay:[],shutdown:[]},plot=this;plot.setData=setData;plot.setupGrid=setupGrid;plot.draw=draw;plot.getPlaceholder=function(){return placeholder};plot.getCanvas=function(){return surface.element};plot.getPlotOffset=function(){return plotOffset};plot.width=function(){return plotWidth};plot.height=function(){return plotHeight};plot.offset=function(){var o=eventHolder.offset();o.left+=plotOffset.left;o.top+=plotOffset.top;return o};plot.getData=function(){return series};plot.getAxes=function(){var res={},i;$.each(xaxes.concat(yaxes),function(_,axis){if(axis)res[axis.direction+(axis.n!=1?axis.n:"")+"axis"]=axis});return res};plot.getXAxes=function(){return xaxes};plot.getYAxes=function(){return yaxes};plot.c2p=canvasToAxisCoords;plot.p2c=axisToCanvasCoords;plot.getOptions=function(){return options};plot.highlight=highlight;plot.unhighlight=unhighlight;plot.triggerRedrawOverlay=triggerRedrawOverlay;plot.pointOffset=function(point){return{left:parseInt(xaxes[axisNumber(point,"x")-1].p2c(+point.x)+plotOffset.left,10),top:parseInt(yaxes[axisNumber(point,"y")-1].p2c(+point.y)+plotOffset.top,10)}};plot.shutdown=shutdown;plot.destroy=function(){shutdown();placeholder.removeData("plot").empty();series=[];options=null;surface=null;overlay=null;eventHolder=null;ctx=null;octx=null;xaxes=[];yaxes=[];hooks=null;highlights=[];plot=null};plot.resize=function(){var width=placeholder.width(),height=placeholder.height();surface.resize(width,height);overlay.resize(width,height)};plot.hooks=hooks;initPlugins(plot);parseOptions(options_);setupCanvases();setData(data_);setupGrid();draw();bindEvents();function executeHooks(hook,args){args=[plot].concat(args);for(var i=0;i<hook.length;++i)hook[i].apply(this,args)}function initPlugins(){var classes={Canvas:Canvas};for(var i=0;i<plugins.length;++i){var p=plugins[i];p.init(plot,classes);if(p.options)$.extend(true,options,p.options)}}function parseOptions(opts){$.extend(true,options,opts);if(opts&&opts.colors){options.colors=opts.colors}if(options.xaxis.color==null)options.xaxis.color=$.color.parse(options.grid.color).scale("a",.22).toString();if(options.yaxis.color==null)options.yaxis.color=$.color.parse(options.grid.color).scale("a",.22).toString();if(options.xaxis.tickColor==null)options.xaxis.tickColor=options.grid.tickColor||options.xaxis.color;if(options.yaxis.tickColor==null)options.yaxis.tickColor=options.grid.tickColor||options.yaxis.color;if(options.grid.borderColor==null)options.grid.borderColor=options.grid.color;if(options.grid.tickColor==null)options.grid.tickColor=$.color.parse(options.grid.color).scale("a",.22).toString();var i,axisOptions,axisCount,fontSize=placeholder.css("font-size"),fontSizeDefault=fontSize?+fontSize.replace("px",""):13,fontDefaults={style:placeholder.css("font-style"),size:Math.round(.8*fontSizeDefault),variant:placeholder.css("font-variant"),weight:placeholder.css("font-weight"),family:placeholder.css("font-family")};axisCount=options.xaxes.length||1;for(i=0;i<axisCount;++i){axisOptions=options.xaxes[i];if(axisOptions&&!axisOptions.tickColor){axisOptions.tickColor=axisOptions.color}axisOptions=$.extend(true,{},options.xaxis,axisOptions);options.xaxes[i]=axisOptions;if(axisOptions.font){axisOptions.font=$.extend({},fontDefaults,axisOptions.font);if(!axisOptions.font.color){axisOptions.font.color=axisOptions.color}if(!axisOptions.font.lineHeight){axisOptions.font.lineHeight=Math.round(axisOptions.font.size*1.15)}}}axisCount=options.yaxes.length||1;for(i=0;i<axisCount;++i){axisOptions=options.yaxes[i];if(axisOptions&&!axisOptions.tickColor){axisOptions.tickColor=axisOptions.color}axisOptions=$.extend(true,{},options.yaxis,axisOptions);options.yaxes[i]=axisOptions;if(axisOptions.font){axisOptions.font=$.extend({},fontDefaults,axisOptions.font);if(!axisOptions.font.color){axisOptions.font.color=axisOptions.color}if(!axisOptions.font.lineHeight){axisOptions.font.lineHeight=Math.round(axisOptions.font.size*1.15)}}}if(options.xaxis.noTicks&&options.xaxis.ticks==null)options.xaxis.ticks=options.xaxis.noTicks;if(options.yaxis.noTicks&&options.yaxis.ticks==null)options.yaxis.ticks=options.yaxis.noTicks;if(options.x2axis){options.xaxes[1]=$.extend(true,{},options.xaxis,options.x2axis);options.xaxes[1].position="top";if(options.x2axis.min==null){options.xaxes[1].min=null}if(options.x2axis.max==null){options.xaxes[1].max=null}}if(options.y2axis){options.yaxes[1]=$.extend(true,{},options.yaxis,options.y2axis);options.yaxes[1].position="right";if(options.y2axis.min==null){options.yaxes[1].min=null}if(options.y2axis.max==null){options.yaxes[1].max=null}}if(options.grid.coloredAreas)options.grid.markings=options.grid.coloredAreas;if(options.grid.coloredAreasColor)options.grid.markingsColor=options.grid.coloredAreasColor;if(options.lines)$.extend(true,options.series.lines,options.lines);if(options.points)$.extend(true,options.series.points,options.points);if(options.bars)$.extend(true,options.series.bars,options.bars);if(options.shadowSize!=null)options.series.shadowSize=options.shadowSize;if(options.highlightColor!=null)options.series.highlightColor=options.highlightColor;for(i=0;i<options.xaxes.length;++i)getOrCreateAxis(xaxes,i+1).options=options.xaxes[i];for(i=0;i<options.yaxes.length;++i)getOrCreateAxis(yaxes,i+1).options=options.yaxes[i];for(var n in hooks)if(options.hooks[n]&&options.hooks[n].length)hooks[n]=hooks[n].concat(options.hooks[n]);executeHooks(hooks.processOptions,[options])}function setData(d){series=parseData(d);fillInSeriesOptions();processData()}function parseData(d){var res=[];for(var i=0;i<d.length;++i){var s=$.extend(true,{},options.series);if(d[i].data!=null){s.data=d[i].data;delete d[i].data;$.extend(true,s,d[i]);d[i].data=s.data}else s.data=d[i];res.push(s)}return res}function axisNumber(obj,coord){var a=obj[coord+"axis"];if(typeof a=="object")a=a.n;if(typeof a!="number")a=1;return a}function allAxes(){return $.grep(xaxes.concat(yaxes),function(a){return a})}function canvasToAxisCoords(pos){var res={},i,axis;for(i=0;i<xaxes.length;++i){axis=xaxes[i];if(axis&&axis.used)res["x"+axis.n]=axis.c2p(pos.left)}for(i=0;i<yaxes.length;++i){axis=yaxes[i];if(axis&&axis.used)res["y"+axis.n]=axis.c2p(pos.top)}if(res.x1!==undefined)res.x=res.x1;if(res.y1!==undefined)res.y=res.y1;return res}function axisToCanvasCoords(pos){var res={},i,axis,key;for(i=0;i<xaxes.length;++i){axis=xaxes[i];if(axis&&axis.used){key="x"+axis.n;if(pos[key]==null&&axis.n==1)key="x";if(pos[key]!=null){res.left=axis.p2c(pos[key]);break}}}for(i=0;i<yaxes.length;++i){axis=yaxes[i];if(axis&&axis.used){key="y"+axis.n;if(pos[key]==null&&axis.n==1)key="y";if(pos[key]!=null){res.top=axis.p2c(pos[key]);break}}}return res}function getOrCreateAxis(axes,number){if(!axes[number-1])axes[number-1]={n:number,direction:axes==xaxes?"x":"y",options:$.extend(true,{},axes==xaxes?options.xaxis:options.yaxis)};return axes[number-1]}function fillInSeriesOptions(){var neededColors=series.length,maxIndex=-1,i;for(i=0;i<series.length;++i){var sc=series[i].color;if(sc!=null){neededColors--;if(typeof sc=="number"&&sc>maxIndex){maxIndex=sc}}}if(neededColors<=maxIndex){neededColors=maxIndex+1}var c,colors=[],colorPool=options.colors,colorPoolSize=colorPool.length,variation=0;for(i=0;i<neededColors;i++){c=$.color.parse(colorPool[i%colorPoolSize]||"#666");if(i%colorPoolSize==0&&i){if(variation>=0){if(variation<.5){variation=-variation-.2}else variation=0}else variation=-variation}colors[i]=c.scale("rgb",1+variation)}var colori=0,s;for(i=0;i<series.length;++i){s=series[i];if(s.color==null){s.color=colors[colori].toString();++colori}else if(typeof s.color=="number")s.color=colors[s.color].toString();if(s.lines.show==null){var v,show=true;for(v in s)if(s[v]&&s[v].show){show=false;break}if(show)s.lines.show=true}if(s.lines.zero==null){s.lines.zero=!!s.lines.fill}s.xaxis=getOrCreateAxis(xaxes,axisNumber(s,"x"));s.yaxis=getOrCreateAxis(yaxes,axisNumber(s,"y"))}}function processData(){var topSentry=Number.POSITIVE_INFINITY,bottomSentry=Number.NEGATIVE_INFINITY,fakeInfinity=Number.MAX_VALUE,i,j,k,m,length,s,points,ps,x,y,axis,val,f,p,data,format;function updateAxis(axis,min,max){if(min<axis.datamin&&min!=-fakeInfinity)axis.datamin=min;if(max>axis.datamax&&max!=fakeInfinity)axis.datamax=max}$.each(allAxes(),function(_,axis){axis.datamin=topSentry;axis.datamax=bottomSentry;axis.used=false});for(i=0;i<series.length;++i){s=series[i];s.datapoints={points:[]};executeHooks(hooks.processRawData,[s,s.data,s.datapoints])}for(i=0;i<series.length;++i){s=series[i];data=s.data;format=s.datapoints.format;if(!format){format=[];format.push({x:true,number:true,required:true});format.push({y:true,number:true,required:true});if(s.bars.show||s.lines.show&&s.lines.fill){var autoscale=!!(s.bars.show&&s.bars.zero||s.lines.show&&s.lines.zero);format.push({y:true,number:true,required:false,defaultValue:0,autoscale:autoscale});if(s.bars.horizontal){delete format[format.length-1].y;format[format.length-1].x=true}}s.datapoints.format=format}if(s.datapoints.pointsize!=null)continue;s.datapoints.pointsize=format.length;ps=s.datapoints.pointsize;points=s.datapoints.points;var insertSteps=s.lines.show&&s.lines.steps;s.xaxis.used=s.yaxis.used=true;for(j=k=0;j<data.length;++j,k+=ps){p=data[j];var nullify=p==null;if(!nullify){for(m=0;m<ps;++m){val=p[m];f=format[m];if(f){if(f.number&&val!=null){val=+val;if(isNaN(val))val=null;else if(val==Infinity)val=fakeInfinity;else if(val==-Infinity)val=-fakeInfinity}if(val==null){if(f.required)nullify=true;if(f.defaultValue!=null)val=f.defaultValue}}points[k+m]=val}}if(nullify){for(m=0;m<ps;++m){val=points[k+m];if(val!=null){f=format[m];if(f.autoscale!==false){if(f.x){updateAxis(s.xaxis,val,val)}if(f.y){updateAxis(s.yaxis,val,val)}}}points[k+m]=null}}else{if(insertSteps&&k>0&&points[k-ps]!=null&&points[k-ps]!=points[k]&&points[k-ps+1]!=points[k+1]){for(m=0;m<ps;++m)points[k+ps+m]=points[k+m];points[k+1]=points[k-ps+1];k+=ps}}}}for(i=0;i<series.length;++i){s=series[i];executeHooks(hooks.processDatapoints,[s,s.datapoints])}for(i=0;i<series.length;++i){s=series[i];points=s.datapoints.points;ps=s.datapoints.pointsize;format=s.datapoints.format;var xmin=topSentry,ymin=topSentry,xmax=bottomSentry,ymax=bottomSentry;for(j=0;j<points.length;j+=ps){if(points[j]==null)continue;for(m=0;m<ps;++m){val=points[j+m];f=format[m];if(!f||f.autoscale===false||val==fakeInfinity||val==-fakeInfinity)continue;if(f.x){if(val<xmin)xmin=val;if(val>xmax)xmax=val}if(f.y){if(val<ymin)ymin=val;if(val>ymax)ymax=val}}}if(s.bars.show){var delta;switch(s.bars.align){case"left":delta=0;break;case"right":delta=-s.bars.barWidth;break;default:delta=-s.bars.barWidth/2}if(s.bars.horizontal){ymin+=delta;ymax+=delta+s.bars.barWidth}else{xmin+=delta;xmax+=delta+s.bars.barWidth}}updateAxis(s.xaxis,xmin,xmax);updateAxis(s.yaxis,ymin,ymax)}$.each(allAxes(),function(_,axis){if(axis.datamin==topSentry)axis.datamin=null;if(axis.datamax==bottomSentry)axis.datamax=null})}function setupCanvases(){placeholder.css("padding",0).children().filter(function(){return!$(this).hasClass("flot-overlay")&&!$(this).hasClass("flot-base")}).remove();if(placeholder.css("position")=="static")placeholder.css("position","relative");surface=new Canvas("flot-base",placeholder);overlay=new Canvas("flot-overlay",placeholder);ctx=surface.context;octx=overlay.context;eventHolder=$(overlay.element).unbind();var existing=placeholder.data("plot");if(existing){existing.shutdown();overlay.clear()}placeholder.data("plot",plot)}function bindEvents(){if(options.grid.hoverable){eventHolder.mousemove(onMouseMove);eventHolder.bind("mouseleave",onMouseLeave)}if(options.grid.clickable)eventHolder.click(onClick);executeHooks(hooks.bindEvents,[eventHolder])}function shutdown(){if(redrawTimeout)clearTimeout(redrawTimeout);eventHolder.unbind("mousemove",onMouseMove);eventHolder.unbind("mouseleave",onMouseLeave);eventHolder.unbind("click",onClick);executeHooks(hooks.shutdown,[eventHolder])}function setTransformationHelpers(axis){function identity(x){return x}var s,m,t=axis.options.transform||identity,it=axis.options.inverseTransform;if(axis.direction=="x"){s=axis.scale=plotWidth/Math.abs(t(axis.max)-t(axis.min));m=Math.min(t(axis.max),t(axis.min))}else{s=axis.scale=plotHeight/Math.abs(t(axis.max)-t(axis.min));s=-s;m=Math.max(t(axis.max),t(axis.min))}if(t==identity)axis.p2c=function(p){return(p-m)*s};else axis.p2c=function(p){return(t(p)-m)*s};if(!it)axis.c2p=function(c){return m+c/s};else axis.c2p=function(c){return it(m+c/s)}}function measureTickLabels(axis){var opts=axis.options,ticks=axis.ticks||[],labelWidth=opts.labelWidth||0,labelHeight=opts.labelHeight||0,maxWidth=labelWidth||(axis.direction=="x"?Math.floor(surface.width/(ticks.length||1)):null),legacyStyles=axis.direction+"Axis "+axis.direction+axis.n+"Axis",layer="flot-"+axis.direction+"-axis flot-"+axis.direction+axis.n+"-axis "+legacyStyles,font=opts.font||"flot-tick-label tickLabel";for(var i=0;i<ticks.length;++i){var t=ticks[i];if(!t.label)continue;var info=surface.getTextInfo(layer,t.label,font,null,maxWidth);labelWidth=Math.max(labelWidth,info.width);labelHeight=Math.max(labelHeight,info.height)}axis.labelWidth=opts.labelWidth||labelWidth;axis.labelHeight=opts.labelHeight||labelHeight}function allocateAxisBoxFirstPhase(axis){var lw=axis.labelWidth,lh=axis.labelHeight,pos=axis.options.position,isXAxis=axis.direction==="x",tickLength=axis.options.tickLength,axisMargin=options.grid.axisMargin,padding=options.grid.labelMargin,innermost=true,outermost=true,first=true,found=false;$.each(isXAxis?xaxes:yaxes,function(i,a){if(a&&(a.show||a.reserveSpace)){if(a===axis){found=true}else if(a.options.position===pos){if(found){outermost=false}else{innermost=false}}if(!found){first=false}}});if(outermost){axisMargin=0}if(tickLength==null){tickLength=first?"full":5}if(!isNaN(+tickLength))padding+=+tickLength;if(isXAxis){lh+=padding;if(pos=="bottom"){plotOffset.bottom+=lh+axisMargin;axis.box={top:surface.height-plotOffset.bottom,height:lh}}else{axis.box={top:plotOffset.top+axisMargin,height:lh};plotOffset.top+=lh+axisMargin}}else{lw+=padding;if(pos=="left"){axis.box={left:plotOffset.left+axisMargin,width:lw};plotOffset.left+=lw+axisMargin}else{plotOffset.right+=lw+axisMargin;axis.box={left:surface.width-plotOffset.right,width:lw}}}axis.position=pos;axis.tickLength=tickLength;axis.box.padding=padding;axis.innermost=innermost}function allocateAxisBoxSecondPhase(axis){if(axis.direction=="x"){axis.box.left=plotOffset.left-axis.labelWidth/2;axis.box.width=surface.width-plotOffset.left-plotOffset.right+axis.labelWidth}else{axis.box.top=plotOffset.top-axis.labelHeight/2;axis.box.height=surface.height-plotOffset.bottom-plotOffset.top+axis.labelHeight}}function adjustLayoutForThingsStickingOut(){var minMargin=options.grid.minBorderMargin,axis,i;if(minMargin==null){minMargin=0;for(i=0;i<series.length;++i)minMargin=Math.max(minMargin,2*(series[i].points.radius+series[i].points.lineWidth/2))}var margins={left:minMargin,right:minMargin,top:minMargin,bottom:minMargin};$.each(allAxes(),function(_,axis){if(axis.reserveSpace&&axis.ticks&&axis.ticks.length){if(axis.direction==="x"){margins.left=Math.max(margins.left,axis.labelWidth/2);margins.right=Math.max(margins.right,axis.labelWidth/2)}else{margins.bottom=Math.max(margins.bottom,axis.labelHeight/2);margins.top=Math.max(margins.top,axis.labelHeight/2)}}});plotOffset.left=Math.ceil(Math.max(margins.left,plotOffset.left));plotOffset.right=Math.ceil(Math.max(margins.right,plotOffset.right));plotOffset.top=Math.ceil(Math.max(margins.top,plotOffset.top));plotOffset.bottom=Math.ceil(Math.max(margins.bottom,plotOffset.bottom))}function setupGrid(){var i,axes=allAxes(),showGrid=options.grid.show;for(var a in plotOffset){var margin=options.grid.margin||0;plotOffset[a]=typeof margin=="number"?margin:margin[a]||0}executeHooks(hooks.processOffset,[plotOffset]);for(var a in plotOffset){if(typeof options.grid.borderWidth=="object"){plotOffset[a]+=showGrid?options.grid.borderWidth[a]:0}else{plotOffset[a]+=showGrid?options.grid.borderWidth:0}}$.each(axes,function(_,axis){var axisOpts=axis.options;axis.show=axisOpts.show==null?axis.used:axisOpts.show;axis.reserveSpace=axisOpts.reserveSpace==null?axis.show:axisOpts.reserveSpace;setRange(axis)});if(showGrid){var allocatedAxes=$.grep(axes,function(axis){return axis.show||axis.reserveSpace});$.each(allocatedAxes,function(_,axis){setupTickGeneration(axis);setTicks(axis);snapRangeToTicks(axis,axis.ticks);measureTickLabels(axis)});for(i=allocatedAxes.length-1;i>=0;--i)allocateAxisBoxFirstPhase(allocatedAxes[i]);adjustLayoutForThingsStickingOut();$.each(allocatedAxes,function(_,axis){allocateAxisBoxSecondPhase(axis)})}plotWidth=surface.width-plotOffset.left-plotOffset.right;plotHeight=surface.height-plotOffset.bottom-plotOffset.top;$.each(axes,function(_,axis){setTransformationHelpers(axis)});if(showGrid){drawAxisLabels()}insertLegend()}function setRange(axis){var opts=axis.options,min=+(opts.min!=null?opts.min:axis.datamin),max=+(opts.max!=null?opts.max:axis.datamax),delta=max-min;if(delta==0){var widen=max==0?1:.01;if(opts.min==null)min-=widen;if(opts.max==null||opts.min!=null)max+=widen}else{var margin=opts.autoscaleMargin;if(margin!=null){if(opts.min==null){min-=delta*margin;if(min<0&&axis.datamin!=null&&axis.datamin>=0)min=0}if(opts.max==null){max+=delta*margin;if(max>0&&axis.datamax!=null&&axis.datamax<=0)max=0}}}axis.min=min;axis.max=max}function setupTickGeneration(axis){var opts=axis.options;var noTicks;if(typeof opts.ticks=="number"&&opts.ticks>0)noTicks=opts.ticks;else noTicks=.3*Math.sqrt(axis.direction=="x"?surface.width:surface.height);var delta=(axis.max-axis.min)/noTicks,dec=-Math.floor(Math.log(delta)/Math.LN10),maxDec=opts.tickDecimals;if(maxDec!=null&&dec>maxDec){dec=maxDec}var magn=Math.pow(10,-dec),norm=delta/magn,size;if(norm<1.5){size=1}else if(norm<3){size=2;if(norm>2.25&&(maxDec==null||dec+1<=maxDec)){size=2.5;++dec}}else if(norm<7.5){size=5}else{size=10}size*=magn;if(opts.minTickSize!=null&&size<opts.minTickSize){size=opts.minTickSize}axis.delta=delta;axis.tickDecimals=Math.max(0,maxDec!=null?maxDec:dec);axis.tickSize=opts.tickSize||size;if(opts.mode=="time"&&!axis.tickGenerator){throw new Error("Time mode requires the flot.time plugin.")}if(!axis.tickGenerator){axis.tickGenerator=function(axis){var ticks=[],start=floorInBase(axis.min,axis.tickSize),i=0,v=Number.NaN,prev;do{prev=v;v=start+i*axis.tickSize;ticks.push(v);++i}while(v<axis.max&&v!=prev);return ticks};axis.tickFormatter=function(value,axis){var factor=axis.tickDecimals?Math.pow(10,axis.tickDecimals):1;var formatted=""+Math.round(value*factor)/factor;if(axis.tickDecimals!=null){var decimal=formatted.indexOf(".");var precision=decimal==-1?0:formatted.length-decimal-1;if(precision<axis.tickDecimals){return(precision?formatted:formatted+".")+(""+factor).substr(1,axis.tickDecimals-precision)}}return formatted}}if($.isFunction(opts.tickFormatter))axis.tickFormatter=function(v,axis){return""+opts.tickFormatter(v,axis)};if(opts.alignTicksWithAxis!=null){var otherAxis=(axis.direction=="x"?xaxes:yaxes)[opts.alignTicksWithAxis-1];if(otherAxis&&otherAxis.used&&otherAxis!=axis){var niceTicks=axis.tickGenerator(axis);if(niceTicks.length>0){if(opts.min==null)axis.min=Math.min(axis.min,niceTicks[0]);if(opts.max==null&&niceTicks.length>1)axis.max=Math.max(axis.max,niceTicks[niceTicks.length-1])}axis.tickGenerator=function(axis){var ticks=[],v,i;for(i=0;i<otherAxis.ticks.length;++i){v=(otherAxis.ticks[i].v-otherAxis.min)/(otherAxis.max-otherAxis.min);v=axis.min+v*(axis.max-axis.min);ticks.push(v)}return ticks};if(!axis.mode&&opts.tickDecimals==null){var extraDec=Math.max(0,-Math.floor(Math.log(axis.delta)/Math.LN10)+1),ts=axis.tickGenerator(axis);if(!(ts.length>1&&/\..*0$/.test((ts[1]-ts[0]).toFixed(extraDec))))axis.tickDecimals=extraDec}}}}function setTicks(axis){var oticks=axis.options.ticks,ticks=[];if(oticks==null||typeof oticks=="number"&&oticks>0)ticks=axis.tickGenerator(axis);else if(oticks){if($.isFunction(oticks))ticks=oticks(axis);else ticks=oticks}var i,v;axis.ticks=[];for(i=0;i<ticks.length;++i){var label=null;var t=ticks[i];if(typeof t=="object"){v=+t[0];if(t.length>1)label=t[1]}else v=+t;if(label==null)label=axis.tickFormatter(v,axis);if(!isNaN(v))axis.ticks.push({v:v,label:label})}}function snapRangeToTicks(axis,ticks){if(axis.options.autoscaleMargin&&ticks.length>0){if(axis.options.min==null)axis.min=Math.min(axis.min,ticks[0].v);if(axis.options.max==null&&ticks.length>1)axis.max=Math.max(axis.max,ticks[ticks.length-1].v)}}function draw(){surface.clear();executeHooks(hooks.drawBackground,[ctx]);var grid=options.grid;if(grid.show&&grid.backgroundColor)drawBackground();if(grid.show&&!grid.aboveData){drawGrid()}for(var i=0;i<series.length;++i){executeHooks(hooks.drawSeries,[ctx,series[i]]);drawSeries(series[i])}executeHooks(hooks.draw,[ctx]);if(grid.show&&grid.aboveData){drawGrid()}surface.render();triggerRedrawOverlay()}function extractRange(ranges,coord){var axis,from,to,key,axes=allAxes();for(var i=0;i<axes.length;++i){axis=axes[i];if(axis.direction==coord){key=coord+axis.n+"axis";if(!ranges[key]&&axis.n==1)key=coord+"axis";if(ranges[key]){from=ranges[key].from;to=ranges[key].to;break}}}if(!ranges[key]){axis=coord=="x"?xaxes[0]:yaxes[0];from=ranges[coord+"1"];to=ranges[coord+"2"]}if(from!=null&&to!=null&&from>to){var tmp=from;from=to;to=tmp}return{from:from,to:to,axis:axis}}function drawBackground(){ctx.save();ctx.translate(plotOffset.left,plotOffset.top);ctx.fillStyle=getColorOrGradient(options.grid.backgroundColor,plotHeight,0,"rgba(255, 255, 255, 0)");ctx.fillRect(0,0,plotWidth,plotHeight);ctx.restore()}function drawGrid(){var i,axes,bw,bc;ctx.save();ctx.translate(plotOffset.left,plotOffset.top);var markings=options.grid.markings;if(markings){if($.isFunction(markings)){axes=plot.getAxes();axes.xmin=axes.xaxis.min;axes.xmax=axes.xaxis.max;axes.ymin=axes.yaxis.min;axes.ymax=axes.yaxis.max;markings=markings(axes)}for(i=0;i<markings.length;++i){var m=markings[i],xrange=extractRange(m,"x"),yrange=extractRange(m,"y");if(xrange.from==null)xrange.from=xrange.axis.min;if(xrange.to==null)xrange.to=xrange.axis.max;
if(yrange.from==null)yrange.from=yrange.axis.min;if(yrange.to==null)yrange.to=yrange.axis.max;if(xrange.to<xrange.axis.min||xrange.from>xrange.axis.max||yrange.to<yrange.axis.min||yrange.from>yrange.axis.max)continue;xrange.from=Math.max(xrange.from,xrange.axis.min);xrange.to=Math.min(xrange.to,xrange.axis.max);yrange.from=Math.max(yrange.from,yrange.axis.min);yrange.to=Math.min(yrange.to,yrange.axis.max);var xequal=xrange.from===xrange.to,yequal=yrange.from===yrange.to;if(xequal&&yequal){continue}xrange.from=Math.floor(xrange.axis.p2c(xrange.from));xrange.to=Math.floor(xrange.axis.p2c(xrange.to));yrange.from=Math.floor(yrange.axis.p2c(yrange.from));yrange.to=Math.floor(yrange.axis.p2c(yrange.to));if(xequal||yequal){var lineWidth=m.lineWidth||options.grid.markingsLineWidth,subPixel=lineWidth%2?.5:0;ctx.beginPath();ctx.strokeStyle=m.color||options.grid.markingsColor;ctx.lineWidth=lineWidth;if(xequal){ctx.moveTo(xrange.to+subPixel,yrange.from);ctx.lineTo(xrange.to+subPixel,yrange.to)}else{ctx.moveTo(xrange.from,yrange.to+subPixel);ctx.lineTo(xrange.to,yrange.to+subPixel)}ctx.stroke()}else{ctx.fillStyle=m.color||options.grid.markingsColor;ctx.fillRect(xrange.from,yrange.to,xrange.to-xrange.from,yrange.from-yrange.to)}}}axes=allAxes();bw=options.grid.borderWidth;for(var j=0;j<axes.length;++j){var axis=axes[j],box=axis.box,t=axis.tickLength,x,y,xoff,yoff;if(!axis.show||axis.ticks.length==0)continue;ctx.lineWidth=1;if(axis.direction=="x"){x=0;if(t=="full")y=axis.position=="top"?0:plotHeight;else y=box.top-plotOffset.top+(axis.position=="top"?box.height:0)}else{y=0;if(t=="full")x=axis.position=="left"?0:plotWidth;else x=box.left-plotOffset.left+(axis.position=="left"?box.width:0)}if(!axis.innermost){ctx.strokeStyle=axis.options.color;ctx.beginPath();xoff=yoff=0;if(axis.direction=="x")xoff=plotWidth+1;else yoff=plotHeight+1;if(ctx.lineWidth==1){if(axis.direction=="x"){y=Math.floor(y)+.5}else{x=Math.floor(x)+.5}}ctx.moveTo(x,y);ctx.lineTo(x+xoff,y+yoff);ctx.stroke()}ctx.strokeStyle=axis.options.tickColor;ctx.beginPath();for(i=0;i<axis.ticks.length;++i){var v=axis.ticks[i].v;xoff=yoff=0;if(isNaN(v)||v<axis.min||v>axis.max||t=="full"&&(typeof bw=="object"&&bw[axis.position]>0||bw>0)&&(v==axis.min||v==axis.max))continue;if(axis.direction=="x"){x=axis.p2c(v);yoff=t=="full"?-plotHeight:t;if(axis.position=="top")yoff=-yoff}else{y=axis.p2c(v);xoff=t=="full"?-plotWidth:t;if(axis.position=="left")xoff=-xoff}if(ctx.lineWidth==1){if(axis.direction=="x")x=Math.floor(x)+.5;else y=Math.floor(y)+.5}ctx.moveTo(x,y);ctx.lineTo(x+xoff,y+yoff)}ctx.stroke()}if(bw){bc=options.grid.borderColor;if(typeof bw=="object"||typeof bc=="object"){if(typeof bw!=="object"){bw={top:bw,right:bw,bottom:bw,left:bw}}if(typeof bc!=="object"){bc={top:bc,right:bc,bottom:bc,left:bc}}if(bw.top>0){ctx.strokeStyle=bc.top;ctx.lineWidth=bw.top;ctx.beginPath();ctx.moveTo(0-bw.left,0-bw.top/2);ctx.lineTo(plotWidth,0-bw.top/2);ctx.stroke()}if(bw.right>0){ctx.strokeStyle=bc.right;ctx.lineWidth=bw.right;ctx.beginPath();ctx.moveTo(plotWidth+bw.right/2,0-bw.top);ctx.lineTo(plotWidth+bw.right/2,plotHeight);ctx.stroke()}if(bw.bottom>0){ctx.strokeStyle=bc.bottom;ctx.lineWidth=bw.bottom;ctx.beginPath();ctx.moveTo(plotWidth+bw.right,plotHeight+bw.bottom/2);ctx.lineTo(0,plotHeight+bw.bottom/2);ctx.stroke()}if(bw.left>0){ctx.strokeStyle=bc.left;ctx.lineWidth=bw.left;ctx.beginPath();ctx.moveTo(0-bw.left/2,plotHeight+bw.bottom);ctx.lineTo(0-bw.left/2,0);ctx.stroke()}}else{ctx.lineWidth=bw;ctx.strokeStyle=options.grid.borderColor;ctx.strokeRect(-bw/2,-bw/2,plotWidth+bw,plotHeight+bw)}}ctx.restore()}function drawAxisLabels(){$.each(allAxes(),function(_,axis){var box=axis.box,legacyStyles=axis.direction+"Axis "+axis.direction+axis.n+"Axis",layer="flot-"+axis.direction+"-axis flot-"+axis.direction+axis.n+"-axis "+legacyStyles,font=axis.options.font||"flot-tick-label tickLabel",tick,x,y,halign,valign;surface.removeText(layer);if(!axis.show||axis.ticks.length==0)return;for(var i=0;i<axis.ticks.length;++i){tick=axis.ticks[i];if(!tick.label||tick.v<axis.min||tick.v>axis.max)continue;if(axis.direction=="x"){halign="center";x=plotOffset.left+axis.p2c(tick.v);if(axis.position=="bottom"){y=box.top+box.padding}else{y=box.top+box.height-box.padding;valign="bottom"}}else{valign="middle";y=plotOffset.top+axis.p2c(tick.v);if(axis.position=="left"){x=box.left+box.width-box.padding;halign="right"}else{x=box.left+box.padding}}surface.addText(layer,x,y,tick.label,font,null,null,halign,valign)}})}function drawSeries(series){if(series.lines.show)drawSeriesLines(series);if(series.bars.show)drawSeriesBars(series);if(series.points.show)drawSeriesPoints(series)}function drawSeriesLines(series){function plotLine(datapoints,xoffset,yoffset,axisx,axisy){var points=datapoints.points,ps=datapoints.pointsize,prevx=null,prevy=null;ctx.beginPath();for(var i=ps;i<points.length;i+=ps){var x1=points[i-ps],y1=points[i-ps+1],x2=points[i],y2=points[i+1];if(x1==null||x2==null)continue;if(y1<=y2&&y1<axisy.min){if(y2<axisy.min)continue;x1=(axisy.min-y1)/(y2-y1)*(x2-x1)+x1;y1=axisy.min}else if(y2<=y1&&y2<axisy.min){if(y1<axisy.min)continue;x2=(axisy.min-y1)/(y2-y1)*(x2-x1)+x1;y2=axisy.min}if(y1>=y2&&y1>axisy.max){if(y2>axisy.max)continue;x1=(axisy.max-y1)/(y2-y1)*(x2-x1)+x1;y1=axisy.max}else if(y2>=y1&&y2>axisy.max){if(y1>axisy.max)continue;x2=(axisy.max-y1)/(y2-y1)*(x2-x1)+x1;y2=axisy.max}if(x1<=x2&&x1<axisx.min){if(x2<axisx.min)continue;y1=(axisx.min-x1)/(x2-x1)*(y2-y1)+y1;x1=axisx.min}else if(x2<=x1&&x2<axisx.min){if(x1<axisx.min)continue;y2=(axisx.min-x1)/(x2-x1)*(y2-y1)+y1;x2=axisx.min}if(x1>=x2&&x1>axisx.max){if(x2>axisx.max)continue;y1=(axisx.max-x1)/(x2-x1)*(y2-y1)+y1;x1=axisx.max}else if(x2>=x1&&x2>axisx.max){if(x1>axisx.max)continue;y2=(axisx.max-x1)/(x2-x1)*(y2-y1)+y1;x2=axisx.max}if(x1!=prevx||y1!=prevy)ctx.moveTo(axisx.p2c(x1)+xoffset,axisy.p2c(y1)+yoffset);prevx=x2;prevy=y2;ctx.lineTo(axisx.p2c(x2)+xoffset,axisy.p2c(y2)+yoffset)}ctx.stroke()}function plotLineArea(datapoints,axisx,axisy){var points=datapoints.points,ps=datapoints.pointsize,bottom=Math.min(Math.max(0,axisy.min),axisy.max),i=0,top,areaOpen=false,ypos=1,segmentStart=0,segmentEnd=0;while(true){if(ps>0&&i>points.length+ps)break;i+=ps;var x1=points[i-ps],y1=points[i-ps+ypos],x2=points[i],y2=points[i+ypos];if(areaOpen){if(ps>0&&x1!=null&&x2==null){segmentEnd=i;ps=-ps;ypos=2;continue}if(ps<0&&i==segmentStart+ps){ctx.fill();areaOpen=false;ps=-ps;ypos=1;i=segmentStart=segmentEnd+ps;continue}}if(x1==null||x2==null)continue;if(x1<=x2&&x1<axisx.min){if(x2<axisx.min)continue;y1=(axisx.min-x1)/(x2-x1)*(y2-y1)+y1;x1=axisx.min}else if(x2<=x1&&x2<axisx.min){if(x1<axisx.min)continue;y2=(axisx.min-x1)/(x2-x1)*(y2-y1)+y1;x2=axisx.min}if(x1>=x2&&x1>axisx.max){if(x2>axisx.max)continue;y1=(axisx.max-x1)/(x2-x1)*(y2-y1)+y1;x1=axisx.max}else if(x2>=x1&&x2>axisx.max){if(x1>axisx.max)continue;y2=(axisx.max-x1)/(x2-x1)*(y2-y1)+y1;x2=axisx.max}if(!areaOpen){ctx.beginPath();ctx.moveTo(axisx.p2c(x1),axisy.p2c(bottom));areaOpen=true}if(y1>=axisy.max&&y2>=axisy.max){ctx.lineTo(axisx.p2c(x1),axisy.p2c(axisy.max));ctx.lineTo(axisx.p2c(x2),axisy.p2c(axisy.max));continue}else if(y1<=axisy.min&&y2<=axisy.min){ctx.lineTo(axisx.p2c(x1),axisy.p2c(axisy.min));ctx.lineTo(axisx.p2c(x2),axisy.p2c(axisy.min));continue}var x1old=x1,x2old=x2;if(y1<=y2&&y1<axisy.min&&y2>=axisy.min){x1=(axisy.min-y1)/(y2-y1)*(x2-x1)+x1;y1=axisy.min}else if(y2<=y1&&y2<axisy.min&&y1>=axisy.min){x2=(axisy.min-y1)/(y2-y1)*(x2-x1)+x1;y2=axisy.min}if(y1>=y2&&y1>axisy.max&&y2<=axisy.max){x1=(axisy.max-y1)/(y2-y1)*(x2-x1)+x1;y1=axisy.max}else if(y2>=y1&&y2>axisy.max&&y1<=axisy.max){x2=(axisy.max-y1)/(y2-y1)*(x2-x1)+x1;y2=axisy.max}if(x1!=x1old){ctx.lineTo(axisx.p2c(x1old),axisy.p2c(y1))}ctx.lineTo(axisx.p2c(x1),axisy.p2c(y1));ctx.lineTo(axisx.p2c(x2),axisy.p2c(y2));if(x2!=x2old){ctx.lineTo(axisx.p2c(x2),axisy.p2c(y2));ctx.lineTo(axisx.p2c(x2old),axisy.p2c(y2))}}}ctx.save();ctx.translate(plotOffset.left,plotOffset.top);ctx.lineJoin="round";var lw=series.lines.lineWidth,sw=series.shadowSize;if(lw>0&&sw>0){ctx.lineWidth=sw;ctx.strokeStyle="rgba(0,0,0,0.1)";var angle=Math.PI/18;plotLine(series.datapoints,Math.sin(angle)*(lw/2+sw/2),Math.cos(angle)*(lw/2+sw/2),series.xaxis,series.yaxis);ctx.lineWidth=sw/2;plotLine(series.datapoints,Math.sin(angle)*(lw/2+sw/4),Math.cos(angle)*(lw/2+sw/4),series.xaxis,series.yaxis)}ctx.lineWidth=lw;ctx.strokeStyle=series.color;var fillStyle=getFillStyle(series.lines,series.color,0,plotHeight);if(fillStyle){ctx.fillStyle=fillStyle;plotLineArea(series.datapoints,series.xaxis,series.yaxis)}if(lw>0)plotLine(series.datapoints,0,0,series.xaxis,series.yaxis);ctx.restore()}function drawSeriesPoints(series){function plotPoints(datapoints,radius,fillStyle,offset,shadow,axisx,axisy,symbol){var points=datapoints.points,ps=datapoints.pointsize;for(var i=0;i<points.length;i+=ps){var x=points[i],y=points[i+1];if(x==null||x<axisx.min||x>axisx.max||y<axisy.min||y>axisy.max)continue;ctx.beginPath();x=axisx.p2c(x);y=axisy.p2c(y)+offset;if(symbol=="circle")ctx.arc(x,y,radius,0,shadow?Math.PI:Math.PI*2,false);else symbol(ctx,x,y,radius,shadow);ctx.closePath();if(fillStyle){ctx.fillStyle=fillStyle;ctx.fill()}ctx.stroke()}}ctx.save();ctx.translate(plotOffset.left,plotOffset.top);var lw=series.points.lineWidth,sw=series.shadowSize,radius=series.points.radius,symbol=series.points.symbol;if(lw==0)lw=1e-4;if(lw>0&&sw>0){var w=sw/2;ctx.lineWidth=w;ctx.strokeStyle="rgba(0,0,0,0.1)";plotPoints(series.datapoints,radius,null,w+w/2,true,series.xaxis,series.yaxis,symbol);ctx.strokeStyle="rgba(0,0,0,0.2)";plotPoints(series.datapoints,radius,null,w/2,true,series.xaxis,series.yaxis,symbol)}ctx.lineWidth=lw;ctx.strokeStyle=series.color;plotPoints(series.datapoints,radius,getFillStyle(series.points,series.color),0,false,series.xaxis,series.yaxis,symbol);ctx.restore()}function drawBar(x,y,b,barLeft,barRight,fillStyleCallback,axisx,axisy,c,horizontal,lineWidth){var left,right,bottom,top,drawLeft,drawRight,drawTop,drawBottom,tmp;if(horizontal){drawBottom=drawRight=drawTop=true;drawLeft=false;left=b;right=x;top=y+barLeft;bottom=y+barRight;if(right<left){tmp=right;right=left;left=tmp;drawLeft=true;drawRight=false}}else{drawLeft=drawRight=drawTop=true;drawBottom=false;left=x+barLeft;right=x+barRight;bottom=b;top=y;if(top<bottom){tmp=top;top=bottom;bottom=tmp;drawBottom=true;drawTop=false}}if(right<axisx.min||left>axisx.max||top<axisy.min||bottom>axisy.max)return;if(left<axisx.min){left=axisx.min;drawLeft=false}if(right>axisx.max){right=axisx.max;drawRight=false}if(bottom<axisy.min){bottom=axisy.min;drawBottom=false}if(top>axisy.max){top=axisy.max;drawTop=false}left=axisx.p2c(left);bottom=axisy.p2c(bottom);right=axisx.p2c(right);top=axisy.p2c(top);if(fillStyleCallback){c.fillStyle=fillStyleCallback(bottom,top);c.fillRect(left,top,right-left,bottom-top)}if(lineWidth>0&&(drawLeft||drawRight||drawTop||drawBottom)){c.beginPath();c.moveTo(left,bottom);if(drawLeft)c.lineTo(left,top);else c.moveTo(left,top);if(drawTop)c.lineTo(right,top);else c.moveTo(right,top);if(drawRight)c.lineTo(right,bottom);else c.moveTo(right,bottom);if(drawBottom)c.lineTo(left,bottom);else c.moveTo(left,bottom);c.stroke()}}function drawSeriesBars(series){function plotBars(datapoints,barLeft,barRight,fillStyleCallback,axisx,axisy){var points=datapoints.points,ps=datapoints.pointsize;for(var i=0;i<points.length;i+=ps){if(points[i]==null)continue;drawBar(points[i],points[i+1],points[i+2],barLeft,barRight,fillStyleCallback,axisx,axisy,ctx,series.bars.horizontal,series.bars.lineWidth)}}ctx.save();ctx.translate(plotOffset.left,plotOffset.top);ctx.lineWidth=series.bars.lineWidth;ctx.strokeStyle=series.color;var barLeft;switch(series.bars.align){case"left":barLeft=0;break;case"right":barLeft=-series.bars.barWidth;break;default:barLeft=-series.bars.barWidth/2}var fillStyleCallback=series.bars.fill?function(bottom,top){return getFillStyle(series.bars,series.color,bottom,top)}:null;plotBars(series.datapoints,barLeft,barLeft+series.bars.barWidth,fillStyleCallback,series.xaxis,series.yaxis);ctx.restore()}function getFillStyle(filloptions,seriesColor,bottom,top){var fill=filloptions.fill;if(!fill)return null;if(filloptions.fillColor)return getColorOrGradient(filloptions.fillColor,bottom,top,seriesColor);var c=$.color.parse(seriesColor);c.a=typeof fill=="number"?fill:.4;c.normalize();return c.toString()}function insertLegend(){if(options.legend.container!=null){$(options.legend.container).html("")}else{placeholder.find(".legend").remove()}if(!options.legend.show){return}var fragments=[],entries=[],rowStarted=false,lf=options.legend.labelFormatter,s,label;for(var i=0;i<series.length;++i){s=series[i];if(s.label){label=lf?lf(s.label,s):s.label;if(label){entries.push({label:label,color:s.color})}}}if(options.legend.sorted){if($.isFunction(options.legend.sorted)){entries.sort(options.legend.sorted)}else if(options.legend.sorted=="reverse"){entries.reverse()}else{var ascending=options.legend.sorted!="descending";entries.sort(function(a,b){return a.label==b.label?0:a.label<b.label!=ascending?1:-1})}}for(var i=0;i<entries.length;++i){var entry=entries[i];if(i%options.legend.noColumns==0){if(rowStarted)fragments.push("</tr>");fragments.push("<tr>");rowStarted=true}fragments.push('<td class="legendColorBox"><div style="border:1px solid '+options.legend.labelBoxBorderColor+';padding:1px"><div style="width:4px;height:0;border:5px solid '+entry.color+';overflow:hidden"></div></div></td>'+'<td class="legendLabel">'+entry.label+"</td>")}if(rowStarted)fragments.push("</tr>");if(fragments.length==0)return;var table='<table style="font-size:smaller;color:'+options.grid.color+'">'+fragments.join("")+"</table>";if(options.legend.container!=null)$(options.legend.container).html(table);else{var pos="",p=options.legend.position,m=options.legend.margin;if(m[0]==null)m=[m,m];if(p.charAt(0)=="n")pos+="top:"+(m[1]+plotOffset.top)+"px;";else if(p.charAt(0)=="s")pos+="bottom:"+(m[1]+plotOffset.bottom)+"px;";if(p.charAt(1)=="e")pos+="right:"+(m[0]+plotOffset.right)+"px;";else if(p.charAt(1)=="w")pos+="left:"+(m[0]+plotOffset.left)+"px;";var legend=$('<div class="legend">'+table.replace('style="','style="position:absolute;'+pos+";")+"</div>").appendTo(placeholder);if(options.legend.backgroundOpacity!=0){var c=options.legend.backgroundColor;if(c==null){c=options.grid.backgroundColor;if(c&&typeof c=="string")c=$.color.parse(c);else c=$.color.extract(legend,"background-color");c.a=1;c=c.toString()}var div=legend.children();$('<div style="position:absolute;width:'+div.width()+"px;height:"+div.height()+"px;"+pos+"background-color:"+c+';"> </div>').prependTo(legend).css("opacity",options.legend.backgroundOpacity)}}}var highlights=[],redrawTimeout=null;function findNearbyItem(mouseX,mouseY,seriesFilter){var maxDistance=options.grid.mouseActiveRadius,smallestDistance=maxDistance*maxDistance+1,item=null,foundPoint=false,i,j,ps;for(i=series.length-1;i>=0;--i){if(!seriesFilter(series[i]))continue;var s=series[i],axisx=s.xaxis,axisy=s.yaxis,points=s.datapoints.points,mx=axisx.c2p(mouseX),my=axisy.c2p(mouseY),maxx=maxDistance/axisx.scale,maxy=maxDistance/axisy.scale;ps=s.datapoints.pointsize;if(axisx.options.inverseTransform)maxx=Number.MAX_VALUE;if(axisy.options.inverseTransform)maxy=Number.MAX_VALUE;if(s.lines.show||s.points.show){for(j=0;j<points.length;j+=ps){var x=points[j],y=points[j+1];if(x==null)continue;if(x-mx>maxx||x-mx<-maxx||y-my>maxy||y-my<-maxy)continue;var dx=Math.abs(axisx.p2c(x)-mouseX),dy=Math.abs(axisy.p2c(y)-mouseY),dist=dx*dx+dy*dy;if(dist<smallestDistance){smallestDistance=dist;item=[i,j/ps]}}}if(s.bars.show&&!item){var barLeft,barRight;switch(s.bars.align){case"left":barLeft=0;break;case"right":barLeft=-s.bars.barWidth;break;default:barLeft=-s.bars.barWidth/2}barRight=barLeft+s.bars.barWidth;for(j=0;j<points.length;j+=ps){var x=points[j],y=points[j+1],b=points[j+2];if(x==null)continue;if(series[i].bars.horizontal?mx<=Math.max(b,x)&&mx>=Math.min(b,x)&&my>=y+barLeft&&my<=y+barRight:mx>=x+barLeft&&mx<=x+barRight&&my>=Math.min(b,y)&&my<=Math.max(b,y))item=[i,j/ps]}}}if(item){i=item[0];j=item[1];ps=series[i].datapoints.pointsize;return{datapoint:series[i].datapoints.points.slice(j*ps,(j+1)*ps),dataIndex:j,series:series[i],seriesIndex:i}}return null}function onMouseMove(e){if(options.grid.hoverable)triggerClickHoverEvent("plothover",e,function(s){return s["hoverable"]!=false})}function onMouseLeave(e){if(options.grid.hoverable)triggerClickHoverEvent("plothover",e,function(s){return false})}function onClick(e){triggerClickHoverEvent("plotclick",e,function(s){return s["clickable"]!=false})}function triggerClickHoverEvent(eventname,event,seriesFilter){var offset=eventHolder.offset(),canvasX=event.pageX-offset.left-plotOffset.left,canvasY=event.pageY-offset.top-plotOffset.top,pos=canvasToAxisCoords({left:canvasX,top:canvasY});pos.pageX=event.pageX;pos.pageY=event.pageY;var item=findNearbyItem(canvasX,canvasY,seriesFilter);if(item){item.pageX=parseInt(item.series.xaxis.p2c(item.datapoint[0])+offset.left+plotOffset.left,10);item.pageY=parseInt(item.series.yaxis.p2c(item.datapoint[1])+offset.top+plotOffset.top,10)}if(options.grid.autoHighlight){for(var i=0;i<highlights.length;++i){var h=highlights[i];if(h.auto==eventname&&!(item&&h.series==item.series&&h.point[0]==item.datapoint[0]&&h.point[1]==item.datapoint[1]))unhighlight(h.series,h.point)}if(item)highlight(item.series,item.datapoint,eventname)}placeholder.trigger(eventname,[pos,item])}function triggerRedrawOverlay(){var t=options.interaction.redrawOverlayInterval;if(t==-1){drawOverlay();return}if(!redrawTimeout)redrawTimeout=setTimeout(drawOverlay,t)}function drawOverlay(){redrawTimeout=null;octx.save();overlay.clear();octx.translate(plotOffset.left,plotOffset.top);var i,hi;for(i=0;i<highlights.length;++i){hi=highlights[i];if(hi.series.bars.show)drawBarHighlight(hi.series,hi.point);else drawPointHighlight(hi.series,hi.point)}octx.restore();executeHooks(hooks.drawOverlay,[octx])}function highlight(s,point,auto){if(typeof s=="number")s=series[s];if(typeof point=="number"){var ps=s.datapoints.pointsize;point=s.datapoints.points.slice(ps*point,ps*(point+1))}var i=indexOfHighlight(s,point);if(i==-1){highlights.push({series:s,point:point,auto:auto});triggerRedrawOverlay()}else if(!auto)highlights[i].auto=false}function unhighlight(s,point){if(s==null&&point==null){highlights=[];triggerRedrawOverlay();return}if(typeof s=="number")s=series[s];if(typeof point=="number"){var ps=s.datapoints.pointsize;point=s.datapoints.points.slice(ps*point,ps*(point+1))}var i=indexOfHighlight(s,point);if(i!=-1){highlights.splice(i,1);triggerRedrawOverlay()}}function indexOfHighlight(s,p){for(var i=0;i<highlights.length;++i){var h=highlights[i];if(h.series==s&&h.point[0]==p[0]&&h.point[1]==p[1])return i}return-1}function drawPointHighlight(series,point){var x=point[0],y=point[1],axisx=series.xaxis,axisy=series.yaxis,highlightColor=typeof series.highlightColor==="string"?series.highlightColor:$.color.parse(series.color).scale("a",.5).toString();if(x<axisx.min||x>axisx.max||y<axisy.min||y>axisy.max)return;var pointRadius=series.points.radius+series.points.lineWidth/2;octx.lineWidth=pointRadius;octx.strokeStyle=highlightColor;var radius=1.5*pointRadius;x=axisx.p2c(x);y=axisy.p2c(y);octx.beginPath();if(series.points.symbol=="circle")octx.arc(x,y,radius,0,2*Math.PI,false);else series.points.symbol(octx,x,y,radius,false);octx.closePath();octx.stroke()}function drawBarHighlight(series,point){var highlightColor=typeof series.highlightColor==="string"?series.highlightColor:$.color.parse(series.color).scale("a",.5).toString(),fillStyle=highlightColor,barLeft;switch(series.bars.align){case"left":barLeft=0;break;case"right":barLeft=-series.bars.barWidth;break;default:barLeft=-series.bars.barWidth/2}octx.lineWidth=series.bars.lineWidth;octx.strokeStyle=highlightColor;drawBar(point[0],point[1],point[2]||0,barLeft,barLeft+series.bars.barWidth,function(){return fillStyle},series.xaxis,series.yaxis,octx,series.bars.horizontal,series.bars.lineWidth)}function getColorOrGradient(spec,bottom,top,defaultColor){if(typeof spec=="string")return spec;else{var gradient=ctx.createLinearGradient(0,top,0,bottom);for(var i=0,l=spec.colors.length;i<l;++i){var c=spec.colors[i];if(typeof c!="string"){var co=$.color.parse(defaultColor);if(c.brightness!=null)co=co.scale("rgb",c.brightness);if(c.opacity!=null)co.a*=c.opacity;c=co.toString()}gradient.addColorStop(i/(l-1),c)}return gradient}}}$.plot=function(placeholder,data,options){var plot=new Plot($(placeholder),data,options,$.plot.plugins);return plot};$.plot.version="0.8.3";$.plot.plugins=[];$.fn.plot=function(data,options){return this.each(function(){$.plot(this,data,options)})};function floorInBase(n,base){return base*Math.floor(n/base)}})(jQuery);
define("flot", ["jquery"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.$.plot;
    };
}(this)));

/*
 * jquery.flot.tooltip
 * 
 * description: easy-to-use tooltips for Flot charts
 * version: 0.8.5
 * authors: Krzysztof Urbas @krzysu [myviews.pl],Evan Steinkerchner @Roundaround
 * website: https://github.com/krzysu/flot.tooltip
 * 
 * build on 2015-05-11
 * released under MIT License, 2012
*/ 
!function(a){var b={tooltip:{show:!1,cssClass:"flotTip",content:"%s | X: %x | Y: %y",xDateFormat:null,yDateFormat:null,monthNames:null,dayNames:null,shifts:{x:10,y:20},defaultTheme:!0,lines:!1,onHover:function(a,b){},$compat:!1}};b.tooltipOpts=b.tooltip;var c=function(a){this.tipPosition={x:0,y:0},this.init(a)};c.prototype.init=function(b){function c(a){var c={};c.x=a.pageX,c.y=a.pageY,b.setTooltipPosition(c)}function d(c,d,f){var g=function(a,b,c,d){return Math.sqrt((c-a)*(c-a)+(d-b)*(d-b))},h=function(a,b,c,d,e,f,h){if(!h||(h=function(a,b,c,d,e,f){if("undefined"!=typeof c)return{x:c,y:b};if("undefined"!=typeof d)return{x:a,y:d};var g,h=-1/((f-d)/(e-c));return{x:g=(e*(a*h-b+d)+c*(a*-h+b-f))/(h*(e-c)+d-f),y:h*g-h*a+b}}(a,b,c,d,e,f),h.x>=Math.min(c,e)&&h.x<=Math.max(c,e)&&h.y>=Math.min(d,f)&&h.y<=Math.max(d,f))){var i=d-f,j=e-c,k=c*f-d*e;return Math.abs(i*a+j*b+k)/Math.sqrt(i*i+j*j)}var l=g(a,b,c,d),m=g(a,b,e,f);return l>m?m:l};if(f)b.showTooltip(f,d);else if(e.plotOptions.series.lines.show&&e.tooltipOptions.lines===!0){var i=e.plotOptions.grid.mouseActiveRadius,j={distance:i+1};a.each(b.getData(),function(a,c){for(var e=0,f=-1,i=1;i<c.data.length;i++)c.data[i-1][0]<=d.x&&c.data[i][0]>=d.x&&(e=i-1,f=i);if(-1===f)return void b.hideTooltip();var k={x:c.data[e][0],y:c.data[e][1]},l={x:c.data[f][0],y:c.data[f][1]},m=h(c.xaxis.p2c(d.x),c.yaxis.p2c(d.y),c.xaxis.p2c(k.x),c.yaxis.p2c(k.y),c.xaxis.p2c(l.x),c.yaxis.p2c(l.y),!1);if(m<j.distance){var n=g(k.x,k.y,d.x,d.y)<g(d.x,d.y,l.x,l.y)?e:f,o=(c.datapoints.pointsize,[d.x,k.y+(l.y-k.y)*((d.x-k.x)/(l.x-k.x))]),p={datapoint:o,dataIndex:n,series:c,seriesIndex:a};j={distance:m,item:p}}}),j.distance<i+1?b.showTooltip(j.item,d):b.hideTooltip()}else b.hideTooltip()}var e=this,f=a.plot.plugins.length;if(this.plotPlugins=[],f)for(var g=0;f>g;g++)this.plotPlugins.push(a.plot.plugins[g].name);b.hooks.bindEvents.push(function(b,f){if(e.plotOptions=b.getOptions(),"boolean"==typeof e.plotOptions.tooltip&&(e.plotOptions.tooltipOpts.show=e.plotOptions.tooltip,e.plotOptions.tooltip=e.plotOptions.tooltipOpts,delete e.plotOptions.tooltipOpts),e.plotOptions.tooltip.show!==!1&&"undefined"!=typeof e.plotOptions.tooltip.show){e.tooltipOptions=e.plotOptions.tooltip,e.tooltipOptions.$compat?(e.wfunc="width",e.hfunc="height"):(e.wfunc="innerWidth",e.hfunc="innerHeight");e.getDomElement();a(b.getPlaceholder()).bind("plothover",d),a(f).bind("mousemove",c)}}),b.hooks.shutdown.push(function(b,e){a(b.getPlaceholder()).unbind("plothover",d),a(e).unbind("mousemove",c)}),b.setTooltipPosition=function(b){var c=e.getDomElement(),d=c.outerWidth()+e.tooltipOptions.shifts.x,f=c.outerHeight()+e.tooltipOptions.shifts.y;b.x-a(window).scrollLeft()>a(window)[e.wfunc]()-d&&(b.x-=d),b.y-a(window).scrollTop()>a(window)[e.hfunc]()-f&&(b.y-=f),e.tipPosition.x=b.x,e.tipPosition.y=b.y},b.showTooltip=function(a,c){var d=e.getDomElement(),f=e.stringFormat(e.tooltipOptions.content,a);""!==f&&(d.html(f),b.setTooltipPosition({x:c.pageX,y:c.pageY}),d.css({left:e.tipPosition.x+e.tooltipOptions.shifts.x,top:e.tipPosition.y+e.tooltipOptions.shifts.y}).show(),"function"==typeof e.tooltipOptions.onHover&&e.tooltipOptions.onHover(a,d))},b.hideTooltip=function(){e.getDomElement().hide().html("")}},c.prototype.getDomElement=function(){var b=a("."+this.tooltipOptions.cssClass);return 0===b.length&&(b=a("<div />").addClass(this.tooltipOptions.cssClass),b.appendTo("body").hide().css({position:"absolute"}),this.tooltipOptions.defaultTheme&&b.css({background:"#fff","z-index":"1040",padding:"0.4em 0.6em","border-radius":"0.5em","font-size":"0.8em",border:"1px solid #111",display:"none","white-space":"nowrap"})),b},c.prototype.stringFormat=function(a,b){var c,d,e,f,g=/%p\.{0,1}(\d{0,})/,h=/%s/,i=/%c/,j=/%lx/,k=/%ly/,l=/%x\.{0,1}(\d{0,})/,m=/%y\.{0,1}(\d{0,})/,n="%x",o="%y",p="%ct";if("undefined"!=typeof b.series.threshold?(c=b.datapoint[0],d=b.datapoint[1],e=b.datapoint[2]):"undefined"!=typeof b.series.lines&&b.series.lines.steps?(c=b.series.datapoints.points[2*b.dataIndex],d=b.series.datapoints.points[2*b.dataIndex+1],e=""):(c=b.series.data[b.dataIndex][0],d=b.series.data[b.dataIndex][1],e=b.series.data[b.dataIndex][2]),null===b.series.label&&b.series.originSeries&&(b.series.label=b.series.originSeries.label),"function"==typeof a&&(a=a(b.series.label,c,d,b)),"boolean"==typeof a&&!a)return"";if("undefined"!=typeof b.series.percent?f=b.series.percent:"undefined"!=typeof b.series.percents&&(f=b.series.percents[b.dataIndex]),"number"==typeof f&&(a=this.adjustValPrecision(g,a,f)),a="undefined"!=typeof b.series.label?a.replace(h,b.series.label):a.replace(h,""),a="undefined"!=typeof b.series.color?a.replace(i,b.series.color):a.replace(i,""),a=this.hasAxisLabel("xaxis",b)?a.replace(j,b.series.xaxis.options.axisLabel):a.replace(j,""),a=this.hasAxisLabel("yaxis",b)?a.replace(k,b.series.yaxis.options.axisLabel):a.replace(k,""),this.isTimeMode("xaxis",b)&&this.isXDateFormat(b)&&(a=a.replace(l,this.timestampToDate(c,this.tooltipOptions.xDateFormat,b.series.xaxis.options))),this.isTimeMode("yaxis",b)&&this.isYDateFormat(b)&&(a=a.replace(m,this.timestampToDate(d,this.tooltipOptions.yDateFormat,b.series.yaxis.options))),"number"==typeof c&&(a=this.adjustValPrecision(l,a,c)),"number"==typeof d&&(a=this.adjustValPrecision(m,a,d)),"undefined"!=typeof b.series.xaxis.ticks){var q;q=this.hasRotatedXAxisTicks(b)?"rotatedTicks":"ticks";var r=b.dataIndex+b.seriesIndex;for(var s in b.series.xaxis[q])if(b.series.xaxis[q].hasOwnProperty(r)&&!this.isTimeMode("xaxis",b)){var t=this.isCategoriesMode("xaxis",b)?b.series.xaxis[q][r].label:b.series.xaxis[q][r].v;t===c&&(a=a.replace(l,b.series.xaxis[q][r].label))}}if("undefined"!=typeof b.series.yaxis.ticks)for(var s in b.series.yaxis.ticks)if(b.series.yaxis.ticks.hasOwnProperty(s)){var u=this.isCategoriesMode("yaxis",b)?b.series.yaxis.ticks[s].label:b.series.yaxis.ticks[s].v;u===d&&(a=a.replace(m,b.series.yaxis.ticks[s].label))}return"undefined"!=typeof b.series.xaxis.tickFormatter&&(a=a.replace(n,b.series.xaxis.tickFormatter(c,b.series.xaxis).replace(/\$/g,"$$"))),"undefined"!=typeof b.series.yaxis.tickFormatter&&(a=a.replace(o,b.series.yaxis.tickFormatter(d,b.series.yaxis).replace(/\$/g,"$$"))),e&&(a=a.replace(p,e)),a},c.prototype.isTimeMode=function(a,b){return"undefined"!=typeof b.series[a].options.mode&&"time"===b.series[a].options.mode},c.prototype.isXDateFormat=function(a){return"undefined"!=typeof this.tooltipOptions.xDateFormat&&null!==this.tooltipOptions.xDateFormat},c.prototype.isYDateFormat=function(a){return"undefined"!=typeof this.tooltipOptions.yDateFormat&&null!==this.tooltipOptions.yDateFormat},c.prototype.isCategoriesMode=function(a,b){return"undefined"!=typeof b.series[a].options.mode&&"categories"===b.series[a].options.mode},c.prototype.timestampToDate=function(b,c,d){var e=a.plot.dateGenerator(b,d);return a.plot.formatDate(e,c,this.tooltipOptions.monthNames,this.tooltipOptions.dayNames)},c.prototype.adjustValPrecision=function(a,b,c){var d,e=b.match(a);return null!==e&&""!==RegExp.$1&&(d=RegExp.$1,c=c.toFixed(d),b=b.replace(a,c)),b},c.prototype.hasAxisLabel=function(b,c){return-1!==a.inArray(this.plotPlugins,"axisLabels")&&"undefined"!=typeof c.series[b].options.axisLabel&&c.series[b].options.axisLabel.length>0},c.prototype.hasRotatedXAxisTicks=function(b){return-1!==a.inArray(this.plotPlugins,"tickRotor")&&"undefined"!=typeof b.series.xaxis.rotatedTicks};var d=function(a){new c(a)};a.plot.plugins.push({init:d,options:b,name:"tooltip",version:"0.8.5"})}(jQuery);
define("flot.tooltip", ["flot"], function(){});

/*
CAxis Labels Plugin for flot. :P
Copyright (c) 2010 Xuan Luo

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */
(function ($) {
    var options = { };

    function init(plot) {
        // This is kind of a hack. There are no hooks in Flot between
        // the creation and measuring of the ticks (setTicks, measureTickLabels
        // in setupGrid() ) and the drawing of the ticks and plot box
        // (insertAxisLabels in setupGrid() ).
        //
        // Therefore, we use a trick where we run the draw routine twice:
        // the first time to get the tick measurements, so that we can change
        // them, and then have it draw it again.
        var secondPass = false;
        plot.hooks.draw.push(function (plot, ctx) {
            if (!secondPass) {
                // MEASURE AND SET OPTIONS
                $.each(plot.getAxes(), function(axisName, axis) {
                    var opts = axis.options // Flot 0.7
                        || plot.getOptions()[axisName]; // Flot 0.6
                    if (!opts || !opts.axisLabel)
                        return;

                    var w, h;
                    if (opts.axisLabelUseCanvas != false)
                        opts.axisLabelUseCanvas = true;

                    if (opts.axisLabelUseCanvas) {
                        // canvas text
                        if (!opts.axisLabelFontSizePixels)
                            opts.axisLabelFontSizePixels = 14;
                        if (!opts.axisLabelFontFamily)
                            opts.axisLabelFontFamily = 'sans-serif';
                        // since we currently always display x as horiz.
                        // and y as vertical, we only care about the height
                        w = opts.axisLabelFontSizePixels;
                        h = opts.axisLabelFontSizePixels;

                    } else {
                        // HTML text
                        var elem = $('<div class="axisLabels" style="position:absolute;">' + opts.axisLabel + '</div>');
                        plot.getPlaceholder().append(elem);
                        w = elem.outerWidth(true);
                        h = elem.outerHeight(true);
                        elem.remove();
                    }

                    if (axisName.charAt(0) == 'x')
                        axis.labelHeight += h;
                    else
                        axis.labelWidth += w;
                    opts.labelHeight = axis.labelHeight;
                    opts.labelWidth = axis.labelWidth;
                });
                // re-draw with new label widths and heights
                secondPass = true;
                plot.setupGrid();
                plot.draw();


            } else {
                // DRAW
                $.each(plot.getAxes(), function(axisName, axis) {
                    var opts = axis.options // Flot 0.7
                        || plot.getOptions()[axisName]; // Flot 0.6
                    if (!opts || !opts.axisLabel)
                        return;

                    if (opts.axisLabelUseCanvas) {
                        // canvas text
                        var ctx = plot.getCanvas().getContext('2d');
                        ctx.save();
                        ctx.font = opts.axisLabelFontSizePixels + 'px ' +
                                opts.axisLabelFontFamily;
                        var width = ctx.measureText(opts.axisLabel).width;
                        var height = opts.axisLabelFontSizePixels;
                        var x, y;
                        if (axisName.charAt(0) == 'x') {
                            x = plot.getPlotOffset().left + plot.width()/2 - width/2;
                            y = plot.getCanvas().height;
                        } else {
                            x = height * 0.72;
                            y = plot.getPlotOffset().top + plot.height()/2 - width/2;
                        }
                        ctx.translate(x, y);
                        ctx.rotate((axisName.charAt(0) == 'x') ? 0 : -Math.PI/2);
                        ctx.fillText(opts.axisLabel, 0, 0);
                        ctx.restore();

                    } else {
                        // HTML text
                        plot.getPlaceholder().find('#' + axisName + 'Label').remove();
                        var elem = $('<div id="' + axisName + 'Label" " class="axisLabels" style="position:absolute;">' + opts.axisLabel + '</div>');
                        if (axisName.charAt(0) == 'x') {
                            elem.css('left', plot.getPlotOffset().left + plot.width()/2 - elem.outerWidth()/2 + 'px');
                            elem.css('bottom', '0px');
                        } else {
                            elem.css('top', plot.getPlotOffset().top + plot.height()/2 - elem.outerHeight()/2 + 'px');
                            elem.css('left', '0px');
                        }
                        plot.getPlaceholder().append(elem);
                    }
                });
                secondPass = false;
            }
        });
    }



    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'axisLabels',
        version: '1.0'
    });
})(jQuery);

define("flot.axislabels", ["flot"], function(){});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/**
 * MizarWidgetGui contains the GUI of MizarWidget.
 *
 * The GUI of Mizar widget provides the following elements:
 * <ul>
 *     <li>a graphical element to handle the different layer : on/off, opacity</li>
 *     <li>a graphical element to select a background layer</li>
 *     <li>a graphical element to resolve an object name to coordinates</li>
 *     <li>a graphical element to find an object name based on its coordinates</li>
 *     <li>a manager to handle graphical events related to the user picking</li>
 *     <li>a graphical element to display the metadata to the user</li>
 *     <li>a graphical iframe to display external link to the user</li>
 *     <li>a graphical element to display the footprint of the camera in the whole sky</li>
 *     <li>a graphical element to handle features on a displayed image (quicklook, wms or Fits data)</li>
 *     <li>a graphical element to handle specific layer</li>
 *     <li>a graphical element to measure the angular distance between two points</li>
 *     <li>a graphical element to measure the distance and compute the elevation profile between two points
 *     on a planet</li>
 *     <li>a graphical element to switch 2D/3D</li>
 *     <li>a graphical element to order data based on a selected area</li>
 *     <li>a graphical element to display credits of the tool to the user</li>
 *     <li>a graphical element to display error to the user</li>
 *     <li>two services : a sharing service and <a href="http://www.ivoa.net/documents/SAMP/">SAMP</a></li>
 * </ul>
 *
 */
//TODO Faire MollweideViewer pour la Terre
//TODO faire switch 2D/3D pour le ciel
define('MizarWidgetGui',["jquery", "underscore-min",

        // Gui
        "./gui/LayerManagerView", "./gui/BackgroundLayersView",
        "./gui/NameResolverView", "./gui/ReverseNameResolverView",
        "./gui/PickingManager", "./gui/FeaturePopup",
        "./gui/IFrame",
        "./gui/MollweideViewer", "./gui/ImageViewer",
        "./gui/MeasureToolSky", "./gui/MeasureToolPlanet", "./gui/DistanceNavigationView",
        "./gui/SwitchTo2D", "./gui/ExportTool",

        // services
        "service/Share", "service/Samp",

        //Utility class
        "./utils/UtilsCore",

        // Externals
        "jquery.ui", "flot",
        "flot.tooltip", "flot.axislabels"],
    function ($, _,
              LayerManagerView, BackgroundLayersView,
              NameResolverView, ReverseNameResolverView,
              PickingManager, FeaturePopup,
              IFrame,
              MollweideViewer, ImageViewer,
              MeasureToolSky, MeasureToolPlanet,DistanceNavigationView,
              SwitchTo2D, ExportTool,
              Share, Samp, UtilsCore) {

        /**
         *    Private variables
         */
        var options;
        var mizarDiv;
        var mizarWidgetAPI;

        /**************************************************************************************************************/

        /**
         * Mizar Widget GUI constructor.
         * @param div
         * @param globalOptions
         * @constructor
         * @listen addFitsEvent#layer:fitsSupported
         */
        //TODO dcrire div et global options
        var MizarWidgetGui = function (div, globalOptions) {
            if (!globalOptions.options.gui) {
                return;
            }
            mizarDiv = div;
            this.mode = _.find(globalOptions.options.ctx, function(obj) { return obj.name === globalOptions.options.defaultCtx });

            options = globalOptions.options;

            mizarWidgetAPI = globalOptions.mizarWidgetAPI;

            this.isMobile = globalOptions.options.gui.isMobile;

            this.activatedContext = mizarWidgetAPI.getContext();

            var self = this;

            mizarWidgetAPI.subscribeCtx('layer:fitsSupported', function (layerDesc) {
                self.addFitsEvent(layerDesc);
            });

            // Create data manager
            PickingManager.init(mizarWidgetAPI, globalOptions);

            // Share configuration module init
            Share.init({
                mizar: mizarWidgetAPI,
                configuration: globalOptions.options
            });

            // Initialize SAMP component
            // TODO : Bear in mind that a website may already implement specific SAMP logics, so check that
            // current samp component doesn't break existing SAMP functionality
            Samp.init(mizarWidgetAPI, mizarWidgetAPI.getServiceByName(mizarWidgetAPI.SERVICE.Samp), globalOptions.options);            

            this.addMouseEvents();

        };

        /**************************************************************************************************************/

        /**
         * Registers all mouse events.
         */
        MizarWidgetGui.prototype.addMouseEvents = function () {
            var body = $( "body" );
            // Fade hover styled image effect
            body.on("mouseenter", "span.defaultImg", function () {
                //stuff to do on mouseover
                $(this).stop().animate({"opacity": "0"}, 100);
                $(this).siblings('.hoverImg').stop().animate({"opacity": "1"}, 100);
            });
            body.on("mouseleave", "span.defaultImg", function () {
                //stuff to do on mouseleave
                $(this).stop().animate({"opacity": "1"}, 100);
                $(this).siblings('.hoverImg').stop().animate({"opacity": "0"}, 100);
            });

            // Close button event
            body.on("click", '.closeBtn', function () {
                switch ($(this).parent().attr("id")) {
                    case "externalIFrame":
                        IFrame.hide();
                        break;
                    case "selectedFeatureDiv":
                        FeaturePopup.hide();
                        break;
                    default:
                        $(this).parent().fadeOut(300);
                }
            });
        };

        /**
         * Adds Fits event to layer if supported
         * @param layerDesc
         */
        //TODO dcrire layerDesc
        MizarWidgetGui.prototype.addFitsEvent = function (layerDesc) {

            // Add onready event if FITS supported by layer
            if (layerDesc.fitsSupported) {
                // TODO : Move it..
                layerDesc.onready = function (fitsLayer) {
                    if (fitsLayer.format === "fits" && fitsLayer.levelZeroImage) {
                        if (fitsLayer.div) {
                            // Additional layer
                            // Using name as identifier, because we must know it before attachment to planet
                            // .. but identfier is assigned after layer creation.
                            var shortName = UtilsCore.formatId(fitsLayer.name);
                            $('#addFitsView_' + shortName).button("enable");
                            fitsLayer.div.setImage(fitsLayer.levelZeroImage);
                        }
                        else {
                            // Background fits layer
                            $('#fitsView').button("enable");
                            var backgroundDiv = BackgroundLayersView.getDiv();
                            backgroundDiv.setImage(fitsLayer.levelZeroImage);
                        }
                    }
                };
            }
        };

        /**
         * Adds/removes the angular distance GUI.
         * @param visible
         */
        //TODO dcrire visible
        MizarWidgetGui.prototype.setAngleDistanceSkyGui = function (visible) {
            if (visible && !this.measureToolSky) {
                // Distance measure tool lazy initialization
                this.measureToolSky = new MeasureToolSky({
                    mizar: mizarWidgetAPI,
                    isMobile: this.isMobile,
                    mode: mizarWidgetAPI.CONTEXT.Sky
                });
            }

            this.activatedContext.setComponentVisibility("measureSkyContainer", visible);
        };

        /**
         * Adds/removes the distance GUI on the planet
         * @param visible
         */
        //TODO dcrire visible
        MizarWidgetGui.prototype.setAngleDistancePlanetGui = function (visible) {
            if (visible) {
                if (!this.measureToolPlanet) {
                    // Distance measure tool lazy initialization
                    this.measureToolPlanet = new MeasureToolPlanet({
                        mizar: mizarWidgetAPI,
                        isMobile: this.isMobile,
                        mode: mizarWidgetAPI.CONTEXT.Planet
                    });
                } else {
                    this.measureToolPlanet.updateContext(mizarWidgetAPI);
                }
            }
            this.activatedContext.setComponentVisibility("measurePlanetContainer", visible);
        };

        /**************************************************************************************************************/

        /**
         * Adds/removes the mode 2D/3D
         * @param visible
         */
        //TODO dcrire visible
        //TODO vrifier que c'est bien utiliser et checker l'icone
        MizarWidgetGui.prototype.setSwitchTo2D = function (visible) {
            if (visible && !this.switchTo2D) {
                this.switchTo2D = new SwitchTo2D({mizar: mizarWidgetAPI});
            }
            this.activatedContext.setComponentVisibility("switch2DContainer", visible);
        };

        /**
         * Adds/remove SAMP GUI utility.
         * @param visible
         */
        //TODO dcrire visible
        MizarWidgetGui.prototype.setSampGui = function (visible) {
            this.activatedContext.setComponentVisibility("sampContainer", visible);            
        };

        /**
         * Adds/remove the sharing application/
         * @param visible
         */
        //TODO dcrire visible
        MizarWidgetGui.prototype.setShortenerUrlGui = function (visible) {
            this.activatedContext.setComponentVisibility("shareContainer", visible);
        };

        /**************************************************************************************************************/

        /**
         * Adds/removes the full sky overview map.
         * @param visible
         */
        //TODO dcrire visible
        //TODO dtruire le composant ?
        MizarWidgetGui.prototype.setMollweideMapGui = function (visible) {
            if (visible && !this.mollweideViewer) {
                // Mollweide viewer lazy initialization
                this.mollweideViewer = new MollweideViewer({
                    mizar: mizarWidgetAPI,
                    mizarBaseUrl: options.global.mizarBaseUrl
                });
            }
            this.activatedContext.setComponentVisibility("2dMapContainer", visible);
        };

        /**
         * Adds/removes reverse name resolver GUI.
         * @param visible
         */
        //TODO dcrire visible
        MizarWidgetGui.prototype.setReverseNameResolverGui = function (visible) {
            if (visible) {
                if (!ReverseNameResolverView.isInitialized())
                    ReverseNameResolverView.init(mizarWidgetAPI);
            }
        };

        MizarWidgetGui.prototype.setDistanceGui = function (visible) {
            if (visible) {
                if (DistanceNavigationView.isInitialized())
                    DistanceNavigationView.update(mizarWidgetAPI);
                else
                    DistanceNavigationView.init(mizarWidgetAPI, "distTracker");
            } else {
                DistanceNavigationView.unregisterEvents();
            }
            this.activatedContext.setComponentVisibility("distanceDiv", visible);
        };

        /**
         * Adds/removes name resolver GUI.
         * @param visible
         */
        //TODO dcrire visible
        MizarWidgetGui.prototype.setNameResolverGui = function (visible) {
            if (visible) {
                if(!NameResolverView.isInitialized())
                    NameResolverView.init(mizarWidgetAPI);
            }
            this.activatedContext.setComponentVisibility("searchDiv", visible);
        };

        /**
         * Adds/removes layer manager view.
         * @param visible
         */
        //TODO dcrire visibles
        MizarWidgetGui.prototype.setCategoryGui = function (visible) {
            if (visible) {
                if(!LayerManagerView.isInitialized())
                    LayerManagerView.init(mizarWidgetAPI, $.extend({element: $(mizarDiv).find("#categoryDiv")}, options));
            } //else {
              //  LayerManagerView.remove();
            //}
            this.activatedContext.setComponentVisibility("categoryDiv", visible);
        };

        /**
         * Adds/removes image viewer GUI
         * @param visible
         */
        //TODO dcrire visible
        MizarWidgetGui.prototype.setImageViewerGui = function (visible) {
            if (!options.isMobile) {
                if (visible) {
                    if(!ImageViewer.isInitialized())
                        ImageViewer.init(mizarWidgetAPI);
                } //else {
                  //  ImageViewer.remove();
                //}
                this.activatedContext.setComponentVisibility("imageViewerDiv", visible);
            }
        };

        /**
         * Adds/removes Export GUI.
         * @param visible
         */
        //TODO dcrire visible
        MizarWidgetGui.prototype.setExportGui = function (visible) {
            if (visible) {
                if (!this.exportTool) {
                    this.exportTool = new ExportTool({
                        mizar: mizarWidgetAPI
                    });
                }
            }
            this.activatedContext.setComponentVisibility("exportContainer", visible);
        };

        /**
         * Returns the MizarGlobal object.
         * MizarGlobal is a wrapper between the GUI and the Mizar's cartographic API.
         * @return {MizarGlobal}
         */
        MizarWidgetGui.prototype.getMizarWidgetAPI = function () {
            return mizarWidgetAPI;
        };

        MizarWidgetGui.prototype.setUpdatedActivatedContext = function(ctx) {
            this.activatedContext = ctx;
        };

        return MizarWidgetGui;
    });


define('text!templates/mizarCore.html',[],function () { return '<div id="webGLNotAvailable">\n    If you see this message, WebGL is not supported in your browser.<br/>\n    Please install a recent version of <a href="http://www.mozilla.com">Firefox</a> or <a\n        href="http://www.google.com/chrome">Google Chrome</a>.<br/>\n    If you already have a recent version of Firefox or Google Chrome, your graphics driver are too old, please update\n    it.<br/>\n    On Google Chrome, you can check why it is not working by entering "about:gpu" in the url bar.\n</div>\n\n<div id="webGLContextLost">\n    Hmmm......can\'t get the background layer<br/>\n    Please check your network or your configuration.\n</div>\n\n<div id="splash">\n    <h1>Welcome to Mizar</h1>\n    <div id="loadingSplash"></div>\n    <div id="splash-logo"></div>\n</div>\n<div id="loading"></div>\n\n<div class="canvas">\n\n    <!-- Side bar will contain available layers -->\n    <div id="categoryDiv">\n    </div>\n\n    <div class="" id="rightTopPopup"></div>\n\n    <div class="" id="popupElevation">\n    </div>\n\n    <a href="#" id="elevationTrackingBtn" style="position:absolute; display:none;" class="elevationTrackingPopup"></a>\n\n    <div class="noSelect" id="distanceDiv"></div>\n    <div class="noSelect" id="navigationDiv">\n        <div id="searchDiv">\n        </div>\n\n        <div id="compassDiv">\n        </div>\n\n        <div id="timeTravelDiv"></div>\n        <div id="textTimeTravelDiv"></div>\n\n        <div id="legendDiv" class="row">\n        </div>\n\n        <div id="imageViewerDiv">\n        </div>\n\n    </div>\n\n\n    <!-- Left-Bottom-section -->\n    <div class="noSelect" id="leftBottomDiv">\n        <!-- Div for relative position 164 = define height of mollweideContent-->\n        <div id="2dMapContainer" style="display: none; position: relative; height: 164px; margin-bottom: 5px;">\n            <div id="mollweideDiv">\n\t\t\t\t<span id="mollweideContent">\n\t\t\t\t\t<canvas id="mollweideCanvas" class="noSelect" width="232px" height="116px"></canvas>\n\t\t\t\t\t<div id="fov" class="ui-widget">Fov : 45 x 45</div>\n\t\t\t\t</span>\n\n                <span id="slideArrow"></span>\n            </div>\n        </div>\n        <div id="shareContainer" style="display: none;" class="leftBottomButton">\n            <input type="button" id="share"/>\n\n            <div id="shareResult" style="pointer-events : auto;">\n                <input type="text" id="shareInput"/>\n                <input type="button" id="shareClear"/>\n            </div>\n        </div>\n        <div id="sampContainer" style="display: none;" class="leftBottomButton">\n            <input type="button" id="sampInvoker"/>\n        </div>\n        <div id="measureSkyContainer" style="display: none;" class="leftBottomButton">\n            <input type="button" id="measureSkyInvoker"/>\n        </div>\n        <div id="measurePlanetContainer" style="display: none;" class="leftBottomButton">\n            <input type="button" id="measurePlanetInvoker"/>\n        </div>\n        <div id="switch2DContainer" style="display: none;" class="leftBottomButton">\n            <input type="button" id="switch2DButton"/>\n        </div>\n        <div id="exportContainer" style="display: none;" class="leftBottomButton">\n            <input type="button" id="exportInvoker"/>\n        </div>\n        <div id="searchContainer" style="display: none;" class="leftBottomButton">\n            <input type="button" id="searchInvoker"/>\n        </div>\n        <div id="warningContainer" style="display: none;" class="leftBottomButton">\n            <input type="button" id="warningButton"/>\n        </div>\n        <div style="display: none;" id="fps" class="statBox ui-widget">FPS : 0</div>\n    </div>\n\n    <div id="attributions">\n        <div class="noSelect" id="skyAttributions"></div>\n        <div class="noSelect" id="globeAttributions"></div>\n    </div>\n    <div id="resultNavigation"></div>\n    <div id="tracker">\n        <div id="posTrackerInfo" class="noSelect"></div>\n        <div id="posTracker" class="noSelect"></div>\n        <div id="elevTracker" class="noSelect"></div>\n    </div>\n\n    <canvas class="noSelect" id="GlobWebCanvas" style="border: none; margin: 0; padding: 0;">\n    </canvas>\n\n</div>\n';});

/**
 * MizarWidgetAPI is the wrapper between the GUI of MizarWidget and the API of mizar.
 */
define('MizarWidgetAPI',["jquery", "underscore-min",
    "./utils/UtilsCore", "MizarWidgetGui",
    "./uws/UWSManager",
    "gw/Mizar", "gw/Gui/dialog/ErrorDialog", "text!templates/mizarCore.html"],
    function ($, _,
        UtilsCore, MizarWidgetGui,
        UWSManager,
        Mizar, ErrorDialog, mizarCoreHTML) {

        // private variables.
        var options;
        var mizarAPI;
        var self;

        /**
         * Returns the mizar URL.
         * @return {String}
         * @private
         */
        var getMizarUrl = function () {
            /**
             *    Store the mizar base urlferf
             *    Used to access to images(Compass, Mollweide, Target icon for name resolver)
             *    Also used to define "star" icon for point data on-fly
             *    NB: Not the best solution of my life.... TODO: think how to improve it..
             */
            // Search throught all the loaded scripts for minified version
            var scripts = document.getElementsByTagName('script');
            var mizarSrc = _.find(scripts, function (script) {
                return script.src.indexOf("MizarWidget.min") !== -1;
            });

            // Depending on its presence decide if Mizar is used on prod or on dev
            var mizarBaseUrl;
            if (mizarSrc) {
                // Prod
                // Extract mizar's url
                mizarBaseUrl = mizarSrc.src.split('/').slice(0, -1).join('/') + '/';
            }
            else {
                // Dev
                // Basically use the relative path from index page
                mizarSrc = _.find(scripts, function (script) {
                    return script.src.indexOf("MizarWidgetAPI") !== -1;
                });
                mizarBaseUrl = mizarSrc.src.split('/').slice(0, -1).join('/') + '/../';
            }
            return mizarBaseUrl;
        };

        /**
         * Loads in a synchronous way all files.
         * @param {url} url URL of the file to retrieve 
         */
        var getUrl = function (url) {
            return $.ajax({
                type: "GET",
                url: url,
                cache: false,
                async: false
            }).responseText;
        };

        /**
         * Builds a deynamic url to avail the brwser cache the URL.
         * The URL is build with a uuid parameter
         * @param {url} url 
         * @param {string} uuid 
         */
        var buildUrlNoCacheUrl = function(url, uuid) {
            var delimiter = (url.indexOf("?")>=0) ? "&" : "?";
            return url+delimiter+"uuid="+uuid;
        }

        /**
         * Applies the shared parameters to options if they exist.
         * @private
         */
        var _applySharedParameters = function (options) {
            var documentURI = window.document.documentURI;
            // Retrieve shared parameters
            var sharedParametersIndex = documentURI
                .indexOf("sharedParameters=");
            if (sharedParametersIndex !== -1) {
                var startIndex = sharedParametersIndex
                    + "sharedParameters=".length;
                var sharedString = documentURI.substr(startIndex);
                if (options.shortener) {
                    $.ajax({
                        type: "GET",
                        url: options.shortener.baseUrl + '/'
                            + sharedString,
                        async: false, // TODO: create callback
                        success: function (sharedConf) {
                            _mergeWithOptions(sharedConf);
                        },
                        error: function (thrownError) {
                            console.error(thrownError);
                        }
                    });
                } else {
                    console.log("Shortener plugin isn't defined, try to extract as a string");
                    var sharedParameters = JSON
                        .parse(decodeURI(sharedString));
                    _mergeWithOptions(sharedParameters);
                }
            }
        };

        /**
         * Removes "C"-like comments lines from string
         * @param string
         * @return {JSON}
         * @private
         */
        var _removeComments = function (string) {
            var starCommentRe = new RegExp("/\\\*(.|[\r\n])*?\\\*/", "g");
            var slashCommentRe = new RegExp("[^:]//.*[\r\n]", "g");
            string = string.replace(slashCommentRe, "");
            string = string.replace(starCommentRe, "");

            return string;
        };

        /**
         * Merges the retrieved shared parameters with Mizar configuration.
         * @param {object} sharedParameters
         * @private
         */
        //TODO dcrire shareparameters
        var _mergeWithOptions = function (sharedParameters) {
            // Navigation
            options.navigation.initTarget = sharedParameters.initTarget;
            options.navigation.initFov = sharedParameters.fov;
            options.navigation.up = sharedParameters.up;

            // Layer visibility
            options.layerVisibility = sharedParameters.visibility;
        };

        function initGUI(MizarWidgetAPI, mode) {
            if (MizarWidgetAPI.getMode() === MizarWidgetAPI.CONTEXT.Sky) {
                // Set different GUIs
                MizarWidgetAPI.setAngleDistancePlanetGui(false);
                MizarWidgetAPI.setAngleDistanceSkyGui(true);
                MizarWidgetAPI.setSwitchTo2D(false);
                MizarWidgetAPI.setSampGui(true);
                MizarWidgetAPI.setShortenerUrlGui(false);
                MizarWidgetAPI.setMollweideMapGui(true);
                MizarWidgetAPI.setReverseNameResolverGui(true);
                MizarWidgetAPI.setNameResolverGui(true);
                MizarWidgetAPI.setCategoryGui(true);
                MizarWidgetAPI.setImageViewerGui(true);
                MizarWidgetAPI.setExportGui(true);
                MizarWidgetAPI.setDistanceGui(false);
            } else if (MizarWidgetAPI.getMode() === MizarWidgetAPI.CONTEXT.Planet) {
                // Set different GUIs
                MizarWidgetAPI.setAngleDistanceSkyGui(false);
                MizarWidgetAPI.setAngleDistancePlanetGui(true);
                MizarWidgetAPI.setSwitchTo2D(true);
                MizarWidgetAPI.setSampGui(false);
                MizarWidgetAPI.setShortenerUrlGui(false);
                MizarWidgetAPI.setMollweideMapGui(false);
                MizarWidgetAPI.setReverseNameResolverGui(false);
                MizarWidgetAPI.setNameResolverGui(true);
                MizarWidgetAPI.setCategoryGui(true);
                MizarWidgetAPI.setImageViewerGui(true);
                MizarWidgetAPI.setExportGui(false);
                MizarWidgetAPI.setDistanceGui(true);
            } else if (MizarWidgetAPI.getMode() === MizarWidgetAPI.CONTEXT.Ground) {
                MizarWidgetAPI.setAngleDistanceSkyGui(false);
                MizarWidgetAPI.setAngleDistancePlanetGui(false);
                MizarWidgetAPI.setSwitchTo2D(false);
                MizarWidgetAPI.setSampGui(false);
                MizarWidgetAPI.setShortenerUrlGui(false);
                MizarWidgetAPI.setMollweideMapGui(false);
                MizarWidgetAPI.setReverseNameResolverGui(false);
                MizarWidgetAPI.setNameResolverGui(false);
                MizarWidgetAPI.setCategoryGui(true);
                MizarWidgetAPI.setImageViewerGui(true);
                MizarWidgetAPI.setExportGui(false);
                MizarWidgetAPI.setDistanceGui(false);
            } else {
                throw "Unable to find mizar.mode=" + mizar.mode;
            }
        }

        /**
         * Adds layers to sky (default) or to planet
         * @param {array} layers to add to a globe : sky or planet
         * @private
         * @fires Mizar#backgroundSurveysReady
         */
        var callbackLayersLoaded = function (layers) {
            // Add surveys
            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i];
                if (layer.name === "Mars") {
                    loadNoStandardPlanetProviders();
                }
                var gwLayer = self.addLayer(layer);
                // Update layer visibility according to options
                if (options.layerVisibility
                    && options.layerVisibility.hasOwnProperty(layer.name)) {
                    gwLayer.visible(options.layerVisibility[layer.name]);
                }
                mizarAPI.publish("backgroundSurveysReady");
            }
        };

        /**
         * Loads No standard data providers
         */
        var loadNoStandardSkyProviders = function () {
            var planetProvider = mizarAPI.ProviderFactory.create(Mizar.PROVIDER.Planet);
            var starProvider = mizarAPI.ProviderFactory.create(Mizar.PROVIDER.Star);
            var constellationProvider = mizarAPI.ProviderFactory.create(Mizar.PROVIDER.Constellation);
            mizarAPI.registerNoStandardDataProvider("planets", planetProvider.loadFiles);
            mizarAPI.registerNoStandardDataProvider("constellation", constellationProvider.loadFiles);
            mizarAPI.registerNoStandardDataProvider("star", starProvider.loadFiles);
        };

        var loadNoStandardPlanetProviders = function () {
            var craterProvider = mizarAPI.ProviderFactory.create(Mizar.PROVIDER.Crater);
            mizarAPI.registerNoStandardDataProvider("crater", craterProvider.loadFiles);
            var trajectoryProvider = mizarAPI.ProviderFactory.create(Mizar.PROVIDER.Trajectory);
            mizarAPI.registerNoStandardDataProvider("trajectory", trajectoryProvider.loadFiles);
        };


        /**
         * Creates global options for mizar configuration.
         * @param configuration
         * @return {Object}
         * @private
         */
        function createOptions(configuration) {
            var isMobile = ('ontouchstart' in window || (window.DocumentTouch !== undefined && window.DocumentTouch && document instanceof DocumentTouch));
            var sitoolsBaseUrl = configuration.global.sitoolsBaseUrl ? configuration.global.sitoolsBaseUrl : "http://demonstrator.telespazio.com/sitools";
            var proxyUrl = configuration.global.proxyUrl ? configuration.global.proxyUrl : null;
            var proxyUse = configuration.global.proxyUse == null ? false : configuration.global.proxyUse;
            options = {};
            $.extend(options, configuration);
            options.global.sitoolsBaseUrl = sitoolsBaseUrl;
            options.global.proxyUrl = proxyUrl;
            options.global.proxyUse = proxyUse;
            options.global.isMobile = isMobile;
            return options;
        }

        function RenderingGlobeFinished() {
            $(self.div).find('#loading').hide();
            $(self.div).find('#splash').hide();
        }

        var getUniqueId = function (prefix) {
            var d = new Date().getTime();
            d += (parseInt(Math.random() * 100)).toString();
            return d;
        };

        /**
         * Update mode according to the CRS.
         * @param {Object} ctxList 
         */
        var updateMode = function(ctxList) {
            var crs;
            for (ctx in ctxList) {
                crs = ctxList[ctx].context.init.coordinateSystem.geoideName;
                ctxList[ctx].mode = Mizar.CRS_TO_CONTEXT[crs];
            }
        }

        /**
         * Entry point to manage Mizar Widget.
         * @param div Div to use for the Widget
         * @param userOptions Configuration properties for the Widget
         * @param callbackInitMain Callback function
         * @constructor
         */
        var MizarWidgetAPI = function (div, userOptions, callbackInitMain) {

            this.div = '#'+div;

            // Retrieves the Mizar's URL
            var mizarBaseUrl = getMizarUrl();

            // Creates the user options
            userOptions.global.mizarBaseUrl = mizarBaseUrl;

            // Loads all context files that are defined in mizarWidget.json
            userOptions.ctx = this._loadConfigFiles(mizarBaseUrl, userOptions.ctx);

            // Update mode (Planet, Sky, Ground) according to the CRS (geoideName)
            updateMode(userOptions.ctx);

            // Retrieves the div element.
            self = this;

            // Merge default options with user options
            this.options = createOptions(userOptions);

            // Create mizar core HTML
            var mizarContent = _.template(mizarCoreHTML, {});
            $(this.div).append(mizarContent);
            _applySharedParameters(options);

            // Call Mizar
            mizarAPI = new Mizar({
                canvas: $(this.div).find('#GlobWebCanvas')[0],
                configuration: {
                    "mizarBaseUrl": this.options.global.mizarBaseUrl,
                    "debug": this.options.gui.debug,
                    "isMobile": this.options.gui.isMobile,
                    "positionTracker": this.options.gui.positionTracker,
                    "elevationTracker": this.options.gui.elevationTracker,
                    "registry": this.options.gui.registry,
                    "proxyUse": this.options.global.proxyUse,
                    "proxyUrl": this.options.global.proxyUrl
                }
            });

            // Search the reference to the default context.
            var selectedCtx = _.find(this.options.ctx, function (obj) { return obj.name === userOptions.defaultCtx });
            if (selectedCtx === undefined) {
                throw "Unable to find the default context";
            } else {
                // Gets the mode : Sky, Ground Planet
                this.mode = selectedCtx.mode;

                // Creates a context for the mode with the init parameters
                selectedCtx.context.init.isMobile = this.options.gui.isMobile;
                mizarAPI.createContext(this.mode, selectedCtx.context.init);

                // Create the API on which the GUI is used
                this.mizarWidgetGui = new MizarWidgetGui(this.div, {
                    mizarWidgetAPI: this,
                    options: this.options
                });

                initGUI(this, this.mode);

                // Removes the spinner when background layers are loaded
                this.subscribeCtx(Mizar.EVENT_MSG.BASE_LAYERS_READY, RenderingGlobeFinished);
                // Removes the spinner when we come back to a previous context (it was not destroyed, then
                // no baseLayersReady event is sent.
                this.subscribeMizar(Mizar.EVENT_MSG.MIZAR_MODE_TOGGLE, RenderingGlobeFinished);

                loadNoStandardSkyProviders();
                loadNoStandardPlanetProviders();

                // Add stats
                if (this.options.gui.stats.visible) {
                    mizarAPI.createStats({
                        element: $("#fps"),
                        verbose: this.options.gui.stats.verbose ? this.options.gui.stats.verbose : false
                    });
                    $("#fps").show();
                }

                // Initialize name resolver
                mizarAPI.getServiceByName(Mizar.SERVICE.NameResolver).init(mizarAPI);

                // Initialize reverse name resolver
                mizarAPI.getServiceByName(Mizar.SERVICE.ReverseNameResolver).init(mizarAPI);

                // UWS services initialization
                UWSManager.init(options);

                // Initialization of tools useful for different modules
                UtilsCore.init(this, options);

                // Initialize moc base
                mizarAPI.getServiceByName(Mizar.SERVICE.MocBase).init(this, options);

                // Fullscreen mode
                document.addEventListener("keydown", function (event) {
                    // Ctrl + Space
                    if (event.ctrlKey === true && event.keyCode === 32) {
                        $('.canvas > canvas').siblings(":not(canvas)").each(
                            function () {
                                $(this).fadeToggle();
                            });
                    }
                });


                ErrorDialog.setIcon('#warningButton');
                $('#warningButton').on('click', function () {
                    if (ErrorDialog.isActive() === true) {
                        ErrorDialog.hide();
                    } else {
                        ErrorDialog.view();
                    }
                })

            }
        };


        /**************************************************************************************************************/

        MizarWidgetAPI.prototype.init = function () {
            var userOptions = this.options;
            var selectedCtx = _.find(this.options.ctx, function (obj) { return obj.name === userOptions.defaultCtx });
            for (var i = 0; i < selectedCtx.context.layers.length; i++) {
                var layer = selectedCtx.context.layers[i];
                mizarAPI.addLayer(layer,
                    function (layerID) {
                        var myLayer = mizarAPI.getLayerByID(layerID);
                        if (myLayer.hasDimension()) {
                            var dimension = myLayer.getDimensions();
                            if (dimension.time) {
                                //console.log("time from API:"+dimension.time.value);
                            }
                        }
                        if (myLayer.type === Mizar.LAYER.WCSElevation) {
                            mizarAPI.setBaseElevationByID(layerID);
                        }
                    },
                    function (e) {
                        console.error(e);
                        var layerDescription = e.layerDescription;
                        if(layerDescription.background) {
                            $(self.div).find('#loading').hide();
                            $(self.div).find('#splash').hide();
                            $(self.div).find("canvas").hide();
                            $(self.div).find("#navigationDiv").hide();
                            $(self.div).find('#webGLContextLost').show();                            
                        }                        
                    }
                );
            }

        };


        /**
         * Loads all configuration files from mizarWidget.json
         * Each configuration file can be located as relative or absolute URL
         * @param {url} mizarUrl Mizar URL
         * @param {string[]} configCtx - List of context files. 
         * @return the list of context objects
         */
        MizarWidgetAPI.prototype._loadConfigFiles = function (mizarUrl, configCtx) {
            var ctxObj = [];
            // generate a unique identifier to avoid the web server puts the configuration file in cache.
            var uuid = getUniqueId();
            for (var i = 0; i < configCtx.length; i++) {
                var ctx = configCtx[i];
                var url;
                if (ctx.context.toLowerCase().startsWith('http')) {
                    url = ctx.context;
                } else {
                    url = mizarUrl + "/conf/" + ctx.context;
                }
                url = buildUrlNoCacheUrl(url, uuid);
                var ctxResult = getUrl(url);
                ctx.context = JSON.parse(_removeComments(ctxResult));
                ctxObj.push(ctx);
            }
            return ctxObj;
        };

        /**
         * Returns the mizarWidget GUI.
         */
        MizarWidgetAPI.prototype.getMizarWidgetGui = function () {
            return this.mizarWidgetGui;
        };

        /**
         * Returns the current Mizar context (Sky/Planet)
         * @function getContext
         * @memberof MizarWidgetAPI.prototype
         * @return {SkyContext} SkyContext
         */
        MizarWidgetAPI.prototype.getContext = function () {
            return mizarAPI.getActivatedContext();
        };

        MizarWidgetAPI.prototype.getRenderContext = function () {
            return mizarAPI.getRenderContext();
        };

        /**
         * Returns the current Scene (Sky or Planet).
         * @function getScene
         * @memberof MizarWidgetAPI.prototype
         * @return {Sky} Scene
         */
        MizarWidgetAPI.prototype.getScene = function () {
            return mizarAPI.getActivatedContext()._getGlobe();
        };

        /**
         * Returns the current Navigation.
         * @function getNavigation
         * @memberof MizarWidgetAPI.prototype
         * @return {AstroNavigation} Navigation
         */
        MizarWidgetAPI.prototype.getNavigation = function () {
            return mizarAPI.getActivatedContext().getNavigation();
        };

        MizarWidgetAPI.prototype.getCrs = function () {
            return mizarAPI.getCrs();
        };

        MizarWidgetAPI.prototype.setCrs = function (coordinateSystem) {
            mizarAPI.setCrs(coordinateSystem);
        };

        MizarWidgetAPI.prototype.subscribeMizar = function (name, callback) {
            mizarAPI.subscribe(name, callback);
        };

        MizarWidgetAPI.prototype.unsubscribeMizar = function (name, callback) {
            mizarAPI.unsubscribe(name, callback);
        };

        MizarWidgetAPI.prototype.publishMizar = function (name, context) {
            mizarAPI.publish(name, context);
        };

        MizarWidgetAPI.prototype.subscribeCtx = function (name, callback) {
            mizarAPI.getActivatedContext().subscribe(name, callback);
        };

        MizarWidgetAPI.prototype.unsubscribeCtx = function (name, callback) {
            mizarAPI.getActivatedContext().unsubscribe(name, callback);
        };

        MizarWidgetAPI.prototype.publishCtx = function (name, context) {
            mizarAPI.getActivatedContext().publish(name, context);
        };


        MizarWidgetAPI.prototype.refresh = function () {
            mizarAPI.getActivatedContext().refresh();
        };

        MizarWidgetAPI.prototype.getTileManager = function () {
            return mizarAPI.getActivatedContext().getTileManager();
        };


        /**
         * Add additional layer(OpenSearch, GeoJSON, HIPS, grid coordinates)
         * @function addLayer
         * @memberof MizarWidgetAPI.prototype
         * @param {Object} layerDesc Layer description
         * @return {Layer}The created layer
         */
        MizarWidgetAPI.prototype.addLayer = function (layerDesc) {
            if (layerDesc.coordinateSystem) {
                layerDesc.coordinateSystem = { geoideName: layerDesc.coordinateSystem };
            }
            return mizarAPI.addLayer(layerDesc);
        };


        MizarWidgetAPI.prototype.getServiceByName = function (name, options) {
            return mizarAPI.getServiceByName(name, options);
        };

        MizarWidgetAPI.prototype.SERVICE = Mizar.SERVICE;

        MizarWidgetAPI.prototype.LAYER = Mizar.LAYER;

        MizarWidgetAPI.prototype.CONTEXT = Mizar.CONTEXT;

        MizarWidgetAPI.prototype.CRS = Mizar.CRS;

        MizarWidgetAPI.prototype.GEOMETRY = Mizar.GEOMETRY;

        MizarWidgetAPI.prototype.UTILITY = Mizar.UTILITY;

        MizarWidgetAPI.prototype.NAVIGATION = Mizar.NAVIGATION;

        MizarWidgetAPI.prototype.LAYER = Mizar.LAYER;

        MizarWidgetAPI.prototype.EVENT_MSG = Mizar.EVENT_MSG;


        /**
         * Show/hide angle distance GUI
         * @function setAngleDistanceSkyGui
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setAngleDistanceSkyGui = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setAngleDistanceSkyGui(visible);
            }
        };

        /**
         * Show/hide angle distance GUI
         * @function setAngleDistanceSkyGui
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setAngleDistancePlanetGui = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setAngleDistancePlanetGui(visible);
            }
        };

        /**
         * Show/hide Switch To 2D
         * @function setSwitchTo2D
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setSwitchTo2D = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setSwitchTo2D(visible);
            }
        };

        /**
         * Show/hide samp GUI
         * Only on desktop
         * @function setSampGui
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setSampGui = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setSampGui(visible);
            }
        };

        /**
         * Show/hide shortener GUI
         * @function setShortenerUrlGui
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setShortenerUrlGui = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setShortenerUrlGui(visible);
            }
        };

        /**
         * Show/hide 2d map GUI
         * @function setMollweideMapGui
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setMollweideMapGui = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setMollweideMapGui(visible);
            }
        };

        /**
         * Show/hide reverse name resolver GUI
         * @function setReverseNameResolverGui
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setReverseNameResolverGui = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setReverseNameResolverGui(visible);
            }
        };

        /**
         * Show/hide reverse name resolver GUI
         * @function setReverseNameResolverGui
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setDistanceGui = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setDistanceGui(visible);
            }
        };

        /**
         * Show/hide name resolver GUI
         * @function setNameResolverGui
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setNameResolverGui = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setNameResolverGui(visible);
            }
        };

        /**
         * Show/hide jQueryUI layer manager view
         * @function setCategoryGui
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setCategoryGui = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setCategoryGui(visible);
            }
        };

        /**
         * Show/hide jQueryUI image viewer GUI
         * @function setImageViewerGui
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setImageViewerGui = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setImageViewerGui(visible);
            }
        };

        /**
         * Show/hide jQueryUI Export GUI
         * @function setExportGui
         * @memberof MizarWidgetAPI.prototype
         * @param {boolean} visible
         */
        MizarWidgetAPI.prototype.setExportGui = function (visible) {
            if (this.mizarWidgetGui) {
                this.mizarWidgetGui.setExportGui(visible);
            }
        };


        MizarWidgetAPI.prototype.getMode = function () {
            return mizarAPI.getActivatedContext().getMode();
        };

        /**
         * Toggle between between 3D and 2D
         * @function toggleDimension
         * @memberof MizarWidgetAPI.prototype
         * @param {Layer} layer the current layer
         */
        MizarWidgetAPI.prototype.toggleDimension = function (layer) {
            mizarAPI.toggleDimension();
            this.setAngleDistancePlanetGui(true);
            this.setSwitchTo2D(true);
        };

        MizarWidgetAPI.prototype.isSkyContext = function () {
            return this.getMode() === Mizar.CONTEXT.Sky;
        };

        MizarWidgetAPI.prototype.isPlanetContext = function () {
            return this.getMode() === Mizar.CONTEXT.Planet;
        };

        MizarWidgetAPI.prototype.isGroundContext = function () {
            return this.getMode() === Mizar.CONTEXT.Ground;
        };


        MizarWidgetAPI.prototype.createMarsContext = function () {
            this.unsubscribeCtx(Mizar.EVENT_MSG.BASE_LAYERS_READY, RenderingGlobeFinished);
            $(this.div).find('#loading').show();
            var userOptions = this.options;
            var selectedCtx = _.find(this.options.ctx, function (obj) { return obj.name === "mars" });
            if (selectedCtx === undefined) {
                throw "Unable to get the Mars context"
            }
            selectedCtx.context.init.isMobile = this.options.gui.isMobile;
            mizarAPI.createContext(Mizar.CONTEXT.Planet, selectedCtx.context.init);
            var self = this;
            mizarAPI.toggleToContext(mizarAPI.getPlanetContext(), {
                "mustBeHidden": true, "callback": function () {
                    initGUI(self, self.getMode());
                    self.subscribeCtx(Mizar.EVENT_MSG.BASE_LAYERS_READY, RenderingGlobeFinished);
                }
            });
            loadNoStandardPlanetProviders();
            for (var i = 0; i < selectedCtx.context.layers.length; i++) {
                var layer = selectedCtx.context.layers[i];
                mizarAPI.addLayer(layer, function (layerID) {
                    var myLayer = mizarAPI.getLayerByID(layerID);
                    if (myLayer.getType() === Mizar.LAYER.WCSElevation) {
                        mizarAPI.setBaseElevationByID(layerID);
                    }
                });
            }
            self.mizarWidgetGui.setUpdatedActivatedContext(self.getContext());

        };

        MizarWidgetAPI.prototype.createCuriosityContext = function () {
            this.unsubscribeCtx(Mizar.EVENT_MSG.BASE_LAYERS_READY, RenderingGlobeFinished);
            $(this.div).find('#loading').show();
            var userOptions = this.options;
            var selectedCtx = _.find(this.options.ctx, function (obj) { return obj.name === "curiosity" });
            selectedCtx.context.init.isMobile = this.options.gui.isMobile;
            mizarAPI.createContext(Mizar.CONTEXT.Ground, selectedCtx.context.init);
            var self = this;
            mizarAPI.toggleToContext(mizarAPI.getGroundContext(), {
                "mustBeHidden": true, "callback": function () {
                    initGUI(self, self.getMode());
                    self.subscribeCtx(Mizar.EVENT_MSG.BASE_LAYERS_READY, RenderingGlobeFinished);
                }
            });
            for (var i = 0; i < selectedCtx.context.layers.length; i++) {
                var layer = selectedCtx.context.layers[i];
                mizarAPI.addLayer(layer, function (layerID) {
                    var myLayer = mizarAPI.getLayerByID(layerID);
                    if (myLayer.getType() === Mizar.LAYER.WCSElevation) {
                        mizarAPI.setBaseElevationByID(layerID);
                    }
                });
            }
            self.mizarWidgetGui.setUpdatedActivatedContext(self.getContext());
        };

        MizarWidgetAPI.prototype.createSunContext = function () {
            this.unsubscribeCtx(Mizar.EVENT_MSG.BASE_LAYERS_READY, RenderingGlobeFinished);
            $(this.div).find('#loading').show();
            var userOptions = this.options;
            var selectedCtx = _.find(this.options.ctx, function (obj) { return obj.name === "sun" });
            selectedCtx.context.init.isMobile = this.options.gui.isMobile;
            mizarAPI.createContext(Mizar.CONTEXT.Planet, selectedCtx.context.init);
            var self = this;
            mizarAPI.toggleToContext(mizarAPI.getPlanetContext(), {
                "mustBeHidden": true, "callback": function () {
                    initGUI(self, self.getMode());
                    self.subscribeCtx(Mizar.EVENT_MSG.BASE_LAYERS_READY, RenderingGlobeFinished);
                }
            });
            for (var i = 0; i < selectedCtx.context.layers.length; i++) {
                var layer = selectedCtx.context.layers[i];
                mizarAPI.addLayer(layer, function (layerID) {
                    var myLayer = mizarAPI.getLayerByID(layerID);
                    if (myLayer.getType() === Mizar.LAYER.WCSElevation) {
                        mizarAPI.setBaseElevationByID(layerID);
                    }
                });
            }
            self.mizarWidgetGui.setUpdatedActivatedContext(self.getContext());
        };

        MizarWidgetAPI.prototype.toggleToSky = function () {
            $(this.div).find('#loading').show();
            var ctx;
            if (mizarAPI.getMode() === Mizar.CONTEXT.Planet) {
                ctx = mizarAPI.getSkyContext();
            } else if (mizarAPI.getMode() === Mizar.CONTEXT.Ground) {
                ctx = mizarAPI.getPlanetContext();
            }
            mizarAPI.toggleToContext(ctx, { mustBeDestroyed: true });
            self.mizarWidgetGui.setUpdatedActivatedContext(self.getContext());
        };

        MizarWidgetAPI.prototype.getMizarAPI = function () {
            return mizarAPI;
        };

        /**
         * Add layer by drag n drop
         */
        MizarWidgetAPI.prototype.addLayerByDragNDrop = function (name, GeoJson) {
            mizarAPI.addLayer({
                name: name,
                type: Mizar.LAYER.GeoJSON,
                pickable: true,
                deletable: true,
                visible: true
            }, function (layerID) {
                var layer = mizarAPI.getLayerByID(layerID);
                layer.addFeatureCollection(GeoJson);
            });
        };

        MizarWidgetAPI.prototype.getLayers = function () {
            return mizarAPI.getLayers();
        };

        MizarWidgetAPI.prototype.removeLayer = function (layerID) {
            return mizarAPI.removeLayer(layerID);
        };

        MizarWidgetAPI.prototype.getLayerByName = function (name) {
            return mizarAPI.getLayerByName(name);
        };

        MizarWidgetAPI.prototype.getLayerByID = function (ID) {
            return mizarAPI.getLayerByID(ID);
        };

        MizarWidgetAPI.prototype.setBackgroundLayer = function (name) {
            return mizarAPI.setBackgroundLayer(name);
        };

        MizarWidgetAPI.prototype.hasSkyContext = function () {
            return mizarAPI.getSkyContext() != null;
        };

        MizarWidgetAPI.prototype.hasPlanetContext = function () {
            return mizarAPI.getPlanetContext() != null;
        };

        MizarWidgetAPI.prototype.createLayerFromFits = function (name, fits) {
            // createLayerFromFits: function (name, fits) {
            //     var gwLayer = createSimpleLayer(name);
            //     gwLayer.dataType = "line";
            //
            //     // Create feature
            //     var coords = Utils.getPolygonCoordinatesFromFits(fits);
            //     var feature = {
            //         "geometry": {
            //             "gid": name,
            //             "coordinates": [coords],
            //             "type": "Polygon"
            //         },
            //         "properties": {
            //             "identifier": name
            //         },
            //         "type": "Feature"
            //     };
            //
            //     gwLayer.addFeature(feature);
            //     PickingManagerCore.addPickableLayer(gwLayer);
            //     this.addLayer(gwLayer, mizarCore.activatedContext.planetLayer);
            //     return gwLayer;
            // },
            //TODO A reimplmenter et mettre le bon CRS
        };




        return MizarWidgetAPI;
    });

/**
 * Mizar widget is a relatively simple and easy-to-use cartographic application with a GUI.
 * This widget is composed of :
 * <ul>
 *     <li>a cartographic element, called Mizar</li>
 *     <li>a GUI to handle the different layers and contexts</li>
 * </ul>
 *
 * Mizar widget can handle two contexts :
 * <ul>
 *     <li>a globe representing the sky with the camera is located at the center of the globe</li>
 *     <li>a globe representing a planet</li>
 *     <li>a hybrid context where the panet is representing whith the sky in background</li>
 * </ul>
 *
 * The GUI of Mizar widget provides the following elements:
 * <ul>
 *     <li>a graphical element to handle the different layer : on/off, opacity</li>
 *     <li>a graphical element to select a background layer</li>
 *     <li>a graphical element to resolve an object name to coordinates</li>
 *     <li>a graphical element to find an object name based on its coordinates</li>
 *     <li>a manager to handle graphical events related to the user picking</li>
 *     <li>a graphical element to display the metadata to the user</li>
 *     <li>a graphical iframe to display external link to the user</li>
 *     <li>a graphical element to display the footprint of the camera in the whole sky</li>
 *     <li>a graphical element to handle features on a displayed image (quicklook, wms or Fits data)</li>
 *     <li>a graphical element to handle specific layer</li>
 *     <li>a graphical element to measure the angular distance between two points</li>
 *     <li>a graphical element to measure the distance and compute the elevation profile between two points
 *     on a planet</li>
 *     <li>a graphical element to switch 2D/3D</li>
 *     <li>a graphical element to order data based on a selected area</li>
 *     <li>a graphical element to display credits of the tool to the user</li>
 *     <li>a graphical element to display error to the user</li>
 *     <li>two services : a sharing service and <a href="http://www.ivoa.net/documents/SAMP/">SAMP</a></li>
 * </ul>
 *
 */
define('MizarWidget',["./MizarWidgetAPI"], function (MizarWidgetAPI) {

    /**
     @name MizarWidget
     @class
         Entry point to manage Mizar Widget.
     @param div Div to use for the Widget.
     @param options Configuration properties for the Widget.
     */
    //TODO dcrire les options
    var MizarWidget = function (div, options) {
        this.mizarWidgetAPI = new MizarWidgetAPI(div, options);
    };

    /**************************************************************************************************************/
    /**
     * Returns the wrapper between mizarWidget and the mizarWidgetAPI
     * @function getMizarGlobal
     * @memberof MizarWidget.prototype
     * @return {MizarGlobal|*}
     */
    MizarWidget.prototype.getMizarWidgetAPI = function () {
        return this.mizarWidgetAPI;
    };

    window.MizarWidget = MizarWidget;

    return MizarWidget;

});

// Register in the values from the outer closure for common dependencies
  // as local almond modules
  define('jquery', function() {
    return $;
  });

  // Use almond's special top level synchronous require to trigger factory
  // functions, get the final module, and export it as the public api.
  return require('MizarWidget');
}));
